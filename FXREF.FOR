C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM PRODUCES A CROSS REFERENCE OF FORTRAN 77 PROGRAM
C        VARIABLES, STATEMENT NUMBERS, INPUT-OUTPUT UNITS, CONSTANTS,
C        AND LITERALS.
C
C        THIS PROGRAM IS LICENSED UNDER THE GNU GPL LICENSE.
C
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARATCER: A
C         CAMP   - CHARACTER VARIABLE, THE CHARACTER: &
C         CAPOS  - CHARACTER VARIABLE, THE CHARACTER: '
C         CAPOSD - CHARACTER VARIABLE, THE CHARACTER: "
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CBSLAS - CHARACTER VARIABLE, BACKWARD SLASH: \
C         CC     - CHARACTER VARIABLE, THE LETTER: C (UPPER CASE)
C         CCR    - CHARACTER VARIABLE, A CARRIAGE RETURN, HEX: 0D
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE
C                  DEFINITION RECORD OF A SUBPROGRAM; LENGTH IS
C                  1496 CHARACTERS
C         CDEFS  - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE
C                  DEFINITION RECORD OF A SUBPROGRAM; LENGTH IS
C                  1496 CHARACTERS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES.
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32. THE
C                                  WORD LENGTH IS IN COLS. 38-44 IN
C                                  ARRAY CNAME.
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CDOT   - CHARACTER VARIABLE, A PERIOD
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CEXTNL - CHARACTER VARIABLE, TABLE OF ALL EXTERNAL STATEMENT
C                  NAMES IN A ROUTINE BEING ANALYZED. THIS IS A GLOBAL
C                  TABLE CONTAINING ALL SUBPROGRAM NAMES DEFINED IN
C                  ANY ROUTINE IN THE CURRENT PROGRAM BEING PROCESSED.
C         CFCALL - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 10
C         CFCOMM - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 11
C         CFEQUI - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 12
C         CFFUNT - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 15
C         CFILEB - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAMES
C                  THAT ARE TO BE PROCESSED. MAXIMUM OF 10 ALLOWED.
C         CFILEN - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAME
C                  THAT IS TO BE PROCESSED
C         CFIUNT - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 8
C         CFLEN  - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 1
C         CFMESS - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 0
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CFORMF - CHARACTER VARIABLE, A FORM FEED '0C'X
C         CFSLIT - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 9
C         CFSNUM - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 4
C         CFSUBP - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 16
C         CFVNME - CHARACTER VARIABLE, THE FILE NAME FOR UNIT 7
C         CIFILE - CHARACTER VARIABLE, LIST OF FILES OCCURRING IN
C                  INCLUDE STATEMENTS; MAXIMUM OF 20 ALLOWED WITHIN A
C                  SINGLE PROGRAM MODULE. THE PATH AND FILE LENGTH
C                  MUST NOT EXCEED 80 CHARACTERS.
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED WITH I2WK1
C         CLEN   - CHARACTER VARIABLE, WORK ARE FOR DATA TYPE LENGTH
C         CLF    - CHARACTER VARIABLE, A LINE FEED, HEX: 0A
C         CLISTN - CHARACTER VARIABLE, THE OUTPUT FILE NAME FOR PRINTING
C                  THE FIRST NODE OF THE FILE NAME WILL BE MODIFIED BY
C                  ROUTINE PSPRINT WHEN POSTSCRIPT OUTPUT IS REQUESTED.
C         CLIT   - CHARACTER VARIABLE, ARRAY CONTAINING THE LITERAL
C                  OCCURRING IN A STATEMENT. MAXIMUM LENGTH IS 80 BYTES
C                  EQUIVALENCED TO CLITWK
C         CLITWK - CHARACTER VARIABLE, WORK AREA FOR WRITING THE
C                  LITERALS AND THEIR ISNS ON UNIT 9
C                   COLS TYPE WORD CONTENT
C                    1-80 A*80  10 THE LITERAL VALUE
C                   81-84 I*4   11 THE LENGTH OF THE LITERAL IN COLS.
C                                  1 - 80
C                   85-88 I*4   12 THE ISN LOCATION OF THE LITERAL IN
C                                   COLS. 1 - 80
C                   89-92 I*4   13 THE ARGUMENT NUMBER WHEN THE LITERAL
C                                  IS THE ARGUMENT OF A CALL STATEMENT
C         CLOGIC - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ANY LOGICAL OPERATOR WITHIN A STATEMENT.
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: - (MINUS SIGN)
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. THIS TABLE DOES NOT CONTAIN THE LIST OF
C                  VARIABLE NAMES BELONGING TO THE COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C         COUTV  - CHARACTER VARIABLE, ARRAY OF INPUT-OUTPUT UNITS
C                  DEFINED AS A VARIABLE
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 4000
C                  PARAMETER STATEMENTS ALLOWED.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  ISN VALUE
C                  37-44  A*8   11  DATA TYPE & LENGTH
C                  45-48  I*4   12  NUMERIC VALUE OF INTEGER VARIABLES
C                                   ONLY. OTHER DATA TYPES LEAVE THIS
C                                   FIELD BLANK
C                  49-52  I*4   13  LENGTH OF THE VARIABLE NAME IN
C                                   COLS 1 - 32
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CPGWRK - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED SAVE AREA. THIS VALUE WILL
C                  BE PLACED IN CFMTH TO INSURE THE CORRECT PROGRAM NAME
C                  APPEARS IN THE LISTING HEADING.
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CRECTB - CHARACTER VARIABLE, TABLE OF RECORD VARIABLE NAMES
C                  AND THEIR LENGTH. A MAXIMUM OF 1000 RECORD VARIABLE
C                  NAME DEFINITIONS ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE VARIABLE NAME CONTAINING
C                                   THE RECORD VARIABLE
C                 33 - 64 A*32  16  RECORD VARIABLE NAME
C                 65 - 68 I*4   17  INTEGER VALUE OF THE LENGTH OF
C                                   THE RECORD DEFINITION
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSREC  - CHARACTER VARIABLE, AN ARRAY WHERE THE TWO RECORDS OF
C                  FORTRAN SOURCE CODE FOLLOWING AN INCLUDE STATEMENT
C                  ARE SAVED. SUBSCRIPT ONE, VALUE 1, IS THE FIRST
C                  RECORD; SUBSCRIPT TWO, VALUE 2, IS THE SECOND RECORD.
C                  THE ARRAY ALLOWS ALLOWS A MAXIMUM OF 20 ENTRIES AND
C                  ALLOWS THAT MANY NESTED INCLUDE STATEMENTS.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED. THIS VARIABLE IS 6606 CHARACTERS IN
C                  LENGTH. WHEN NCOLS IS 72, 99 CONTINUATION RECORDS ARE
C                  ALLOWED. WHEN NCOLS IS 132, 51 CONTINUATION RECORDS
C                  ARE ALLOWED.
C                  RECORD STRUCTURE
C                  CASE 1: NCOLS IS 72
C                  COLS 1 -  72  FIRST INPUT RECORD OF A STATEMENT
C                      73 - 138  SECOND INPUT RECORD OF THE STATEMENT
C                     139 - 204  THIRD RECORD, ETC.
C                  CASE 2: NCOLS IS 132
C                  COLS 1 - 132  FIRST INPUT RECORD OF A STATEMENT
C                     133 - 258  SECOND INPUT RECORD OF A STATEMENT
C                     259 - 384  THIRD RECORD, ETC.
C         CSTNME - CHARACTER VARIABLE, THE STRUCTURE NAME FOR THE RECORD
C                  STATEMENT BEING PROCESSED
C         CSTR   - CHARACTER VARIABLE, TABLE OF ALL STRUCTURE NAMES
C                  DEFINED IN THE MODULE CURRENTLY PROCESSED. A MAXIMUM
C                  OF 1000 UNIQUE  STRUCTURES MAY OCCUR.
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CSTRNM - CHARACTER VARIABLE, TABLE OF ALL NESTED STRUCTURES
C                  WITHIN A SINGLE NESTED GROUP DEFINED IN THE MODULE
C                  BEING PROCESSED. A MAXIMUM OF 6 NESTED STRUCTURES MAY
C                  OCCUR.
C                  RECORD STRUCTURE
C
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C
C                  1 - 32 A*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CSUBTB - CHARACTER VARIABLE, TABLE OF ALL DEFINED ENTRY,
C                  FUNCTION, AND SUBROUTINE SUBPROGRAM DEFINITIONS. A
C                  MAXIMUM OF 1000 SUBPROGRAMS ARE ALLOWED.
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZER0)
C                  37-44  11   TYPE AND LENGTH CHARACTERISTICS
C                  45-48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS IN COLS 1-32
C                  53-56  14   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CTYPE  - CHARACTER VARIABLE, THE TYPE CODE FOR A VARIABLE,
C                  USED TO SORT VARIABLE NAMES
C         CTYPED - CHARACTER VARIABLE, THE TYPE CODE FOR A VARIABLE,
C                  USED TO SORT VARIABLE NAMES
C         CUNION - CHARACTER VARIABLE, TABLE OF ALL VARIABLE NAMES
C                  USED WITHIN A UNION. A MAXIMUM OF 500 RE ALLOWED.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED WITHIN A UNION
C                     33 A*1       DATA TYPE CODE OF VARIABLE
C                  34-40 A*7    10 VARIABLE LENGTH CHARACTERISTIC
C                  41-44 I*4    11 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C         CVARST - CHARACTER VARIABLE, CONTAINS THE NAME OF ALL
C                  VARIABLES DEFINED WITHIN STRUCTURES IN THE
C                  CURRENT MODULE.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED IN THE CURRENT
C                                  STRUCTURE
C                  33-64 A*32   16 NAME OF THE STRUCTURE DEFINING THE
C                                  VARIABLE IN COLS 1-32
C                     65 A*1       DATA TYPE CODE OF THE VARIABLE IN
C                                  COLS 1-32
C                  66-72 A*7    18 LENGTH DEFINITION OF THE VARIABLE IN
C                                  COLS 1-32
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CZZ    - CHARACTER VARIABLE, THE CHARATCER: Z
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FUNTBL - A TABLE OF STANDARD FORTRAN INTRINSIC FUNCTIONS
C                  COLS  1-32 THE FUNCTION NAME
C                  COLS 33-35 THE TYPE AND LENGTH OF FUNCTION'S RETURN
C                             VALUE AS NUMERIC CHARACTERS. A # IN COLUMN
C                             34 INDICATES THE LENGTH IS DEPENDENT UPON
C                             ARGUMENTS OF THE FUNCTION.
C
C                  TYPE CODES USED ARE:
C
C                  B - SINGLE PRECISION COMPLEX
C                  C - CHARACTER
C                  D - DOUBLE PRECISION REAL
C                  E - DOUBLE PRECISION COMPLEX
C                  I - INTEGER (ALL LENGTHS)
C                  L - LOGICAL (ALL LENGTHS)
C                  R - SINGLE PRECISION REAL
C         FCONFT - ARRAY OF ALL REAL CONSTANTS OCCURING IN A PROGRAM
C                  MODULE. THE ARRAY IS DEFINED AS DOUBLE PRECISION.
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C         IA     - INDICATES AN END OF FILE WHEN IT EQUALS -1, ALSO
C                  USED AS A WORK AREA
C         IB     - WORK AREA, LENGTH OF THE FILE NAME PORTION FROM THE
C                  FIRST CHARACTER THROUGH TO THE PERIOD FOR COMPOUND
C                  VARIABLES
C         ICAPS  - THE VALUE TO SUBTRACT FROM A LOWER CASE ALPHABETIC
C                  CHARACTER TO CONVERT IT TO UPPER CASE FOR ASCII CODE
C         ICOMKT - COUNT OF ENTRIES IN COMTBL, A LIST OF ALL COMMON
C                  BLOCK NAMES
C         ICONF  - COUNT OF THE NUMBER IF REAL CONSTANTS IN FCONFT
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN ICONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C                  THIS TABLE MAY HAVE MULTIPLE ENTRIES FOR THE SAME
C                  INTEGER WHEN THE INTEGER IS USED IN DIFFERENT
C                  STATEMENTS THROUGH OUT THE PROGRAM MODULE.
C         ICONT  - THE MAXIMUM NUMBER OF CONTINUATION RECORDS ALLOWED
C         ICONTL - THE STARTING AND ENDING LOCATION OF EACH RECORD IN A
C                  FORTRAN STATEMENT
C         ICTN   - THE VALUE TO ADD TO AN INTEGER DIGIT TO CONVERT IT
C                  TO A TEXT DIGIT, OT TO SUBTRACT FROM A TEXT DIGIT
C                  TO CONVERT IT TO AN INTEGER DIGIT.
C         IDTN   - THE VALUE TO CHANGE A CHARACTER DIGIT TO AN ALGEBRAIC
C                  DIGIT OR FROM AN ALGEBRAIC NUMERIC VALUE TO A
C                  CHARACTER DIGIT
C         IDXA   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 4 IF A FOUR BYTE WORD IS BEING USED
C         IDXB   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IDXC   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IDXD   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IDXF   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IE     - LOCATION OF THE FIRST CHARACTER IN THE STATEMENT
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IEOF   - INDICATES AN END OF FILE WHEN IT EQUALS -1
C         IERR   - THE ERROR RETURN CODE FFORM CALLING FUNCTION
C                  NUM_FILES
C         IFLEN  - LENGTH OF EACH FIELD TO BE SORTED IN THE SORT
C                  ROUTINES
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         ILIT   - COUNT OF THE NUMBER OF LITERALS ON UNIT 9
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         INFILE - COUNT OF THE NUMBER OF DIFFERENT INPUT FORTRAN SOURCE
C                  FILES TO BE PROCESSED. THE MAXIUMUM IS 10.
C         INPUT  - INPUT UNIT NUMBER FOR SOURCE FORTRAN CODE. NORMALLY,
C                  ITS VALUE IS 5, BUT THE OCCURRENCE OF AN INCLUDE
C                  STATEMENT CAUSES IT TO BE MODIFIED SO THAT THE
C                  INCLUDED FILE MAY BE PROCESSED. WHEN MODIFIED, THE
C                  VALUES ARE FROM 14 THROUGH 20 DEPENDING WHETHER
C                  NESTED INLUDE STATEMENT OCCUR. IT WILL EVENTUALLY
C                  BE SET TO A VALUE OF 5 TO CONTINUE PROCESSING OF THE
C                  MAIN ROUTINE THAT CONTAINS THE INCLUDE STATEMENT.
C         IOUTC  - ARRAY OF INPUT-OUTPUT UNITS DEFINED AS A CONSTANT
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN IOUTC
C         IOUTNV - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN COUTV
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN THE TABLE OF
C                  INTEGER PARAMETER DEFINITIONS
C         IPAGE  - COUNT OF THE PAGES PRINTED IN THE LISTING FILE
C         IPGNME - PROGRAM NAME CHARACTER LENGTH
C         IQ     - DO LOOP PARAMETER, AND WORK AREA
C         IR     - DO LOOP PARAMETER
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINITIONS
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IREC3  - COUNT OF THE NUMBER OF RECORDS ON UNIT 3
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IREC7  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 7 (VARIABLE NAMES)
C         IREC8  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 8 (INPUT-OUTPUT VARIABLE
C                  NAMES
C         IREC9  - COUNT OF THE NUMBER OF LITERAL RECORDS WRITTE ON
C                  UNIT 9
C         IREC11 - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 11 (COMMON DEFINITIONS)
C         IRET   - A VALUE RETURNED FROM SUBROUTINE COMPRS. SET TO ZERO
C                  TO CONTINUE THE NEXT STATEMENT, SET TO 1 TO EXECUTE
C                  STATEMENT NUMBER 17. SUBROUTINE COMPRS RETURNS A
C                  VALUE OF 1 WHEN AN INCLUDE STATEMENT HAS AN INVALID
C                  LITERAL AS ITS ARGUMENT. THE INCLUDE STATEMENT IS NOT
C                  PROCESSED.
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         ISNUM  - TABLE OF DEFINED STATEMENT NUMBERS FOUND IN THE
C                  PROGRAM; WORD 1 CONTAINS THE STATEMENT
C                  NUMBER VALUE, WORD 2 CONTAINS THE ISN DEFINING
C                  THE STATMENT NUMBER (128 IS NOT ADDED TO THIS VALUE)
C         ISPLIT - DETERMINE IF THE OUTPUT FILE IS SPLIT INTO TWO
C                  SEPARATE FILES WHEN THE OUTPUT FILE IS CREATED AS A
C                  POSTSCRIPT FILE. VALUES ARE:
C                  1 - A SINGLE OUTPUT FILE IS CREATED WITH PAGES IN
C                      ASCENDING ORDER. VARIABLE LPS MAY BE TRUE OR
C                      FALSE.
C                  2 - THE OUTPUT FILE IS CREATED AS TWO SEPARATE FILES.
C                      ONE FILE CONTAINS THE ODD PAGES, THE OTHER FILE
C                      CONTAINS THE EVEN PAGES. BOTH FILES HAVE PAGES IN
C                      ASCENDING ORDER. VARIABLE LPS MUST BE TRUE.
C                  3 - THE OUTPUT FILE IS CREATED AS TWO SEPARATE FILES.
C                      ONE FILE CONTAINS THE ODD PAGES IN ASCENDING
C                      ORDER; THE FILE CONTAINING THE EVEN PAGES ARE IN
C                      DESCENDING (REVERSE) ORDER. VARIABLE LPS MUST BE
C                      TRUE.
C         ISRECL - THE RECORD LENGTH OF THE STATEMENT FOLLOWING AN
C                  INCLUDE STATEMENT IN THE SOURCE CODE
C         ISTART - THE START LOCATION OF A FIELD IN A RECORD TO BE
C                  SORTED
C         ISTRUC - COUNT OF THE NUMBER OF STRUCTURE STATEMENTS. THIS
C                  VALUE IS THE TOTAL NUMBER OF STRUCTURE STATEMENTS
C                  DEFINED IN TABLE CSTR.
C         IUNION - COUNT OF THE LEVELS OF UNION STATEMENTS. ONE IS
C                  ADDED WHEN A UNION STATEMENT IS PROCESSED, ONE
C                  IS SUBTRACTED WHEN AN END UNION STATEMENT IS
C                  PROCESSED.
C         IUSIZE - THE SIZE OF THE UNION. THIS VALUE IS THE SIZE OF THE
C                  LARGEST MAP ENCAPSULATED BY THE UNION.
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - SUBSCRIPT VARIABLE
C         I2WK1  - LENGTH 2 INTEGER VARIABLE. USED TO FORCE ALPHABETIC
C                  CHARACTERS TO UPPER CASE
C         I4WK1  - LENGTH FOUR INTEGER VARIABLE. USED AS A GENERAL WORK
C                  AREA
C         J      - SUBSCRIPT VARIABLE, THIS VARIABLE USIALLY INDICATES
C                  THE LOCATION OF THE CURRENT CHARACTER BEING PROCESSED
C                  WITHIN A FORTRAN STATEMENT.
C         JA     - SUBSCRIPT VARIABLE, AND DO LOOP PARAMETER
C         JB     - SUBSCRIPT VARIABLE
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         JBTEST - BIT SWITCHES SET IN CNAME THAT ARE COMPARED AGAINST
C                  JBITS. AFTER CORRECTION FOR SWITCHES SET IN JBITS BUT
C                  NOT IN CNAME FOR THE CURRENT VARIABLE, THE CNAME
C                  COLUMNS 45 - 48 ARE REPLACED WITH JBTEST.
C         JC     - SUBSCRIPT VARIABLE
C         JCONFT - THE ISN OF AN ENTRY IN FCONFT
C         JDIM   - THE NUMBER OF DIMENSION TABLE ENTRIES IN CDIM
C         JFILES - INDEX COUNT OF THE SOURCE INPUT FILE CURRENTLY BEING
C                  PROCESSED. THIS CONTROLS THE FILE BEING PROCESSED
C                  WHEN MORE THAN ONE FORTRAN SOURCE CODE INPUT FILE
C                  IS SPECIFIED IN THE CONTROL CARD FILE.
C         JINCL  - COUNT OF THE NUMBER OF INCLUDE STATEMENT FILE NAMES
C                  CURRENTLY ACTIVE
C         JPGNME - PROGRAM NAME CHARACTER LENGTH SAVED
C         JSNA   - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS WHEN THE STATEMENT IS
C                  READ, EXCEPT COMMENTS AND CONTINUTION STATEMENTS.
C                  THIS IS THE PRINTED OUTPUT VALUE.
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUC
C         JSTRUC - COUNT OF THE LEVELS OF NESTED STRUCTURE STATEMENTS.
C                  ONE IS ADDED WHEN A STRUCTURE STATEMENT IS PROCESSED,
C                  ONE IS SUBTRACTED WHEN AN END STRUCTURE STATEMENT IS
C                  PROCESSED. THIS CONTROL ENTRIES INTO TABLE CSTRNM.
C         JSUBTB - EQUIVALENCED TO CSUBTB
C         JUNION - COUNT OF THE LEVELS OF UNION STATEMENTS. ONE IS ADDED
C                  WHEN A UNION STATEMENT IS PROCESSED, ONE IS
C                  SUBTRACTED WHEN AN END UNION STATEMENT IS PROCESSED.
C         K      - COUNTER OF THE NUMBER OF CARD IMAGES READ FOR A
C                  SINGLE FORTRAN STATEMENT
C         KA     - START POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KBITS  - INTEGER VALUE USED TO SET THE BIT SWITCHES FOR CDEF
C         KC     - LOCATION OF THE FIRST CHARACTER OF THE FORTRAN
C                  STATEMENT IN CSTMT
C         KD     - LOCATION OF THE LAST CHARACTER IN THE RECORD IN CREC
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KG     - LAST CHARACTER LOCATION IN CREC; USED TO LOCATE THE
C                  NEXT FORTRAN STATEMENT TO BE PROCESSED
C         KH     - SAVE AREA FOR THE LOCATION OF THE LAST CHARACTER IN
C                  CSTMT
C         KI     - COUNT OF THE INDEX OF WORK AREA IW USED IN EVALUATING
C                  EXPRESSIONS OF PARAMETER DEFINITIONS
C         KISN   - SAVE AREA FOR THE ISN OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         KSNA   - SAVE AREA FOR JSNA OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         L      - LOGICAL VARIABLE, SET TRUE WHEN A CONTINUATION RECORD
C                  EXISTS, SET FALSE OTHERWISE. LATER USED TO INDICATE
C                  WHEN FORMAT ARE THE FIRST SIX CHARACTERS OF A
C                  STATEMENT AND AN EQUAL SIGN ALSO OCCURS, FALSE WHEN
C                  NOT.
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN A NEW STATEMENT HAS
C                  BEEN FOUND, SET FALSE OTHERWISE
C         LAPOS  - LOGICAL VARIABLE, SET TRUE WHEN LITERALS ARE
C                  ENCAPSULATED IN QUOTATION MARKS("); SET FALSE IF
C                  LITERALS ARE ENCAPSULATED IN APOSTROPHES(').
C         LASC   - LOGICAL VARIABLE, SET TRUE FOR ASCENDING SORT
C         LB     - LOGICAL VARIABLE, SET FALSE TO READ THE FIRST RECORD
C                  ON UNIT 5, SET TRUE FOR ALL SUBSEQUENT RECORDS
C         LC     - LOGICAL VARIABLE, SET TRUE TO FORCE A CALL TO WRSTMT,
C                  SET FALSE OTHERWISE
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LCONT  - LOGICAL VARIABLE, SET TRUE WHEN THE LISTING HEADER
C                  HAS BEEN WRITTEN FOR THE INITIAL STATEMENT WHEN IT
C                  IS A COMMENT STATEMENT. SET FALSE OTHERWISE; THIS
C                  ALLOWS THE INITIAL HEADER TO BE WRITTEN ONLY ONCE.
C         LD     - LOGICAL VARIABLE, SET TRUE WHEN A POSSIBLE ARITHMETIC
C                  STATEMENT HAS AN EQUAL SIGN NOT ENCAPSULATED BY LEFT
C                  AND RIGHT PARENTHESES. THIS INDICATES THE STATEMENT
C                  IS AN ARITHMETIC STATEMENT. SET FALSE OTHERWISE.
C         LE     - LOGICAL STATEMENT, SET TRUE WHEN A STATEMENT IS A
C                  BLANK RECORD OR A COMMENT STATEMENT, SET FALSE
C                  OTHERWISE
C         LEND   - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL RECORD
C                  OF THE FORTRAN PROGRAM TO BE ANALYZED HAS BEEN READ.
C                  AN END OF DATA HAS BEEN REACHED. SET FALSE OTHERWISE.
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF A FORTRAN ROUTINE HAS BEEN READ. SET FALSE
C                  OTHERWISE; NOT THE END OF FILE FOR UNIT 5 OR AN
C                  INCLUDED FILE WHEN SET TRUE.
C         LEOF   - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE IS
C                  REACHED ON UNIT 5, SET FALSE OTHERWISE. THIS SWITCH
C                  IS USED TO INSURE INPUT WORK BUFFERS ARE FILLED WITH
C                  BLANKS WHEN MULTIPLE FILES OF FORTRAN CODE INPUT
C                  ARE BEING PROCESSED.
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF THE STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT. IT IS USED TO FORCE
C                  PROCESSING OF A NEW STATEMENT.
C         LEXIST - LOGICAL VARIABLE, SET TRUE IF WORK FILES USED BY THIS
C                  PROGRAM EXIST, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFOR   - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST SIX
C                  CHARACTERS BEING PROCESSED ARE FORMAT, SET FALSE
C                  OTHERWISE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IS
C                  TO BE PERFORMED, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LINCLM - LOGICAL VARIABLE, SET TRUE WHEN THE UNIT NUMBER IS
C                  INCREMENTED BY ONE IN ROUTINE RDSTMT, SET FALSE
C                  OTHERWISE. THIS PREVENTS ROUTINE STMT33 FROM
C                  INCREMENTING THE UNIT NUMBER AGAIN AFTER IT HAS
C                  ALREADY BEEN DONE ONCE.
C         LNONE  - LOGICAL VARIABLE, SET TRUE WHEN AN IMPLICIT NONE
C                  IS SPECIFIED FOR A PROGRAM OR SUBPROGRAM, SET FALSE
C                  OTHERWISE.
C         LPARAM - LOGICAL VARIABLE, SET TRUE WHEN A PARAMETER STATEMENT
C                  IS BEING PROCESSED, SET FALSE OTHERWISE. THIS SWITCH
C                  IS USED TO SAVE THE VALUES OF ALL INTEGER PARAMETER
C                  DEFINITIONS IN CASE THE INTEGER PARAMETER VARIABLE
C                  IS USED AS A DIMENSION SIZE OR A CHARACTER LENGTH
C                  SPECIFICATION.
C         LPAREN - LOGICAL VARIABLE, SET TRUE WHEN A PARAMETER STATEMENT
C                  HAS A BALANCED NUMBER OF LEFT AND RIGHT PARENTHESES,
C                  SET FALSE OTHERWISE.
C         LPGNUM - LOGICAL VARIABLE, SET TRUE WHEN THE OUTPUT LISTING ON
C                  UNIT 3 IS TO HAVE A MAXIMUM OF 60 LINES PER PAGE, SET
C                  FALSE WHEN THE OUTPUT LISTING IS TO HAVE A MAXIMUM OF
C                  80 LINES PER PAGE
C         LPS    - LOGICAL VARIABLE, SET TRUE WHEN THE OUTPUT LISTING IS
C                  CREATED AS A POSTSCRIPT FILE. VARIABLE ISPLIT MAY
C                  HAVE A VALUE OF 1 - 3. SET FALSE WHEN THE LISTING IS
C                  CREATED AS A TEXT FILE WITH CARRIAGE CONTROL
C                  CHARACTERS IN COLUMN 1 OF EACH RECORD; VARIABLE
C                  ISPLIT MUST HAVE A VALUE OF 1.
C         LREC   - LOGICAL VARIABLE, SET TRUE WHEN PROCESSING A RECORD
C                  STATEMENT, SET FALSE OTHERWISE
C         LRET   - LOGICAL VARIABLE, SET TRUE WHEN STMT07 IS CALLED FROM
C                  SUBROUTINE COMPRS, SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE,
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT, JSTRUC, RETURNS TO ZERO.
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 0.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LUNION - LOGICAL VARIABLE, SET TRUE WHEN A UNION STATEMENT IS
C                  PROCESSED, SET FALSE WHEN AN END UNION IS PROCESSED
C         LVAR   - LOGICAL VARIABLE, SET TRUE WHEN A FORTRAN STATEMENT
C                  IS AN EXPRESSION, SET FALSE WHEN IT IS A COMMAND
C         LWR    - LOGICAL VARIABLE, SET TRUE TO FORCE WRITING OUT
C                  THE CROSS REFERENCE LISTING, SET FALSE OTHERWISE.
C                  THE VALUE IS SET IN SUBROUTINES STMT21 AND RDSTMT.
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST RECORD OF
C                  THE FORTRAN SOURCE CODE INPUT IS TO BE PROCESSED, SET
C                  FALSE FOR ALL OTHER RECORDS. THIS PREVENTS SUBSEQUENT
C                  SUBPROGRAMS FROM HAVING THEIR INITIAL RECORD FROM
C                  BEING WRITTEN ON THE OUTPUT LISTING TWICE.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A STATEMENT'S FIRST
C                  SEVEN CHARACTERS ARE 'PROGRAM', BUT THE STATEMENT
C                  IS NOT A PROGRAM STATEMENT, SET FALSE OTHERWISE.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE MAIN MODULE HAS
C                  PLACED THE PROGRAM NAME IN CFMTH IF THERE IS NO
C                  PROGRAM STATEMENT, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A BACKSPACE HAS BEEN
C                  PERFORMED, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE ONCE ARRAY CNAME IS
C                  CHECKED AFTER THE FIRST EXECUTABLE STATEMENT HAS
C                  BEEN PROCESSED; SET FALSE OTHERWISE. WHEN THE FIRST
C                  EXECUTABLE STATEMENT HAS BEEN OCCURS, ARRAY CNAME
C                  IS CHECKED TO INSURE THAT ALL DEFINED VARIABLES
C                  HAVE TYPE AND LENGTH CHARACTERISTICS DEFINED.
C         MNUM   - COUNT OF THE NUMBER OF ENTRIES INTO TABLE ISNUM
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C         NARGD  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C         NB     - SAVE AREA FOR THE VALUE OF KB WHILE PROCESSING
C                  INCLUDE FILES.
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  CONTAINING THE FORTRAN SOURCE CODE TEXT
C         NLINE  - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON A
C                  SINGLE PAGE IN THE OUTPUT LISTINGS
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C         NLIMIT - MAXIMUM NUMBER OF LINES PER PRINTED PAGE
C         NUMFIL - NUMBER OF ALLOWED FILES TO BE OPEN SIMULTANEOUSLY
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 121 CHAR-
C                  ACTERS OR LESS
C         1      - CONTROL CARDS CONTAINING THE FILE NAME OF THE FORTRAN
C                  CODE TO BE ANALYZED; RECORD LENGTH IS 80 CHARACTERS.
C                  AFTER READING THE CONTROL CARDS, UNIT 1 IS CLOSED AND
C                  THEN MAY BE REOPENED TO SAVE ALL COMMON BLOCK
C                  DEFINITIONS OCCURRING WITHIN THE ENTIRE PROGRAM WHEN
C                  GLOBAL ANALYSIS IS REQUESTED. UNIT 11 CONTAINS DATA
C                  USED TO DETERMINE THE LENGTH OF A COMMON BLOCK WITHIN
C                  A SINGLE SUBPROGRAM.
C         2      - THIS UNIT CONTAINS ALL ISN REFERENCES OF INPUT-OUPUT
C                  UNITS DEFINED BY A VARIABLE NAME. RECORD LENGTH IS 40
C                  CHARACTERS.
C         3      - LIST OF ALL DEFINED SUBPROGRAMS THAT CAN BE CALLED.
C                  EVERY SUBROUTINE, ENTRY, AND DEFINED FUNCTION
C                  SUBPROGRAM HAS A SINGLE RECORD ON THIS FILE. THE
C                  RECORD CONTAINS A LIST AND DEFINITION OF UP TO 30
C                  ARGUMENTS OF THE SUBPROGRAM. INTRINSIC FUNCTIONS USED
C                  ARE NOT IN THIS FILE. EACH RECORD IS 1496 CHARACTERS.
C                  THIS IS A GLOBAL RECORD AND EXTENDS BEYOND A SINGLE
C                  SUBPROGRAM.
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C         5      - THE FORTRAN PROGRAM TO BE CROSS REFERENCED; RECORD
C                  LENGTH IS UP TO 132 CHARACTERS
C         6      - THE OUTPUT LISTING FILE TO BE PRINTED
C         7      - THE VARIABLE NAMES AND THE ISNS WHERE THEY OCCUR,
C                  RECORD LENGTH IS 52 CHARACTERS
C         8      - NUMERIC INPUT-OUTPUT UNIT NAMES, RECORD LENGTH IS 40
C                  CHARACTERS
C         9      - LITERALS AND THE ISNS WHERE THEY OCCUR, RECORD LENGTH
C                  IS 92 CHARACTERS
C        10      - LIST OF ALL CALLED SUBPROGRAMS WITHIN THE ENTIRE
C                  PROGRAM. THIS IS A GLOBAL RECORD AND EXTENDS BEYOND A
C                  SINGLE SUBPROGRAM. RECORD LENGTH IS 1532 CHARACTERS.
C                  THIS FILE CONTAINS ONLY THE CALL STATEMENTS.
C        11      - LIST OF COMMON DEFINITIONS BY BLOCK FOR NAMED AND
C                  BLANK COMMON, RECORD LENGTH IS 40 CHARACTERS. UNIT 1
C                  CONTAINS DATA TO VERIFY COMMON BLOCK LENGTH BETWEEN
C                  DIFFERENT SUBPROGRAMS. DATA ON THIS UNIT IS USED TO
C                  DETERMINE THE LENGTH OF ALL COMMON DEFINITIONS IN A
C                  SINGLE PROGRAM MODULE.
C        12      - LIST OF EQUIVALENCED VARIABLES BY GROUP, RECORD
C                  LENGTH IS 72 CHARACTERS
C        13 - 20 - INCLUDE FILES OF A PROGRAM OR SUBPROGRAM
C
C     DATA TYPE DEFINITIONS
C
C        STANDARD DEFINITIONS FOR ALL RECORD STRUCTURES REFERING TO THE
C        DATA TYPE OF A VARIABLE
C
C         CODE      DESCRIPTION
C           A       BYTE
C           B       COMPLEX, 8 BYTES
C           C       CHARACTER
C           D       DOUBLE PRECISION, REAL*8
C           E       DOUBLE COMPLEX, COMPLEX*16
C           I       INTEGER
C           L       LOGICAL
C           R       REAL
C
C     BIT SWITCHES
C
C     BIT SWITCHES ARE USED TO RECORD USAGE OF VARIABLES IN A PROGRAM
C     MODULE. THEY CONTROL THE USAGE CODES SHOWN FOR EACH VARIABLE IN
C     OUTPUT TABLE 1, THE LIST OF ALL VARIABLES. NOTE THAT DIFFERENT
C     BIT SWITCHES MAY CAUSE THE SAME CODE TO APPEAR IN THE OUTPUT
C     LISTING. BIT SWITCHES ALSO INDICATE OTHER CHARCTERISTICS OF
C     VARIABLES USED WITHIN THE PROGRAM BEING ANALYZED.
C
C     STANDARD MEANING OF BIT SWITCHES USED TO INDICATE A CONDITION
C     EXISTS OR A PARTICULAR USAGE OF THE VARIABLE; WHEN SET TO 1,
C     THE SWITCH IS ON (EQUIVALENT TO TRUE); WHEN SET TO ZERO, THE
C     SWITCH IS OFF (EQUIVALENT TO FALSE).
C
C     CHAR &
C        BIT  HEX  PRINT
C     NUMBER VALUE CODE  DESCRIPTION
C
C     45  0   1        NOT USED
C         1   2    C   THE VARIABLE IS IN A COMMON BLOCK
C         2   4    R   THE VARIABLE IS IN A RECORD DEFINITION
C         3   8    E   THE VARIABLE IS IN AN EQUIVALENCE DEFINITION
C         4   1    N   THE VARIABLE IS IN A NAMELIST DEFINITION
C         5   2    U   THE VARIABLE IS IN A UNION DEFINITION
C         6   4    T   THE VARIABLE IS IN A STRUCTURE DEFINITION
C         7   8    A   THE VARIABLE IS AN ARGUMENT IN A SUBPROGRAM CALL
C                      OR AN INPUT - OUPUT CONTROL LIST
C     46  8   1    B   THE VARIABLE IS AN ENTRY SUBPROGRAM DEFINITION
C                      NAME
C         9   2    S   THE VARIABLE IS A SUBROUTINE SUBPROGRAM
C                      DEFINITION NAME
C        10   4    F   THE VARIABLE IS A FUNCTION SUBPROGRAM DEFINITION
C                      NAME
C        11   8    C   THE VARIABLE IS A COMMON BLOCK DEFINITION NAME
C        12   1    N   THE VARIABLE IS A NAMELIST DEFINITION NAME
C        13   2    T   THE VARIABLE IS A STRUCTURE DEFINITION NAME
C        14   4    P   THE VARIABLE IS A PARAMETER DEFINITION NAME
C        15   8        THE VARIABLE IS TO APPEAR IN THE OUTPUT LISTINGS
C     47 16   1    F   THE VARIABLE IS AN INTRINSIC FUNCTION NAME
C        17   2    D   THE VARIABLE IS DIMENSIONED
C        18   4        A CALLED SUBPROGRAM NAME MATCHES A DEFINED
C                      SUBPROGRAM NAME
C        19   8        A FUNCTION STATEMENT HAS A LENGTH BUT NO DATA
C                      TYPE
C        20   1        THIS VARIABLE IS AN ENTRY, FUNCTION, OR SUBROUTINE
C                      DUMMY ARGUMENT
C        21   2        A SUBPROGRAM NAME IS AN EXTERNAL ROUTINE
C        22   4        NOT USED
C        23   8        NOT USED
C     48 24   1        NOT USED
C        25   2        NOT USED
C        26   4        NOT USED
C        27   8        NOT USED
C        28   1        NOT USED
C        29   2        NOT USED
C        30   4        NOT USED
C        31   8        NOT USED
C
C         THE THREE COMMON DEFINITIONS /ALPHA/, /DIGITS/, AND /SYMBOL/
C         CONTAIN SINGLE CHARACTER TYPE VALUES OF THE ALPHABET, DIGITS,
C         AND SPECIAL SYMBOLS USED THROUGH OUT THE PROGRAM.
C         IN THE /ALPHA/ COMMON DEFINITION, THE ALPHABETIC CHARACTERS
C         ARE ALL UPPER CASE, EXCEPT CAS, CCS, CSC, AND CZS.
C
C     COMMENTS
C
C         FXREF PRESUMES THAT THE INPUT FORTRAN SOURCE CODE FILE
C         CONTAINS A SINGLE PROGRAM, AND THAT ALL SUBPROGRAM MODULES
C         BELONG TO THAT PROGRAM. MIXING DIFFERENT PROGRAMS MAY CAUSE
C         THE OUTPUT FILE TO BE INACCURATE. THE INPUT FORTRAN SOURCE
C         CODE MAY CONTAIN THE INCLUDE STATEMENT. ANY INCLUDE FILE
C         REQUIRED BY THE SOURCE FORTRAN CODE MUST BE IN THE SAME
C         DIRECTORY AS THE FIRST INPUT FILE FROM UNIT 5; OTHERWISE,
C         FXREF TERMINATES EXECUTION WITH AN ERROR MESSAGE ON THE
C         THE MONITOR SCREEN.
C
C         THE SUBROUTINES THAT PROCESS INDIVIDUAL FORTRAN STATEMENTS ARE
C         NAMED STMTXX, WHERE XX RANGES FROM 01 THROUGH 60. THERE ARE
C         NO SUBROUTINES NAMED STMT03, STMT28, STMT40, STMT51, STMT56,
C         OR STMT58.  THE STATEMENTS THEY REPRESENT ARE PROCESSED BY
C         ONE OF THE OTHER STMTXX ROUTINES.
C
C         INTERNAL STATEMENTS NUMBERS WRITTEN ONTO DISK FILES HAVE
C         A VALUE OF 128 ADDED TO THEM TO AVOID THE BINARY VALUE
C         FROM BEING INTERPRETED AS ASCII COMMANDS WITH VALUES FROM
C         HEX 00 THROUGH 1F. THIS TECHNIQUE AVOIDS CORRPUTION OF THE
C         WORK FILES WHEN THEY ARE SORTED OR READ.
C         WHEN THE ISN VALUE IS LESS THAN -1, THIS SIGNIFIES THE
C         VARIABLE NAME IS THE NAME OF A COMMON BLOCK OR RECORD
C         DEFINITION.
C
C         STANDARD FORTRAN DEFAULT TYPING OF ALL VARIABLES IS USED
C         BY THIS PROGRAM. EACH ROUTINE CONTAINS AN IMPLICIT STATEMENT
C         TO INSURE THIS STANDARD IS MET. HOWEVER, THIS PROGRAM USES AN
C         INTERNAL STANDARD THAT ALL VARIABLES STARTING WITH THE LETTER
C         L ARE LOGICAL VARIABLES, AND THOSE STARTING WITH THE LETTER C
C         ARE CHARACTER VARIABLES. EXCEPTIONS ARE THE NAMES OF TABLES.
C
C         OS/2 PROGRAMS RUNNING AS A PROCESS ARE ALLOWED A MAXIMUM OF 20
C         SIMULTANEOUSLY OPEN FILES. WHEN A FORTRAN MODULE BEING
C         ANALYZED BY FXREF CONTAINS INCLUDE STATEMENTS DEFINING FILES
C         INCLUDED WITH THE CURRENT CODE, FXREF REQUIRES MORE THAN THE
C         MINIMUM 20 FILES.  WATCOM FORTRAN FOR OS/2 ALLOWS THIS VALUE
C         TO BE INCREASED BY CALLING A LIBRARY FUNCTION NAMED
C         GROWHANDLES.THIS IS A NONSTANDARD FORTRAN FUNCTION, AND IT
C         MUST NOT BE USED FOR OTHER OPERATING SYSTEMS AND OTHER
C         COMPILERS. SOME OPERATING SYSTEMS MAY NOT HAVE THIS
C         LIMITATION.  DELETE THE STATEMENT WHICH MODIFIES THE TOTAL
C         OPEN FILES LIMIT COMMENTS OFR NON-OS/2 OPERATING SYSTEMS.
C         OTHER OPERATING SYSTEMS MAY REQUIRE A REPLACEMENT FUNCTION
C         WHICH COULD INVOLVE SETTING THE CORRECT ENVIORNMENT
C         PARAMETERS FOR THE OPERATING SYSYTEM; LIKEWISE, OTHER FORTRAN
C         COMPILERS MAY OR MAY NOT REQUIRE SPECIAL PARAMETERS TO ALLOW
C         A SUFFICIENT NUMBER OF OPEN FILES FOR THIS PROGRAM.
C
C     CONTROL CARD RECORD STRUCTURE ON UNIT 1
C
C     FILE NAME: FXREF.CCD
C
C     THIS FILE MUST BE IN THE SAME DIRECTORY AS THE EXECUTION MODULE:
C     FXREF.EXE UNLESS THE PATH COMMAND IN CONFIG.SYS CONTAINS A
C     REFERENCE TO THE PATH LOCATION FOR THE FILE.
C
C         CARD 1
C         COLUMNS  CONTENTS  MEANING
C
C            1        T      THE OUTPUT LISTING ON UNIT 6 IS TO HAVE 60
C                            LINES PER PAGE
C                     F      THE OUTOUT LISTING ON UNIT 6 IS TO HAVE 80
C                            LINES PER PAGE
C            2        T      THE OUTPUT LISTING ON UNIT 6 IS TO BE A
C                            POSTSCRIPT FILE. COLUMN 4 MAY HAVE VALUES
C                            BETWEEN 1 AND 3
C                     F      THE OUTPUT LISTING ON UNIT 6 IS TO BE A
C                            TEXT FILE WITH STANDARD CARRIAGE CONTROL
C                            CHARACTERS IN COLUMN 1 OF EACH RECORD TO BE
C                            PRINTED. COLUMN 4 MUST BE 1.
C            3        F      NO GLOBAL ANALYSIS OF COMMON BLOCK LENGTHS
C                            AND ARGUMENT LISTS OF CALL, ENTRY, FUNCTION
C                            SUBROUTINE STATEMENTS WILL BE PERFORMED.
C                     T      GLOBAL ANALYSIS OF COMMON BLOCK LENGTHS AND
C                            ARGUMENT LISTS OF CALL, ENTRY, FUNCTION, &
C                            SUBROUTINE STATEMENTS IS PERFORMED.
C            4        1      A SINGLE OUTPUT FILE IS CREATED WITH PAGES
C                            IN ASCENDING ORDER. COLUMN 2 MAY BE T OR F.
C                     2      THE OUTPUT FILE IS CREATED AS TWO SEPARATE
C                            FILES. ONE FILE CONTAINS THE ODD PAGES, THE
C                            OTHER FILE CONTAINS THE EVEN PAGES. BOTH
C                            FILES HAVE PAGES IN ASCENDING PAGE ORDER.
C                            COLUMN 2 MUST BE T. COLUMN 3 MAY BE T OR F.
C                     3      THE OUTPUT FILE IS CREATED AS TWO SEPARATE
C                            FILES. ONE FILE CONTAINS THE ODD PAGES IN
C                            ASCENDING ORDER; THE FILE CONTAINING THE
C                            EVEN PAGES ARE IN DESCENDING (REVERSE)
C                            ORDER. COLUMN 2 MUST BE T, AND COLUMN 3 MAY
C                            BE T OR F.
C          6 - 7     72      THE COLUMN CONTAINING THE FINAL CHARACTER
C                            OF A FORTRAN LANGUAGE RECORD ON UNIT 5
C          5 - 7    132      THE COLUMN CONTAINING THE FINAL CHARACTER
C                            OF A FORTRAN LANGUAGE RECORD ON UNIT 5
C         CARD 2
C          1 - 80            THE PATH AND FILE NAME OF THE OUTPUT
C                            LISTING FILE (PATH IS OPTIONAL). WHEN A
C                            POSTSCRIPT OUTPUT LISTING IS REQUIRED,
C                            THIS FILE NAME WILL BE MODIFIED IF SEPARATE
C                            ODD PAGE AND EVEN PAGE FILES ARE REQUESTED.
C         CARDS 3 - 12
C          1 - 80            THE PATH AND FILE NAME OF THE INPUT FORTRAN
C                            SOURCE CODE FILES. A MAXIMUM OF 10 FILE
C                            NAMES MAY BE SPECIFIED (PATH IS OPTIONAL).
C                            USE ONE CARD FOR EACH FILE NAME.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         ARGCHK COMCHK COMPRS EXPR LIST LOCERR PMAP PSPRINT RDSTMT
C         SETUP STMT01 STMT02 STMT04 STMT05 STMT06 STMT07 STMT08 STMT09
C         STMT10 STMT11 STMT12 STMT13 STMT14 STMT15 STMT16 STMT17 STMT18
C         STMT18 STMT19 STMT21 STMT23 STMT25 STMT26 STMT27 STMT29 STMT30
C         STMT31 STMT32 STMT33 STMT34 STMT35 STMT36 STMT37 STMT38 STMT39
C         STMT41 STMT42 STMT43 STMT44 STMT45 STMT46 STMT47 STMT48 STMT49
C         STMT50 STMT52 STMT53 STMT54 STMT56 STMT57 STMT59 SUBTBL WKCLOS
C         WKOPEN
C
C     ******************************************************************
C
C         PROGRAM STATEMENT
C
      PROGRAM FXREF
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CFILEB(10)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEN, CFILEB, CIFILE, CLISTN
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CPGWRK, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*4       ICONIT, IOUTC, ISNUM, JCONFT, JSTR
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7  CLEN
      INTEGER*4    NUMFIL
      LOGICAL*4    LEXIST
      LOGICAL*1    LA, LB, LC, LCONT, LD, LE, LPGNUM, LPS, LRET,
     1             L1, L2, L3, L4, L5
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /INFILE/ JFILES, CFILEB
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C    *******************************************************************
C    *                                                                 *
C    *   WHEN MORE THAN 20 SIMULTANEOUSLY OPEN FILES ARE USED, USE THE *
C    *   CODE SEGMENT BELOW.                                           *
C    *                                                                 *
C    *******************************************************************
C
C         EXTERNAL STATEMENTS
C
C     EXTERNAL GROWHANDLES
C     INTEGER GROWHANDLES
C
C         INCLUDE STATEMENTS
C
C     INCLUDE 'E:\WATCOM\SRC\FORTRAN\FSUBLIB.FI'
C
C         PROVIDE THE CORRECT DIRECTORY PATH FOR THE INCLUDE STATEMENT
C         FOR YOUR SYSYTEM.
C
C     ******************************************************************
C
C       SAVE STATEMENT
C
      SAVE
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CDEF(45:48),KBITS), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
      EQUIVALENCE (CDEF(53:56),NARGD), (CDEF(33:36),JSNU),
     1            (CDEF(49:52),MVCNT)
C
C         DATA STATEMENTS FOR THIS ROUTINE ONLY
C
      DATA LEXIST/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' NO CONTROL CARD FILE')
 101  FORMAT(' NO FILE SPECIFIED')
 102  FORMAT(' INPUT FILE EMPTY')
 104  FORMAT(3L1,I1,I3/80A1)
 105  FORMAT(' ISN:',I6,' NOT A FORTRAN STATEMENT')
 106  FORMAT(' INPUT AND OUTPUT FILE NAMES ARE IDENTICAL')
 107  FORMAT(' NOT A FORTRAN STATEMENT: ',A20)
 108  FORMAT(' CONTROL CARD ERROR: COLUMN 4 ERROR FOR TEXT OUTPUT.'/' CO
     1LUMN 4 IS SET TO 1.')
 109  FORMAT(80A1)
 110  FORMAT(' CONTROL CARD ERROR: COLUMN 4 ERROR FOR POSTSCRIPIT OUTPUT
     1.'/' COLUMN 4 IS SET TO 1.')
 111  FORMAT(' FILE NOT FOUND: ',A80)
C
C     ******************************************************************
C     *                                                                *
C     *   PROGRAM INITIALIZATION                                       *
C     *                                                                *
C     ******************************************************************
C
      INQUIRE(FILE='DIAG.LST',EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=13,FILE='DIAG.LST')
         CLOSE (UNIT=13,STATUS='DELETE')
      END IF
      OPEN (UNIT=13,FILE='DIAG.LST',FORM='FORMATTED',ACTION='WRITE',
     1RECL=133,STATUS='NEW')
C
C         SET THE MAXIMUM NUMBER OF FILES TO 20
C
C     NUMFIL = GROWHANDLES(40)
      NUMFIL = 20
C
C         IF WORK FILES FROM A PRIOR RUN EXIST, DELETE THEM
C
      INQUIRE (FILE=CFMESS,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=0,FILE=CFMESS)
         CLOSE (UNIT=0,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFCLEN,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=1,FILE=CFCLEN)
         CLOSE (UNIT=1,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFFUNT,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=2,FILE=CFFUNT)
         CLOSE (UNIT=2,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFSUBP,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=3,FILE=CFSUBP)
         CLOSE (UNIT=3,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFSNUM,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=4,FILE=CFSNUM)
         CLOSE (UNIT=4,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFVNME,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=7,FILE=CFVNME)
         CLOSE (UNIT=7,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFIUNT,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=8,FILE=CFIUNT)
         CLOSE (UNIT=8,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFSLIT,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=9,FILE=CFSLIT)
         CLOSE (UNIT=9,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFCALL,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=10,FILE=CFCALL)
         CLOSE (UNIT=10,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFCOMM,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=11,FILE=CFCOMM)
         CLOSE (UNIT=11,STATUS='DELETE')
      END IF
      INQUIRE (FILE=CFEQUI,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=12,FILE=CFEQUI)
         CLOSE (UNIT=12,STATUS='DELETE')
      END IF
C
C         DETERMINE IF THE CONTROL CARD FILE EXISTS
C
      INQUIRE (FILE='FXREF.CCD',EXIST=LEXIST)
      IF(.NOT.LEXIST) THEN
         WRITE (*,100)
         LEND = LTRUE
         LENDS = LTRUE
         STOP 'FILE FXREF.CCD NOT FOUND'
      END IF
C
C         OPEN THE MESSAGES OUTPUT FILE
C
      OPEN (UNIT=0,FILE=CFMESS,FORM='FORMATTED',ACTION='READWRITE',
     1RECL=121,STATUS='NEW')
C
C         OPEN THE INPUT CONTROL CARD FILE
C
      OPEN (UNIT=1,ACCESS='SEQUENTIAL',FILE='FXREF.CCD',ACTION='READ',
     1FORM='FORMATTED',STATUS='OLD')
C
C         INITIALIZE WORK ARRAYS
C
      JFILES = 1
      CALL SETUP (LB)
      LCONT = LFALSE
      IPAGE = 0
      LC = LTRUE
      L1 = LTRUE
      L5 = LFALSE
      LEND = LFALSE
      LZEND = LFALSE
      DO 10 I = 1,10,8
      CLISTN(I:I+7) = CBLANK(1:8)
 10   CONTINUE
C
C         READ THE FILE NAME OF THE OUTPUT LISTING, AND THE PRINT
C         CONTROL PARAMETERS
C
      READ (1,104,IOSTAT=IEOF) LPGNUM,LPS,LGLOBL,ISPLIT,NCOLS,
     1(CLISTN(IA:IA),IA = 1,80)
C
C         AN END OF FILE FOR THE FIRST RECORD INDICATES THE CONTROL
C         CARD FILE IS EMPTY.
C
      IF(IEOF .EQ. -1) THEN
         WRITE (0,102)
         IREC0 = IREC0 + 1
         GO TO 30
      END IF
C
C         DETERMINE IF PRINT PARAMETERS ARE CORRECT
C
      IF(LPS) THEN
         IF(.NOT.(ISPLIT .GT. 0 .AND. ISPLIT .LE. 3)) THEN
            WRITE (0,110)
            IREC0 = IREC0 + 1
            ISPLIT = 1
         END IF
      ELSE
         IF(ISPLIT .GT. 1) THEN
            WRITE (0,108)
            IREC0 = IREC0 + 1
            ISPLIT = 1
         END IF
      END IF
C
C         OPEN GLOBAL SUBPROGRAM AND CALL ARGUMENT CHECK FILES
C
      IF(LGLOBL) THEN
         IREC3 = 0
         OPEN (UNIT=3,FILE=CFSUBP,FORM='UNFORMATTED',RECL=1496,
     1   STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
         IREC10 = 0
         OPEN (UNIT=10,FILE=CFCALL,FORM='UNFORMATTED',RECL=1532,
     1   STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      END IF
C
C         VERIFY THE VALUE OF THE INPUT RECORD LENGTH CONTAINING
C         FORTRAN CODE. WHEN NO VALUE IS SPECIFIED, SET THE LENGTH TO
C         132 CHARACTERS; WHEN LESS THAN 72, SET THE LENGTH TO 72
C         CHARACTERS.
C
      IF(NCOLS .EQ. 0) NCOLS = 132
      IF(NCOLS .LT. 72) NCOLS = 72
C
C         DETERMINE THE MAXIMUM NUMBER OF CONTINUATION RECORDS ALLOWED
C         FOR THE INPUT RECORD LENGTH
C
      IF(NCOLS .EQ. 72) ICONT = 99
      IF(NCOLS .EQ. 132) ICONT = 51
C
C         READ THE FILE NAMES CONTAINING THE INPUT FORTRAN SOURCE CODE
C         TO BE ANALYZED. ALL FILES SPECIFIED ARE TREATED AS A SINGLE
C         PROGRAM. A MAXIMUM OF TEN FILE NAMES ARE ALLOWED.
C
      DO 11 I = 1,10
      READ (1,109,IOSTAT=I4WK1) (CFILEB(I)(IA:IA),IA = 1,80)
C
C         DETERMINE IF ALL FORTRAN INPUT SOURCE FILE NAMES HAVE BEEN
C         READ
C
      IF(CFILEB(I)(1:1) .EQ. CBLANK(1:1) .OR. I4WK1 .EQ. -1) THEN
C
C         CLOSE THE CONTROL CARD FILE
C
         CLOSE (1)
         INFILE = I - 1
         GO TO 12
      END IF
C
C         DETERMINE IF THE FORTRAN SOURCE CODE INPUT FILE EXISTS
C
      INQUIRE (FILE=CFILEB(I),EXIST=LEXIST)
      IF(.NOT.LEXIST) THEN
         IF(CFILEB(I)(1:8) .NE. CBLANK(1:6)) THEN
            WRITE (*,111) CFILEN(1:80)
            STOP 'UNIT 5 INPUT FILE NOT FOUND'
         END IF
      END IF
C
C         DETERMINE IF ONE OF THE FORTRAN INPUT SOURCE FILE NAMES IS
C         IDENTICAL TO THE OUTPUT FILE NAME.
C
      IF(CFILEB(I)(1:80) .EQ. CLISTN(1:80)) THEN
         WRITE (0,106)
         IREC0 = IREC0 + 1
      END IF
 11   CONTINUE
C
C         DETERMINE IF THE OUTPUT FILE IS SPECIFIED
C
 12   IF(CLISTN(1:1) .NE. CBLANK(1:1)) THEN
         DO 13 JA = 1,80
         IF(CLISTN(JA:JA) .EQ. CDOT(1:1)) THEN
            IF(CLISTN(JA+1:JA+3) .EQ. 'PS ') THEN
               IF(LPS) CLISTN(JA+1:JA+3) = 'PRT'
            END IF
         END IF
 13      CONTINUE
      END IF
C
C         CREATE THE TABLE OF ALL ENTRY, FUNCTION, AND SUBROUTINE
C         SUBPROGRAM NAMES IN THE INPUT FILES IN RECORDS 3 THROUGH 12
C         OF THE FILE FXREF.CCD ON UNIT 1
C
      CALL SUBTBL (CFILEB,INFILE)
C
C         SET THE INITIAL INPUT FILE NAME FOR PROCESSING
C
      CFILEN(1:80) = CFILEB(JFILES)(1:80)
C
C         LOCATE THE PERIOD IN THE INPUT FILE NAME
C
      DO 16 JA = 1,80
      IF(CFILEN(JA:JA) .EQ. CDOT(1:1)) THEN
         J = JA
C
C         DETERMINE IF A BACKSLASH OCCURS
C
         DO 14 JB = 1,JA
         JC = JA - JB + 1
         IF(CFILEN(JC:JC) .EQ. CBSLAS(1:1)) THEN
            JC = JC + 1
            GO TO 15
         END IF
 14      CONTINUE
C
C         CREATE OUTPUT LISTING FILE NAME AND PLACE THE FILE NAME IN
C         THE PRINTER LISTING HEADER. IF A PROGRAM, FUNCTION, OR
C         SUBROUTINE STATEMENTS OCCUR, THEY WILL OVERRIDE THE PROGRAM
C         FILE NAME ENTRY IN THE HEADER FOR CREATING THE PRINTER OUTPUT
C         FILE NAME.
C
 15      IB = JA - JC + 1
         CFMTH(64:95) = CBLK52(1:32)
         CPGNME(1:32) = CBLK52(1:32)
         CPGWRK(1:32) = CBLK52(1:32)
         CFMTH(64:IB+63) = CFILEN(JC:JA-1)
C
C         SAVE THE OUTPUT TABLES PROGRAM NAME
C
         IPGNME =  JA - JC
         JPGNME = IPGNME
         CPGNME(1:IPGNME) = CFILEN(JC:JA-1)
         CPGWRK(1:IPGNME) = CPGNME(1:IPGNME)
C
C         CREATE THE DEFAULT OUTPUT FILE NAME FROM THE INPUT FILE NAME
C         ONLY IF NO OUTPUT FILE NAME IS PROVIDED
C
         IF(CLISTN(1:1) .EQ. CBLANK(1:1)) THEN
            CLISTN(1:IB) = CFILEN(JC:JA)
            CLISTN(IB+1:IB+3) = 'PRT'
            GO TO 17
         END IF
      END IF
 16   CONTINUE
C
C         TEST IF A FILE NAME WAS PROVIDED
C
 17   IF(J .EQ. 1) THEN
         WRITE (0,101)
         IREC0 = IREC0 + 1
         STOP 'NO INPUT FILE NAME'
      END IF
C
C         SET THE NUMBER OF LINES PER PAGE TO BE PRINTED IN THE OUTPUT
C         LISTING FILE
C
      IF(LPGNUM) THEN
         NLINES = 60
      ELSE
         NLINES = 80
      END IF
C
C         VERIFY AN OUTPUT LISTING FILE DOES NOT EXIST WITH THE SAME
C         PATH AND FILE NAME AS THAT SPECIFED IN VARIABLE CLISTN.  IF
C         A FILE OF THE SAME NAME DOES EXIST, THE OLD FILE WILL BE
C         DELETED WITHOUT ANY MESSAGE TO THE USER.
C
      INQUIRE (FILE=CLISTN,EXIST=LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT=6,FILE=CLISTN)
         CLOSE (UNIT=6,STATUS='DELETE')
      END IF
C
C         OPEN THE FORTRAN SOURCE INPUT AND THE OUTPUT LISTING FILES
C
      OPEN (UNIT=5,FILE=CFILEN,ACCESS='SEQUENTIAL',FORM='FORMATTED',
     1ACTION='READ')
C
C         OPEN THE OUTPUT LISTING FILE
C
      OPEN (UNIT=6,FILE=CLISTN,BLOCKSIZE=1330,FORM='FORMATTED',
     1ACTION='READWRITE',STATUS='NEW',ACCESS='SEQUENTIAL')
C
C         OPEN ALL WORK FILES
C
      CALL WKOPEN
      CTYPED (1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      LEOF = LFALSE
C
C         BEGIN PROCESSING THE FORTRAN PROGRAM STATEMENTS; EACH PROGRAM
C         OR SUBPROGRAM PROCESSING STARTS HERE.
C
C         INITALIZE COUNTERS AND WORK AREAS
C
 18   KB = 0
      KC = 0
      K = 0
      LA = LTRUE
      LB = LFALSE
      LE = LFALSE
      KSNA = 0
      INPUT = 5
      IF(IREC0 .GT. 100) STOP 'STOP: MORE THAN 100 ERRORS'
C
C         READ THE RECORD FROM THE FORTRAN PROGRAM INPUT UNIT
C
      IEOF = 0
      IRET = 0
C     ISN = 0
C
C         BEGIN PROCESSING OF THE FORTRAN INPUT FILE. SUBROUTINE
C         RDSTMT WILL ONLY RETURN FORTRAN STATEMENTS. BLANK, COMMENT,
C         AND COMPILER DIRECTIVE RECORDS ARE NOT RETURNED IN CSTMT.
C
 19   CALL RDSTMT (CFILEN,LE,LB)
      KG = KD
C
C         RESET THE LPARAM SWITCH TO OFF FOR A NEW STATEMENT TO BE
C         PROCESSED
C
      LPARAM = LFALSE
C
C     *****************************************************************
C     *                                                               *
C     *        INSURE ALL VARIABLE NAMES IN ARRAY CNAME HAVE          *
C     *        DEFINED TYPE AND LENGTH CHARACTERISTICS AFTER          *
C     *        THE FIRST EXECUTABLE STATEMENT IS PROCESSED.           *
C     *                                                               *
C     *****************************************************************
C
      IF(LSTART .AND. .NOT.L5) THEN
         J = 1
         DO WHILE (J .LE. INAME)
C
C         WHEN THE TYPE AND LENGTH CHARACTERISTICS ARE BLANK, THEY ARE
C         DIMENSIONED VARIABLES THAT ARE NOT USED IN A SUBPROGRAM.
C         SET THEIR TYPE AND LENGTH CHARACTERISITICS TO THE DEFAULT
C         VALUES IN CIMPL.
C
         IF(CNAME(J)(37:44) .EQ. CBLANK(1:8)) THEN
            CWORK(1:52) = CBLK52(1:52)
            CWORK(1:32) = CNAME(J)(1:32)
            CALL SETTL (CWORK)
            CNAME(J)(37:44) = CWORK(37:44)
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
         END IF
         J = J + 1
         END DO
         L5 = LTRUE
      END IF
C
C         COMPRESS THE STATEMENT TO REMOVE UNNECESSARY BLANKS. BLANKS
C         WITHIN QUOTATION MARKS WILL NOT BE REMOVED. IF THE STATEMENT
C         HAS A STATEMENT NUMBER, THE SUBPROGRAM WILL PLACE IT IN THE
C         SAVE TABLE FOR STATEMENT NUMBERS AND DELETE IT FROM THE
C         STATEMENT. LITERALS ARE REMOVED FROM THE STATEMENT AND PLACED
C         IN THE LITERAL TABLE.  ALL LITERALS ARE REPLACED BY HEX CF IN
C         THE ORIGINAL STATEMENT TO INDICATE A LITERAL EXISTS. IF A
C         LITERAL OCCURS AS AN ARGUMENT IN A CALL STATEMENT, THE
C         SYNTHETIC VARIABLE NAME C##LIT OR C##nnn IS USED INSTEAD OF
C         CF. LOGICAL OPERATORS ARE REPLACED BY HEX CD IN THE ORIGINAL
C         STATEMENT. ANY TEXT BETWEEN SQUARE BRACKETS, [ .. ], ARE
C         REMOVED (INCLUDING THE BRACKETS). HORIZONTAL TABS ARE ALSO
C         REMOVED FROM THE SOURCE CODE. ARITHMETIC OPERATORS ARE NOT
C         MODIFIED OR REMOVED. FORMAT STATEMENTS ARE PROCESSED BY
C         SUBROUTINE FMTSYN THAT IS CALLED FROM SUBROUTINE COMPRS.
C
      IF(CSTMT(1:1) .NE. CDOL .AND. CSTMT(1:1) .NE. CSHARP)
     1   CALL COMPRS (IRET)
C
C         FORCE ALL ALPHABETIC CHARACTERS TO UPPER CASE. ALL STATEMENTS
C         WILL START IN COLUMN ONE AFTER COMPRESSION. THIS WILL NOT
C         AFFECT FORMAT STATEMENTS BECAUSE THEY HAVE ALREADY BEEN
C         PROCESSED. LITERALS, LOGICAL OPERATORS, AND STATEMENT NUMBERS
C         ARE NOT AFFECTED BECAUSE HAVE BEEN REMOVED FROM THE STATEMENT.
C
 21   KF = 1
      I2WK1 = 0
      DO 22 J = KF,KB
      IF(CSTMT(J:J) .GE. CAS .AND. CSTMT(J:J) .LE. CZS) THEN
         CI2WK1(IDXE:IDXE) = CSTMT(J:J)
         I2WK1 = I2WK1 - ICAPS
         CSTMT(J:J) = CI2WK1(IDXE:IDXE)
      END IF
 22   CONTINUE
C
C         THE FIRST CHARACTER OF THE COMPRESSED STATEMENT MUST BE
C         AN ALPHABETIC CHARACTER, AN UNDERSCORE, OR A BLANK
C
      IF(.NOT.(CSTMT(1:1) .GE. CAA .AND. CSTMT(1:1) .LE. CZZ .OR.
     1   CSTMT(1:1) .EQ. CUNDER .OR. CSTMT(1:1) .EQ. CBLANK(1:1))
     2   .AND. .NOT.LINCL) THEN
         IF(CSTMT(1:1) .LE. CBLANK .AND. ISN .EQ. 1) THEN
            WRITE (0,107) CSTMT(1:20)
         ELSE
            WRITE (0,105) ISN
         END IF
         IREC0 = IREC0 + 1
         GO TO 28
      END IF
C
C         TEST IF A FORMAT STATEMENT IS BEING PROCESSED
C
      IF(LFOR) GO TO 27
      KH = KB
C
C         DETERMINE IF THE A NEW PROGRAM MODULE IS TO BE PROCESSED
C
      IF(.NOT.LB .AND. .NOT.LCALL .AND. ISN .EQ. 1) THEN
C
C         WHEN A STATEMENT IS A SUBROUTINE OR A FUNCTION, IT MUST BE THE
C         FIRST STATEMENT THAT IS NOT A BLANK, COMMENT, OR COMPILER
C         DIRECTIVE RECORD; OTHERWISE, THE STATEMENT MUST BE THE MAIN
C         PROGRAM. THE TESTS BELOW ARE NECESSARY WHEN THE INITIAL
C         PROGRAM MODULE ON UNIT 5 IS NOT THE MAIN PROGRAM.
C
         IQ = 0
         IF(CSTMT(1:10) .EQ. 'SUBROUTINE') LTEST = LTRUE
         IF(CSTMT(1:8) .EQ. 'FUNCTION') LTEST = LTRUE
         IF(CSTMT(1:7) .EQ. 'INTEGER' .OR. CSTMT(1:7) .EQ.
     1      'LOGICAL' .OR. CSTMT(1:7) .EQ. 'COMPLEX') IQ = 15
         IF(CSTMT(8:16) .EQ. 'CHARACTER') IQ = 17
         IF(CSTMT(8:12) .EQ. 'REAL' .OR. CSTMT(8:12) .EQ. 'BYTE')
     1      IQ = 13
         IF(CSTMT(8:13) .EQ. 'DOUBLE') THEN
            IF(CSTMT(14:20) .EQ. 'COMPLEX') IQ = 21
            IF(CSTMT(14:22) .EQ. 'PRECISION') IQ = 23
         END IF
         IF(IQ .GT. 0) THEN
            DO 23 IR = IQ,KB
            IF(CSTMT(IR:IR+9) .EQ. 'SUBROUTINE' .OR. CSTMT(IR:IR+7) .EQ.
     1         'FUNCTION') LTEST = LTRUE
 23         CONTINUE
         END IF
C
C         CHANGE THE PROGRAM NAME IN CFMTH WHEN IQ IS ZERO
C
         IF(.NOT.LTEST) THEN
            CFMTH(64:JPGNME+63) = CPGWRK(1:JPGNME)
            IPGNME = JPGNME
            L3 = LFALSE
         END IF
      END IF
C
C         THE LOCATION OF THE FIRST CHARACTER OF THE STATEMENT IS IN
C         VARIABLE KF; THIS LOCATION OMITS THE STATEMENT NUMBER; THE
C         LOCATION OF THE LAST CHARACTER IS IN VARIABLE KB.
C
C         THE STATEMENT IS NOW COMPLETE, BEGIN ANALYSIS TO
C         IDENTIFY THE INDEX VALUE FOR THE FORTRAN STATEMENT IN THE
C         STATEMENT TABLE. THIS INDEX VALUE WILL CHOOSE THE SUBROUTINE
C         TO PERFORM THE ANAYSIS OF A PARTICULAR FORTRAN STATEMENT.
C
C         DETERMINE IF FORMAT IS A VARIABLE NAME RATHER THAN A
C         STATEMENT
C
C         BLANK WORK AREAS FOR THE NEXT STATEMENT
C
      CTYPED (1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH
C         THE LETTER A
C
      IF(CSTMT(KF:KF) .EQ. CAA .AND. .NOT.LINCL) THEN
C
C         DETERMINE IF ONE OF THE STATEMENTS STARTING WITH THE LETTER A
C         IS ACCESS OR ASSIGN
C
         IF(CSTMT(KF+1:KF+5) .EQ. 'CCEPT') THEN
C
C         THIS MAY BE AN ACCEPT STATEMENT
C
            LSTART = LTRUE
            CALL STMT01
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE AN ASSIGN STATEMENT
C
         IF(CSTMT(KF+1:KF+5) .EQ. 'SSIGN') THEN
            LSTART = LTRUE
            CALL STMT02
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH B
C
      IF(CSTMT(KF:KF) .EQ. CBB) THEN
C
C         DETERMINE IF ONE OF THE STATEMENTS STARTING WITH THE LETTER B
C         IS BACKSPACE, BLOCK DATA, OR BYTE
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'ACKSPACE' .AND. .NOT.LINCL) THEN
C
C         THIS MAY BE A BACKSPACE STATEMENT
C
            LSTART = LTRUE
            CALL STMT04
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A BLOCK DATA STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'LOCKDATA' .AND. .NOT.LINCL) THEN
            IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
            CALL STMT05
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A BYTE STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'YTE') THEN
            CALL STMT06
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH C
C
      IF(CSTMT(KF:KF) .EQ. CCC) THEN
C
C         THIS MAY BE A CALL STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'ALL' .AND. .NOT.LINCL) THEN
            LRET = LFALSE
            LSTART = LTRUE
            CALL STMT07 (LRET,LRET)
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A CHARACTER STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'HARACTER') THEN
            CALL STMT08
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A CLOSE STATEMENT
C
         IF(CSTMT(KF+1:KF+4) .EQ. 'LOSE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT09
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A COMMON, COMPLEX, OR CONTINUE STATEMENT
C
         IF(CSTMT(KF+1:KF+1) .EQ. COO) THEN
C
C         DETERMINE IF A POSSIBLE COMMON STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'MMON') THEN
               CALL STMT10 (LFALSE)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE COMPLEX STATEMENT
C
            IF(CSTMT(KF+2:KF+6) .EQ. 'MPLEX') THEN
               CALL STMT11
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE CONTINUE STATEMENT
C
            IF(CSTMT(KF+2:KF+7) .EQ. 'NTINUE' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT12
               IF(LEXEC) GO TO 27
            END IF
         END IF
C
C         WHEN AN INCLUDE FILE IS BEING PROCESSED, DETERMINE IF A
C         POSSIBLE C$ TYPE STATEMENT FROM OS/2 SYSTEM API CONTROLS
C         EXISTS
C
         IF(LINCL .AND. CSTMT(1:2) .EQ. 'C$') GO TO 27
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH D
C
      IF(CSTMT(KF:KF) .EQ. CDD) THEN
C
C         THIS MAY BE A DATA STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'ATA' .AND. .NOT.LINCL) THEN
            CALL STMT13
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A DECODE STATEMENT
C
         IF(CSTMT(KF+1:KF+5) .EQ. 'ECODE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT14
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A DIMENSION STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'IMENSION') THEN
            CALL STMT15 (LFALSE)
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE A DO, DO WHILE, OR DOUBLE PRECISION STATEMENT
C
         IF(CSTMT(KF+1:KF+1) .EQ. COO) THEN
C
C         DETERMINE IF A POSSIBLE DO STATEMENT
C
            IF(CSTMT(KF+2:KF+2) .GE. C0 .AND. CSTMT(KF+2:KF+2) .LE.
     1         C9 .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               IF(LINCL) THEN
                  GO TO 27
               ELSE
                  CALL STMT16
                  IF(LEXEC) GO TO 27
               END IF
            END IF
C
C         DETERMINE IF A POSSIBLE DOUBLE PRECISION OR A DOUBLE COMPLEX
C         STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'UBLE') THEN
               CALL STMT18
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE DO STATEMENT WITHOUT A LABEL WHICH IS
C         TERMINATED BY AN END DO STATEMENT
C
            IF(CSTMT(KF+2:KF+2) .GE. CAA .AND. CSTMT(KF+2:KF+2) .LE.
     1         CZZ .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT16
               IF(LEXEC) GO TO 27
            END IF
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH E
C
      IF(CSTMT(KF:KF) .EQ. CEE) THEN
C
C         THIS MAY BE AN ELSE OR ELSE IF STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'LSE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT19
            IF(LEXEC) GO TO 27
         END IF
C
C         THIS MAY BE AN ENCODE, END, ENDFILE, END IF, END DO STATMENT
C
         IF(CSTMT(KF+1:KF+1) .EQ. CNN) THEN
C
C         DETERMINE IF A POSSIBLE ENCODE STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'CODE' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT14
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE END STATEMENT
C
            IF(CSTMT(KF+2:KF+3) .EQ. 'D ' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN END DO STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'DDO ' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT21 (*28)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN END MAP STATEMENT
C
            IF(CSTMT(KF+2:KF+6) .EQ. 'DMAP ' .AND. .NOT.LINCL) THEN
               IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN ENDFILE STATEMENT
C
            IF(CSTMT(KF+2:KF+7) .EQ. 'DFILE ' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT23
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE END IF STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'DIF ' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN END STRUCTURE STATEMENT
C
            IF(CSTMT(KF+2:KF+12) .EQ. 'DSTRUCTURE ') THEN
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN END UNION STATEMENT
C
            IF(CSTMT(KF+2:KF+8) .EQ. 'DUNION ') THEN
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF AN END WHILE STATEMENT
C
            IF(CSTMT(KF+3:KF+7) .EQ. 'WHILE') THEN
               LSTART = LTRUE
               CALL STMT21 (*27)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE ENTRY STATEMENT
C
            IF(CSTMT(KF+2:KF+4) .EQ. 'TRY') THEN
               LSTART = LTRUE
               CALL STMT25
               IF(LEXEC) GO TO 27
            END IF
         END IF
C
C         DETERMINE IF AN EQUIVALENCE STATEMENT
C
         IF(CSTMT(KF+1:KF+10) .EQ. 'QUIVALENCE') THEN
            CALL STMT26
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF AN EXIT STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'XIT') THEN
            IF( KF + 3 .EQ. KB) GO TO 27
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE EXTERNAL STATEMENT
C
         IF(CSTMT(KF+1:KF+7) .EQ. 'XTERNAL') THEN
            CALL STMT27
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH F
C
      IF(CSTMT(KF:KF) .EQ. CFF) THEN
C
C         DETERMINE IF A FORMAT STATEMENT
C
         IF(CSTMT(KF+1:KF+5) .EQ. 'ORMAT' .AND. .NOT.LINCL) THEN
            IF(LFOR) THEN
C
C         THIS IS A FORMAT STATEMENT
C
               GO TO 27
            ELSE
C
C         THIS IS AN EXPRESSION WITH FORMAT AS A VARIABLE NAME
C
               GO TO 24
            END IF
         END IF
C
C         DETERMINE IF A FUNCTION STATEMENT
C
         IF(CSTMT(KF+1:KF+7) .EQ. 'UNCTION') THEN
            CALL STMT29 (CFF,CLEN)
            IF(.NOT.LEXEC) GO TO 27
            JPGNME = IPGNME
            CPGWRK(1:IPGNME) = CWORK(1:IPGNME)
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH G,
C         (GO TO)
C
      IF(CSTMT(KF:KF+3) .EQ. 'GOTO' .AND. .NOT.LINCL) THEN
         LSTART = LTRUE
         CALL STMT30
         IF(LEXEC) GO TO 27
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH H
C
      IF(CSTMT(KF:KF) .EQ. CHH) THEN
         IF(LINCL)  THEN
            GO TO 27
         ELSE
            GO TO 24
         END IF
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH I
C
      IF(CSTMT(KF:KF) .EQ. CII) THEN
C
C         DETERMINE IF A POSSIBLE IF STATEMENT
C
         IF(CSTMT(KF+1:KF+2) .EQ. 'F(' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT31 (LFALSE,*24,*21)
         END IF
C
C         DETERMINE IF A POSSIBLE IMPLICIT STATEMENT
C
         IF(CSTMT(KF:KF+7) .EQ. 'IMPLICIT' .AND. .NOT.LINCL) THEN
            CALL STMT32
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF AN INCLUDE, INQUIRE, INTEGER, OR INTRINSIC
C         STATEMENT
C
C         DETERMINE IF A POSSIBLE INCLUDE STATEMENT
C
         IF(CSTMT(KF:KF+6) .EQ. 'INCLUDE') THEN
            CALL STMT33
            IF(LEXEC) GO TO 27
            K = 0
            GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE INQUIRE STATEMENT
C
         IF(CSTMT(KF:KF+6) .EQ. 'INQUIRE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT34
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE INTEGER STATEMENT
C
         IF(CSTMT(KF:KF+6) .EQ. 'INTEGER') THEN
            CALL STMT35
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE INTRINSIC STATEMENT
C
         IF(CSTMT(KF:KF+8) .EQ. 'INTRINSIC') THEN
            CALL STMT36
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH J
C
      IF(CSTMT(KF:KF) .EQ. CJJ) THEN
         LSTART = LTRUE
         IF(LINCL)  THEN
            GO TO 27
         ELSE
            GO TO 24
         END IF
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH K
C
      IF(CSTMT(KF:KF) .EQ. CKK) THEN
         LSTART = LTRUE
         IF(LINCL)  THEN
            GO TO 27
         ELSE
            GO TO 24
         END IF
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH L.
C         THIS MAY BE A LOGICAL STATEMENT.
C
      IF(CSTMT(KF:KF+6) .EQ. 'LOGICAL') THEN
         CALL STMT37
         IF(LEXEC) GO TO 27
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH M
C
      IF(CSTMT(KF:KF+2) .EQ. 'MAP' .AND. .NOT.LINCL) THEN
C
C         DETERMINE IF A POSSIBLE MAP STATEMENT
C
         CALL PMAP
         IF(KF+2 .EQ. KB) GO TO 27
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH N
C
      IF(CSTMT(KF:KF+7) .EQ. 'NAMELIST' .AND. .NOT.LINCL) THEN
         CALL STMT38
         IF(LEXEC) GO TO 27
      END IF
C
C         DETERMINE IF AN OPEN STATEMENT
C
      IF(CSTMT(KF:KF+3) .EQ. 'OPEN' .AND. .NOT.LINCL) THEN
         LSTART = LTRUE
         CALL STMT39
         IF(LEXEC) GO TO 27
         GO TO 24
      ELSE
         IF(CSTMT(KF:KF) .EQ. COO) GO TO 27
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH P
C
      IF(CSTMT(KF:KF) .EQ. CPP) THEN
C
C         DETERMINE IF A PARAMETER STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'ARAMETER') THEN
            IF(.NOT.LINCL) CALL STMT41
            CALL STMT41
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A PAUSE STATEMENT
C
         IF(CSTMT(KF+1:KF+4) .EQ. 'AUSE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT42
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A PRINT STATEMENT
C
         IF(CSTMT(KF+1:KF+4) .EQ. 'RINT' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT43 (LFALSE)
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A PROGRAM STATEMENT
C
         IF(CSTMT(KF+1:KF+6) .EQ. 'ROGRAM' .AND. .NOT.LINCL) THEN
            L2 = LFALSE
            DO I = KF+7,KB
            IF(CSTMT(I:I) .EQ. CLPAR .OR. CSTMT(I:I) .EQ. CEQ .OR.
     1         CSTMT(I:I) .EQ. CEXCL) THEN
               L2 = LTRUE
            END IF
            END DO
            IF(.NOT.L2) THEN
               IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
               CALL STMT44
               IF(LEXEC) GO TO 27
            END IF
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH Q
C
      IF(CSTMT(KF:KF) .EQ. CQQ) THEN
         IF(LINCL)  THEN
            GO TO 27
         ELSE
            GO TO 24
         END IF
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH R
C
      IF(CSTMT(KF:KF) .EQ. CRR) THEN
C
C         DETERMINE IF A READ, REAL, RECORD, RETURN, OR REWIND
C         STATEMENT
C
         IF(CSTMT(KF+1:KF+1) .EQ. CEE) THEN
C
C         DETERMINE IF A POSSIBLE READ STATEMENT
C
            IF(CSTMT(KF+2:KF+3) .EQ. 'AD' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT45 (LFALSE)
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE REAL STATEMENT
C
            IF(CSTMT(KF+2:KF+3) .EQ. 'AL') THEN
               CALL STMT46
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE RECORD STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'CORD') THEN
               CALL STMT47
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE RETURN STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'TURN' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT48
               IF(LEXEC) GO TO 27
            END IF
C
C         DETERMINE IF A POSSIBLE REWIND STATEMENT
C
            IF(CSTMT(KF+2:KF+5) .EQ. 'WIND' .AND. .NOT.LINCL) THEN
               LSTART = LTRUE
               CALL STMT49
               IF(LEXEC) GO TO 27
            END IF
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH S
C
      IF(CSTMT(KF:KF) .EQ. CSS) THEN
C
C         DETERMINE IF A POSSIBLE SAVE STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'AVE' .AND. .NOT.LINCL) THEN
            CALL STMT50 (LFALSE)
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE STOP STATEMENT
C
         IF(CSTMT(KF+1:KF+3) .EQ. 'TOP' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT52
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE STRUCTURE STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'TRUCTURE') THEN
            CALL STMT53
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE SUBROUTINE STATEMENT
C
         IF(CSTMT(KF+1:KF+9) .EQ. 'UBROUTINE') THEN
            CALL STMT54
            IF(.NOT.LEXEC) GO TO 27
            JPGNME = IPGNME
            CPGWRK(1:IPGNME) = CWORK(1:IPGNME)
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH T.
C         ONLY THE TYPE STATEMENT IS POSSIBLE; HOWEVER, SINCE IT
C         IS EQUIVALENT TO THE PRINT STATEMENT, SUBROUTINE STMT43 IS
C         USED. THERE IS NO SUBROUTINE STMT55.
C
      IF(CSTMT(KF:KF+3) .EQ. 'TYPE' .AND. .NOT.LINCL) THEN
         LSTART = LTRUE
         CALL STMT43 (LTRUE)
         IF(LEXEC) GO TO 27
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH U
C
      IF(CSTMT(KF:KF) .EQ. CUU) THEN
         IF(CSTMT(KF+1:KF+4) .EQ. 'NION' .AND. KF+4 .EQ. KB) THEN
            CALL STMT56
            GO TO 27
         END IF
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH V
C
      IF(CSTMT(KF:KF) .EQ. CVV .AND. .NOT.LINCL) THEN
C
C         DETERMINE IF A POSSIBLE VIRTUAL STATEMENT
C
         IF(CSTMT(KF+1:KF+6) .EQ. 'IRTUAL') THEN
            CALL STMT15 (LTRUE)
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF A POSSIBLE VOLATILE STATEMENT
C
         IF(CSTMT(KF+1:KF+8) .EQ. 'OLATILE' .AND. .NOT.LINCL) THEN
            CALL STMT50 (LTRUE)
            IF(LEXEC) GO TO 27
         END IF
         GO TO 24
      END IF
C
C         DETERMINE IF A POSSIBLE STATEMENT SPECIFICATION STARTS WITH W
C
      IF(CSTMT(KF:KF) .EQ. CWW .AND. .NOT.LINCL) THEN
C
C         DETERMINE IF THIS IS A WHILE ... DO STATEMENT
C
         IF(CSTMT(KF+1:KF+5) .EQ. 'HILE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT59 (*24,*19)
            IF(LEXEC) GO TO 27
         END IF
C
C         DETERMINE IF THIS IS A WRITE STATEMENT
C
         IF(CSTMT(KF+1:KF+4) .EQ. 'RITE' .AND. .NOT.LINCL) THEN
            LSTART = LTRUE
            CALL STMT45 (LTRUE)
            IF(LEXEC) GO TO 27
         END IF
      END IF
C
C         WHEN NOT A DEFINED STATEMENT, NO PROCESSING OCCURS FOR
C         FORTRAN SOURCE CODE INSERTED FROM AN INCLUDE STATEMENT
C
      IF(LINCL) GO TO 26
C
C         NOT A DEFINED STATEMENT, CHECK FOR AN ASSIGNED VALUE STATEMENT
C         AN ASSIGNED VALUE STATEMENT MAY BE ARITHMETIC, LOGICAL, OR
C         CHARACTER, AND REQUIRES AN EQUAL SIGN NOT ENCAPSULATED WITHIN
C         PARENTHESES. IF PARENTHESES OCCUR, THEY MUST BE BALANCED. ALL
C         OTHER STATEMENTS WHERE AN EQUAL SIGN OCCURS OUTSIDE OF
C         ENCAPSULATING PARENTHESES HAVE ALREADY BEEN PROCESSED.
C
 24   JB = 0
      KF = 1
      LD = LFALSE
      DO 25 I = KF,KB
C
C         COUNT PARENTHESES
C
      IF(CSTMT(I:I) .EQ. CLPAR) JB = JB + 1
      IF(CSTMT(I:I) .EQ. CRPAR) JB = JB - 1
      IF(CSTMT(I:I) .EQ. CEQ(1:1)) THEN
C
C         WHEN AN EQUAL SIGN OCCURS OUTSIDE OF ENCAPSULATING PARENTHESES
C         THIS MUST BE AN ARITHMETIC ASSIGNMENT STATEMENT
C
         IF(JB .EQ. 0) THEN
            LD = LTRUE
            LSTART = LTRUE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            I4WK1 = IPGNME
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 27
         ELSE
            IF(.NOT.LINCL) THEN
               IREC0 = IREC0 + 1
               GO TO 26
            END IF
         END IF
      END IF
 25   CONTINUE
C
C         TEST IF AN END OF A ROUTINE CONDITION EXISTS
C
 26   IF(LWR) GO TO 27
C
C         TEST IF THE PROGRAM IS TO BE TERMINATED
C
      IF(LE .OR. CSTMT(1:8) .EQ. CBLANK(1:8) .OR. KB .EQ. 0)
     1   GO TO 28
C
C         DETERMINE IF THE STATEMENT IS CYCLE WHEN NO ARITHMETIC
C         STATEMENT EXISTS AND CYCLE IS NOT A VARIABLE NAME
C
      IF(CSTMT(1:5) .EQ. 'CYCLE') GO TO 28
C
C         NO FORTRAN STATEMENT IDENTIFIED
C
      IF(.NOT.LEXEC .AND. ISN .GT. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,105) ISN
         IREC0 = IREC0 + 1
      END IF
      GO TO 28
C
C         TEST IF A SUBPROGRAM OR PROGRAM IS COMPLETELY PROCESSED
C         AND WRITE OUT THE LISTINGS
C
 27   IF(LWR) THEN
C
C         DETERMINE IF NO LISTING IS TO BE GENERATED BECAUSE NO END
C         STATEMENT OCCURS AFTER PROCESSING THE FORTRAN CODE WITH AN
C         ADDED END STATEMENT
C
         CALL LIST
         L4 = LFALSE
         IF(IEOF .EQ. -1) THEN
            LEND = LTRUE
            GO TO 28
         ELSE
            IF(.NOT.LZEND .AND. .NOT.LENDS) BACKSPACE (5)
            L4 = LTRUE
            IF(CSTMT(1:10) .EQ. 'END       ') LZEND = LFALSE
         END IF
         IF(LEND .AND. LENDS .OR. IEOF .EQ. -1) GO TO 28
         IPAGE = 1
         L3 = LTRUE
         LWR = LFALSE
         KD = 0
C
C         DELETE OLD WORK FILES, AND REOPEN WORK FILES FOR THE NEXT
C         PROGRAM OR SUBPROGRAM
C
         CALL WKCLOS
C
C         REOPEN THE MESSAGES OUTPUT FILE FOR A NEW MODULE
C
         OPEN (UNIT=0,FILE=CFMESS,FORM='FORMATTED',ACTION='READWRITE',
     1   RECL=121,STATUS='NEW')
C
C         DETERMINE IF AN END OF FILE IS THE NEXT RECORD
C
         IF(.NOT.LEND .AND. LENDS) THEN
            READ (5,'(A2)',IOSTAT=IQ) CI2WK1(1:2)
            IF(IQ .EQ. 0) BACKSPACE (5)
            IF(IQ .EQ. -1) THEN
              LEND = LTRUE
              BACKSPACE (6)
              GO TO 28
            ELSE
              IF(LA) LENDS = LFALSE
              IF(.NOT.L4) THEN
                 BACKSPACE (5)
              ELSE
                 LENDS = LFALSE
              END IF
              L4 = LFALSE
            END IF
         END IF
         IF(.NOT.LEND) CALL WKOPEN
         LWR = LFALSE
         LCONT = LFALSE
C
C         SETUP FOR THE NEXT SUBPROGRAM
C
         CALL SETUP (LB)
         L5 = LFALSE
      END IF
C
C         TEST FOR AN END OF ALL DATA ON THE INPUT FILE, UNIT 5
C
 28   IF(LEND) THEN
C
C         DETERMINE IF MULTIPLE FILES ARE TO USED AS INPUT FROM UNIT 5
C
         IF(INFILE .GT. JFILES) THEN
            CLOSE (5)
            JFILES = JFILES + 1
            CFILEN(1:80) = CFILEB(JFILES)(1:80)
C           INQUIRE (UNIT=0,OPENED=LEXIST)
C
C         DETERMINE IF THE NEW FILE EXISTS
C
            INQUIRE (FILE=CFILEN,EXIST=LEXIST)
            IF(LEXIST) THEN
               OPEN (UNIT=5,ACCESS='SEQUENTIAL',FILE=CFILEN,
     1               ACTION='READ',FORM='FORMATTED',STATUS='OLD')
               IEOF = 0
               LB = LFALSE
               LEND = LTRUE
            END IF
            CALL SETUP (LB)
            L5 = LFALSE
            CALL WKCLOS
            CALL WKOPEN
C
C         REOPEN THE MESSAGES OUTPUT FILE
C
            OPEN (UNIT=0,FILE=CFMESS,FORM='FORMATTED',ACTION='READWRITE'
     1            ,RECL=121,STATUS='NEW')
            LEND = LFALSE
            LWR = LFALSE
            ISN = 0
            GO TO 18
         END IF
C
C         DETERMINE IF GLOBAL ANALYSIS IS TO BE MADE
C
         IF(LGLOBL) THEN
C
C         DETERMINE IF UNIT 0 MUST BE OPENED FOR POSSIBLE GLOBAL COMMON
C         AND SUBPROGRAM ARGUMENT ERRORS
C
            IF(IREC3 .GT. 0 .OR. IREC10 .GT. 0 .OR. IREC1 .GT. 0)
     1         OPEN (UNIT=0,FILE=CFMESS,FORM='FORMATTED',
     2         ACTION='READWRITE',RECL=121)
               REWIND (0)
C
C         DETERMINE IF ANY GLOBAL COMMON ANALYSIS IS NEEDED
C
            IF(IREC1 .GT. 0) CALL COMCHK
C
C         PERFORM SUBPROGRAM ARGUMENT ANALYSIS WHEN REQUIRED
C
            IF(IREC0 .GT. 0 .OR. IREC3 .GT. 0 .OR. IREC10 .GT. 0)
     1         CALL ARGCHK
         END IF
         CLOSE (1)
         CLOSE (5)
         END FILE (6)
         REWIND (6)
         CLOSE (0,STATUS='DELETE')
         CLOSE (2,STATUS='DELETE')
         CLOSE (4,STATUS='DELETE')
         CLOSE (7,STATUS='DELETE')
         CLOSE (8,STATUS='DELETE')
         CLOSE (9,STATUS='DELETE')
         CLOSE (11,STATUS='DELETE')
         CLOSE (12,STATUS='DELETE')
         IF(INFILE .EQ. JFILES .AND. LGLOBL) THEN
            CLOSE (3,STATUS='DELETE')
            CLOSE (10,STATUS='DELETE')
         END IF
C
C         DETERMINE IF THE OUTPUT LISTING FILE IS TO BE CONVERTED TO A
C         POSTSCRIPT FILE FOR PRINTING.
C
         IF(LPS) THEN
            CALL PSPRINT (LPGNUM,ISPLIT,CLISTN)
            CLOSE (UNIT=6,STATUS='DELETE')
         ELSE
            REWIND (6)
            CLOSE (UNIT=6,STATUS='KEEP')
         END IF
         GO TO 30
      END IF
C
C         INITIALIZE THE STATEMENT WORK SPACE TO PROCESS ANOTHER
C         STATEMENT
C
      DO 29 I = 1,KH
      CSTMT(I:I) = CBLANK(1:1)
 29   CONTINUE
C
C         DETERMINE IF THE END OF A PROGRAM OR SUBPROGRAM WAS FOUND
C         BUT NOT THE END OF FILE
C
C         BEGIN PROCESSING A NEW PROGRAM OR SUBPROGRAM
C
      KB = 0
      KC = 0
      K = 0
      IE = 0
C
C         RESET THE HEADER FORMAT FOR THE NEXT SUBPROGRAM TO BE
C         PROCESSED
C
      IF(NLINE .GE. NLINES) CFMTH(3:3) = C1
C
C         BEGIN PROCESSING ANOTHER PROGRAM OR SUBPROGRAM
C
      IF(LEND) GO TO 18
      IF(LENDS) THEN
         CALL SETUP (LB)
         L5 = LFALSE
C
C         A CALL TO ROUTINE LOCERR INITIALIZES THE ROUTINE FOR EACH
C         PROGRAM MODULE PROCESSED
C
         LSTART = LFALSE
         CALL LOCERR (LSTART,ISN,IREC0)
         GO TO 18
      END IF
C
C         PROCESS ANOTHER STATEMENT RECORD
C
      GO TO 19
C
C         TERMINATE EXECUTION
C
 30   STOP 'FXREF ENDED NORMALLY'
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM INITIALIZES NAMED COMMON
C
C     ******************************************************************
C
      BLOCK DATA
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000),IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CRECD(132)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION CFILE(3), CPAGE(1000), IPSIZE(2)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CMACRO(25)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILE, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*41    CBLK41, CWFMT
      CHARACTER*40    CFONT, CF108, COMTBL
      CHARACTER*39    CF101
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32, CMACRO
      CHARACTER*23    CFMT2
      CHARACTER*21    CF104
      CHARACTER*16    CPAGE
      CHARACTER*15    CF103
      CHARACTER*12    CF107
      CHARACTER*9     CDATE
      CHARACTER*8     CBLANK, CIMPL, CTIME, CWK8
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*4     CBLNK4
      CHARACTER*2     CI2WK1, CPOINT
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CEND, CFINAL, CTYPE, CRECD
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LORIE, LPAGE, LREV, LSPLIT, L2
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
      COMMON /PMACRO/ CMACRO
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (I2WK1,CI2WK1), (CWK8(2:2),
     1            CWK7), (CNAME(1),IENAME(1,1)), (CREC(1:1),CRECD(1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CAA/'A'/, CBB/'B'/, CCC/'C'/, CDD/'D'/, CEE/'E'/, CFF/'F'/,
     1     CGG/'G'/, CHH/'H'/, CII/'I'/, CJJ/'J'/, CKK/'K'/, CLL/'L'/,
     2     CMM/'M'/, CNN/'N'/, COO/'O'/, CPP/'P'/, CQQ/'Q'/, CRR/'R'/,
     3     CSS/'S'/, CTT/'T'/, CUU/'U'/, CVV/'V'/, CWW/'W'/, CXX/'X'/,
     4     CYY/'Y'/, CZZ/'Z'/, CAS/'a'/, CCS/'c'/, CSC/'s'/, CZS/'z'/
      DATA C0/'0'/, C1/'1'/, C2/'2'/, C3/'3'/, C4/'4'/, C5/'5'/,
     1     C6/'6'/, C7/'7'/, C8/'8'/, C9/'9'/
      DATA CAMP/'&'/, CAPOS/''''/, CAPOSD/'22'X/, CASTER/'*'/,
     1     CBAR/'|'/, CBSLAS/'\'/, CCR/'0D'X/, CDASH/'-'/, CDOL/'$'/,
     2     CDOT/'.'/, CEQ/'='/, CEXCL/'!'/, CLBRAK/'['/, CLF/'0A'X/,
     3     CLPAR/'('/, CMINUS/'-'/, COLON/':'/, COMMA/','/,CPERC/'%'/,
     4     CPLUS/'+'/, CQUES/'?'/, CRBRAK/']'/, CRPAR/')'/, CSLASH/'/'/,
     5     CSHARP/'#'/, CSYMCD/'CD'X/, CSYMCE/'CE'X/, CSYMCF/'CF'X/,
     6     CUNDER/'_'/
      DATA CFCALL/'CALL.XXX'/, CFCOMM/'COMM.XXX'/, CFEQUI/'EQUI.XXX'/,
     1     CFFUNT/'FUNT.XXX'/, CFIUNT/'IUNT.XXX'/, CFCLEN/'CLEN.XXX'/,
     2     CFMESS/'MESS.LST'/, CFSLIT/'SLIT.XXX'/, CFSUBP/'SUNP.XXX'/,
     3     CFSNUM/'SNUM.XXX'/, CFVNME/'VNME.XXX'/
      DATA ISUBTB /0/
      DATA CBLANK /'        '/
      DATA JINCL/0/
      DATA IREC1 /0/
      DATA L, LAPOS, LEND, LFOR, LGLOBL, LPARAM, LPAREN, LSNUM, LVAR
     1     /9*.FALSE./
      DATA LFALSE/.FALSE./, LTRUE/.TRUE./
      DATA LTEST /.FALSE./
      DATA CFMTH /'(''1F O R T R A N  C R O S S  R E F E R E N C E  L I
     1S T I N G: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'',08X,''PAGE'',I5)'/
      DATA CFMTL/'('' ISN:'',I6,'' THIS STATEMENT CAN NOT OCCUR AFTER TH
     1E FIRST EXECUTABLE STATEMENT'')'/
      DATA CBLK52/'                                                    '
     1/
      DATA (CIFILE(I),I = 1,20)/20*'
     1                                            '/
      DATA CRECD /132*' '/
      DATA CBLNK4 /'    '/
      DATA CBLK41 /'                                         '/
      DATA CEND   /'0A'X/
      DATA CFINAL /'1A'X/
      DATA CFONT  /'                                        '/
      DATA CF101  /'('' -90 rotate''/I5,'' neg 0.0 translate'')'/
      DATA CF103  /'(2I5,'' moveto'')'/
      DATA CF104  /'(''%%Page:          '')'/
      DATA CF107  /'(''showpage'')'/
      DATA CF108  /'(''%%Trailer''/''%%Pages: '',I4/''%All done'')'/
      DATA NPAGE  /0/
      DATA NPAGEB /0/
      DATA L2     /.FALSE./, LPAGE/.FALSE./
      DATA FUNTBL(1)  /'ABS                             R# '/,
     1     FUNTBL(2)  /'ACOS                            R# '/,
     2     FUNTBL(3)  /'ACOSD                           R# '/,
     3     FUNTBL(4)  /'AIMAG                           R4 '/,
     4     FUNTBL(5)  /'AINT                            R4 '/,
     5     FUNTBL(6)  /'ALOG                            R4 '/,
     6     FUNTBL(7)  /'ALOG10                          R4 '/,
     7     FUNTBL(8)  /'AMAX0                           R4 '/,
     8     FUNTBL(9)  /'AMAX1                           R4 '/,
     9     FUNTBL(10) /'AMIN0                           R4 '/,
     A     FUNTBL(11) /'AMIN1                           R4 '/,
     B     FUNTBL(12) /'AMOD                            R4 '/,
     C     FUNTBL(13) /'AND                             L# '/,
     D     FUNTBL(14) /'ANINT                           R4 '/,
     E     FUNTBL(15) /'ASIN                            R# '/,
     F     FUNTBL(16) /'ASIND                           R4 '/
      DATA FUNTBL(17) /'ATAN                            R# '/,
     1     FUNTBL(18) /'ATAN2                           R4 '/,
     2     FUNTBL(19) /'ATAN2D                          R4 '/,
     3     FUNTBL(20) /'ATAND                           R4 '/,
     4     FUNTBL(21) /'BTEST                           L4 '/,
     5     FUNTBL(22) /'CABS                            B8 '/,
     6     FUNTBL(23) /'CCOS                            B8 '/,
     7     FUNTBL(24) /'CDABS                           E16'/,
     8     FUNTBL(25) /'CDCOS                           E16'/,
     9     FUNTBL(26) /'CDEXP                           E16'/,
     A     FUNTBL(27) /'CDLOG                           E16'/,
     B     FUNTBL(28) /'CDSIN                           E16'/,
     C     FUNTBL(29) /'CDSQRT                          E16'/,
     D     FUNTBL(30) /'CEXP                            B8 '/,
     E     FUNTBL(31) /'CHAR                            C1 '/,
     F     FUNTBL(32) /'CLOG                            B8 '/
      DATA FUNTBL(33) /'CMPLX                           B8 '/,
     1     FUNTBL(34) /'CONJG                           B# '/,
     2     FUNTBL(35) /'COS                             R# '/,
     3     FUNTBL(36) /'COSD                            R4 '/,
     4     FUNTBL(37) /'COSH                            R# '/,
     5     FUNTBL(38) /'COTAN                           R# '/,
     6     FUNTBL(39) /'CSQRT                           B8 '/,
     7     FUNTBL(40) /'DABS                            D8 '/,
     8     FUNTBL(41) /'DACOS                           D8 '/,
     9     FUNTBL(42) /'DACOSD                          D8 '/,
     A     FUNTBL(43) /'DAINT                           D8 '/,
     B     FUNTBL(44) /'DASIN                           D8 '/,
     C     FUNTBL(45) /'DASIND                          D8 '/,
     D     FUNTBL(46) /'DATAN                           D8 '/,
     E     FUNTBL(47) /'DATAN2                          D8 '/,
     F     FUNTBL(48) /'DATAN2D                         D8 '/
      DATA FUNTBL(49) /'DATAND                          D8 '/,
     1     FUNTBL(50) /'DBLE                            D8 '/,
     2     FUNTBL(51) /'DCMPLX                          E16'/,
     3     FUNTBL(52) /'DCONJG                          E16'/,
     4     FUNTBL(53) /'DCOS                            D8 '/,
     5     FUNTBL(54) /'DCOSH                           D8 '/,
     6     FUNTBL(55) /'DCOTAN                          D8 '/,
     7     FUNTBL(56) /'DDIM                            D8 '/,
     8     FUNTBL(57) /'DERF                            D8 '/,
     9     FUNTBL(58) /'DERFC                           D8 '/,
     A     FUNTBL(59) /'DEXP                            D8 '/,
     B     FUNTBL(60) /'DFLOAT                          D8 '/,
     C     FUNTBL(61) /'DIM                             R# '/,
     D     FUNTBL(62) /'DIMAG                           D8 '/,
     E     FUNTBL(63) /'DINT                            D8 '/,
     F     FUNTBL(64) /'DLOG                            D8 '/
      DATA FUNTBL(65) /'DLOG10                          D8 '/,
     1     FUNTBL(66) /'DMAX1                           D8 '/,
     2     FUNTBL(67) /'DMIN1                           D8 '/,
     3     FUNTBL(68) /'DMOD                            D8 '/,
     4     FUNTBL(69) /'DNINT                           D8 '/,
     5     FUNTBL(70) /'DPROD                           D8 '/,
     6     FUNTBL(71) /'DSIGN                           D8 '/,
     7     FUNTBL(72) /'DSIN                            D8 '/,
     8     FUNTBL(73) /'DSINH                           D8 '/,
     9     FUNTBL(74) /'DSQRT                           D8 '/,
     A     FUNTBL(75) /'DTAN                            D8 '/,
     B     FUNTBL(76) /'DTANH                           D8 '/,
     C     FUNTBL(77) /'EOF                             L4 '/,
     D     FUNTBL(78) /'EPSILON                         R# '/,
     E     FUNTBL(79) /'ERF                             R4 '/,
     F     FUNTBL(80) /'ERFC                            D8 '/
      DATA FUNTBL(81) /'EXP                             R# '/,
     1     FUNTBL(82) /'FLOAT                           R4 '/,
     2     FUNTBL(83) /'GAMMA                           R# '/,
     3     FUNTBL(84) /'IABS                            I# '/,
     4     FUNTBL(85) /'IAND                            L# '/,
     5     FUNTBL(86) /'IBCLR                           I4 '/,
     6     FUNTBL(87) /'IBITS                           I4 '/,
     7     FUNTBL(88) /'IBSET                           I4 '/,
     8     FUNTBL(89) /'ICHAR                           I4 '/,
     9     FUNTBL(90) /'IDIM                            I4 '/,
     A     FUNTBL(91) /'IDINT                           I# '/,
     B     FUNTBL(92) /'IEOR                            I4 '/,
     C     FUNTBL(93) /'IFIX                            I# '/,
     D     FUNTBL(94) /'IMAG                            R# '/,
     E     FUNTBL(95) /'IMAX                            I# '/,
     F     FUNTBL(96) /'IMAX0                           I# '/
      DATA FUNTBL(97) /'IMAX1                           I# '/,
     1     FUNTBL(98) /'IMIN                            I# '/,
     2     FUNTBL(99) /'IMIN0                           I# '/,
     3     FUNTBL(100)/'IMIN1                           I# '/,
     4     FUNTBL(101)/'IMOD                            I# '/,
     5     FUNTBL(102)/'INDEX                           I4 '/,
     6     FUNTBL(103)/'ININT                           I# '/,
     7     FUNTBL(104)/'INT                             I# '/,
     8     FUNTBL(105)/'IOR                             I# '/,
     9     FUNTBL(106)/'ISHFT                           I# '/,
     A     FUNTBL(107)/'ISHFTC                          I# '/,
     B     FUNTBL(108)/'ISIGN                           I# '/,
     C     FUNTBL(109)/'LEN                             I4 '/,
     D     FUNTBL(110)/'LENTRIM                         I4 '/,
     E     FUNTBL(111)/'LEN_TRIM                        I4 '/,
     F     FUNTBL(112)/'LGAMMA                          R# '/
      DATA FUNTBL(113)/'LOG                             R# '/,
     1     FUNTBL(114)/'LOG10                           R# '/,
     2     FUNTBL(115)/'LSHIFT                          I# '/,
     3     FUNTBL(116)/'MAX                             I# '/,
     4     FUNTBL(117)/'MAX0                            I# '/,
     5     FUNTBL(118)/'MAX1                            I# '/,
     6     FUNTBL(119)/'MIN                             I# '/,
     7     FUNTBL(120)/'MIN0                            I# '/,
     8     FUNTBL(121)/'MIN1                            I# '/,
     9     FUNTBL(122)/'MOD                             I# '/,
     A     FUNTBL(123)/'NEAREST                         R# '/,
     B     FUNTBL(124)/'NINT                            I# '/,
     C     FUNTBL(125)/'NOT                             I# '/,
     D     FUNTBL(126)/'OR                              I# '/,
     E     FUNTBL(127)/'REAL                            R4 '/,
     F     FUNTBL(128)/'RSHIFT                          I# '/
      DATA FUNTBL(129)/'SIGN                            R# '/,
     1     FUNTBL(130)/'SIN                             R# '/,
     2     FUNTBL(131)/'SINH                            R# '/,
     3     FUNTBL(132)/'SNGL                            R4 '/,
     4     FUNTBL(133)/'SQRT                            R# '/,
     5     FUNTBL(134)/'TAN                             R# '/,
     6     FUNTBL(135)/'TAND                            R# '/,
     7     FUNTBL(136)/'TANH                            R# '/,
     8     FUNTBL(137)/'XOR                             I# '/,
     9     FUNTBL(138)/'ZABS                            E16'/,
     A     FUNTBL(139)/'ZCOS                            E16'/,
     B     FUNTBL(140)/'ZEXP                            E16'/,
     C     FUNTBL(141)/'ZLOG                            E16'/,
     D     FUNTBL(142)/'ZSIN                            E16'/,
     E     FUNTBL(143)/'ZSQRT                           E16'/
C     *                                                                *
C     ******************************************************************
C     *                                                                *
C     *   CMACRO LISTS THE MACROS USED BY THE OS/2 API FUNCTIONS.      *
C     *   THEY HAVE NO USE IN OTHER OPERATING SYSYTEMS.                *
C     *
C     ******************************************************************
C     *                                                                *
      DATA CMACRO(1) /'CHAR1FROMMP                     '/,
     1     CMACRO(2) /'CHAR2FROMMP                     '/,
     2     CMACRO(3) /'CHAR3FROMMP                     '/,
     3     CMACRO(4) /'CHAR4FROMMP                     '/,
     4     CMACRO(5) /'DDES_PABDATA                    '/,
     5     CMACRO(6) /'DDES_PSZITEMNAME                '/,
     6     CMACRO(7) /'HWNDFROMMP                      '/,
     7     CMACRO(8) /'LONGFROMMP                      '/,
     8     CMACRO(9) /'LONGFROMMR                      '/,
     9     CMACRO(10)/'MPFROM2SHORT                    '/,
     A     CMACRO(11)/'MPFROMCHAR                      '/,
     B     CMACRO(12)/'MPFROMHWND                      '/,
     C     CMACRO(13)/'MPFROMLONG                      '/,
     D     CMACRO(14)/'MPFROMMP                        '/,
     E     CMACRO(15)/'MPFROMSHORT                     '/,
     F     CMACRO(16)/'MPFROMSJ2CH                     '/
      DATA CMACRO(17)/'PDDEITOSEL                      '/,
     1     CMACRO(18)/'PDDESTOSEL                      '/,
     2     CMACRO(19)/'PVOIDFROMMP                     '/,
     3     CMACRO(20)/'PVOIDFROMMR                     '/,
     4     CMACRO(21)/'SELTOPDDES                      '/,
     5     CMACRO(22)/'SHORT1FROMMP                    '/,
     6     CMACRO(23)/'SHORT1FROMMR                    '/,
     7     CMACRO(24)/'SHORT2FROMMP                    '/,
     8     CMACRO(25)/'SHORT2FROMMR                    '/
C
C         USE THIS DATA STATEMENT FOR LITTLE ENDIAN ASCII SYSTEMS
C
      DATA ICAPS/32/, ICTN/64/, IDTN/48/, IDXA/1/, IDXB/2/, IDXC/3/,
     1     IDXD/4/, IDXE/1/, IDXF/2/
C
C         USE THIS DATA STATEMENT FOR BIG ENDIAN ASCII SYSTEMS
C
C     DATA ICAPS/32/, ICTN/64/, IDTN/48/, IDXA/4/, IDXB/3/, IDXC/2/,
C    1     IDXD/1/, IDXE/2/, IDXF/1/
C
C         USE THIS DATA STATEMENT FOR LITTLE ENDIAN EBCDIC SYSTEMS
C
C     DATA ICAPS/64/, ICTN/192/, IDTN/240/, IDXA/1/, IDXB/2/,
C    1     IDXC/3/, IDXD/4/, IDXE/1/, IDXF/2/
C
C         USE THIS DATA STATEMENT FOR BIG ENDIAN EBCDIC SYSTEMS
C
C     DATA ICAPS/64/, ICTN/192/, IDTN/240/, IDXA/4/, IDXB/3/,
C    1     IDXC/2/, IDXD/1/, IDXE/2/, IDXF/1/
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE INITIALIZES THE LARGE COMMON ARRAYS TO BLANKS;
C         RESETS COUNTERS, BIT SWITCHES, LOGICAL VARIABLES, AND
C         INITIALIZES COUNTERS WHEN NEW ROUTINE PROCESSING BEGINS.
C
C     *****************************************************************
C
      SUBROUTINE SETUP (LB)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION JMAP(20), MAPLEN(20,20)
C
C         TYPE STATEMENTS
C
      CHARACTER*8000  CONFT, CONIT
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1, LB
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /MUS/ JMAP, MAPLEN
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CONFT,FCONFT(1)), (CONIT,ICONIT(1,1)),
     1(CWORK(33:36),IWORK), (CWORK(45:48),JBITS), (I2WK1,CI2WK1),
     2(CNAME(1),IENAME(1,1)), (CDEF(45:48),KBITS), (CWK8(2:2),CWK7),
     3(CSUBTB,JSUBTB)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA L1/.FALSE./
C
C         INITIALIZE THE ARRAYS
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      DO 10 I = 1,817
      IA = 1 + 8 * (I - 1)
      IB = IA + 7
      CSTMT(IA:IB) = CBLANK(1:8)
 10   CONTINUE
      DO 11 I = 1,1000
      ISNUM(1,I) = 0
      ISNUM(2,I) = 0
      JCONFT(I) = 0
      ISNW(I) = 0
      IA = 1 + 8 * (I - 1)
      IB = IA + 7
      CONFT(IA:IB) = CBLANK(1:8)
      CONIT(IA:IB) = CBLANK(1:8)
      CDIM(I)(1:104) = CBLK52(1:52)//CBLK52(1:52)
 11   CONTINUE
      DO 12 I = 1,4000
      CNAME(I)(1:52) = CBLK52(1:52)
 12   CONTINUE
      DO 13 I = 1,100
      COUTV(I)(1:32) = CBLK52(1:32)
      IOUTC(I) = 0
 13   CONTINUE
      IF(.NOT.LB) THEN
         DO 14 I = 1,33
         IA = 1 + 4 * (I - 1)
         IB = IA + 3
         CREC(IA:IB) = CBLANK(1:4)
 14      CONTINUE
      END IF
      DO 15 I = 1,4000
      CPARAM(I)(1:52) = CBLK52(1:52)
 15   CONTINUE
C
C         INITIALIZE IMPLICIT TYPE AND LENGTH CHARACTERISTICS TO
C         DEFAULT VALUES
C
      DO 16 I = 1,27
      IF(I .GE. 9 .AND. I .LE. 14) THEN
         CIMPL(I)(1:8) = 'I4      '
      ELSE
         CIMPL(I)(1:8) = 'R4      '
      END IF
 16   CONTINUE
      ICALKT = 0
      ICOMKT = 0
      ICONF = 0
      ICONI = 0
      JDIM = 0
      ILIT = 0
      INAME = 0
      IOUTNC = 0
      IOUTNV = 0
      IP = 0
      IPAGE = 0
      IRECD = 0
      IREC0 = 0
      IREC2 = 0
      IREC4 = 0
      IREC5 = 0
      IREC7 = 1
      IREC8 = 1
      IREC9 = 0
      IREC11 = 1
      IREC12 = 0
      ISN = 0
      ISTRUC = 0
      ISUBTB = 0
      IUNION = 0
      JINCL = 0
      JSTRUC = 0
      JUNION = 0
      JVSRST = 0
      KUNION = 0
      KI = 0
      MNUM = 0
      NARGM = 0
      NARGS = 0
      NVARST = 0
      NLINE = 0
      LCALL = LFALSE
      LENDS = LFALSE
      LINCLM = LFALSE
      LSTART = LFALSE
      LSTRUC = LFALSE
      LTEST = LFALSE
      LWR = LFALSE
C
C         SET THE MAP LENGTH AND STRUCTURE LENGTH TABLES TO ZEROS, AND
C         THE STRUCTURE NAME TABLE TO BLANKS
C
      DO 17 I = 1,20
      JMAP(I) = 0
      JSTR(I) = 0
      CSTRNM(I)(1:36) = CBLK52(1:36)
 17   CONTINUE
C
C         FILL THE SUBPROGRAM DEFINITION RECORD WITH BLANKS
C
      IB = 0
      DO 18 I = 1,31
      IA = IB + 1
      IB = IA + 47
      CDEF(IA:IB) = CBLK52(1:48)
 18   CONTINUE
      CDEF(1489:1496) = CBLANK(1:8)
      KBITS = 0
C
C         FILL THE EXTERNAL VARIABLE NAME TABLE WITH BLANKS
C
      IF(.NOT.L1) THEN
         IEXTNL = 0
         L1 = .TRUE.
         DO 19 I = 1,200
         CEXTNL(I)(1:32) = CBLK52(1:32)
 19      CONTINUE
      END IF
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         OPEN ALL WORK FILES
C
C     ******************************************************************
C
      SUBROUTINE WKOPEN
C
C         TYPE STATEMENTS
C
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
C
C         COMMON STATEMENTS
C
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
C
C       SAVE STATEMENT
C
      SAVE
C
C     OPEN ALL WORK FILES
C
      OPEN (UNIT=2,FILE=CFFUNT,FORM='UNFORMATTED',RECL=40,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=4,FILE=CFSNUM,FORM='UNFORMATTED',RECL=8,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=7,FILE=CFVNME,FORM='UNFORMATTED',RECL=52,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=8,FILE=CFIUNT,FORM='UNFORMATTED',RECL=40,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=9,FILE=CFSLIT,FORM='UNFORMATTED',RECL=92,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=11,FILE=CFCOMM,FORM='UNFORMATTED',RECL=44,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
      OPEN (UNIT=12,FILE=CFEQUI,FORM='UNFORMATTED',RECL=80,
     1STATUS='UNKNOWN',ACCESS='DIRECT',ACTION='READWRITE')
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         CLOSE ALL WORK FILES AFTER PROCESSING FOR A PROGRAM OR
C         SUBPROGRAM MODULE IS COMPLETE
C
C     MEANING OF THE VARIABLES
C
C         LEXIST - LOGICAL VARIABLE, SET TRUE WHEN A FILE EXISTS, SET
C                  FALSE OTHERWISE
C
C     ******************************************************************
C
      SUBROUTINE WKCLOS
C
C         COMMON STATEMENTS
C
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
C
C         TYPE STATEMENTS
C
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      LOGICAL*4 LEXIST, LOPEN
C
C       SAVE STATEMENT
C
      SAVE
C
C         CLOSE ANY OPEN WORK FILES FOR THE NEXT ROUTINE PROCESSING
C
      INQUIRE (FILE=CFMESS,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=0,STATUS='DELETE')
      INQUIRE (FILE=CFFUNT,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=2,STATUS='DELETE')
      INQUIRE (FILE=CFSNUM,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=4,STATUS='DELETE')
      INQUIRE (FILE=CFVNME,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=7,STATUS='DELETE')
      INQUIRE (FILE=CFIUNT,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=8,STATUS='DELETE')
      INQUIRE (FILE=CFSLIT,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=9,STATUS='DELETE')
      INQUIRE (FILE=CFCOMM,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=11,STATUS='DELETE')
      INQUIRE (FILE=CFEQUI,EXIST=LEXIST,OPENED=LOPEN)
      IF(LEXIST .OR. LOPEN) CLOSE (UNIT=12,STATUS='DELETE')
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE READS INDIVIDUAL RECORDS FROM THE FORTRAN
C        INPUT FILE AND CREATES AN ENTIRE FORTRAN STATEMENT FOR ANALYSIS
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CFILEN - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAME
C                  THAT CURRENTLY BEING PROCESSED
C         CFORMF - CHARACTER VARIABLE, A FORM FEED '0C'X
C         CI2WK1 - CHARACTER VARIABLE, WORK AREA USED TO FORCE ALL
C                  CHARACTERS IN CI4WK1 TO UPPER CASE
C         CI4WK2 - CHARACTER VARIABLE, WORK AREA TO SAVE THE FIRST FOUR
C                  ALPHABETIC CHARACTERS FOR A STATEMENT. USED TO
C                  DETECT A TRUE END STATEMENT TERMINATING A PROGRAM OR
C                  A SUBPROGRAM FORTRAN SOURCE CODE. EQUIVALENCED TO
C                  I4WK2.
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CSNUM  - CHARACTER VARIABLE, SAVE AREA FOR THE STATEMENT
C                  NUMBER IF ONE EXISTS
C         CSAVST - CHARACTER VARIABLE, SAVE AREA FOR THE RECORD IN CREC
C                  STATEMENT PRIOR TO BEING PROCESSED
C         CSREC  - CHARACTER VARIABLE, AN ARRAY WHERE THE TWO RECORDS OF
C                  FORTRAN SOURCE CODE FOLLOWING AN INCLUDE STATEMENT
C                  ARE SAVED. SUBSCRIPT TWO, VALUE 1, IS THE FIRST
C                  RECORD; SUBSCRIPT TWO, VALUE 2, IS THE SECOND RECORD.
C         CSTMT  - CHARACTER VARIABLE, THE STATEMENT TO BE PROCESSED
C         CTAB   - CHARACTER VARIABLE, THE HEX CONSTANT 09, A TAB
C                  CHARACTER. THIS VALUE MUST BE CHANGED TO HEX 05 FOR
C                  AN EBCDIC COMPUTER.
C         CWRK   - CHARACTER VARIABLE, USED TO DETERMINE IF AN END OF
C                  FILE CONDITION EXISTS
C         CWRK7  - CHARACTER VARIABLE, CONTAINS THE FIRST SEVEN
C                  AFTER COLUMN 6 EXCLUDING BLANKS
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         ICAPS  - VALUE TO CONVERT LOWER CASE ALPHABETIC CHARACTERS TO
C                  UPPER CASE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IFMT   - THE ASSIGN VARIABLE TO SPECIFY WHICH FORMAT STATEMENT
C                  IS TO BE USED AS INPUT IN READING THE FORTRAN SOURCE
C                  CODE
C         IG     - SUBSCRIPT VARIABLE; AFTER A RECORD IS READ, THE VALUE
C                  IS THE LENGTH OF THE RECORD.
C         IJ     - SUBSCRIPT VARIABLE
C         IL     - NUMBER OF DIGITS FOR EACH CHARACTERS TO BE SHIFTED TO
C                  THE RIGHT
C         IK     - SUBSCRIPT VARIABLE
C         IM     - COUNTER OF THE NUMBER OF APHABETIC CHARACTERS READ TO
C                  ALLOW DETERMINATION OF AN END STATEMENT
C         IN     - WORK AREA
C         INFILE - COUNT OF THE NUMBER OF DIFFERENT INPUT FORTRAN SOURCE
C                  FILES TO BE PROCESSED. THE MAXIUMUM IS 10.
C         INPUT  - INPUT UNIT NUMBER FOR SOURCE FORTRAN CODE. NORMALLY,
C                  ITS VALUE IS 5, BUT THE OCCURRENCE OF AN INCLUDE
C                  STATEMENT CAUSES IT TO BE MODIFIED SO THAT THE
C                  INCLUDED FILE MAY BE PROCESSED. WHEN MODIFIED, THE
C                  VALUES ARE FROM 21 THROUGH 40 DEPENDING WHETHER
C                  NESTED INLUDE STATEMENTS OCCUR.
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IRET   - SET TO 1 TO TERMINATE PROCESSING OF AN INCLUDE
C                  STATEMENT. USED WHEN THE LITERAL SPECIFYING THE
C                  FILE NAME IS INVALID. SET TO 0 NORMALLY.
C         ISN    - THE ISN OF THE STATEMENT CURRENTLY BEING PROCESSED
C         ISRECL - THE RECORD LENGTH OF THE STATEMENT FOLLOWING AN
C                  INCLUDE STATEMENT IN THE SOURCE CODE
C         ITAB   - LOCATION OF THE INITIAL TAB CHARACTER WHEN ONE EXISTS
C         I1     - SUBSCRIPT VARIABLE
C         I2WK1  - WORK AREA USED TO FORCE ALPHABETIC CHARACTERS TO
C                  UPPER CASE WHEN SEARCHING FOR THE END STATEMENT
C         I4WK1  - USED TO DETECT AN END OF FILE CONDITION. SET TO -1
C                  WHEN AN EOF EXISTS, SET 0 OTHERWISE.
C         I4WK2  - WORK AREA TO SAVE THE FIRST FOUR ALPHABETIC
C                  CHARACTERS FOR A STATEMENT. USED TO DETECT A TRUE
C                  END STATEMENT TERMINATING A SUBPROGRAM LISTING.
C         JFILES - INDEX COUNT OF THE SOURCE INPUT FILE CURRENTLY BEING
C                  PROCESSED
C         JINCL  - COUNT OF THE NUMBER OF INCLUDE STATEMENT FILE NAMES
C                  CURRENTLY ACTIVE (THE NESTING LEVEL)
C         JSNA   - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS, EXCEPT COMMENTS AND
C                  INCLUDE FILES, WHEN THE STATEMENT IS READ
C         J1     - SUBSCRIPT VARIABLE
C         J2     - START LOCATION OF A RECORD FROM UNIT INPUT FOR
C                  MOVING THE RECORD INTO CSTMT IN ROUTINE MOVREC
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KD     - LOCATION OF THE LAST CHARACTER IN THE RECORD IN
C                  CSTMT
C         KE     - LOCATION OF THE LAST CHARACTER IN THE RECORD IN CREC
C         KINCL  - SAVE AREA FOR JINCL WHEN THE END OF FILE HAS BEEN
C                  REACHED ON AN INCLUDE FILE
C         KISN   - SAVE AREA OF THE ISN TO BE RESTORED WHEN THE END OF
C                  FILE HAS BEEN REACHED ON AN INCLUDE FILE
C         KSNA   - SAVE AREA FOR JSNA OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         K1     - COUNT OF THE NUMBER OF CONTINUATION RECORDS
C         LB     - LOGICAL VARIABLE, SET FALSE TO READ THE FIRST RECORD
C                  ON UNIT 5, SET TRUE FOR ALL SUBSEQUENT RECORDS
C         LC     - LOGICAL VARIABLE, SET TRUE TO RESET THE PAGE NUMBER
C                  FOR THE OUT PUT LISTING, SET FALSE TO PREVENT A
C                  CHANGE IN THE PAGE NUMBER
C         LE     - LOGICAL STATEMENT, SET TRUE WHEN A STATEMENT IS A
C                  BLANK RECORD OR A COMMENT STATEMENT, SET FALSE
C                  OTHERWISE
C         LEND   - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE HAS
C                  OCCURRED ON UNIT INPUT, SET FALSE OTHERWISE.
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF THE FORTRAN ROUTINE HAS BEEN READ
C         LEOF   - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE IS
C                  REACHED ON UNIT 5, SET FALSE OTHERWISE. THIS SWITCH
C                  IS USED TO INSURE INPUT WORK BUFFERS ARE FILLED WITH
C                  BLANKS WHEN MULTIPLE FILES OF FORTRAN CODE INPUT
C                  ARE BEING PROCESSED.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LH     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER OF
C                  CHARACTERS READ IS EQUAL TO OR GREATER THAN NCOLS,
C                  SET FALSE OTHERWISE
C         LI     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER IS FOUND, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  OPEN AND BEING PROCESSED, SET FALSE OTHERWISE
C         LINCLM - LOGICAL VARIABLE, SET TRUE WHEN THE UNIT NUMBER IS
C                  INCREMENTED BY ONE IN ROUTINE RDSTMT, SET FALSE
C                  OTHERWISE. THIS PREVENTS ROUTINE STMT33 FROM
C                  INCREMENTING THE UNIT NUMBER AGAIN AFTER IT HAS
C                  ALREADY BEEN DONE ONCE.
C         LINCLX - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  CLOSED AND THE FINAL RECORD OF THE INCLUDE FILE IS
C                  BEING PROCESSED, SET FALSE OTHERWISE. WHEN TRUE, THIS
C                  VARIABLE FORCES LINCL TO BE FALSE UPON THE NEXT ENTRY
C                  TO THIS ROUTINE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LWR    - LOGICAL VARIABLE, SET TRUE WHEN A TRUE END STATEMENT
C                  OCCURS TO FORCE WRITE OUT FOR THE CURRENT ROUTINE
C                  BEING PROCESSED, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE OF
C                  THE FORTRAN SOURCE CODE FILE FROM UNIT 5 OCCURS, SET
C                  FALSE OTHERWISE. THIS VAARIABLE IS SET ONLY WHEN THE
C                  END OF FILE OCCURS WITHOUT AN END STATEMENT.
C         L2     - LOGICAL RECORD, SET TRUE WHEN THE FORTRAN RECORD ON
C                  UNIT INPUT IS A COMMENT RECORD, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END
C                  STATEMENT HAS BEEN PROCESSED AND AN END OF FILE ON
C                  UNIT 5 EXISTS, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN ISN .NE. 0, SET
C                  FALSE, WHEN ISN .EQ. 0. THIS SWITCH IS SET TO TRUE
C                  ONLY IF THE FIRST RECORD IS NOT A FORTRAN EXECUTABLE
C                  STATEMENT.
C         L5     - LOGICAL VARIABLE, SET TRUE TO PRINT AN ISN ON UNIT 6,
C                  SET FALSE TO PREVENT THE ISN FROM BEING PRINTED
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN THE STATEMENT IS A
C                  A BLANK OR COMMENT STATEMENT, SET FALSE OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN A STATEMENT IS
C                  WRITTEN ON UNIT 6, SET FALSE OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN A STATEMENT IS TO
C                  BE PROCESSED, SET FALSE OTHERWISE. THIS PREVENTS
C                  THE LAST READ RECORD FROM UNIT INPUT FROM REPLACING
C                  A NEW FORTRAN STATEMENT BEFORE IT S PROCESSED.
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C         NLINE  - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON A
C                  SINGLE PAGE IN THE OUTPUT LISTINGS
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         5      - THE FORTRAN PROGRAM TO BE CROSS REFERENCED, RECORD
C                  LENGTH IS UP TO 132 CHARACTERS
C
C     COMMENTS
C
C         WHEN SUBROUTINE RDSTMT EXITS, CSTMT WILL CONTAIN ONLY DATA
C         DEFINITION, DESCRIPTIVE, DEFINING, AND EXECUTABLE STATEMENTS
C         FOR ANALYSIS. ALL COMMENT STATEMENTS, BLANK RECORDS, ETC.
C         WILL NOT BE RETURNED TO FXREF FOR ANALYSIS.
C
C         NO RECORD FROM UNIT INPUT WILL BE WRITTEN ON UNIT 6 IF IT IS
C         FROM A FILE SPECIFIED IN AN INCLUDE STATEMENT.
C
C     SUBROUTINES CALLED
C
C         GETRCD MOVREC PREC WRSTMT
C
C     ******************************************************************
C
      SUBROUTINE RDSTMT (CFILEN,LE,LB)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000),IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEN, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK2
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1   LB, LE
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I4WK2,CI4WK2), (I2WK1,CI2WK1), (CWORK(33:36),IWORK),
     1            (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         INITIALIZE WORK AREAS FOR A NEW FORTRAN STATEMENT
C
C
C         WHEN AN END OF FILE OCCURS, SET LB TO FALSE TO INITIALIZE
C         THE READING OF THE FIRST RECORD ON A POSSIBLE NEW FILE
C
C     IF(IEOF .EQ. -1) LB = LFALSE
      I2WK1 = 0
      I4WK2 = 0
      K1 = 0
      LE = LFALSE
C
C         WHEN THE VALUE OF VARIABLE INPUT IS 5, INSURE LINCL IS FALSE
C
      IF(INPUT .EQ. 5) LINCL = LFALSE
C
C         WHEN LEOF IS TRUE INDICATING AN END OF FILE HAS OCCURRED ON
C         UNIT 5, INSURE CSAVST AND CREC ARE ALL BLANKS
C
      IF(LEOF) THEN
         CREC(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
         CSAVST(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      END IF
C
C         OBTAIN ONE RECORD OF THE FORTRAN SOURCE CODE FOR ANALYSIS
C
C
C     ******************************************************************
C     *                                                                *
C     *   THE FOLLOWING CODE IS PERFORMED ONLY ONCE WHEN FXREF READS   *
C     *   THE FIRST RECORD FROM UNIT 5. SUBSEQUENT READ REQUESTS OF    *
C     *   UNIT 5 NEVER USE THIS CODE.                                  *
C     *                                                                *
C     ******************************************************************
C
      IF(.NOT.LB) THEN
          IF(LEOF) LEOF = LFALSE
          K = 0
C
C         READ A FORTRAN RECORD FROM UNIT INPUT
C
         CALL GETRCD (K1,CREC,CFILEN)
C
C         PROCESS THE FIRST FORTRAN RECORD
C
         CALL PRCD (K1,CFILEN)
C
C         SET SWITCH LB FOR ALL FURTHER PROCESSING AFTER THE FIRST
C         RECORD FROM UNIT INPUT HAS BEEN READ
C
         LB = LTRUE
      ELSE
C
C     ******************************************************************
C     *                                                                *
C     *   PROCESS ALL RECORDS FROM UNIT INPUT AFTER THE INITIAL RECORD *
C     *   HAS BEEN PROCESSED. UNIT INPUT MAY HAVE THE VALUES OF 5 OR   *
C     *   14 THROUGH 20.                                               *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE LOCATION OF THE FINAL CHARACTER OF THE RECORD
C
         DO 10 I = NCOLS,1,-1
         IF(CREC(I:I) .NE. CBLANK(1:1)) THEN
            KD = I
            GO TO 11
         END IF
 10      CONTINUE
 11      IF(ISN .EQ. 0) CALL GETRCD (0,CREC,CFILEN)
         CALL PRCD (K1,CFILEN)
C
C         DETERMINE IF THE CONTENTS IN CREC IS A CONTINUATION STATEMENT
C
         IF(CREC(1:1) .EQ. CAMP .OR. (CREC(6:6) .NE. CBLANK(1:1) .AND.
     1      CREC(1:5) .EQ. CBLANK(1:5))) CALL MOVREC (K1,1)
C
C         DETERMINE LOCATION OF THE FINAL CHARACTER IN CREC
C
         KE = 0
         DO I = NCOLS,1,-1
         IF(KE .EQ. 0) THEN
            IF(CREC(I:I) .NE. CBLANK(1:1)) KE = I
         END IF
         END DO
C
C         WHEN KD AND KE ARE NOT EQUAL, CSTMT CONTAINS A COMPLETE
C         FORTRAN STATEMENT
C
         IF(KD .NE. KE) THEN
            GO TO 13                      ! EXIT ROUTINE
         ELSE
C
C         THE LENGTH OF TEXT IN CREC AND CSTMT ARE EQUAL. DETERMINE
C         IF THE TWO RECORDS ARE IDENTICAL. IF NOT, EXIT ROUTINE.
C
            DO I = 1,KD
            IF(CSTMT(I:I) .NE. CREC(I:I)) GO TO 13
            END DO
         END IF
C
C         WHEN AN INCLUDE FILE IS BEING PROCESSED, READ ANOTHER RECORD
C
         IF(LINCL .AND. KD .GT. 0) CALL GETRCD (K1,CREC,CFILEN)
      END IF
C
C         THE WORK BUFFER, VARIABLE CSTMT, NOW CONTAINS THE FORTRAN
C         STATEMENT TO BE ANALYZED. IT HAS NOT BEEN COMPRESSED TO
C         REMOVE ALL BLANKS AT THIS STATE OF PROCESSING.
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C
      DO 12 I = KB,1,-1
      IF(CSTMT(I:I) .NE. CBLANK) THEN
         KB = I
         GO TO 13
      END IF
 12   CONTINUE
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE ASSEMBLES AN ENTIRE FORTRAN STATEMENT FROM THE
C         INDIVIUAL RECORDS ON UNIT 5 AND RETURNS THE STATEMENT FOR
C         PROCESSING.
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CFILEN - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAME
C                  THAT CURRENTLY BEING PROCESSED
C         CI2WK1 - CHARACTER VARIABLE, WORK AREA USED TO FORCE ALL
C                  CHARACTERS IN CI4WK1 TO UPPER CASE
C         CI4WK2 - CHARACTER VARIABLE, WORK AREA TO SAVE THE FIRST FOUR
C                  ALPHABETIC CHARACTERS FOR A STATEMENT. USED TO
C                  DETECT A TRUE END STATEMENT TERMINATING A PROGRAM OR
C                  A SUBPROGRAM FORTRAN SOURCE CODE. EQUIVALENCED TO
C                  I4WK2.
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CSNUM  - CHARACTER VARIABLE, SAVE AREA FOR THE STATEMENT
C                  NUMBER IF ONE EXISTS
C         CSAVST - CHARACTER VARIABLE, SAVE AREA FOR THE RECORD IN CREC
C                  STATEMENT PRIOR TO BE PROCESSED
C         CSREC  - CHARACTER VARIABLE, AN ARRAY WHERE THE TWO RECORDS OF
C                  FORTRAN SOURCE CODE FOLLOWING AN INCLUDE STATEMENT
C                  ARE SAVED. SUBSCRIPT TWO, VALUE 1, IS THE FIRST
C                  RECORD; SUBSCRIPT TWO, VALUE 2, IS THE SECOND RECORD.
C         CSTMT  - CHARACTER VARIABLE, THE STATEMENT TO BE PROCESSED
C         CWRK   - CHARACTER VARIABLE, USED TO DETERMINE IF AN END OF
C                  FILE CONDITION EXISTS
C         CWRK7  - CHARACTER VARIABLE, CONTAINS THE FIRST SEVEN
C                  AFTER COLUMN 6 EXCLUDING BLANKS
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         ICAPS  - VALUE TO CONVERT LOWER CASE ALPHABETIC CHARACTERS TO
C                  UPPER CASE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IEOF   - INDICATES AN END OF FILE WHEN IT EQUALS -1
C         IFMT   - THE ASSIGN VARIABLE TO SPECIFY WHICH FORMAT STATEMENT
C                  IS TO BE USED AS INPUT IN READING THE FORTRAN SOURCE
C                  CODE
C         IG     - SUBSCRIPT VARIABLE; AFTER A RECORD IS READ, THE VALUE
C                  IS THE LENGTH OF THE RECORD.
C         IJ     - SUBSCRIPT VARIABLE
C         IK     - SUBSCRIPT VARIABLE
C         IL     - NUMBER OF DIGITS FOR EACH CHARACTERS TO BE SHIFTED TO
C                  THE RIGHT
C         ILOCL  - LOCATION OF THE INITIAL CHARACTER IN CSTMT
C         ILOCR  - LOCATION OF THE FINAL CHARACTER IN CSTMT
C         IM     - COUNTER OF THE NUMBER OF APHABETIC CHARACTERS READ TO
C                  ALLOW DETERMINATION OF AN END STATEMENT
C         IN     - WORK AREA
C         INFILE - COUNT OF THE NUMBER OF DIFFERENT INPUT FORTRAN SOURCE
C                  FILES TO BE PROCESSED. THE MAXIUMUM IS 10.
C         INPUT  - INPUT UNIT NUMBER FOR SOURCE FORTRAN CODE. NORMALLY,
C                  ITS VALUE IS 5, BUT THE OCCURRENCE OF AN INCLUDE
C                  STATEMENT CAUSES IT TO BE MODIFIED SO THAT THE
C                  INCLUDED FILE MAY BE PROCESSED. WHEN MODIFIED, THE
C                  VALUES ARE FROM 21 THROUGH 40 DEPENDING WHETHER
C                  NESTED INLUDE STATEMENTS OCCUR.
C         IREC0  - COUNT OF THE NUMBER OF ERROR MESSAGES ON UNIT 0
C         IRET   - SET TO 1 TO TERMINATE PROCESSING OF AN INCLUDE
C                  STATEMENT. USED WHEN THE LITERAL SPECIFYING THE
C                  FILE NAME IS INVALID. SET TO 0 NORMALLY.
C         ISN    - THE ISN OF THE STATEMENT CURRENTLY BEING PROCESSED
C         ISRECL - THE RECORD LENGTH OF THE STATEMENT FOLLOWING AN
C                  INCLUDE STATEMENT IN THE SOURCE CODE
C         ITAB   - LOCATION OF THE INITIAL TAB CHARACTER WHEN ONE EXISTS
C         I1     - SUBSCRIPT VARIABLE
C         I2WK1  - WORK AREA USED TO FORCE ALPHABETIC CHARACTERS TO
C                  UPPER CASE WHEN SEARCHING FOR THE END STATEMENT
C         I4WK1  - USED TO DETECT AN END OF FILE CONDITION. SET TO -1
C                  WHEN AN EOF EXISTS, SET 0 OTHERWISE.
C         I4WK2  - WORK AREA TO SAVE THE FIRST FOUR ALPHABETIC
C                  CHARACTERS FOR A STATEMENT. USED TO DETECT A TRUE
C                  END STATEMENT TERMINATING A SUBPROGRAM LISTING.
C         JD     - LOCATION OF THE FINAL CHARACTER IN A STATEMENT
C                  AFTER ANY TAB CHARACTERS HAVE BEEN REMOVED
C         JINCL  - COUNT OF THE NUMBER OF INCLUDE STATEMENT FILE NAMES
C                  CURRENTLY ACTIVE (THE NESTING LEVEL)
C         JSNA   - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS, EXCEPT COMMENTS AND
C                  INCLUDE FILES, WHEN THE STATEMENT IS READ
C         J1     - SUBSCRIPT VARIABLE
C         J2     - START LOCATION OF A RECORD FROM UNIT INPUT FOR
C         J3     - SUBSCRIPT VARIABLE
C         J4     - SUBSCRIPT VARIABLE
C                  MOVING THE RECORD INTO CSTMT IN ROUTINE MOVREC
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KD     - LOCATION OF THE LAST CHARACTER IN THE RECORD IN CREC
C         KINCL  - SAVE AREA FOR JINCL WHEN THE END OF FILE HAS BEEN
C                  REACHED ON AN INCLUDE FILE
C         KISN   - SAVE AREA OF THE ISN TO BE RESTORED WHEN THE END OF
C                  FILE HAS BEEN REACHED ON AN INCLUDE FILE
C         KSNA   - SAVE AREA FOR JSNA OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         K1     - COUNT OF THE NUMBER OF CONTINUATION RECORDS
C         LB     - LOGICAL VARIABLE, SET TRUE AFTER THE INITIAL FORTRAN
C                  RECORD HAS BEEN READ FROM UNIT INPUT, SET FALSE
C                  OTHERWISE.
C         LC     - LOGICAL VARIABLE, SET TRUE TO RESET THE PAGE NUMBER
C                  FOR THE OUT PUT LISTING, SET FALSE TO PREVENT A
C                  CHANGE IN THE PAGE NUMBER
C         LE     - LOGICAL STATEMENT, SET TRUE WHEN A STATEMENT IS A
C                  BLANK RECORD OR A COMMENT STATEMENT, SET FALSE
C                  OTHERWISE
C         LEND   - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE HAS
C                  OCCURRED ON UNIT INPUT, SET FALSE OTHERWISE.
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF THE FORTRAN ROUTINE HAS BEEN READ
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LH     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER OF
C                  CHARACTERS READ IS EQUAL TO OR GREATER THAN NCOLS,
C                  SET FALSE OTHERWISE
C         LI     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER IS FOUND, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  OPEN AND BEING PROCESSED, SET FALSE OTHERWISE
C         LINCLM - LOGICAL VARIABLE, SET TRUE WHEN THE UNIT NUMBER IS
C                  INCREMENTED BY ONE IN ROUTINE RDSTMT, SET FALSE
C                  OTHERWISE. THIS PREVENTS ROUTINE STMT33 FROM
C                  INCREMENTING THE UNIT NUMBER AGAIN AFTER IT HAS
C                  ALREADY BEEN DONE ONCE.
C         LINCLX - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  CLOSED AND THE FINAL RECORD OF THE INCLUDE FILE IS
C                  BEING PROCESSED, SET FALSE OTHERWISE. WHEN TRUE, THIS
C                  VARIABLE FORCES LINCL TO BE FALSE UPON THE NEXT ENTRY
C                  TO THIS ROUTINE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LWR    - LOGICAL VARIABLE, SET TRUE WHEN A TRUE END STATEMENT
C                  OCCURS TO FORCE WRITE OUT FOR THE CURRENT ROUTINE
C                  BEING PROCESSED, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE OF
C                  THE FORTRAN SOURCE CODE FILE FROM UNIT 5 OCCURS, SET
C                  FALSE OTHERWISE. THIS VARIABLE IS SET ONLY WHEN THE
C                  END OF FILE OCCURS WITHOUT AN END STATEMENT.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  IS FOUND, SET FALSE OTHERWISE. THIS IS USED TO
C                  PREVENT A MISSING END STATMENT MESSAGE WHEN ONE
C                  EXISTS AND IT IS THE FINAL RECORD OF THE INPUT FILE
C                  FROM UNIT 2.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL CHARACTER
C                  OF A RECORD IS FOUND, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A CONTINUATION RECORD
C                  OF A FORTRAN STATEMENT OCCURS, SET FALSE OTHERWISE.
C                  USED TO FORCE PROCESSING OF A FORTRAN STATEMENT WITH
C                  CONTINUATION RECORDS WHEN ALL CONTINUIATION RECORDS
C                  FOR THE STATEMENT HAVE BEEN READ. PREVENTS IMMEDIATE
C                  PROCESSING OF A NEW STATEMENT UNTIL THE CONTINUATION
C                  STATEMENT IS PROCESSED.
C         L5     - LOGICAL VARIABLE, SET TRUE TO PRINT AN ISN ON UNIT 6,
C                  SET FALSE TO PREVENT THE ISN FROM BEING PRINTED
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN THE STATEMENT IS A
C                  A BLANK OR COMMENT STATEMENT, SET FALSE OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  IS FOUND, SET FALSE OTHERWISE. THIS IS USED TO
C                  PREVENT OBTAINING THE NEXT RECORD FOLLOWING AN END
C                  STATEMENT UNTIL THE SUBPROGRAM IS FULLY PROCESSED
C                  AND ALL TABLES ARE WRITTEN ON UNIT 6.
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C         NLINE  - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON A
C                  SINGLE PAGE IN THE OUTPUT LISTINGS
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     COMMENTS
C
C         ONLY DESCRIPTIVE, DECLARITIVE, AND EXECUTABLE STATEMENTS
C         ARE RETURNED FROM SUBROUTINE GETRCD. ALL COMMENT, BLANK,
C         AND COMPILER OR OPERATING SYSTEM DIRECTIVES ARE NOT RETURNED
C         BE GETRCD.
C
C         WHEN AN END STATEMENT IS FOUND, NO FURTHER PROCESSING OF
C         FORTRAN STATEMENTS ON UNIT 5 ARE PROCESSED UNTIL THE
C         PROGRAM OR SUBPROGRAM TERMINATED BY THE END STATEMENT HAS
C         BEEN PROCESSED, AND ALL TABLES ARE WRITTEN ON UNIT 6.
C         NO FORTRAN STATEMENTS FOLLOWING AN END STATEMENT ON UNIT 5
C         MAY BELONG TO THE CURRENT PROGRAM OR SUBPROGRAM.
C
C     ******************************************************************
C
      SUBROUTINE PRCD (K1,CFILEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEN, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK2
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1, L2, L3, L4, L5, L6
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
C     CHARACTER*7 CWRK7
C     CHARACTER*1 CTAB, CFORMF
C     CHARACTER*1 CFORMF
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I4WK2,CI4WK2), (I2WK1,CI2WK1), (CWORK(33:36),IWORK),
     1            (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA L1/.FALSE./, L2/.FALSE./
C     DATA CFORMF/'0C'X/, L1/.FALSE./, L2/.FALSE./
C     DATA LZ/.FALSE./
C
C         FORMAT STATEMENTS
C
 101  FORMAT(' COLUMN 1 OF FORTRAN RECORD IS AN ILLEGAL CHARACTER'/5X,A7
     12)
 102  FORMAT(' ISN:',I6,' MORE THAN',I3,' CONTINUATION RECORDS')
 103  FORMAT(' ISN:',I6,' COLUMNS 1-5 MUST BE BLANK IN CONTINUATION RECO
     1RDS')
C
C         INSURE THE CONTINUATION SWITCH IS SET OFF FOR EACH NEW FORTRAN
C         STATEMENT
C
      L4 = LFALSE
C
C         DETERMINE IF AN END OF FILE HAS OCCURRED ON UNIT INPUT
C
 10   IF(IEOF .EQ. -1) THEN
         IF(.NOT.LINCL) THEN
            LEND = LTRUE
            LWR = LTRUE
         ELSE
C
C         THE END OF FILE IS FROM AN INCLUDE STATEMENT SPECIFIED FILE
C
            CALL EINCL
         END IF
      END IF
C
C         DETERMINE THE LOCATION OF FINAL CHARACTER IN THE RECORD
C
      KD = 0
      DO 11 I = NCOLS,1,-1
      IF(CREC(I:I) .NE. CBLANK) THEN
         KD = I
         GO TO 12
      END IF
 11   CONTINUE
C
C         DETERMINE IF COLUMN 1 OF THE RECORD IS: C, c, OR *
C
 12   IF(CREC(1:1) .EQ. CCC .OR. CREC(1:1) .EQ. CCS .OR. CREC(1:1) .EQ.
     1   CASTER) THEN
         CSTMT(1:KD) = CREC(1:KD)
         GO TO 14
      END IF
C
C         DETERMINE IF THIS IS A BLANK RECORD. THE RECORD WILL BE WRITTEN
C         ON UNIT 6 WITHOUT AN ISN.
C
      IF(KD .GT. 0) THEN
C
C         SET THE LOCATION OF THE FINAL CHARACTER IN THE RECORD
C
         IG = KD
      END IF
C
C         WHEN CHARACTER ONE OF A RECORD IS NOT: BLANK, c, C, *, &, $,
C         !, d, D, x, X, OR A DIGIT, ANY OTHER CHARACTER IS AN ERROR.
C         THE RECORD WILL BE WRITTEN ON UNIT 6 WITHOUT AN ISN AND IS
C         TREATED AS A COMMENT STATEMENT.
C
      IF(.NOT.(CREC(1:1) .GE. C0 .AND. CREC(1:1) .LE. C9) .AND.
     1   CREC(1:1) .NE. CBLANK(1:1) .AND. CREC(1:1) .NE. CDOL .AND.
     2   CREC(1:1) .NE. CCC .AND. CREC(1:1) .NE. CCS .AND. CREC(1:1)
     3   .NE. CAMP .AND. CREC(1:1) .NE. CASTER .AND. CREC(1:1) .NE.
     4   CEXCL .AND. CREC(1:1) .NE. CDD .AND. CREC(1:1) .NE. 'd' .AND.
     5   CREC(1:1) .NE. CXX .AND. CREC(1:1) .NE. 'x') THEN
         IF(.NOT.LINCL) THEN
            CALL WRSTMT (L5,CFILEN,LFALSE,LFALSE,LFALSE)
            IREC0 = IREC0 + 2
            WRITE (0,101) CREC(1:72)
         END IF
C
C         GET NEXT RECORD
C
         CALL GETRCD (K1,CREC,CFILEN)
         IF(IEOF .LT. 0 .AND. L2) L2 = LFALSE
         GO TO 10
      END IF
C
C         SINCE ALL BLANK, COMMENT, DEBUGGING, AND COMPILER DIRECTIVE
C         RECORDS HAVE BEEN SCREENED AND BEEN PROCESSED, ONLY A NEW
C         FORTRAN OR CONTINUATION RECORD CAN EXIST IN THE BUFFER AT THIS
C         POINT.
C
C         DETERMINE IF THE RECORD IS A CONTINUATION RECORD OR A NEW
C         STATEMENT. A CONTINUATION RECORD IS DEFINED BY HAVING AN
C         AMPERSAND IN COLUMN 1 OR HAVING COLUMN 1 NOT AN AMPERSAND
C         WHILE COLUMN 6 IS NOT BLANK.
C
 13   IF(CREC(1:1) .EQ. CAMP .OR. (CREC(1:5) .EQ. CBLANK(1:5) .AND.
     1   CREC(6:6) .NE. CBLANK(1:1))) THEN
C
C         THE RECORD IS A CONTINUATION RECORD
C
         L4 = LTRUE
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER
C
         DO J3 = 72,1,-1
         IF(CREC(J3:J3) .NE. CBLANK(1:1)) THEN
            KD = J3
            GO TO 128
         END IF
         END DO
C
C         DETERMINE IF THE TOTAL NUMBER OF RECORDS FOR A SINGLE
C         FORTRAN STATEMENT EXCEEDS 99
C
 128     IF(K1 .GT. 99 .AND. NCOLS .EQ. 72 .OR. (K1 .GT. 49 .AND.
     1      NCOLS .GT. 72 .AND. NCOLS .LE. 132))  THEN
            IREC0 = IREC0 + 1
            WRITE (0,102) ISN,K1
            GO TO 10
         END IF
C
C         ADD THE RECORD TO CSTMT TO BUILD THE COMPLETE FORTRAN
C         STATEMENT.
C
         IF(CREC(1:1) .EQ. CAMP) THEN
            J2 = 2
         ELSE
            J2 = 7
         END IF
         L1 = LTRUE
         IF(CREC(6:6) .EQ. CBLANK(1:1) .AND. CREC(1:1) .NE. CAMP)
     1      K1 = 0
         CALL MOVREC(K1,J2)
C
C         THE RECORD IS A CONTINUATION STATEMENT RECORD; WRITE THE
C         RECORD ON UNIT 6 WITHOUT AN ISN.
C
         L5 = LFALSE
         L6 = LTRUE
         IF(.NOT.LINCL) THEN
            CALL WRSTMT (L5,CFILEN,LFALSE,LFALSE,LFALSE)
C
C         DETERMINE IF COLUMNS 1 THROUGH 5 ARE BLANK FOR A CONTINUATION
C         RECORD,AND WRITE A MESSAGE IF NOT
C
            IF(CREC(1:5) .NE. CBLANK(1:5)) THEN
               IF(CREC(1:1) .NE. CAMP .OR. CREC(6:6) .NE. CBLANK(1:1))
     1            THEN
                  IREC0 = IREC0 + 1
                  WRITE (0,103) ISN
               END IF
            END IF
         END IF
C
C         OBTAIN A NEW RECORD FROM THE FORTRAN UNIT INPUT
C
         CALL GETRCD (K1,CREC,CFILEN)
         IF(IEOF .LT. 0 .AND. L2) L2 = LFALSE
C
C         DETERMINE IF THE RECORD IS A CONTINUATION RECORD
C
         IF(CREC(1:1) .EQ. CAMP .OR. CREC(6:6) .NE. CBLANK(1:1)) THEN
            IF(IEOF .GE. 0) THEN
               GO TO 10
            ELSE
               GO TO 13
            END IF
         END IF
C
C         WHEN THE RECORD IS NOT A CONTINUATION RECORD, IT MUST BE A
C         NEW FORTRAN STATEMENT RECORD
C
         GO TO 14
      END IF
C
C         DETERMINE IF THE RECORD IS A NEW OR CONTINUATION RECORD FOR
C         FORTRAN STATEMENT
C
      IF(CREC(1:1) .NE. CAMP .AND. CREC(6:6) .EQ. CBLANK(1:1)) THEN
C
C         DETERMINE IF THIS NEW RECORD TERMINATES A STATEMENT WITH
C         CONTINUATION RECORDS
C
C
C         SET THE LOCATION OF THE FINAL CHARACTER FOR CURRENT STATEMENT
C
         KB = 0
C
C         DETERMINE LOCATION OF THE FINAL CHARACTER IN THE RECORD
C
         L3 = LFALSE
         DO I = NCOLS,1,-1
         IF(.NOT.L3 .AND. CREC(I:I) .NE. CBLANK) THEN
            KD = I
            L3 = LTRUE
         END IF
         END DO
C
C         DETERMINE LOCATION OF THE FIRST NON-BLANK CHARACTER IN CREC
C
         DO I = 1,NCOLS
         IF(CREC(I:I) .NE. CBLANK(1:1)) THEN
C
C         DETERMINE IF CREC MAY CONTAIN AN END STATEMENT
C
            IF(KD - I .EQ. 2) THEN
               IF(CREC(I:KD) .EQ. 'END' .OR. CREC(I:KD) .EQ. 'end')
     1            THEN
                  LENDS = LTRUE
                  LWR = LTRUE
               END IF
            ELSE
               GO TO 129
            END IF
         END IF
         END DO
C
C         PLACE THE RECORD IN CSTMT TO CREATE THE COMPLETE FORTRAN
C         STATEMENT FOR PROCESSING
C
 129     IF(.NOT.LENDS) CALL MOVREC (K1,1)
C
C         WRITE THE RECORD ON UNIT 6 WITH AN ISN WHEN THE STATEMENT IS
C         NOT IN AN INCLUDE FILE
C
         IF(.NOT.LINCL) THEN
            IF(CREC(1:1) .EQ. CCC .OR. CREC(1:1) .EQ. 'c' .OR.
     1         CREC(1:1) .EQ. CASTER) THEN
               CONTINUE
            ELSE
               L5 = LFALSE
               IF(KD .GT. 0) THEN
                  ISN = ISN + 1
                  L5 = LTRUE
               END IF
               L6 = LFALSE
               CALL WRSTMT (L5,CFILEN,LFALSE,LFALSE,L6)
C
C         DETERMINE IF THE RECORD JUST WRITTEN WAS AN END STATEMENT.
C         DO NOT GET THE NEXT FORTRAN RECORD UNTIL AFTER WRITING ALL
C         TABLES FOR THE ROUTINE TERMINATED BY THIS END STATEMENT.
C
               DO J3 = 7,NCOLS
                  IF(CSTMT(J3:J3) .NE. CBLANK(1:1)) THEN
                     DO J4 = NCOLS,J3,-1
                     IF(CSTMT(J4:J4) .NE. CBLANK(1:1)) THEN
                        IF(J4 - J3 .EQ. 2) THEN
                           IF(CSTMT(J3:J3) .EQ. CEE .OR. CSTMT(J3:J3)
     1                        .EQ. 'e' .AND. CSTMT(J3+1:J3+1) .EQ. CNN
     2                        .OR. CSTMT(J3+1:J3+1) .EQ. 'n' .AND.
     3                        CSTMT(J4:J4) .EQ. CDD .OR. CSTMT(J4:J4)
     4                        .EQ. 'd') THEN
                              GO TO 14
                           ELSE
                              GO TO 130
                           END IF
                        ELSE
                           GO TO 130
                        END IF
                     END IF
                     END DO
                  END IF
               END DO
            END IF
         END IF
C
C         GET THE NEXT RECORD
C
 130     IF(ISN .GT. 0) CALL GETRCD (K1,CREC,CFILEN)
         IF(IEOF .LT. 0) L2 = LFALSE
C
C         DETERMINE IF THE CURRENT RECORD IS A STATEMENT CONTINUATION
C
         IF(CREC(1:1) .EQ. CAMP) THEN
            J1 = 2
            GO TO 13
         ELSE IF(CREC(6:6) .NE. CBLANK(1:1) .AND. CREC(1:5) .EQ.
     1      CBLANK(1:5)) THEN
            J1 = 7
            GO TO 13
         ELSE
C
C         THE CURRENT RECORD IS A NEW STATEMENT
C
C         CREATE CSTMT FOR PROCESSING
C
C
C         WHEN THE ISN IS ZERO, THIS IS THE FIRST FORTRAN STATEMENT.
C
            IF(ISN .EQ. 0) THEN
               DO I = NCOLS,1,-1
               IF(CREC(I:I) .NE. CBLANK(1:1)) THEN
                  ISN = ISN + 1
                  KB = I
                  CALL MOVREC (1,1)
                  GO TO 14
               END IF
               END DO
            END IF
            GO TO 14
         END IF
      END IF
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM READS A RECORD FROM THE FORTRAN PROGRAM INPUT
C        FILE UNIT AND CREATES THE ENTIRE FORTRAN STATEMENT FOR ANALYSIS
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CCC    - CHARACTER VARIABLE, THE CHARACTER: C
C         CCS    - CHARACTER VARIABLE, THE CHARACTER: c
C         CFILEN - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAME
C                  THAT IS TO BE PROCESSED
C         CFORMF - CHARACTER VARIABLE, A FORM FEED '0C'X
C         CINBUF - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C         CSAVST - CHARACTER VARIABLE, SAVE AREA FOR THE RECORD IN CREC
C                  STATEMENT PRIOR TO BEING PROCESSED
C         I      - SUBSCRIPT VARIABLE
C         IA     - LOCATION OF THE INITIAL CHARACTER IN THE INPUT RECORD
C                  AFTER COLUMN 6
C         IEQ    - LOCATION IN CINBUF OF THE INITIAL EQUAL SIGN
C         IEOF   - END OF FILE INDICATOR, SET TO -1 WHEN AN END OF FILE
C                  HAS BEEN REACHED ON UNIT INPUT, SET TO 0 OTHERWISE.
C         IJ     - SUBSCRIPT VARIABLE
C         INPUT  - INPUT UNIT NUMBER FOR SOURCE FORTRAN CODE. NORMALLY,
C                  ITS VALUE IS 5, BUT THE OCCURRENCE OF AN INCLUDE
C                  STATEMENT CAUSES IT TO BE MODIFIED SO THAT THE
C                  INCLUDED FILE MAY BE PROCESSED. WHEN MODIFIED, THE
C                  VALUES ARE FROM 14 THROUGH 20 AND THE UNIT VALUE
C                  DEPENDS ON WHETHER NESTED INLUDE STATEMENTS OCCUR.
C                  SINGLE PAGE IN THE OUTPUT LISTINGS
C         I1     - WORK AREA
C         I2     - WORK AREA
C         I3     - WORK AREA
C         I4     - LOCATION OF THE FIRST APOSTROPHE OR QUOTATION MARKS
C                  OF A LITERAL
C         I5     - LOCATION OF THE LAST APOSTROPHE OR QUOTATION MARKS
C                  OF A LITERAL
C         I6     - LOCATION OF AN EXCLAMATION MARK
C         JA     - LOCATION OF THE INITIAL CHARACTER OF A RECORD IN
C                  CINBUF
C         JB     - LOCATION OF THE FINAL CHARACTER OF A RECORD IN
C                  CINBUF
C         JINCL  - COUNT OF THE LEVEL OF NESTED INCLUDE STATEMENTS
C         KD     - LOCATION OF THE FINAL CHARACTER IN THE RECORD
C         K1     - COUNT OF THE NUMBER OF CONTINUATION RECORDS
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF A FORTRAN ROUTINE HAS BEEN READ. SET FALSE
C                  OTHERWISE; NOT THE END OF FILE FOR UNIT 5 WHEN SET
C                  TRUE.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST CHARACTER
C                  OF A RECORD IS FOUND, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE INITIAL EQUAL
C                  SIGN IS FOUND, SET FALSE OTHERWISE
C                  OR SUBROUTINE STATEMENT IS A VARIABLE NAME, SET FALSE
C                  OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE LAST CHARACTER
C                  OF A RECORD IS FOUND, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN CREC IS A TRUE
C                  END STATEMEMT, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A RECORD IS NOT
C                  ALL BLANKS, SET FALSE WHEN THE RECORD IS ALL BLANKS
C         NCOLS  - THE NUMBER OF COLUMNS ALLOWED IN AN INPUT RECORD
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         INPUT  - THE FORTRAN STATEMENTS TO BE CROSS REFERENCED, RECORD
C                  LENGTH IS UP TO 132 CHARACTERS
C
C     ******************************************************************
C
      SUBROUTINE GETRCD (K1,CINBUF,CFILEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CSREC(20), ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST, CINBUF
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEN
      CHARACTER*68    CWK68
      CHARACTER*52    CBLK52, CWORK
      CHARACTER*32    CWK32
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CFORMF
      INTEGER*2       I2WK1, ISRECL
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1, L2, L3, L4, L5
      REAL*8          FP
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
C
C         DATA STATEMENTS
C
      DATA CFORMF /'0C'X/
C     DATA L1 /.FALSE./
      DATA INCL /0/
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(A72)
 101  FORMAT(A132)
 102  FORMAT(' ISN:',I6,' END STATEMENT MISSING')
C
C         DETERMINE IF AN END OF FILE HAS BEEN REACHED
C
C
C         MOVE CINBUF TO CSTMT.  CINBUF CONTAINS THE LAST READ RECORD
C
      IF(K1 .EQ. 0) CSTMT(1:NCOLS) = CINBUF(1:NCOLS)
C
C         READ ONE RECORD OF THE FORTRAN SOURCE CODE
C
 10   CINBUF(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      IF(NCOLS .LE. 72) THEN
         READ (INPUT,100,IOSTAT=IEOF) CINBUF(1:NCOLS)
         IF(LINCL) INCL = INCL + 1
      ELSE
         READ (INPUT,101,IOSTAT=IEOF) CINBUF(1:NCOLS)
      END IF
C
C         DETERMINE IF THE RECORD JUST READ IS THE START OF A NEW
C         STATEMENT OR A CONTINUATION STATEMENT
C
      IF(CREC(6:6) .EQ. CBLANK(1:1) .OR. CREC(1:1) .EQ. CAMP) THEN
         K1 = 0
      ELSE IF(K1 .GT. 0) THEN
         K1 = K1 + 1
      END IF
C
C         DETERMINE IF THE END OF A SUBROUTINE OR FUNCTION HAS OCCURRED
C
      IF(LENDS) GO TO 14
C
C         DETERMINE IF AN END OF FILE OCCURED WHILE ATTEMPTING TO READ
C         THE NEXT RECORD ON UNIT INPUT
C
      IF(IEOF .EQ. -1) THEN
C
C         WHEN AN END OF FILE OCCURRED ON UNIT INPUT AND THE CURRENT
C         FILE BEING READ IS AN INCLUDE FILE, FORCE AN END STATEMENT
C         TO ALLOW PROPER PROCESSING.
C
         IF(LINCL) THEN
            CINBUF(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
            CINBUF(7:9) = 'END'
         END IF
         GO TO 14
      END IF
C
C         DETERMINE IF THE RECORD PRIOR TO THE CURRENT RECORD WAS A
C         CONTINUATION RECORD
C
      IF(K1 .GT. 0) THEN
C
C         DETERMINE IF THE NEW RECORD IS A CONTINUATION RECORD
C
         IF(CINBUF(1:1) .EQ. CAMP .OR. CINBUF(1:5) .EQ. CBLANK(1:5)
     1      .AND. CINBUF(6:6) .NE. CBLANK(1:1)) GO TO 14
      END IF
C
C         DETERMINE IF THE RECORD JUST READ IS A COMMENT, SYSTEM OR
C         COMPILER DIRECTIVE, OR DEBUGING RECORD.
C
      IF(CINBUF(1:1) .EQ. CCC .OR. CINBUF(1:1) .EQ. CCS .OR. CINBUF(1:1)
     1.EQ. CASTER .OR. CINBUF(1:1) .EQ. CDOL .OR. CINBUF(1:1) .EQ.
     2CEXCL .OR. CINBUF(1:1) .EQ. CDD .OR. CINBUF(1:1) .EQ. 'd' .OR.
     3CINBUF(1:1) .EQ. CXX .OR. CINBUF(1:1) .EQ. 'x') THEN
C
C         DETERMINE IF THE PRIOR STATEMENT WAS AN END STATEMENT
C
         IF(.NOT.L4) THEN
            IF(.NOT.LINCL) CALL WRSTMT (LFALSE,CFILEN,LFALSE,LFALSE,
     1         LFALSE)
            IF(LINCL) GO TO 14
            GO TO 10
         END IF
C
C         DETERMINE IF AN END STATEMENT WAS THE LAST RECORD
C
         IF(L4) THEN
            L4 = LFALSE
            IF(.NOT.LINCL) CALL WRSTMT (LFALSE,CFILEN,LFALSE,LFALSE,
     1         LFALSE)
            GO TO 10
         END IF
      END IF
C
C         DETERMINE IF THIS A BLANK RECORD
C
      L5 = LFALSE
      DO 11 I = 1,NCOLS
      IF(CINBUF(I:I) .NE. CBLANK(1:1)) THEN
         L5 = LTRUE
         GO TO 113
      END IF
 11   CONTINUE
C
C         NORMAL TERMINATION OF THE ABOVE DO LOOP INDICATE A BLANK
C         RECORD EXISTS
C
      IF(LINCL) THEN
         GO TO 10
      ELSE
         GO TO 12
      END IF
C
C         WHEN COLUMN 1 OF THE RECORD IS A FORM FEED, THIS INDICATES
C         THE INPUT RECORD IS FROM A PRINT FILE; SKIP THIS RECORD.
C         A RECORD WITH A FORM FEED IN COLUMN 1 WILL NOT APPEAR IN THE
C         LISTING ON UNIT 6.
C
 113  IF(CREC(1:1) .EQ. CFORMF(1:1) .AND. .NOT.LINCL) THEN
         WRITE (0,100) CREC(1:72)
         IREC0 = IREC0 + 2
         IF(IEOF .LT. 0 .AND. L2) L2 = LFALSE
         GO TO 10
      END IF
C
C         DETERMINE IF THE RECORD IS ALL BLANKS
C
      IF(.NOT.L5) THEN
C
C         WHEN THE ENTIRE RECORD IS ALL BLANKS, WRITE THE BLANK RECORD
C         ON UNIT 6
C
         IF(.NOT.LINCL) CALL WRSTMT (LFALSE,CFILEN,LFALSE,LFALSE,LFALSE)
C
C         READ THE NEXT RECORD FROM UNIT INPUT
C
         GO TO 10
C     ELSE
C
C         THE RECORD IS NOT BLANK
C
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   WHEN EXECUTION HAS REACHED THIS POINT, PASS THE RECORD T0    *
C     *   SUBROUTINE PRCD FOR PROCESSING.                              *
C     *                                                                *
C     ******************************************************************
C
 12   IJ = 0
      I4 = 0
      I5 = 0
      I6 = 0
C
C         SCAN THE INPUT REC0RD TO DETERMINE IF HORIZONTAL TAB
C         CHARACTERS EXIST AND REMOVE THEM FROM THE RECORD. ANY LINE
C         COMMENT HAS ALREADY BEEN REMOVED FROM THE RECORD.
C
      CALL REMTAB (CINBUF)
      L2 = LFALSE
C
C         DETERMINE IF THE CURRENT RECORD IS A CONTINUATION RECORD
C
      IF(CREC(1:1) .EQ. CAMP .OR. (CREC(6:6) .NE. CBLANK(1:1) .AND.
     1   CREC(1:5) .EQ. CBLANK(1:5))) K1 = K1 + 1
C
C         DETERMINE THE LOCATION OF THE FIRST AND LAST CHARACTER IN THE
C         RECORD
C
      L1 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      DO I = 7,NCOLS
      I3 = NCOLS - I + 1
      IF(CREC(I:I) .NE. CBLANK(1:1) .AND. .NOT.L1) THEN
         JA = I
         L1 = LTRUE
      END IF
      IF(CREC(I3:I3) .NE. CBLANK(1:1) .AND. .NOT.L3) THEN
         JB = I3
         L3 = LTRUE
      END IF
      END DO
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM MOVES A RECORD FROM THE FORTRAN PROGRAM INPUT
C        BUFFER, CREC, TO THE STATEMEMT RECORD WORK AREA, CSTMT
C
C     MEANING OF THE VARIABLES
C
C         CAMP   - CHARACTER VARIABLE, THE CHARACTER: &
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         ICONT  - THE MAXIMUM NUMBER OF CONTINUATION STATEMENTS ALLOWED
C         ICONTL - THE STARTING (SUBSCRIPT 1 - VALUE 1) AND ENDING
C                  (SUBSCRIPT 1 - VALUE 2) LOCATIONS OF EACH RECORD
C                  IN A FORTRAN STATEMENT
C         I1     - SUBSCRIPT VARIABLE AND WORK AREA
C         I2     - NUMBER OF CHARCTERS TO BE MOVED FROM CREC TO CSTMT
C                  AND WORK AREA
C         I3     - SUBSCRIPT CREATION WORK AREA, START VALUE
C         I4     - SUBSCRIPT CREATION WORK AREA, END VALUE
C         I5     - COUNT OF THE NUMBER OF ENTRIES IN TABLE ICONTL AND
C                  SUBSCRIPT VARIABLE
C         JD     - SUBSCRIPT VARIABLE, THE VALUE SETS THE START LOCATION
C                  FOR THE MOVE IN VARIABLE CREC
C         K1     - NUMBER OF CONTINUATION STATEMENTS
C         MA     - START POINTER LOCATION OF THE CARD IMAGE IN VARIABLE
C                  CSTMT
C         MB     - END POINTER LOCATION OF THE CARD IMAGE IN VARIABLE
C                  CSTMT.
C         MC     - LOCATION WHERE CREC IS TO BE PLACED IN CSTMT
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C
C     COMMENTS
C
C         EACH RECORD IS PLACED IN CSTMT WITHOUT ANY MODIFICATION AND
C         INCLUDES ANY LINE COMMENTS AND WILL NOT MOVE COLUMNS 1 - 6
C         WHEN COLUMN 6 IS NOT BLANK. IF COLUMN 1 IS AN AMPERSAND, THEN
C         COLUMN 1 WILL NOT BE MOVED.
C
C         THE RECORD STRUCTURE OF CSTMT WHEN A FORTRAN STATEMENT IS
C         COMPLETE IS SHOWN BELOW.
C
C         RECORDS ARE 72 CHARACTERS IN LENGTH
C         RECORD 1
C         COLS        CONTENTS
C           1-   72   FIRST RECORD
C
C         WHEN COLUMN 6 IS NOT A BLANK CONTINUATION RECORD, 66
C         CHARACTERS ARE MOVED.
C
C          73 - 138   SECOND RECORD
C         139 - 204   THIRD RECORD
C         ETC. TO THE 99TH RECORD
C
C         WHEN COLUMN ONE IS AN AMPERSAND CONTINUATION RECORD, 131
C         CHARACTERS ARE MOVED.
C
C          73 - 143   SECOND RECORD
C         141 - 214   THIRD RECORD
C         ETC. TO THE 92ND RECORD
C
C         RECORDS ARE 132 CHARACTERS IN LENGTH
C         RECORD 1
C         COLS        CONTENTS
C           1-  132   FIRST RECORD
C
C         WHEN COLUMN 6 IS NOT A BLANK CONTINUATION RECORD, 126
C         CHARACTERS ARE MOVED.
C
C         131 - 258   SECOND RECORD
C         259 - 384   THIRD RECORD
C         ETC. TO THE 51ST RECORD
C
C         WHEN COLUMN ONE IS AN AMPERSAND CONTINUATION RECORD, 131
C         CHARACTERS ARE MOVED.
C
C         133 - 263   SECOND RECORD
C         264 - 394   THIRD RECORD
C         ETC. TO THE 49TH RECORD
C
C         SUBROUTINE DELCOM WILL REMOVE ALL LINE COMMENTS WITHOUT
C         BREAKING LITERALS THAN SPAN CONTINUATION RECORDS.
C
C     *****************************************************************
C
      SUBROUTINE MOVREC (K1,JD)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWK8(2:2),CWK7), (CNAME(1),IENAME(1,1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         DETERMINE WHEN A CONTINUATION RECORD IS TO BE PROCESSED
C
      IF(K1 .EQ. 0) THEN
C
C         SET THE RECORD START LOCATION FOR THE INITIAL RECORD OF A
C         FORTRAN STATEMENT
C
         MA = 1
         MB = NCOLS
         I5 = 0
C
C         INITIALIZE TABLE ICONTL TO ZEROS
C
         DO I1 = 1,100
         ICONTL(1,I1) = 0
         ICONTL(2,I1) = 0
         END DO
C
C         FILL THE STATEMENT WORK AREA WITH BLANKS FOR EACH NEW
C         STATEMENT
C
         DO 10 I1 = 1,132
         I3 = 50 * (I1 - 1) + 1
         I4 = I3 + 49
         CSTMT(I3:I4) = CBLK52(1:50)
 10      CONTINUE
         CSTMT(6601:6606) = CBLK52(1:6)
C
C         MOVE THE INITIAL RECORD OF A FORTRAN STATEMENT TO CSTMT
C
         CSTMT(1:NCOLS) = CREC(1:NCOLS)
C
C         ENTER THE START AND END LOCATIONS OF THE FIRST RECORD INTO
C         TABLE ICONTL
C
         I5 = I5 + 1
         ICONTL(1,I5) = 1
         ICONTL(2,I5) = NCOLS
         GO TO 11
      ELSE
C
C         PROCESS CONTINUATION RECORDS OF THE FORTRAN STATEMENT. WHEN
C         THE NUMBER OF CONTINUATION RECORDS EXCEED THE MAXIMUM ALLOWED,
C         THE INPUT RECORDS ARE DISCARDED UNTIL A NEW STATEMENT IS
C         FOUND.
C
         IF(K1 .LE. ICONT) THEN
C
C         DETERMINE WHERE TRANSMISSION IS TO START IN CSTMT AND SET THE
C         LENGTH OF THE FORTRAN CODE FIELD IN THE RECORD.
C
            IF(CREC(1:1) .EQ. CAMP) THEN
               MC = 1
               IF(NCOLS .EQ. 72) THEN
                  I2 = 70
               ELSE IF(NCOLS .EQ. 132) THEN
                  I2 = 130
               END IF
            ELSE IF(CREC(6:6) .NE. CBLANK(1:1)) THEN
               MC = 6
               IF(NCOLS .EQ. 72) THEN
                  I2 = 65
               ELSE IF(NCOLS .EQ. 132) THEN
                  I2 = 125
               END IF
            END IF
C
C         DETERMINE THE LOCATION IN CSTMT WHERE CREC IS TO BE MOVED
C
            I1 = JD + I2
            MA = NCOLS * K1 - MC * (K1 - 1) + 1
            MB = (K1 + 1) * NCOLS - MC * K1
            CSTMT(MA:MB) = CREC(JD:I1)
C
C         ENTER THE START AND END LOCATIONS OF THE FIRST RECORD INTO
C         TABLE ICONTL
C
         I5 = I5 + 1
         ICONTL(1,I5) = MA
         ICONTL(2,I5) = MB
         END IF
      END IF
C
C         ROUTINE EXIT
C
 11   KB = MB
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE WILL REMOVE ANY LINE COMMENTS FROM A COMPLETE
C         FORTRAN STATEMENT. LITERALS CONTAINING AN EXCLAMATION MARK
C         WILL NOT BE MODIFIED OR DELETED.
C
C     MEANING OF THE VARIABLES
C
C         CAPOS  - CHARACTER VARIABLE, THE APOSTROPHE CHARACTER: '
C         CAPOSD - CHARACTER VARIABLE, THE QUOTATION MARK CHARACTER: "
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CCC    - CHARACTER VARIABLE, THE CHARACTER: C
C         CEXCL  - CHARACTER VARIABLE, THE EXCLAMATION MARK CHARACTER: !
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED. THIS VARIABLE IS 6606 CHARACTERS IN
C                  LENGTH. WHEN NCOLS IS 72, 99 CONTINUATION RECORDS ARE
C                  ALLOWED. WHEN NCOLS IS 132, 51 CONTINUATION RECORDS
C                  ARE ALLOWED.
C         I      - SUBSCRIPT VARIABLE (RECORD NUMBER)
C         ICONTL - THE STARTING AND ENDING LOCATION OF EACH RECORD IN A
C                  FORTRAN STATEMENT; SUBSCRIPT1 IS THE START LOCATION
C                  AND SUBSCRIPT 2 IS THE ENDING LOCATION.
C         IEXCL  - LOCATION OF EACH EXCLAMATION MARK OCCURRING IN THE
C                  FORTRAN STATEMENT
C         ILOCA  - LOCATION OF ALL APOSTROPHES IN THE FORTRAN STATEMENT
C         ILOCQ  - LOCATION OF ALL QUOTATION MARKS IN THE FORTRAN
C                  STATEMENT
C         I1     - LENGTH OF THE LINE COMMENT
C         I2     - LOCATION OF THE NEAREST APOSTROPHE TO THE LEFT OF AN
C                  EXCLAMATION MARK
C         I3     - WORK AREA
C         I4     - COUNT OF THE NUMBER OF APOSTROPHES OR QUOTATION MARKS
C                  OCCURRING WITHIN A RECORD OF THE FORTRAN STATEMENT
C         I5     - WORK AREA AND SUBSCRIPT VARIABLE
C         I6     - DO LOOP PARAMETER AND COUNTER OF APOSTROPHES
C         I7     - WORK AREA AND SUBSCRIPT VARIABLE
C         I8     - COUNT OF ALL APOSTROPHES IN THE STATEMENT
C         I9     - COUNT OF ALL QUOTATION MARKS IN THE STATEMENT
C         I10    - LOCATION OF THE END OF THE CURRENT RECORD OF THE
C                  FORTRAN STATEMENT
C         I11    - COUNTER OF QUOTATION MARKS FOR CASE 5
C         J1     - INDEX VARIABLE OF A DO LOOP
C         J4     - DO LOOP CONTROL PARAMETER, FIRST VALUE
C         J5     - DO LOOP CONTROL PARAMETER, SECOND VALUE
C         J6     - NUMBER OF ENTRIES IN TABLE ICONTL (NUMBER OF RECORDS
C                  IN THE COMPLETE FORTRAN STATEMENT)
C         KB       THE VALUE IS THE LOCATION OF THE FINAL CHARACTER IN
C         NCOLS  - NUMBER OF COLUMNS IN A FORTRAN INPUT RECORD FROM
C                  UNIT 2. ITS VALUE IS EITHER 72 OR 132.
C
C     COMMENTS
C
C         ALL HOLLERITH FIELDS HAVE BEEN REMOVED FROM THE FORTRAN
C         STATEMENT BEFORE THIS ROUTINE IS EXECUTED. HOWEVER, LITERALS
C         HAVE NOT BEEN REMOVED.
C
C     ******************************************************************
C
      SUBROUTINE DELCOM
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
      DIMENSION IEXCL(200), ILOCA(300), ILOCQ(300)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C     LOGICAL*1       L1, L2, L3
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,L NONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWK8(2:2),CWK7), (CNAME(1),IENAME(1,1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         DETERMINE IF THE CURRENT STATEMENT IS A COMMENT STATEMENT.
C         A COMMENT STATEMENT IS NOT PROCESSED.
C
      IF(CSTMT(1:1) .EQ. CCC .OR. CSTMT(1:1) .EQ. CEXCL) GO TO 23
C
C        INITIALIZE COUNTERS FOR APOSTROPHES, QUOTATION MARKS, AND
C        EXCLAMATION MARKS IN THE STATEMENT
C
      I1 = 0
      I2 = 0
      I3 = 0
      I8 = 0
      I9 = 0
      J6 = 0
C
C         COMPUTE THE NUMBER OF ENTRIES IN TABLE ICONTL; THIS IS THE
C         NUMBER OF INPUT RECORDS IN THE ENTIRE FORTRAN STATEMENT.
C
      I = 1
      DO 10 WHILE (ICONTL(1,I) .GT. 0)
      J6 = J6 + 1
      I = I + 1
 10   CONTINUE
C
C         DETERMINE LOCATION OF EXCLAMATION MARKS, APOPSTROPHES, AND
C         QUOTATION MARKS IN THE FORTRAN STATEMENT
C
      DO 11 I = 1,KB
C
C         DETERMINE LOCATION OF ALL EXCLAMATION MARKS
C         STATEMENT
C
      IF(CSTMT(I:I) .EQ. CEXCL) THEN
         I3 = I3 + 1
         IEXCL(I3) = I
         GO TO 11
      END IF
C
C         DETERMINE LOCATION OF ALL APOSTROPHES
C
      IF(CSTMT(I:I) .EQ. CAPOS) THEN
         I8 = I8 + 1                      ! COUNT OF APOSTROPHES
         ILOCA(I8) = I
         GO TO 11
      END IF
C
C         DETERMINE LOCATION OF ALL QUOTATION MARKS
C
      IF(CSTMT(I:I) .EQ. CAPOSD) THEN
         I9 = I9 + 1
         ILOCQ(I9) = I                    ! COUNT OF QUOTATION MARKS
         GO TO 11
      END IF
 11   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *       DELETE ALL LINE COMMENTS FROM THE RECORDS OF THE         *
C     *       FORTRAN STATEMENT                                        *
C     *                                                                *
C     ******************************************************************
C
C         AT THIS STAGE OF PROCESSING, LOCATION OF ALL APOSTROPHES,
C         QUOTATION MARKS, AND EXCLAMATION MARKS ARE KNOWN FOR THE
C         CURRENT FORTRAN STATMENT.
C
C         CASE 1: NO EXCLAMATION MARK EXISTS IN THE FORTRAN STATEMENT;
C                 CONSEQUENTLY, NO LINE COMMENT EXISTS.
C
      IF(I3 .EQ. 0) GO TO 23
C
C         AN EXCLAMATION MARK EXISTS IN THE FORTRAN STATEMENT
C
      IF(I3 .GT. 0) THEN
C
C         DETERMINE IF ANY APOSTROPHES OR QUOTATION MARKS EXIST
C
         IF(I8. EQ. 0 .AND. I9 .EQ. 0) THEN
C
C         CASE 2: NO APOSTROPHES OR QUOTATION MARKS EXIST
C
C         WHEN AN EXCLAMATION MARK EXISTS AND NO APOSTROPHES OR
C         QUOTATION MARKS EXIST FOR EACH RECORD WITHIN THE FORTRAN
C         STATEMENT, THE LEFT MOST EXCLAMATION MARK IS THE START OF A
C         LINE COMMENT. DELETE THE LINE COMMENT FROM THE FORTRAN RECORD
C         WITHIN THE STATEMENT. A MAXIMUM OF 132 CHARACTERS MAY OCCUR
C         IN A RECORD WITHIN A FORTRAN STATEMENT. ANY EXCLAMATION MARKS
C         OCCURRING WITHIN THE LINE COMMENT FOR THE CURRENT RECORD ARE
C         ALSO DELETED.
C
C         WHEN AN EXCLAMATION MARK EXISTS WITHIN A LINE COMMENT, IT WILL
C         BE IGNORED.
C
            I = 1                         ! RECORD NUMBER
  12        IF(I .GT. J6) GO TO 23        ! ROUTINE EXIT
            J4 = ICONTL(1,I)              ! RECORD START LOCATION
            J5 = ICONTL(2,I)              ! RECORD END LOCATION
C
C         DETERMINE THE LOCATION OF THE LEFT MOST EXCLAMATION MARK IN
C         THE CURRENT RECORD.
C
            I4 = 0
            DO 13 J1 = J4,J5
            IF(CSTMT(J1:J1) .EQ. CEXCL) THEN
               I4 = I4 + 1
               IF(I4 .EQ. 1) I5 = J1      ! LEFT MOST EXCLAMATION MARK
               GO TO 130
            END IF
 13         CONTINUE
C
C         WHEN NO EXCLAMATION MARK EXISTS WITHIN THE CURRENT RECORD,
C         PROCESS THE NEXT RECORD.
C
            IF(I4 .EQ. 0) THEN
               I = I + 1
               GO TO 12
            END IF
C
C         DELETE THE LINE COMMENT TEXT. THE LEFT MOST EXCLAMATION MARK
C         IS THE START OF THE FIELD TO BE DELETED, AND THE FINAL
C         CHARACTER OF THE RECORD IS THE END OF THE FIELD. WHEN ONE OR
C         MORE EXCLAMATION MARKS EXIST IN THE LINE COMMENT, THEY ARE
C         DELETED SINCE THEY ARE WITHIN THE FIELD.
C
 130        I1 = J5 - I5 + 1              ! LENGTH OF THE FIELD
            IF(I1 .LE. 52) THEN
               CSTMT(I5:J5) = CBLK52(1:I1)
            ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
               CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
            ELSE IF(NCOLS .GT. 104) THEN
               CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                        CBLK52(1:J5-104)
            END IF
            I = I + 1                     ! NEXT RECORD
            GO TO 12
C
C         CASE 3: APPOSTROPHES EXIST, BUT NO QUOTATION MARKS EXIST
C
         ELSE IF(I8 .GT. 0 .AND. I9 .EQ. 0) THEN
            I = 1                         ! RECORD NUMBER
  14        IF(I .GT. J6) GO TO 23        ! ROUTINE EXIT
            J4 = ICONTL(1,I)              ! RECORD START LOCATION
            J5 = ICONTL(2,I)              ! RECORD END LOCATION
C
C         DETERMINE THE LOCATION OF THE LEFT MOST EXCLAMATION MARK IN
C         THE CURRENT RECORD.
C
            I4 = 0
            DO 15 J1 = J4,J5
            IF(CSTMT(J1:J1) .EQ. CEXCL) THEN
               I4 = I4 + 1
               IF(I4 .EQ. 1) I5 = J1
               GO TO 150
            END IF
 15         CONTINUE
C
C         WHEN NO EXCLAMATION MARK EXISTS WITHIN THE CURRENT RECORD,
C         PROCESS THE NEXT RECORD.
C
            IF(I4 .EQ. 0) THEN
               I = I + 1
               GO TO 14
            END IF
C
C         FOR THE CURRENT RECORD, DETERMINE IF APOSTROPHES PRECEDE THE
C         LEFT MOST EXCLAMATION MARK FROM THE FIRST RECORD OF THE
C         FORTRAN STATEMENT. A LITERAL MAY SPAN MILTIPLE RECORDS, AND
C         THE LITERAL MAY ENCAPSULATE THE EXCLAMATION MARK.
C
 150        I6 = 0
            DO 16 J1 = 1,I5
            IF(CSTMT(J1:J1) .EQ. CAPOS) I6 = I6 + 1
 16         CONTINUE
C
C         DETERMINE IF AN EVEN NUMBER OF APPOSTROPHES EXIST TO THE LEFT
C         OF THE LEFT MOST EXCLAMATION MARK. WHEN AN EVEN NUMBER OF
C         APOSTROPHES EXIST PRIOR TO THE EXCLAMATION MARK, THE
C         EXCLAMATION MARK IS THE START OF A LINE COMMENT.
C
            I1 = J5 - I5 + 1              ! LENGTH OF THE FIELD
            I7 = I6 - 2 * (I6/2)          ! 0 - EVEN; 1 - ODD
            IF(I7 .EQ. 0) THEN
C
C         THE LEFT MOST EXCLAMATION MARK IS THE START OF A LINE COMMENT
C         WHEN AN EVEN NUMBER OF APOSTROPHES PRECEDE IT FROM THE START
C         OF THE FIRST RECORD OF THE FORTRAN STATEMENT.
C
               IF(I1 .LE. 52) THEN
                  CSTMT(I5:J5) = CBLK52(1:I1)
               ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
               ELSE IF(NCOLS .GT. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                           CBLK52(1:J5-104)
               END IF
            END IF
C
C         WHEN AN ODD NUMBER OF APOPSTROPHES PRECEDE THE LEFT MOST
C         APOSTROPHE, THE EXCLAMATION MARK IS PART OF A LITERAL. THE
C         FIELD WILL NOT BE DELETED FROM THE CURRENT RECORD.
C
            I = I + 1                     ! NEXT RECORD
            GO TO 14
C
C         CASE 4: QUOTATION MARKS EXIST, BUT NO APOSTROPHES EXIST
C
         ELSE IF(I8 .EQ. 0 .AND. I9 .GT. 0) THEN
            I = 1                         ! RECORD NUMBER
  17        IF(I .GT. J6) GO TO 23        ! ROUTINE EXIT
            J4 = ICONTL(1,I)              ! RECORD START LOCATION
            J5 = ICONTL(2,I)              ! RECORD END LOCATION
C
C         DETERMINE THE LOCATION OF THE LEFT MOST EXCLAMATION MARK IN
C         THE CURRENT RECORD.
C
            I4 = 0
            DO 18 J1 = J4,J5
            IF(CSTMT(J1:J1) .EQ. CEXCL) THEN
               I4 = I4 + 1
               IF(I4 .EQ. 1) I5 = J1
               GO TO 190
            END IF
 18         CONTINUE
C
C         WHEN NO EXCLAMATION MARKS EXIST IN THIS RECORD, PROCESS A NEW
C         RECORD
C
            IF(I4 .EQ. 0) THEN
               I = I + 1
               GO TO 17
            END IF
C
C         FOR THE CURRENT RECORD, DETERMINE IF QUOTATION MARKS PRECEDE
C         THEN LEFT MOST EXCLAMATION MARK FROM THE FIRST RECORD OF THE
C         FORTRAN STATEMENT. A LITERAL MAY SPAN MILTIPLE RECORDS, AND
C         THE LITERAL MAY ENCAPSULATE THE QUOTATION MARK.
C
 190        I6 = 0
            DO 19 J1 = 1,I5
            IF(CSTMT(J1:J1) .EQ. CAPOSD) I6 = I6 + 1
 19         CONTINUE
C
C         DETERMINE IF AN EVEN NUMBER OF QUOTQTION MARKS EXIST TO THE
C         LEFT OF THE LEFT MOST EXCLAMATION MARK. WHEN AN EVEN NUMBER OF
C         QUOTATION MARKS EXIST PRIOR TO THE EXCLAMATION MARK, THE
C         EXCLAMATION MARK IS THE START OF A LINE COMMENT.
C
            I1 = J5 - I5 + 1              ! LENGTH OF THE FIELD
            I7 = I6 - 2 * (I6/2)          ! 0 - EVEN; 1 - ODD
            IF(I7 .EQ. 0) THEN
C
C         THE LEFT MOST EXCLAMATION MARK IS THE START OF A LINE COMMENT
C         WHEN AN EVEN NUMBER OF QUOTATION MARKS PRECEDE IT FROM THE
C         START OF THE FIRST RECORD OF THE FORTRAN STATEMENT.
C
               IF(I1 .LE. 52) THEN
                  CSTMT(I5:J5) = CBLK52(1:I1)
               ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
               ELSE IF(NCOLS .GT. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                           CBLK52(1:J5-104)
               END IF
            END IF
C
C         WHEN AN ODD NUMBER OF APOPSTROPHES PRECEDE THE LEFT MOST
C         APOSTROPHE, THE EXCLAMATION MARK IS PART OF A LITERAL. THE
C         FIELD WILL NOT BE DELETED FROM THE CURRENT RECORD.
C
            I = I + 1                     ! NEXT RECORD
            GO TO 17
C
C         CASE 5: BOTH APPOSTROPHES AND QUOTATION MARKS EXIST
C
         ELSE IF(I8 .GT. 0 .AND. I9 .GT. 0) THEN
            I = 1                         ! RECORD NUMBER
  20        IF(I .GT. J6) GO TO 23        ! ROUTINE EXIT
            J4 = ICONTL(1,I)              ! RECORD START LOCATION
            J5 = ICONTL(2,I)              ! RECORD END LOCATION
C
C         DETERMINE THE LOCATION OF THE LEFT MOST EXCLAMATION MARK IN
C         THE CURRENT RECORD.
C
            I4 = 0
            DO 21 J1 = J4,J5
            IF(CSTMT(J1:J1) .EQ. CEXCL) THEN
               I4 = I4 + 1
               IF(I4 .EQ. 1) I5 = J1      ! LOCATION OF EXCLAMATION MARK
               GO TO 210
            END IF
 21         CONTINUE
C
C         WHEN NO EXCLAMATION MARK EXISTS WITHIN THE CURRENT RECORD,
C         PROCESS THE NEXT RECORD.
C
            IF(I4 .EQ. 0) THEN
               I = I + 1                  ! NEXT RECORD
               GO TO 20
            END IF
C
C         DETERMINE THE NUMBER OF APOSTROPHES AND QUOTATION MARKS
C         OCCURRING THE LEFT OF THE CURRENT RECORD'S LEFT MOST
C         EXCLAMATION MARK IN THE FORTRAN STATEMENT.
C
 210        I6 = 0                        ! NUMBER OF APOSTROPHES
            I10 = 0
            I11 = 0                       ! NUMBER OF QUOTATION MARKS
            DO 22 J1 = I5,1,-1
            IF(CSTMT(J1:J1) .EQ. CAPOS) THEN
               I6 = I6 + 1
               IF(I6 .EQ. 1) I2 = J1      ! FIRST PRIOR APOSTROPHE
            END IF
            IF(CSTMT(J1:J1) .EQ. CAPOSD) THEN
               I11 = I11 + 1
               IF(I11 .EQ. 1) I10 = J1    ! FIRST PRIOR QUOTATION MARK
            END IF
 22         CONTINUE
C
C         DETERMINE IF ANY APOSTROPHES OR QUOTATION MARKS OCCUR PRIOR
C         TO THE CURRENT RECORD'S LEFT MOST EXCLAMATION MARK IN THE
C         FORTRAN STATEMENT. THE EXCLAMATION MARK IS THE START OF A
C         LINE COMMENT,
C
            IF(I5 .EQ. 0 .AND. I10 .EQ. 0) THEN
C
C         DELETE THE LINE COMMENT IN THE CURRENT RECORD
C
               I1 = J5 - I5 + 1              ! LENGTH OF THE FIELD
C
C         DELETE THE LINE COMMENT WHEN AN EVEN NUMBER OF PRIOR
C         APOPSTROPHES EXIST
C
               IF(I1 .LE. 52) THEN
                  CSTMT(I5:J5) = CBLK52(1:I1)
               ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
               ELSE IF(NCOLS .GT. 104) THEN
                  CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                           CBLK52(1:J5-104)
               END IF
               I = I + 1
               GO TO 20                   ! NEXT RECORD
            END IF
C
C         DETERMINE WHETHER THE FIRST APOSTROPHE OR FIRST QUOTATION MARK
C         PRIOR TO THE EXCLAMATION MARK IS NEARER TO THE EXCLAMATION
C         MARK
C
            IF(I5 .GT. I10) THEN
C
C         WHEN THE NUMBER OF APOSTROPHES PRIOR TO THE LEFT MOST
C         EXCLAMATION MARK IS EVEN, THE EXCLAMATION MARK IS THE START
C         OF A LINE COMMENT.
C
               I1 = J5 - I5 + 1              ! LENGTH OF THE FIELD
               I7 = I6 - 2 * (I6/2)          ! 0 - EVEN; 1 - ODD
               IF(I7 .EQ. 0) THEN
C
C         DELETE THE LINE COMMENT WHEN AN EVEN NUMBER OF PRIOR
C         APOPSTROPHES EXIST
C
                  IF(I1 .LE. 52) THEN
                     CSTMT(I5:J5) = CBLK52(1:I1)
                  ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
                     CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
                  ELSE IF(NCOLS .GT. 104) THEN
                     CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                              CBLK52(1:J5-104)
                  END IF
               END IF
               I = I + 1                  ! NEXT RECORD
               GO TO 20
C
C         DETERMINE WHETHER THE FIRST APOSTROPHE OR FIRST QUOTATION MARK
C         PRIOR TO THE EXCLAMATION MARK IS NEARER TO THE EXCLAMATION
C         MARK
C
            ELSE IF(I10 .GT. I5) THEN
C
C         WHEN THE NUMBER OF QUOTATION MARKS PRIOR TO THE LEFT MOST
C         EXCLAMATION MARK IS EVEN, THE EXCLAMATION MARK IS THE START
C         OF A LINE COMMENT.
C
               I1 = J5 - I10 + 1              ! LENGTH OF THE FIELD
               I7 = I11 - 2 * (I11/2)         ! 0 - EVEN; 1 - ODD
               IF(I7 .EQ. 0) THEN
C
C         DELETE THE LINE COMMENT WHEN AN EVEN NUMBER OF PRIOR
C         QUOTATION MARKS EXIST
C
                  IF(I1 .LE. 52) THEN
                     CSTMT(I5:J5) = CBLK52(1:I1)
                  ELSE IF(I1 .GT. 52 .AND. I1 .LE. 104) THEN
                     CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:J5-52)
                  ELSE IF(NCOLS .GT. 104) THEN
                     CSTMT(I5:J5) = CBLK52(1:52)//CBLK52(1:52)//
     1                              CBLK52(1:J5-104)
                  END IF
               END IF
               I = I + 1                  ! NEXT RECORD
               GO TO 20
            END IF
         END IF
      END IF
C
C         ROUTINE EXIT
C
 23   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE WILL CHECK FOR THE OCCURRENCE OF TAB CHARACTERS
C         IN AN INPUT FORTRAN SOURCE RECORD READ FROM UNIT AND REMOVE
C         THEM FROM THE RECORD.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CREX   - CHARACTER VARIABLE, A RECORD IMAGE TO BE SCANNED
C                  FOR HORIZONTAL TAB CHARACTERS
C         CTAB   - CHARACTER VARIABLE, THE HEX CONSTANT 09, A TAB
C                  CHARACTER. THIS VALUE MUST BE CHANGED TO HEX 05 FOR
C                  AN EBCDIC COMPUTER.
C         I      - SUBSCRIPT VARIABLE
C                  IS THE LENGTH OF THE RECORD.
C         IJ     - SUBSCRIPT VARIABLE
C         IK     - SUBSCRIPT VARIABLE
C         IL     - NUMBER OF DIGITS FOR EACH CHARACTERS TO BE SHIFTED TO
C                  THE RIGHT
C         IN     - WORK AREA
C         ITAB   - LOCATION OF THE INITIAL TAB CHARACTER WHEN ONE EXISTS
C         JD     - LOCATION OF THE FINAL CHARACTER IN A STATEMENT
C                  AFTER ANY TAB CHARACTERS HAVE BEEN REMOVED
C         KD     - LOCATION OF THE LAST CHARACTER IN THE RECORD IN CREC
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C     COMMENTS
C
C         WHEN A HORIZONTAL TAB CHARACTER OCCURS BEFORE COLUMN 7 OF THE
C         INPUT RECORD, IT WILL BE REPLACED WITH A BLANK CHARACTER, AND
C         ALL TEXT FOLLOWING THE TAB CHARACTER WILL BE SHIFTED TO THE
C         RIGHT SO THAT THE FIELD BEGINS IN COLUMN 7.
C
C         ANY HORIZONTAL TAB CHARACTER OCCURRING AFTER COLUMN 6 WILL BE
C         REPLACED WITH A BLANK CHARACTER, AND NO SHIFT OF CHARACTERS
C         WILL OCCUR.
C
C     ******************************************************************
C
      SUBROUTINE REMTAB (CREX)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST, CREX
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK2
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
C     CHARACTER*7 CWRK7
      CHARACTER*1 CTAB
C     LOGICAL*1   LE
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I4WK2,CI4WK2), (I2WK1,CI2WK1), (CWORK(33:36),IWORK),
     1            (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CTAB/'09'X/
C
C         FIND AN INITIAL TAB CHARACTER IN THE RECORD, IF ANY EXIST
C
      DO 13 I = 1,NCOLS
      IF(CREX(I:I) .EQ. CTAB) THEN
         CREX(I:I) = CBLANK(1:1)
C
C         DETERMINE IF THE INITIAL TAB CHARACTER IN THE RECORD OCCURS
C         BEFORE COLUMN 6
C
         IF(I .LT. 6) THEN
            IL = 6 - I                 ! SHIFT VALUE
            DO 12 IJ = NCOLS,I+1,-1
C
C          SET INDEX VALUE TO MOVE ALL CHARACTERS TO THE RIGHT BY THE
C          VALUE IN IL
C
            IN = IJ + IL
            IF(IJ .EQ. NCOLS) JD = IN
C
C         REPLACE A TAB CHARACTER WITH A BLANK BEFORE SHIFTING THE
C         CHARACTER RIGHT; OTHERWISE SHIFT RIGHT ONLY.
C
            IF(CREX(IJ:IJ) .EQ. CTAB) CREX(IJ:IJ) = CBLANK(1:1)
            CREX(IN:IN) = CREX(IJ:IJ)
            CREX(IJ:IJ) = CBLANK(1:1)
 12         CONTINUE
            KD = JD
            GO TO 14
         ELSE
C
C         THE INITIAL TAB CHARACTER OCCURS AFTER COLUMN 6. NO SHIFT
C         IS REQUIRED. REPLACE THE TAB CHARACTER WITH A BLANK.
C
            CREX(I:I) = CBLANK(1:1)
         END IF
      END IF
 13   CONTINUE
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM WRITES A RECORD ON FORTRAN OUTPUT UNIT 6, THE
C         PRINTER LISTING OF THE PROGRAM BEING ANALYZED
C
C     MEANING OF THE VARIABLES
C
C         CFILEB - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAMES
C                  THAT ARE TO BE PROCESSED. MAXIMUM OF 10 ALLOWED.
C         CFILEN - CHARACTER VARIABLE, THE FILE NAME OF THE INPUT SOURCE
C                  CODE
C         CFMT1  - CHARACTER VARIABLE, CONTAINS THE HEADER FORMAT DATA
C                  FOR THE OUTPUT LISTING
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED WITH I2WK1
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CWK132 - CHARACTER VARIABLE, WORK AREA USED TO DETERMINE IF
C                  THE RECORD TO BE WRITTEN ON UNIT 6 IS AN END
C                  STATEMENT TERMINATING A SUBPROGRAM
C         I      - SUBSCRIPT VARIABLE
C         ID     - THE NUMBER OF CHARACTERS IN THE STATEMENT RECORD
C         IDAY   - THE DAY OF THE MONTH
C         IDTN   - THE VALUE TO CHANGE FROM AN ALGEBRAIC NUMERIC VALUE
C                  TO CONVERT IT TO A NUMERIC DIGIT FOR ASCII
C                  CODE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IHOUR  - THE HOUR OF THE DAY
C         IHSECS - HUNDREDTHS OF A SECOND
C         IMINT  - THE MINUTE OF THE HOUR
C         IMON   - THE MONTH OF THE YEAR
C         IPAGE  - COUNT OF THE PAGES PRINTED IN THE LISTING FILE
C         IPGNME - PROGRAM NAME CHARACTER LENGTH
C         ISEC   - THE SECONDS OF THE MINUTE
C         ISN    - THE INTERNAL STATEMENT NUMBER WHEN PROCESSED. THIS
C                  VALUE IS PRINTED IN THE OUTPUT LISTING.
C         IYEAR  - THE CURRENT YEAR
C         I1     - LOCATION OF THE FIRST CHARACTER IN CREC
C         I2     - WORK VARIABLE
C         I3     - LOCATION OF THE FINAL CHARACTER IN CREF
C         I4     - NUMBER OF BLANK CHARACTERS IN CREF
C         I2WK1  - LENGTH 2 INTEGER VARIABLE, USED AS A WORK AREA
C         J      - THE NUMBER OF CHARACTERS IN THE FILE NAME BEING
C                  PROCESSED
C         JFILES - INDEX COUNT OF THE SOURCE INPUT FILE CURRENTLY BEING
C                  PROCESSED. THIS CONTROLS THE FILE BEING PROCESSED
C                  WHEN MORE THAN ONE FORTRAN SOURCE CODE INPUT FILE
C                  IS SPECIFIED IN THE CONTROL CARD FILE.
C         JSNA   - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS, EXCEPT COMMENTS AND ALL
C                  SOURCE CODE IN INCLUDE FILES, WHEN THE STATEMENT IS
C                  READ. IT IS THE PRINTED VALUE IN THE OUTPUT TABLES.
C         KISN   - THE VALUE OF THE ISN TO BE PRINTED
C         LA     - LOGICAL VARIABLE, SET TRUE TO PRINT THE ISN, SET
C                  FALSE TO PREVENT PRINTING OF ISN
C         LB     - LOGICAL VARIABLE, SET TRUE TO RESET THE PAGE NUMBER,
C                  LINE COUNT
C         LC     - LOGICAL VARIABLE, SET TRUE TO WRITE A NEW PAGE
C                  HEADER ONLY, SET FALSE OTHERWISE
C         LD     - LOGICAL VARIABLE, SET TRUE AFTER THE INITIAL
C                  ENTRANCE TO THIS PROGRAM. THIS CAUSES THE LENGTH
C                  OF THE INPUT FORTRAN FILE NAME TO BE SET IN CFMT1
C         LEND   - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL RECORD
C                  OF THE FORTRAN PROGRAM TO BE ANALYZED HAS BEEN READ.
C                  AN END OF DATA HAS BEEN REACHED. SET FALSE OTHERWISE.
C         LF     - LOGICAL VARIABLE, SET TRUE TO FORCE PRINTING THE END
C                  STATEMENT AT THE END OF A ROUTINE, SET FALSE
C                  OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE LAST NON-BLANK
C                  CHARACTER IS FOUND IN CREC, SET FALSE OTHERWISE
C         NLINE  - MAXIMUM NUMBER OF LINES PER PRINTED PAGE
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C         NMELEN - THE NUMBER OF CHARACTERS IN THE FILE NAME OF THE
C                  PROGRAM BEING PROCESSED
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         6      - THE LISTING FILE TO BE PRINTED
C
C     *****************************************************************
C
      SUBROUTINE WRSTMT (LA,CFILEN,LB,LC,LF)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CFILEB(10), CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100),
     2CSREC(20), CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500),
     3CSUBTB(1000), CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST, CWK132
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEB, CFILEN, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       IDAY, IMON
      INTEGER*2       IHOUR, IHSECS, IMINT, ISEC
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*50 CFMT1
      LOGICAL*1 LA, LB, LC, LD, LF, L2
C
C         EXTERNAL STATEMENTS
C
      EXTERNAL GETDAT
      EXTERNAL GETTIM
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /INFILE/ JFILES, CFILEB
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CNAME(1),IENAME(1,1)), (CWK8(2:2),
     1            CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA IHOUR/0/, IMINT/0/, ISEC/0/, IHSECS/0/, IYEAR/0/, IMON/0/,
     1     IDAY/0/
      DATA CFMT1/'(''1LISTING OF THE FORTRAN PROGRAM IN FILE: '',XXA1)'
     1/
      DATA LD/.FALSE./
C     DATA LZ/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(/2X,'ISN',2X,'FORTRAN STATEMENTS',T34,'DATE: ',I2,'/',I2.2,
     1'/',I4,T52,'TIME: ',I2,':',I2.2,':',I2.2,T78,'PAGE ',I4//7X,
     2'1',7X,'10',8X,'20',8X,'30',8X,'40',8X,'50',8X,'60',8X,'70',8X,
     3'80'/7X,'****+****|****+****|****+****|****+****|****+****|****+**
     4**|****+****|****+****|')
 101  FORMAT(/2X,'ISN',2X,'FORTRAN STATEMENTS',52X,'PAGE ',I4//7X,
     1'1',7X,'10',8X,'20',8X,'30',8X,'40',8X,'50',8X,'60',8X,'70',8X,
     2'80'/7X,'****+****|****+****|****+****|****+****|****+****|****+**
     3**|****+****|****+****|')
 102  FORMAT(1X,I5,1X,80A1)
 103  FORMAT(7X,80A1)
C
C         INITIALIZATION
C
      I1 = 0
      I2 = 0
      I4 = 0
      L2 = LFALSE
C
C         FILL THE WORK AREA WITH BLANKS AND THEN MOVE THE LAST PREVIOUS
C         RECORD INTO THE WORK AREA
C
      CWK132(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      CWK132(1:NCOLS) = CREC(1:NCOLS)
C
C         DETERMINE IF AN EXCLAMATION MARK OCCURS WITHIN THE STATEMENT
C
      DO 11 I = 7,NCOLS
      IF(CREC(I:I) .EQ. CEXCL) THEN
         DO 10 I1 = I,NCOLS
         CWK132(I1:I1) = CBLANK(1:1)
 10      CONTINUE
         GO TO 12
      END IF
 11   CONTINUE
C
C         DETERMINE IF THE RECORD IS AN END STATEMENT
C
 12   DO 15 I = 7,NCOLS
      IF(CWK132(I:I) .NE. CBLANK(1:1)) THEN
         I1 = I
         DO 13 I2 = I1,NCOLS
         IF(.NOT.L2 .AND. CWK132(I2:I2) .EQ. CBLANK(1:1)) THEN
            I3 = I2
            L2 = LTRUE
            GO TO 14
         END IF
 13      CONTINUE
C
C         IF THE STATEMENT IS A COMMENT STATEMENT, WRITE IT; OTHERWISE,
C         CONTINUE PROCESSING
C
         IF(CWK132(1:1) .EQ. CCC .OR. CWK132(1:1) .EQ. CCS) GO TO 16
 14      IF(I3 - I1 .EQ. 3) THEN
            IF(LA .AND. LF) GO TO 16
            IF(LZEND) THEN
               IF(CWK132(I1:I3).EQ. 'END' .OR. CWK132(I1:I3) .EQ. 'end')
     1            THEN
                  IF(ISN .EQ. 1) THEN
                     GO TO 22
                  ELSE
                     LENDS = LTRUE
                     GO TO 16
                  END IF
               END IF
            END IF
         ELSE
            GO TO 16
         END IF
      END IF
C
C         COUNT THE NUMBER OF BLANKS
C
      I4 = I4 + 1
 15   CONTINUE
C
C       WHEN THE DO LOOP TERMINATES, THE ENTIRE RECORD SHOULD BE BLANK.
C       VERIFY THE RECORD IS ALL BLANKS, AND DO NOT WRITE THE RECORD
C       WHEN THE ISN EQUALS 1.
C
      IF(I4 .EQ. NCOLS .AND. ISN .EQ. 1) THEN
         ISN = ISN - 1
         LA = LFALSE
      END IF
C
C         DETERMINE IF AN INCLUDE FILE FORTRAN STATEMENTS ARE BEING
C         PROCESSED. NO OUTPUT IS WRITTEN FOR INCLUDE FILES.
C
 16   IF(LINCL) RETURN
C
C         TEST IF THE END OF DATA OCCURRED
C
      IF(LEND .AND. .NOT.LF) RETURN
C
C         DETERMINE THE LENGTH OF THE RECORD TO BE WRITTEN
C
      DO 17 I = NCOLS,1,-1
      IF(CREC(I:I) .NE. CBLANK(1:1)) THEN
         ID = I
         GO TO 18
      END IF
 17   CONTINUE
C
C         TEST IF A NEW PAGE HEADER IS REQUIRED
C
 18   IF(LB) THEN
         IF(NLINE .GE. NLINES .OR. IPAGE .EQ. 1 .AND. NLINE .NE. 0)
     1      IPAGE = IPAGE + 1
         NLINE = 1
      END IF
C
C         INITIALIZE THE INITIAL FILE NAME LENGTH IN CFMT1
C
      IF(.NOT.LD) THEN
         DO 19 I = 1,80
         IF(CFILEN(I:I) .EQ. CBLANK(1:1)) GO TO 20
 19      CONTINUE
 20      NMELEN = I - 1
C
C     GET THE DATE AND TIME
C
         CALL GETTIM (IHOUR,IMINT,ISEC,IHSECS)
         CALL GETDAT (IYEAR,IMON,IDAY)
         I2WK1 = NMELEN/10
         IF(I2WK1 .EQ. 0) THEN
            CFMT1(46:46) = CBLANK(1:1)
         ELSE
            I2WK1 = I2WK1 + IDTN
            CFMT1(46:46) = CI2WK1(IDXE:IDXE)
         END IF
         I2WK1 = NMELEN - 10 * (NMELEN/10) + IDTN
         CFMT1(47:47) = CI2WK1(IDXE:IDXE)
         WRITE (6,CFMT1) (CFILEN(I:I),I = 1,NMELEN)
         IPAGE = IPAGE + 1
         WRITE (6,100) IMON,IDAY,IYEAR,IHOUR,IMINT,ISEC,IPAGE
         IF(NLINE .GE. NLINES) IPAGE = IPAGE + 1
         NLINE = 7
         LD = LTRUE
      END IF
C
C         TEST IF A NEW PAGE HEADER ONLY IS REQUIRED
C
      IF(LC .OR. LB) THEN
         WRITE (6,CFMT1) (CFILEN(I:I),I = 1,NMELEN)
         IPAGE = IPAGE + 1
         WRITE (6,101) IPAGE
         IF(NLINE .GE. NLINES) IPAGE = IPAGE + 1
         NLINE = 7
         IF(ISN .EQ. 0) LD = LTRUE
         GO TO 21
      END IF
C
C         TEST IF A NEW PAGE IS REQUIRED
C
      IF(NLINE .GT. NLINES .OR. NLINE .EQ. 0) THEN
C
C         WRITE THE NEW PAGE HEADER
C
         WRITE (6,CFMT1) (CFILEN(I:I),I = 1,NMELEN)
         IPAGE = IPAGE + 1
         WRITE (6,101) IPAGE
         NLINE = 7
      ELSE IF(NLINE .EQ. NLINES) THEN
C
C         WHEN THE LAST RECORD OF A PAGE IS TO BE PRINTED, PRINT THE
C         RECORD BEFORE PRINTING THE NEW PAGE HEADER WHEN THE RECORD
C         TO BE PRINTED IS A COMMENT RECORD.
C
         CONTINUE
      END IF
C
C         WRITE A RECORD WITH OR WITHOUT AN ISN BEING PRINTED
C
 21   IF(LA) THEN
C
C         PRINT A STATEMENT RECORD WITH AN ISN
C
         WRITE (6,102) ISN,(CREC(I:I),I = 1,ID)
      ELSE
C
C         PRINT A STATEMENT WITHOUT AN ISN. THIS MAY BE A CONTINUATION,
C         COMMENT STATEMENT, OR A BLANK RECORD.
C
         WRITE (6,103) (CREC(I:I),I = 1,ID)
      END IF
C
C         WHEN AN END OF FILE OCCURS, DETERMINE IF IT IS FROM AN INCLUDE
C         FILE
C
      IF(LINCL) THEN
         CREC(1:1) = CBLANK(1:1)
      ELSE
         NLINE = NLINE + 1
      END IF
 22   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE WILL TEST IF A VARIABLE NAME HAS ALREADY BEEN
C         ENTERED IN THE MASTER TABLE OF NAMES AND INSERT IT INTO THE
C         TABLE IF IT IS NOT IN THE TABLE.
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES
C                  COLS  TYPE LEN
C
C                  COLS  1 - 32 VARIABLE NAME
C                  COLS 33 - 36 LENGTH OF THE VARIABLE NAME IN COLS 1-32
C                  COLS 37 - 40 NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  COLS 41 - 44 FIRST SUBSCRIPT SIZE
C                  COLS 45 - 48 SECOND SUBSCRIPT SIZE
C                  COLS 49 - 52 THIRD SUBSCRIPT SIZE
C                  COLS 53 - 56 FOURTH SUBSCRIPT SIZE
C                  COLS 57 - 60 FIFTH SUBSCRIPT SIZE
C                  COLS 61 - 64 SIXTH SUBSCRIPT SIZE
C                  COLS 65 - 68 SEVENTH SUBSCRIPT SIZE
C                  COLS 69 - 72 FIRST SUBSCRIPT LOWER STARTING VALUE
C                  COLS 73 - 76 SECOND SUBSCRIPT LOWER STARTING VALUE
C                  COLS 77 - 80 THIRD SUBSCRIPT LOWER STARTING VALUE
C                  COLS 81 - 84 FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  COLS 85 - 88 FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  COLS 89 - 92 SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  COLS 93 - 96 SEVENTH SUBSCRIPT LOWER STARTING VALUE
C                  COLS 97 - 100 NUMBER OF WORDS OF MEMORY FOR THE
C                                VARIABLE NAME IN COLS 1-32
C                  COLS 101- 104 ISN WHERE DEFINED
C         CEXTNL - CHARACTER VARIABLE, TABLE OF ALL EXTERNAL STATEMENT
C                  NAMES IN A ROUTINE BEING ANALYZED. THIS IS A GLOBAL
C                  TABLE CONTAINING ALL SUBPROGRAM NAMES DEFINED IN
C                  ANY ROUTINE IN THE CURRENT PROGRAM BEING PROCESSED.
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CI2WK2 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK2
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS  TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. THIS TABLE DOES NOT CONTAIN THE LIST OF
C                  VARIABLE NAMES BELONGING TO THE COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CQUES  - CHARACTER VARIABLE, THE CHARACTER: ?
C         CSHARP - CHARACTER VARIABLE, THE CHARACTER: #
C         CSTMTA - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSTR   - TABLE OF ALL STRUCTURES DEFINED IN THE MODULE BEING
C                  CURRENTLY PROCESSED. A MAXIMUM OF 1000 UNIQUE
C                  STRUCTURES MAY OCCUR.
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CSTRNM - CHARACTER VARIABLE, ARRAY OF ALL NESTED STRUCTURE
C                  NAMES WITHIN A SINGLE NESTED GROUP OF STRUCTURES
C                  FOR THE CURRENT PROGRAM MODULE BEING PROCESSED
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32    8 STRUCTURE NAME (CHARACTER VARIABLE)
C                 33 - 36 I*4     9 INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CSUBTB - CHARACTER VARIABLE, THE TABLE OF ALL ENTRY, FUNCTION,
C                  AND SUBROUTINE NAMES.
C                  RECORD STRUCTURE
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZERO)
C                  37-44  11   CODE AND LENGTH CHARACTERISTIC
C                  45-48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS OM COLS 1-32
C         CTYPED - CHARACTER VARIABLE, THE DATA TYPE CODE IF A VARIABLE
C                  FROM A DATA TYPE STATEMENT IS BEING PROCESSED, BLANK
C                  OTHERWISE
C         CVARST - CHARACTER VARIABLE, CONTAINS THE NAME OF EACH
C                  VARIABLE DEFINED WITHIN A STRUCTURE.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED IN THE CURRENT
C                                  STRUCTURE
C                  33-64 A*32   16 NAME OF THE STRUCTURE DEFINING THE
C                                  VARIABLE IN COLS 1-32
C                     65 A*1       DATA TYPE CODE OF THE VARIABLE IN
C                                  COLS 1-32
C                  66-72 A*7    18 LENGTH DEFINITION OF THE VARIABLE IN
C                                  COLS 1-32
C         CWK7   - CHARACTER VARIABLE, A SEVEN CHARACTER WORK AREA FOR
C                  CREATING THE INTEGER FORM OF THE LENGTH OF VARIABLES
C                  ENCAPSULATED WITHIN UNION AND STRUCTURE DEFINITIONS
C         CWK72  - CHARACTER VARIABLE, WORK AREA USED TO ASSEMBLE THE
C                  DATA TO BE PLACED IN TABLE CVARST
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C                  FOR CNAME TABLE
C         FUNTBL - A TABLE OF STANDARD FORTRAN INTRINSIC FUNCTIONS
C                  COLS  1-32 THE FUNCTION NAME
C                  COLS 33-35 THE TYPE AND LENGTH OF FUNCTION'S RETURN
C                             VALUE AS NUMERIC CHARACTERS.
C
C                  TYPE CODES USED ARE:
C
C                  B - SINGLE PRECISION COMPLEX
C                  C - CHARACTER
C                  D - DOUBLE PRECISION REAL
C                  E - DOUBLE PRECISION COMPLEX
C                  I - INTEGER (ALL LENGTHS)
C                  L - LOGICAL (ALL LENGTHS)
C                  R - SINGLE PRECISION REAL
C         I      - SUBSCRIPT VARIABLE
C         IBITWK - THE 32 BIT SWITCHES WORK AREA
C         ID     - NUMBER OF CHARACTERS IN A LENGTH SPECIFICATION FOR
C                  A DATA TYPE VARIABLE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IEDIM  - EQUIVALENCED TO CDIM
C         IENAME - EQUIVALENCED TO CNAME. USED TO ACCESS THE BIT
C                  SWITCHES IN COLS 45 - 48 OF EACH VARIABLE NAME IN
C                  TABLE CNAME
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IREC7  - COUNT OF THE NUMBER OF VARIABLE NAMES WRITTEN ON
C                  UNIT 7
C         IREC0 - COUNT OF THE NUMBER OF ERROR MESSAGES WRITTEN ON
C                  UNIT 0
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRETA  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRETB  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRETC  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRETD  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRETE  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET1  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET2  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND; SAVE AREA FOR THE
C                  ORIGINAL VALUE OF IRET
C         IRET3  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISAVE  - WORK AREA USED TO SAVE AND RESTORE THER VALUE OF
C                  I WHEN CHKNME IS CALLED
C         ISN    - ISN OF THE CURRENT STATEMENT BEING PROCESSED
C         ISUBTB - COUNT OF THE NUMBER OF ENTRIES IN CSUBTB
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - WORK AREA, THE LENGTH CHARACTERISTIC OF A VARIABLE IN
C                  INTEGER FORM
C         I2WK1  - WORK AREA
C         I2WK2  - WORK AREA
C         I3     - COUNT OF THE NUMBER OF BLANK CHARACTERS IN CNAME
C                  BETWEEN LOCATIONS 38 TO 44. THIS IS USED TO DETERMINE
C                  THE NUMBER OF DIGITS IN THE LENGTH CHARACTERISTIC OF
C                  A VARIABLE
C         I4     - WORK AREA FOR SUBSCRIPT VALUES TO MOVE THE LENGTH
C                  CHARACTERISTIC OF A VARIABLE
C         I5     - SUBSCRIPT VARIABLE
C         JBITS  - THE 32 BIT SWITCHES IN CWORK
C         JDIM   - THE NUMBER OF DIMENSION TABLE ENTRIES IN CDIM
C         JJ     - INDEX VALUE OF THE IMPLICIT LENGTH DEFINTIONS. USED
C                  TO CHECK THE LENGTH FOR INTRINSIC FUNCTION NAMES WHEN
C                  NONE IS DEFINED
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT FOR A GIVEN NEST
C                  LEVEL OF THE UNION. SUBSCRIPT 1 DESIGNATES THE UNION
C                  LEVEL, SUBSCRIPT 2 DESIGNATES THE MAP LEVEL
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUCT
C         JSTRUC - COUNT OF THE NUMBER OF ENTRIES IN ARRAY CSTRNM
C         JSUBTB - EQUIVALENCED TO CSUBTB
C         JUNION - COUNT OF THE LEVELS OF UNION STATEMENTS. ONE IS ADDED
C                  WHEN A UNION STATEMENT IS PROCESSED, ONE IS
C                  SUBTRACTED WHEN AN END UNION STATEMENT IS PROCESSED.
C         KBITS  - THE 32 BIT SWITCHES IN CNAME
C         LBIT   - LOGICAL VARIABLE, SET TRUE WHEN A BIT IS 1, SET FALSE
C                  WHEN A BIT IS ZERO, WORK AREA
C         LBITA  - LOGICAL VARIABLE, SET TRUE WHEN A BIT IS 1, SET FALSE
C                  WHEN A BIT IS ZERO, WORK AREA
C         LBITB  - LOGICAL VARIABLE, SET TRUE WHEN A BIT IS 1, SET FALSE
C                  WHEN A BIT IS ZERO, WORK AREA
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE. THIS SWITCH WILL FORCE A
C                  VARIABLE NAME THAT IS IDENTICAL TO AN INTRINSIC
C                  FUNCTION NAME TO NOT BE TREATED AS A FUNCTION.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LREC   - LOGICAL VARIABLE, SET TRUE WHEN PROCESSING A RECORD
C                  STATEMENT, SET FALSE OTHERWISE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE AND ITS
C                  VARIABLES ARE BEING PROCESSED, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE LENGTH
C                  HAS BEEN COMPUTED, SET FALSE OTHERWISE. THIS PREVENTS
C                  DUPLICATE COMPUTATION OF STRUCTURE LENGTH.
C         L2     - LOGICAL VARIABLE, SET TRUE AFTER THE STRUCTURE NAME
C                  IN A RECORD STATEMENT HAS BEEN PROCESSED BY THIS
C                  ROUTINE, SET FALSE OTHERWISE. THIS SWITCH PREVENTS
C                  DOUBLE COUNTING OF THE RECORD LENGTH.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE TYPE OR LENGTH IN
C                  CWORK(37:44) DOES NOT MATCH THAT OF THE SAME NAMED
C                  VARIABLE IN CNAME, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN MORE THAN 1OOO
C                  STRUCTURE VARIABLES ARE DEFINED, SET FALSE OTHERWISE.
C                  THE PREVENTS MULTIPLE ERROR MESSAGES WHEN THE LIMIT
C                  OF 1000 IS EXCEEDED.
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN THE ERROR MESSAGE
C                  THAT AN INTRINSIC FUNCTION NAME MATCHES A VARIABLE
C                  NAME. SET FALSE OTHERWISE. THIS IS USED TO PREVENT
C                  SETTING THE BIT SWITCH TO INDICATE THE VARIABLE IS AN
C                  INTRINSIC FUNCTION.
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME
C                  MATCHES A COMMON BLOCK NAME AND IT IS NOT AN
C                  EXTENSION OF THE SAME COMMON BLOCK, SET FALSE OTHER-
C                  WISE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C         NVARST - COUNT OF THE NUMBER OF ENTRIES IN TABLE CVARST
C
C     FORTRAN INPUT OUTPUT UNITS USED
C
C         0 - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 121 CHAR-
C             ACTERS OR LESS
C         7 - DISK FILE TO SAVE ALL VARIABLE NAME OCCURRENCES
C
C     COMMENTS
C
C         VARIABLE CWORK MUST BE INITIALIZED PRIOR TO EXECUTION OF
C         THIS SUBROUTINE.
C
C         ALL ISN VALUES HAVE 128 ADDED TO ALL ISN VALUES, AND 128
C         MUST BE SUBTRACTED FROM ISN VALUES FOR PRINTING.
C
C         THE CHARACTERISTICS OF THE VARIABLE, COLS. 37 - 48, MAY BE
C         ADDED IN THIS ROUTINE.
C
C         EACH VARIABLE NAME IS CHECKED FOR VALIDITY. IF THE NAME IS
C         INVALID, A DIAGNOSTIC MESSAGE IS WRITTEN, AND THE ILLEGAL
C         VARIABLE NAME IS NOT ENTERED INTO THE MASTER NAME LIST.
C
C         THE VARIABLE NAME IS SAVED ON OUTPUT UNIT 7
C
C         IF AN INTRINSIC FUNCTION HAS A TYPE LENGTH THAT IS DERIVED
C         FROM ITS ARGUMENT OR ARGUMENTS, COLUMNS 34-35 WILL CONTAIN
C         '# ', A SHARP OR POUND SIGN AND A BLANK, RATHER THAN A
C         SPECIFIC LENGTH SPECIFICATION. THIS SYMBOL IS USED TO PREVENT
C         THE LENGTH SECIFICATION FROM BEING MODIFIED BECAUSE IT WILL BE
C         DEPENDENT UPON THE LENGTH OF THE FUNCTION ARGUMENT. THE
C         DEFAULT VALUE WILL BE USED FOR THE LENGTH CHARACTERISTIC.
C
C         THE TABLE OF INTRINSIC FUNCTIONS IS NOT MEANT TO BE COMPLETE,
C         SINCE INDIVIDUAL COMPILERS HAVE DIFFERENT FUNCTIONS IN THEIR
C         LIBRARY. IF DESIRED, THE TABLE MAY BE EXPANDED OR CONTRACTED
C         BY ADDING OR DELETING FUNCTIONS. HOWEVER, THE FUNCTION NAMES
C         ADDED MUST BE IN COLLATING ORDER, OR THE TABLE SEARCH ROUTINE
C         WILL FAIL SINCE IT USES A BINARY SEARCH METHOD. ANY TABLE
C         MODIFICATIONS MUST ADJUST THE SUBSCRIPT VALUE IN THE DATA
C         STATEMENT CREATING THE TABLE ENTRIES SO THAT ALL ENTRIES ARE
C         IN COLLATING SEQUENCE; ALSO, THE DIMENSION STATEMENT WILL
C         REQUIRE A REDEFINITION OF THE NUMBER OF ITEMS IN THE TABLE.
C         AND, IT IS NECESSARY TO MODIFY THE TABLE SEARCH SUBROUTINE
C         CALL AS FOLLOWS:
C
C         CALL TABSRH (FUNTBL,xxx,35,1,32,CWORK,1,32,IRET,nnn)
C
C         WHERE xxx IS THE VALUE OF THE NUMBER ITEMS IN THE INTRINSIC
C         FUNCTION TABLE, VARIABLE FUNTBL, AND nnn IS THE SIZE OF THE
C         DIMENSION OF FUNTBL ARRAY IN WORDS OF THE LENGTH OF THE
C         DEFINED LENGTH CHARACTERISTIC OF ARRAY FUNTBL, 35 BYTES.
C
C         NOTE THAT ANY INTRINSIC FUNCTION NAME IN A FORTRAN LIBRARY
C         BECOMES A RESERVED VARIABLE NAME.  THIS IS CONTRARY TO THE
C         THE GENERAL RULE THAT FORTRAN HAS NO RESERVED VARIABLE NAMES.
C         THIS SUBROUTINE WILL BE CALLED ONLY FOR THE INITIAL OCCURRENCE
C         OF THE NAME. THE FUNCTIONS INCLUDED ARE THOSE THAT OCCUR IN
C         MOST LIBRARIES, MAINLY MATHEMATICAL FUNCTIONS.
C
C         THE VARIABLE FUNTBL IS DEFINED IN THE BLOCK DATA SUBROUTINE
C         WHERE A SERIES OF DATA STATEMENTS INITIALIZE ITS CONTENTS.
C         THE RECORD STRUCTURE OF THE TABLE IS SHOWN BELOW.
C         COLUMN    CONTENTS
C          1 - 32   INTRINSIC FUNCTION NAME (UPPER CASE ONLY)
C              33   INTRINISIC FUNCTION DATA TYPE CODE
C         34 - 35   INTRINISIC FUNCTION LENGTH DEFINITION. (COLUMN 34
C                   CONTAINS A # CHARACTER WHEN THE LENGTH IS
C                   DETERMINED BY ITS ARGUMENTS WHEN THE FUNCTION IS
C                   USED. (COLUMN 35 SHOULD BE LEFT BLANK WHEN # OR A
C                   SINGLE DIGIT LENGTH IS SPECIFIED.)
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         BTEST CHKSWS IBCLR SETTL TABINS TABSRH TBLINS TBLSRH
C
C     *****************************************************************
C
      SUBROUTINE CHKNME (CSTMTA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20), JSUBTB(14,1000)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION JMAP(20), MAPLEN(20,20)
      DIMENSION IEDIM(26,1000)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST, CWK72
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION, CWK44
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1, CI2WK2
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LBITA, LBITB, L1, L2, L3, L4, L5, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      COMMON /MUS/ JMAP, MAPLEN
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (I2WK2,CI2WK2), (CWORK(33:36),IWORK),
     1(CWORK(45:48),JBITS), (CWORK(49:52),IVCNT), (CWK8(2:2),CWK7),
     2(CNAME(1),IENAME(1,1)), (CDIM(1),IEDIM(1,1)), (CSUBTB,JSUBTB)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA L2/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' ILLEGAL VARIABLE NAME: ',A32)
 101  FORMAT(' ISN:',I6,' VARIABLE NAME EXCEEDS 32 CHARACTERS: ',A32)
 102  FORMAT(' ISN:',I6,' SUBROUTINE ARGUMENT IS DEFINED IN COMMON: ',
     1A32)
 103  FORMAT(' ISN:',I6,' INTRINSIC FUNCTION NAME USED AS A VARIABLE: ',
     1A32)
 105  FORMAT(' ISN:',I6,' MORE THAN 4000 VARIABLE NAMES USED')
 106  FORMAT(' ISN:',I6,' MORE THAN 1000 VARIABLES ARE DEFINED IN STRUCT
     1URE STATEMENTS')
 107  FORMAT(I7)
 108  FORMAT(' ISN:',I6,' SUBPROGRAM NAME IS AN ARGUMENT BUT IS NOT DEFI
     1NED IN AN EXTERNAL STATEMENT: ',A32)
C
C         INITIALIZATION
C
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      ISAVE = I
      CWK32(1:32) = CBLK52(1:32)
C
C         IF THE VARIABLE NAME IN CWORK(1:32) IS BLANK SKIP PROCESSING
C
      IF(CWORK(1:1) .EQ. CBLANK(1:1)) GO TO 20
C
C         INSURE THAT LFORCE IS OFF AFTER ALL DATA AND VARIABLE
C         DEFINITIONS HAVE BEEN PROCESSED.  THAT IS, LSTART IS TRUE.
C
      IF(LSTART) LFORCE = LFALSE
C
C         INSURE THE BIT SWITCH TO PRINT THIS VARIABLE IS SET TO OFF
C         WHEN THE VARIABLE IS PART OF AN INCLUDE FILE
C
      IF(LINCL) THEN
         IWORK = -1
         IF(BTEST(JBITS,15)) JBITS = IBCLR(JBITS,15)
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS A LEGAL VARIABLE NAME
C
      IF(.NOT.(CWORK(1:1) .GE. CAA .AND. CWORK(1:1) .LE. CZZ) .AND.
     1   CWORK(1:1) .NE. CUNDER .AND. CWORK(1:1) .NE. CBLANK(1:1) .AND.
     2   .NOT.LINCL) THEN
         WRITE (0,100) ISN, CWORK(1:32)
         IREC0 = IREC0 + 1
         GO TO 20
      END IF
C
C         DETERMINE IF ANY ILLEGAL CHARACTERS OCCUR IN A VARIABLE NAME
C
      DO 10 I = 1,32
      IF(I .EQ. 1 .AND. CWORK(1:3) .EQ. 'C##') GO TO 11
      IF(I .GT. 1 .AND. CWORK(I:I) .EQ. CBLANK(1:1)) THEN
         IVCNT = I - 1
         GO TO 11
      END IF
      IF(I .GT. 1 .AND. CWORK(I:I) .EQ. CBLANK(1:1)) GO TO 11
      IF(CWORK(I:I) .GE. CAA .AND. CWORK(I:I) .LE. CZZ) THEN
         GO TO 10
      ELSE IF (CWORK(I:I) .GE. C0 .AND. CWORK(I:I) .LE. C9) THEN
         GO TO 10
      ELSE IF(CWORK(I:I) .EQ. CUNDER) THEN
         GO TO 10
      ELSE IF(CWORK(I:I) .EQ. CDOL) THEN
         GO TO 10
      ELSE IF (CWORK(I:I) .EQ. CBLANK(1:1)) THEN
         GO TO 11
      ELSE
C
C         WRITE DIAGNOSTIC MESSAGE WHEN A CHARACTER OF A VARIABLE NAME
C         IS NOT ALPHABETIC, NUMERIC, UNDERSCORE, OR DOLLAR SIGN.
C
         IF(CWORK(1:32) .NE. CBLK52(1:32)) THEN
            IREC0 = IREC0 + 1
            WRITE (0,100) ISN, CWORK(1:32)
            GO TO 20
         END IF
      END IF
 10   CONTINUE
C
C         TEST IF A VARIABLE NAME LENGTH EXCEEDS 32 CHARACTERS
C
 11   IF(IVCNT .GT. 32) THEN
         IF(.NOT.LINCL) THEN
            WRITE (0,101) ISN, CWORK(1:32)
            IREC0 = IREC0 + 1
         END IF
         IVCNT = 32
         GO TO 20
      END IF
C
C         TEST FOR AN INITIAL TABLE ENTRY
C
      IF(INAME .EQ. 0) GO TO 14
C
C         DETERMINE IF THE VARIABLE NAME IS ALREADY IN THE TABLE OF
C         VARIABLE NAMES. A DISTINCTION IS MADE BETWEEN VARIABLES USED
C         IN A STRUCTURE DEFINITION AND THOSE THAT ARE NOT.
C
      IF(LSTRUC) THEN
C
C         THE VARIABLE IS DEFINED IN A STRUCTURE
C
         CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         INSURE THE STRUCTURE USAGE BIT IS SET IN CWORK WHEN THE
C         VARIABLE NAME OCCURS IN A STRUCTURE STATEMENT. IT IS USED
C         TO DISTINGUISH IDENTICAL VARIABLE NAMES WITH DIFFERENT
C         LENGTH CHARACTERISTICS IN THE OUTPUT LISTING.
C
            JBITS = IBSET(JBITS,6)
C
C         INSURE THE RECORD USAGE BIT IS SET WHEN THE VARIABLE NAME
C         OCCURS IN A RECORD STATEMENT
C
            IF(LREC) IENAME(12,IRET) = IBSET(IENAME(12,IRET),2)
C
C         THE VARIABLE NAME EXISTS IN THE MASTER NAME TABLE. SET THE
C         LISTING SWITCH IF IT IS NOT FROM AN INCLUDE FILE, BUT
C         HAS BEEN DEFINED PREVIOUSLY IN AN INCLUDE FILE STATEMENT.
C
            IF(IENAME(9,IRET) .EQ. -1 .AND. .NOT.LINCL) THEN
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),15)
               IENAME(9,IRET) = ISN + 128
            END IF
C
C         DETERMINE IF TYPE, LENGTH, AND BIT SWITCHES ARE ALREADY SET
C
            IF(CWORK(37:48) .NE. CBLANK(1:8)) CALL TBLSRH (CNAME,INAME,
     1          52,1,32,CWORK,1,32,IRET1,4000)
            IF(IRET1 .LT. 0) LFORCE = LFALSE
            GO TO 15
         ELSE
C
C         THE VARIABLE NAME IS IN A STRUCTURE, BUT IS NOT CATALOGED;
C         SET THE SWITCH TO INDICATE THE VARIABLE IS DEFINED WITHIN A
C         STRUCTURE DEFINITION.
C
            JBITS = IBSET(JBITS,6)
            GO TO 14
         END IF
      END IF
C
C         THE VARIABLE IS NOT DEFINED IN A STRUCTURE
C
      IF(.NOT.LSTRUC) THEN
C
C         DETERMINE THE LOCATION OF THE VARIABLE NAME IN CNAME USING
C         THE NAME ONLY, IRET, OR THE NAME AND LENGTH, IRET1.
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         IRET2 = IRET
         CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
C
C         WHEN IRET IS GREATER THAN ZERO AND IRET1 IS NEGATIVE, THEN
C         DETERMINE IF THE VARIABLE ENTRY IN CNAME IS A COMMON BLOCK
C         NAME. THIS CONDITION INDICATES THE NEW ENTRY FOR THE SAME
C         VARIABLE NAME MUST BE AN ORDINARY VARIABLE, AND IT IS A
C         POSSIBLE NEW ENTRY FOR AN ARITHMETIC VARIABLE NAME.
C
         IF(IRET .GT. 0 .AND. IRET1 .LT. 0) THEN
C
C         DETERMINE IF THE NAME IN CNAME IS A BLOCK COMMON VARIABLE
C
            L6 = LFALSE
            CALL TABSRH (COMTBL,ICOMKT,40,1,32,CWORK,1,32,IRETB,200)
            IF(IRETB .GT. 0) THEN
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
               L6 = LTRUE
            END IF
         END IF
C
C         DETERMINE IF BOTH RET AND RET1 ARE POSITIVE AND EQUAL
C
         IF(IRET .GT. 0 .AND. IRET1 .GT. 0 .AND. IRET .EQ. IRET1) THEN
C
C         WHEN THIS VARIABLE IS NOT IN AN INCLUDE FILE, INSURE THAT A
C         PREVIOUS OCCURRENCE IN AN INCLUDE FILE HAS THE ISN CHANGED
C         FROM -1 TO THE CORRECT ISN VALUE.
C
            IF(.NOT.LINCL) THEN
               IF(IENAME(9,IRET) .EQ. -1) IENAME(9,IRET) = ISN + 128
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),15)
            END IF
C
C         WHEN BOTH RET AND RET1 ARE POSITIVE AND EQUAL, A SINGLE ENTRY
C         EXISTS IN CNAME. INSURE BITS IN CNAME(IRET)(45:48) ARE SET
C         TO REFLECT ANY BIT CHANGES IN CWORK(45:48) FOR THIS VARIABLE.
C
            LBIT = BTEST(IENAME(12,IRET),1)     ! COMMON
            LBITA = BTEST(JBITS,1)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),1)
            LBIT = BTEST(IENAME(12,IRET),2)     ! RECORD
            LBITA = BTEST(JBITS,2)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),2)
            LBIT = BTEST(IENAME(12,IRET),17)    ! DIMENSIONED
            LBITA = BTEST(JBITS,17)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),17)
            LBIT = BTEST(IENAME(12,IRET),7)     ! SUBPROGRAM ARGUMENT
            LBITA = BTEST(JBITS,7)
            IF(LBITA .AND. .NOT.LBIT) THEN
               CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRETC,
     1                      1000)
               IF(IRETC .GT. 0) THEN
                  IENAME(12,IRET) = IBCLR(IENAME(12,IRET),7)
               ELSE
                  IENAME(12,IRET) = IBSET(IENAME(12,IRET),7)
               END IF
               IF(.NOT.BTEST(IENAME(12,IRET),17) .AND.
     1            (BTEST(IENAME(12,IRET),8) .OR. BTEST(IENAME(12,IRET),
     2            9) .OR. BTEST(IENAME(12,IRET),10))) THEN
                  CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CWORK,1,32,IRETB,
     1                         1000)
                  CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRETD,143)
C
C         WRITE MESSAGE WHEN A SUBPROGRAM NAME IS AN ARGUMENT IN A
C         STATEMENT AND IT IS NOT DEFINED AS AN EXTERNAL VARIABLE
C
                  IF(IRETB .LT. 0 .AND. IRETC .LT. 0 .AND. IRETD .LT. 0
     1               .AND. .NOT.BTEST(IENAME(12,IRET1),20) .AND.
     2               .NOT.BTEST(IENAME(12,IRET1),8) .AND.
     3               .NOT.BTEST(IENAME(12,IRET1),9) .AND.
     4               .NOT.BTEST(IENAME(12,IRET1),10) .AND.
     5               .NOT.BTEST(IENAME(12,IRET1),17)) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,108) ISN,CWORK(1:32)
                  END IF
               END IF
            END IF
            LBIT = BTEST(IENAME(12,IRET),3)     ! EQUIVALENCE
            LBITA = BTEST(JBITS,3)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),3)
            LBIT = BTEST(IENAME(12,IRET),5)     ! UNION
            LBITA = BTEST(JBITS,5)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),5)
            LBIT = BTEST(IENAME(12,IRET),4)     ! NAMELIST VARIABLE
            LBITA = BTEST(JBITS,4)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),4)
            LBIT = BTEST(IENAME(12,IRET),6)     ! STRUCTURE VARIABLE
            LBITA = BTEST(JBITS,6)
            IF(LBITA .AND. .NOT.LBIT) IENAME(12,IRET) =
     1         IBSET(IENAME(12,IRET),6)
         END IF
C
C         WHEN BOTH IRET AND IRET1 ARE NEGATIVE, NO TABLE ENTRY FOR THIS
C         VARIABLE EXISTS
C
         IF(IRET .LT. 0 .AND. IRET1 .LT. 0 .AND. .NOT.BTEST(JBITS,11)
     1      .AND. CWORK(37:37) .NE. CBAR .AND. .NOT.BTEST(JBITS,1)) THEN
C
C         DETERMINE IF THE VARIABLE NAME MAY BE AN INTRINSIC FUNCTION
C
            CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRETA,143)
            IF(IRETA .GT. 0) THEN
C
C         WRITE MESSAGE WHEN A VARIABLE NAME MATCHES AN INTRINSIC
C         FUNCTION NAME
C
               IF(.NOT.BTEST(JBITS,10)) THEN
                  WRITE (0,103) ISN,FUNTBL(IRETA)(1:32)
                  IREC0 = IREC0 + 1
               END IF
C
C         SET TYPE AND LENGTH CHARACTERISTICS
C
               CWORK(27:44) = CBLANK(1:8)
               IF(FUNTBL(IRETA)(34:34) .EQ. CSHARP) THEN
                  CWORK(37:39) = FUNTBL(IRETA)(33:33)//'? '
               ELSE
                  CWORK(37:39) = FUNTBL(IRETA)(33:34)
               END IF
               JBITS = IBSET(JBITS,16)
               IF(.NOT.BTEST(JBITS,17)) THEN
                  IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
                     JBITS = IBSET(JBITS,16)
                     IF(FUNTBL(IRETA)(34:34) .EQ. CSHARP) THEN
                        CWORK(37:44) = FUNTBL(IRETA)(33:33)//CQUES//
     1                                 CBLANK(1:6)
                     ELSE
                        IF(.NOT.BTEST(JBITS,16))
     1                  CWORK(37:44) = FUNTBL(IRETA)(33:34)//CBLANK(1:6)
                     END IF
                  ELSE
C
C         THE VARIABLE IS NOT AN INTRINSIC FUNCTION, USE THE IMPLICIT
C         TABLE TO SET THE TYPE AND LENGTH CHARACTERISTICS
C
                     IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
                        IF(.NOT.BTEST(JBITS,16) .OR.
     1                     .NOT.BTEST(JBITS,17))
     2                     CALL SETTL (CWORK)
                        ELSE
C
C         THIS VARIABLE NAME CAN NOT BE AN INTRINSIC FUNCTION NAME
C         WRITE A WARNING DIAGNOSTIC OF NAME CONFLICT
C
                           IF(CWORK(38:38) .NE. CSHARP .AND.
     1                        .NOT.BTEST(JBITS,16)) THEN
                              WRITE (0,103) ISN, CWORK(1:32)
                              IREC0 = IREC0 + 1
                              L5 = LTRUE
                           END IF
                        END IF
                     END IF
                  END IF
               END IF
C
C         WHEN AN INTRINSIC FUNCTION LENGTH IS #, MAKE IT ? IN CWORK
C
            IF(CWORK(38:38) .EQ. CSHARP) CWORK(38:38) = CQUES
C
C         WHEN NO ENTRY IN CNAME EXISTS, DETERMINE IF THIS IS A
C         SUBROUTINE STATEMENT
C
            IF(IRET .LT. 0 .AND. IRET1 .LT. 0 .AND. BTEST(JBITS,11))
     1         GO TO 18
C
C         SET THE SWITCH TO INCLUDE THE VARIABLE IN THE OUTPUT TABLES
C         WHEN AN INCLUDE FILE IS NOT BEING PROCESSED
C
            IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
         END IF
C
C         WHEN NO ENTRY EXISTS IN THE MASTER NAME TABLE FOR THIS
C         VARIABLE, DETERMINE IF IT HAS A BAR FOR THE TYPE. THIS
C         CAN BE INSERTED IN THE MASTER NAME TABLE WITHOUT FURTHER
C         PROCESSING.
C
         IF(IRET .LT. 0 .AND. IRET1 .LT. 0 .AND. CWORK(37:37) .EQ. CBAR)
     1      GO TO 18
C
C         WHEN LFORCE IS SET IN A TYPE DEFINITION STATEMENT, DO NOT
C         CHANGE THE VALUE OF LFORCE
C
         IF(.NOT.LFORCE) THEN
C
C         DETERMINE THE DATA TYPE AND LENGTH FROM THE DEFAULT STANDARDS
C
C         WHEN A VARIABLE NAME IS THE NAME OF A COMMON BLOCK AND IT IS
C         ALSO USED AS A NORMAL VARIABLE OR ARRAY NAME, SET THE LENGTH
C         AND TYPE TO REFLECT ONLY THE VARIABLE USE - NOT THE COMMON
C         BLOCK USE.
C
            IF(BTEST(IENAME(12,IRET),9)) THEN
               LBIT = LTRUE
            ELSE
               LBIT = LFALSE
            END IF
            IF(BTEST(IENAME(12,IRET),10)) THEN
               LBITA = LTRUE
            ELSE
               LBITA = LFALSE
            END IF
            IF(BTEST(IENAME(12,IRET),8)) THEN
               LBITB = LTRUE
            ELSE
               LBITB = LFALSE
            END IF
            IF(LBIT .OR. LBITA .OR. LBITB) THEN
               LFORCE = LTRUE
            ELSE
               LFORCE = LFALSE
            END IF
         END IF
C
C         WHEN THE VARIABLE NAME IS NOT IN THE MASTER NAME TABLE, SET
C         THE TYPE AND LENGTH CODE TO THE DEFAULT IN CIMPL, EXCEPT WHEN
C         THE VARIABLE IS IN A TYPE DEFINITION, A STRUCTURE, OR A RECORD
C         STATEMENT.
C
         IF(IRET .LT. 0 .AND. IRET1 .LT. 0 .AND. .NOT.LFORCE .AND.
     1      CWORK(37:38) .EQ. CBLANK(1:2) .AND. .NOT.BTEST(JBITS,6)
     2      .AND. .NOT.BTEST(JBITS,2) .AND. .NOT.BTEST(JBITS,17))
     3      CALL SETTL (CWORK)
C
C         WHEN MULTIPLE ENTRIES IN CNAME EXIST FOR THE SAME VARIABLE
C         NAME, DETERMINE WHICH TABLE ENTRY INDEX VALUE IS TO BE USED.
C
         IF(IRET .GT. 0) THEN
            IF(IRET1 .GT. 0) THEN
               IF(CWORK(1:32) .EQ. CNAME(IRET)(1:32)) THEN
                  IF(CWORK(1:32) .NE. CNAME(IRET1)(1:32)) THEN
                     IF(LFORCE) CNAME(IRET)(37:44) = CWORK(37:44)
                     IF(BTEST(IENAME(12,IRET),9) .AND. CWORK(37:37) .NE.
     1                  CBLANK(1:1) .AND. CWORK(37:37) .NE. CBAR)
     2                  CNAME(IRET)(37:44) = CWORK(37:44)
                  ELSE
                     IF(CNAME(IRET)(37:44) .NE. CWORK(37:44) .AND.
     1                  LFORCE) CNAME(IRET)(37:44) = CWORK(37:44)
                  END IF
               END IF
               IF(CWORK(1:32) .EQ. CNAME(IRET1)(1:32) .AND. CWORK(1:32)
     1            .NE. CNAME(IRET)(1:32)) THEN
                  IF(LFORCE) CNAME(IRET)(37:44) = CWORK(37:44)
               END IF
               IF(.NOT.BTEST(JBITS,1)) THEN
                  IF(CWORK(37:44) .NE. CNAME(IRET)(37:44)) IRET = IRET1
               END IF
            ELSE
               IF(LFORCE) THEN
                  IF(CWORK(37:44) .NE. CNAME(IRET)(37:44) .AND.
     1               .NOT.BTEST(IENAME(12,IRET),6)) CNAME(IRET)(37:44) =
     2               CWORK(37:44)
               ELSE
                  IF(IRET .GT. 0 .AND. IRET1 .LT. 0 .AND. .NOT.L6) THEN
                     KBITS = IENAME(12,IRET)
                     IF(CWORK(37:44) .EQ. CBLANK(1:8) .OR.
     1                  .NOT.BTEST(JBITS,17))
     2                  CWORK(37:44) = CNAME(IRET)(37:44)
                     CALL CHKSWS (KBITS,JBITS)
                     IENAME(12,IRET) = KBITS
                  END IF
               END IF
C
C         DETERMINE IF THE EXISTING ENTRY IN CNAME FOR THIS VARIABLE
C         NAME IS DEFINED AS A SUBROUTINE.
C
               IF(BTEST(IENAME(12,IRET),9) .AND. CWORK(37:44) .NE.
     1            CBLANK(1:8)) THEN
                  CNAME(IRET)(37:44) = CWORK(37:44)
                  IF(BTEST(IENAME(12,IRET),9)) THEN
                     IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
                     IENAME(12,IRET) = IBSET(IENAME(12,IRET),10)
                  END IF
               END IF
               IF(CWORK(1:32) .EQ. CNAME(IRET)(1:32) .AND. CWORK(37:44)
     1            .NE. CNAME(IRET)(37:44)) THEN
C
C         DETERMINE IF THE SAME VARIABLE NAME OCCURS AFTER THE CURRENT
C         LOCATION IN CNAME
C
                  IF(CWORK(1:32) .EQ. CNAME(IRET+1)(1:32)) THEN
                     IF(JBITS .EQ. 0) THEN
                        IF(IRET .GT. 0) THEN
                           LBIT = BTEST(IENAME(12,IRET),1)
                           LBITA = BTEST(IENAME(12,IRET),11)
                           IF(LBIT .AND. .NOT.LBITA) THEN
                              CWORK(45:48) = CNAME(IRET)(45:48)
                              IF(.NOT.BTEST(JBITS,17))
     1                           CWORK(37:44) = CNAME(IRET)(37:44)
                           END IF
                        END IF
                        IF(IRET .GT. 1) THEN
                           LBIT = BTEST(IENAME(12,IRET+1),1)
                           LBITA = BTEST(IENAME(12,IRET+1),11)
                           IF(LBIT .AND. .NOT.LBITA) THEN
                              CWORK(45:48) = CNAME(IRET+1)(45:48)
                              IF(.NOT.BTEST(JBITS,17))
     1                           CWORK(37:44) = CNAME(IRET+1)(37:44)
                           END IF
                        END IF
                     END IF
                  END IF
C
C         DETERMINE IF THE SAME VARIABLE NAME OCCURS BEFORE THE
C         CURRENT LOCATION IN CNAME
C
                  IF(CWORK(1:32) .EQ. CNAME(IRET-1)(1:32)) THEN
                     IF(IRET .GT. 1) THEN
                        LBIT = BTEST(IENAME(12,IRET-1),1)
                        LBITA = BTEST(IENAME(12,IRET-1),11)
C
C         WHEN THE VARIABLE IS NOT A COMMON DEFINITION, SET THE TYPE
C         AND LENGTH CHARACTERISICS
C
                        IF(.NOT.LBITA) THEN
                           IF(.NOT.BTEST(JBITS,17))
     1                        CWORK(37:44) = CNAME(IRET-1)(37:44)
                           CWORK(45:48) = CNAME(IRET-1)(45:48)
                        END IF
                        IF(LBIT .AND. .NOT.LBITA) THEN
                           IF(.NOT.BTEST(JBITS,17))
     1                        CWORK(37:44) = CNAME(IRET-1)(37:44)
                           LBIT = BTEST(JBITS,7)
                           IF(LBIT) THEN
                              CWORK(45:48) = CNAME(IRET-1)(45:48)
                              IENAME(12,IRET-1) =
     1                           IBSET(IENAME(12,IRET-1),7)
                              IF(.NOT.BTEST(IENAME(12,IRET),17) .AND.
     1                           (BTEST(IENAME(12,IRET),8) .OR.
     2                            BTEST(IENAME(12,IRET),9) .OR.
     3                            BTEST(IENAME(12,IRET),10))) THEN
                                  CALL TABSRH (CEXTNL,IEXTNL,32,1,32,
     1                                        CWORK,1,32,IRETB,1000)
                                  CALL TABSRH (CSUBTB,ISUBTB,56,1,32,
     1                                        CWORK,1,32,IRETC,1000)
                                  CALL TABSRH (FUNTBL,143,35,1,32,
     1                                         CWORK,1,32,IRETD,143)
                                  IF(IRETC .GT. 0) THEN
                                     IENAME(12,IRET) =
     1                               IBCLR(IENAME(12,IRET),7)
                                  ELSE
                                     IENAME(12,IRET) =
     1                               IBSET(IENAME(12,IRET),7)
                                  END IF
C
C         WRITE MESSAGE WHEN A SUBPROGRAM NAME IS AN ARGUMENT IN A
C         STATEMENT AND IT IS NOT DEFINED AS AN EXTERNAL VARIABLE
C
                                 IF(IRETB .LT. 0 .AND. IRETC .LT. 0
     1                              .AND. IRETD .LT. 0 .AND.
     2                              .NOT.BTEST(IENAME(12,IRET),20) .AND.
     3                              .NOT.BTEST(IENAME(12,IRET),8) .AND.
     4                              .NOT.BTEST(IENAME(12,IRET),9) .AND.
     5                              .NOT.BTEST(IENAME(12,IRET),10) .AND.
     6                              .NOT.BTEST(IENAME(12,IRET),17)) THEN
                                    IREC0 = IREC0 + 1
                                    WRITE (0,108) ISN,CWORK(1:32)
                                 END IF
                              END IF
                           ELSE
                              CWORK(45:48) = CNAME(IRET-1)(45:48)
                           END IF
                        END IF
                     END IF
                  END IF
C
C         SET THE BIT SWITCHES THAT ARE ALL FALSE AND HAVE NOT BEEN SET
C         IN CWORK
C
                  IF(JBITS .EQ. 0) THEN
                     IF(BTEST(IENAME(12,IRET),11)) THEN
                        IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
                     ELSE
                        CWORK(45:48) = CNAME(IRET)(45:48)
                        IF(.NOT.BTEST(JBITS,17))
     1                     CWORK(37:44) = CNAME(IRET)(37:44)
                        IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
                     END IF
                  ELSE
                     IF(JBITS .NE. IENAME(12,IRET))  CALL TBLINS (CNAME,
     1                  INAME,52,1,32,CWORK,1,32,IRETA,4000)
                     IRET = IRETA
                  END IF
                  IF(IRET .NE. IABS(IRET1)) THEN
                     IF(LFORCE) CALL TBLINS (CNAME,INAME,52,1,32,CWORK,
     1                                       1,32,IRETA,4000)
                  ELSE IF(IRET .EQ. IABS(IRET1)) THEN
                     LBIT = BTEST(IENAME(12,IRET),11)
                     LBITA = BTEST(IENAME(12,IRET),10)
                     IF(LBIT .OR. LBITA) THEN
                        IF(LFORCE) CALL TBLINS (CNAME,INAME,52,1,32,
     1                             CWORK,1,32,IRETA,4000)
                     ELSE
                        IRETA = IRET
                     END IF
                  END IF
                  IF(IRETA .GT. 0 .AND. CNAME(IRETA)(1:32) .EQ.
     1               CWORK(1:32)) IRET = IRETA
                  IF(.NOT.LFORCE) THEN
                     CALL TABINS (CNAME,INAME,52,1,32,CWORK,1,32,IRETA,
     1                            4000)
                  END IF
               END IF
            END IF
C
C         WHEN THIS IS A VARIABLE FROM AN INCLUDE FILE, SET THE ISN
C         TO -1
C
            IF(LINCL) IWORK = -1
C
C         WHEN CWORK TYPE AND LENGTH ARE BLANK, MOVE THE TYPE AND LENGTH
C         CODE FROM CNAME TO CWORK
C
            IF(CWORK(37:44) .EQ. CBLANK(1:8) .OR.
     1         BTEST(IENAME(12,IRET),6)) THEN
               IF(LFORCE) THEN
                  IF(.NOT.BTEST(JBITS,2)) CNAME(IRET)(37:44) =
     1               CWORK(37:44)
               ELSE
                  IF(.NOT.BTEST(JBITS,1) .AND. IRET .GT. 0 .OR.
     1               .NOT.BTEST(JBITS,17))
     2                  CWORK(37:44) = CNAME(IRET)(37:44)
               END IF
            END IF
         END IF
      END IF
C
C         THERE IS A MATCHING ENTRY FOR THIS NAME IN THE TABLE OF
C         VARIABLE NAMES
C
      IF(IRET .GT. 0) THEN
C
C         WHEN BIT 10 IN CWORK(45:48) INDICATES THIS VARIABLE IS
C         DEFINED AS A FUNCTION RATHER THAN A SUBROUTINE, CORRECT
C         THE BIT SETTINGS IN CNAME(45:48) TO SHOW THIS.
C
         IF(BTEST(IENAME(12,IRET),9) .AND. BTEST(JBITS,10)) THEN
C
C         IF THE VARIABLE NAME IS DIMENSIONED OR IN COMMON, IT CAN NOT
C         BE A FUNCTION, ENTRY, OR SUBROUTINE DEFINITION NAME
C
            IF(.NOT.(BTEST(IENAME(12,IRET),2) .OR.
     1         BTEST(IENAME(12,IRET),17))) THEN
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),10)
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
            END IF
         END IF
C
C         CHANGE TYPE AND LENGTH CHARACTERISTICS IN CNAME WHEN A TYPE
C         STATEMENT REQUIRES IT.
C
         IF(LFORCE) THEN
C
C         WHEN THE DEFINED TYPE AND LENGTH MATCH THE ONE IN CNAME, DO
C         NOT MODIFY THE CNAME ENTRY.
C
            IF(CNAME(IRET)(37:44) .NE. CWORK(37:44)) THEN
               IF(BTEST(IENAME(12,IRET),11)) THEN
                  CONTINUE
               ELSE
                  CNAME(IRET)(37:44) = CWORK(37:44)
               END IF
            END IF
         ELSE
C
C         DO NOT SET L3 TO TRUE IF THE VARIABLE DOES NOT BELONG TO
C         A STRUCTURE OR A UNION
C
            IF(BTEST(JBITS,5) .AND. BTEST(JBITS,6)) THEN
C
C         DETERMINE IF THE TYPES AND LENGTHS ARE DIFFERENT
C
               IF(CWORK(37:37) .NE. CNAME(IRET)(37:37)) THEN
                  L3 = LTRUE
                  GO TO 14
               END IF
               IF(CWORK(38:44) .NE. CNAME(IRET)(38:44)) THEN
                  L3 = LTRUE
                  GO TO 14
               END IF
            END IF
         END IF
C
C         SINCE THE CURRENT VARIABLE NAME HAS ALREADY BEEN PLACED IN THE
C         CNAME ARRAY, INITIALIZE CWK32 WHEN GLOBAL ERROR CHECKING IS TO
C         BE PERFORMED. THE SAVED VARIABLE IS USED TO SET THE TYPE CODE
C         OF AN EXPRESSION ARGUMENT OF A CALL STATEMENT.
C
         IF(LGLOBL) CWK32(1:32) = CNAME(IRET)(1:32)
C
C         DETERMINE IF A VARIABLE NAME PREVIOUSLY USED IN AN INCLUDE
C         FILE IS NOW BEING USED BY THE CALLING ROUTINE CURRENTLY BEING
C         PROCESSED
C
         IF(IENAME(9,IRET) .EQ. -1 .AND. .NOT.LINCL) THEN
            IENAME(9,IRET) = ISN + 128
C
C         DETERMINE IF THE VARIABLE NAME STARTS WITH C##. THIS IS A
C         REPRESENTATION OF A LITERAL THAT IS NOT TO BE PRINTED IN
C         OUTPUT LISTING. IT IS USED TO DESIGNATE A LITERAL ARGUMENT
C         IN A CALL STATEMENT.
C
            IF(CWORK(1:3) .EQ. 'C##') THEN
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),15)
               JBITS = IBCLR(JBITS,15)
               IENAME(9,IRET) = -1
            ELSE
C
C         WHEN A VARIABLE NAME LENGTH CHARACTERISTIC IS NOT EQUAL TO
C         THE ONE SPECIFIED IN CWORK, DO NOT SET THE SWITCH TO CAUSE
C         THE VARIABLE NAME TO BE PRINTED IF THE VARIABLE IN CNAME IS
C         A STRUCTURE VARIABLE AND THE VARIABLE IN CWORK IS IN COMMON.
C
               IF(CWORK(37:44) .NE. CNAME(IRET)(37:44)) THEN
                  IF(BTEST(IENAME(12,IRET),6) .AND. BTEST(JBITS,1)) THEN
                     CONTINUE
                  ELSE
                     IF(.NOT.LINCL) IENAME(12,IRET) =
     1                  IBSET(IENAME(12,IRET),15)
                  END IF
               ELSE
                  IF(.NOT.LINCL) IENAME(12,IRET) =
     1               IBSET(IENAME(12,IRET),15)
               END IF
            END IF
         END IF
C
C         DETERMINE IF CWORK BIT SWITCHES AND CNAME BIT SWITCHES AGREE
C         FOR A FUNCTION OR SUBROUTINE DEFINITION. WHEN CNAME HAS BIT 10
C         SET ON AND CWORK HAS BIT 9 ON, SET CNAME BIT 10 OFF AND BIT
C         9 ON. A VARIABLE NAME CAN NOT BE BOTH A FUNCTION AND A
C         SUBROUTINE SIMULTANEOUSLY. THE VARIBLE IS SET TO BE A
C         SUBROUTINE WHEN LCALL IS TRUE.
C
         IF(LCALL) THEN
            IF(BTEST(JBITS,9) .AND. BTEST(IENAME(12,IRET),10)) THEN
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),10)
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),9)
            END IF
         END IF
C
C         DETERMINE IF ANY BIT SWITCHES MUST BE SET FOR THIS VARIABLE
C         THAT HAVE NOT BEEN SET
C
         IF(CWORK(37:37) .EQ. CBAR) THEN
            IF(CWORK(1:32) .EQ. CNAME(IRET)(1:32)) THEN
               IF(JBITS .NE. IENAME(12,IRET)) THEN
                  DO 12 I = 1,17
                  LBIT = BTEST(JBITS,I)
                  LBITA = BTEST(IENAME(12,IRET),I)
                  IF(LBIT .AND. .NOT.LBITA .AND. I .NE. 11)
     1               IENAME(12,IRET) = IBSET(IENAME(12,IRET),I)
 12               CONTINUE
               END IF
            END IF
         END IF
C
C         TEST IF A VARIABLE NAME IS A SUBPROGRAM DUMMY ARGUMENT DEFINED
C         IN COMMON AND WRITE A DIAGNOSTIC IF TRUE
C
         LBITA = BTEST(JBITS,1)
         IF(.NOT.LCALL .AND. LBIT .AND. LBITA .AND. .NOT.LINCL .AND.
     1      (BTEST(JBITS,8) .OR. BTEST(JBITS,9) .OR. BTEST(JBITS,10)))
     2      THEN
            WRITE (0,102) ISN,CWORK(1:32)
            IREC0 = IREC0 + 1
         END IF
C
C         TEST IF THE VARIABLE NAME TYPE IS SPECIFIED, AND SET THE
C         VARIABLE'S LENGTH CHARACTERISTIC
C
         IF((CNAME(IRET)(37:37) .EQ. CBLANK(1:1) .AND. CWORK(37:37) .NE.
     1      CBLANK(1:1)) .OR. CWORK(37:37) .EQ. CQUES) THEN
            CNAME(IRET)(38:44) = CWORK(38:44)
         END IF
C
C         WHEN A USAGE SWITCH FOR A SUBROUTINE EXISTS FOR A VARIABLE
C         NAME, AND A TYPE AND LENGTH CODE EXIST, THEN THE VARIABLE
C         MUST BE A FUNCTION RATHER THAN A SUBROUTINE NAME, SINCE A
C         SUBROUTINE NAME HAS NO TYPE OR LENGTH CHARACTERISTICS.
C
         LBIT = BTEST(JBITS,9)
         IF(LBIT .AND. CWORK(37:37) .NE. CBAR .AND. CNAME(IRET)(37:37)
     1     .NE. CBLANK(1:1) .AND. .NOT.LINCL) THEN
            JBITS = IBSET(JBITS,10)
            JBITS = IBCLR(JBITS,9)
            JBITS = IBCLR(JBITS,8)
            CWK44(1:32) = CWORK(1:32)
            CWK44(33:36) = CWORK(49:52)
            CWK44(37:44) = CWORK(37:44)
         END IF
C
C         WHEN THE NAME TABLE ENTRY FOR THIS VARIABLE NAME IS DEFINED
C         AS A SUBROUTINE AND THE CURRENT VARIABLE HAS A DEFINED LENGTH,
C         THIS NAME MUST BE A FUNCTION.
C
         IF(LBIT .AND. CWORK(37:44) .NE. CBLANK(1:8) .AND.
     1      CNAME(IRET)(37:37) .NE. CBAR .AND. .NOT.LCALL) THEN
            JBITS = IBCLR(JBITS,8)
            JBITS = IBCLR(JBITS,9)
            JBITS = IBSET(JBITS,10)
            CWK44(33:36) = CWORK(49:52)
            CWK44(37:44) = CWORK(37:44)
         END IF
C
C         TEST IF A STRUCTURE VARIABLE
C
         IF(JSTRUC .GT. 0 .AND. .NOT.BTEST(JBITS,13) .AND.
     1      .NOT.BTEST(JBITS,6) .AND. .NOT.BTEST(IENAME(12,IRET),6))
     2      THEN
            JBITS = IBSET(JBITS,13)
            JBITS = IBCLR(JBITS,6)
            IENAME(12,IRET) = IBSET(IENAME(12,IRET),13)
            IENAME(12,IRET) = IBCLR(IENAME(12,IRET),6)
            L1 = LTRUE
C
C         COUNT THE DEFINED LENGTH OF THE VARIABLE TOWARDS THE TOTAL
C         STRUCTURE LENGTH ONLY IF NO UNION STATEMENT IS BEING PROCESSED
C
            IF(JUNION .EQ. 0) THEN
               I3 = 0
               DO 13 I5 = 38,44
               IF(CWORK(I5:I5) .EQ. CBLANK(1:1)) I3 = I3 + 1
 13            CONTINUE
C
C         COMPUTE THE NUMBER OF DIGITS IN THE LENGTH CHARACTERISTIC OF
C         THE VARIABLE
C
               I4 = 7 - I3
               CWK7(1:7) = CBLANK(1:7)
               CWK7(I3+1:7) = CWORK(38:37+I4)
               READ (CWK7,107) I1
               IF(.NOT.L2) JSTR(JSTRUC) = JSTR(JSTRUC) + I1
               CWK7(1:7) = CBLANK(1:7)
               IF(LREC) THEN
                  L2 = LTRUE
               ELSE
                  L2 = LFALSE
               END IF
            ELSE
               L1 = LFALSE
            END IF
         END IF
C
C         TEST IF A UNION VARIABLE
C
         IF(JUNION .GT. 0) IENAME(12,IRET) = IBSET(IENAME(12,IRET),5)
         IWORK = ISN + 128
C
C         WHEN STATEMENTS FROM AN INCLUDE FILE ARE BEING PROCESSED, SET
C         THE ISN TO -1. THIS IS USED TO DETECT INCLUDED VARIABLE NAMES
C         THAT ARE NOT TO BE PRINTED IN THE OUTPUT LISTINGS.
C
         IF(LINCL) THEN
C
C         DETERMINE IF THE VARIABLE NAME ALREADY EXISTS IN CNAME
C
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRETB,4000)
C
C         DETERMINE IF A TYPE AND LENGTH SPECIFICATION ALREADY EXISTS
C         FOR THIS VARIABLE. DO NOT MODIFY THE TYPE AND LENGTH DEFINED
C         IN CNAME AND WRITE A DIAGNOSTIC.
C
            IF(IRETB .LE. 0) THEN
               IWORK = -1
               CNAME(IRET)(33:36) = CWORK(33:36)
            END IF
         END IF
C
C         TEST IF USAGE IS SPECIFIFED AND INSURE SWITCHES ARE SET
C
         LBIT = BTEST(IENAME(12,IRET),1)     ! COMMON
         LBITA = BTEST(JBITS,1)
         IF(LBIT .AND. .NOT.LBITA) IENAME(12,IRET) =
     1      IBSET(IENAME(12,IRET),1)
         LBIT = BTEST(IENAME(12,IRET),2)     ! RECORD
         LBITA = BTEST(JBITS,2)
         IF(LBIT .AND. .NOT.LBITA) IENAME(12,IRET) =
     1      IBSET(IENAME(12,IRET),2)
         CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRETC,1000)
         IF(IRETC .GT. 0) THEN               ! SUBPROGRAM ARGUMENT
            IF(.NOT.BTEST(IENAME(12,IRET),20)) THEN
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),7)
            END IF
         END IF
         LBITA = BTEST(JBITS,7)
         IF(LBITA .AND. .NOT.LBIT) THEN
            IF(.NOT.BTEST(IENAME(12,IRET),17) .AND.
     1         (BTEST(IENAME(12,IRET),8) .OR. BTEST(IENAME(12,IRET),9)
     2          .OR. BTEST(IENAME(12,IRET),10))) THEN
                CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CWORK,1,32,IRETB,
     1                        1000)
                CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRETD,143)
C
C         WRITE MESSAGE WHEN A SUBPROGRAM NAME IS AN ARGUMENT IN A
C         STATEMENT AND IT IS NOT DEFINED AS AN EXTERNAL VARIABLE
C
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRETE,4000)
               IF(IRETB .LT. 0 .AND. IRETC .LT. 0 .AND. IRETD .LT. 0
     1            .AND. .NOT.BTEST(IENAME(12,IRETE),20) .AND.
     2            .NOT.BTEST(IENAME(12,IRETE),8) .AND.
     3            .NOT.BTEST(IENAME(12,IRETE),9) .AND.
     4            .NOT.BTEST(IENAME(12,IRETE),10) .AND.
     5            .NOT.BTEST(IENAME(12,IRETE),16) .AND.
     6            .NOT.BTEST(IENAME(12,IRETE),17)) THEN
                  IREC0 = IREC0 + 1
                  WRITE (0,108) ISN,CWORK(1:32)
               END IF
            END IF
         END IF
         LBIT = BTEST(IENAME(12,IRET),3)     ! EQUIVALENCE
         LBITA = BTEST(JBITS,3)
         IF(LBIT .AND. .NOT.LBITA) IENAME(12,IRET) =
     1      IBSET(IENAME(12,IRET),3)
         LBIT = BTEST(IENAME(12,IRET),5)     ! UNION
         LBITA = BTEST(JBITS,5)
         IF(LBIT .AND. .NOT.LBITA) IENAME(12,IRET) =
     1      IBSET(IENAME(12,IRET),5)
         LBIT = BTEST(IENAME(12,IRET),4)     ! NAMELIST VARIABLE
         LBITA = BTEST(JBITS,12)
         IF(LBIT .AND. .NOT.LBITA) IENAME(12,IRET) =
     1      IBSET(IENAME(12,IRET),4)
         LBIT = BTEST(IENAME(12,IRET),6)     ! STRUCTURE VARIABLE
         LBITA = BTEST(JBITS,6)
         IF(LBIT) THEN
            IF(LBITA) THEN
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),13)
            END IF
         END IF
C
C         WHEN THE VARIABLE NAME IS PART OF A RECORD, DO NOT CHANGE
C         THE TYPE AND LENGTH CODE, BECAUSE THEY ARE CORRECTLY SET ONLY
C         BY THE STRUCTURE STATEMENT
C
         IF(.NOT.BTEST(IENAME(12,IRET),4)) THEN
C
C         TEST IF LENGTH AND TYPE ARE SPECIFIED
C
            IF(CNAME(IRET)(37:37) .EQ. CBLANK(1:1) .AND. CWORK(37:37)
     1         .NE. CBLANK(1:1)) CNAME(IRET)(37:37) = CWORK(37:37)
            IF(CNAME(IRET)(38:44) .EQ. CBLANK(1:7) .AND. CWORK(38:44)
     1         .NE. CBLANK(1:7) .AND. CNAME(IRET)(37:37) .NE. CBAR)
     2         CNAME(IRET)(38:44) = CWORK(38:44)
         END IF
C
C         CORRECT THE USAGE CODE WHEN A USAGE DESIGNATION CONTAINS
C         A SUBROUTINE, BUT A LENGTH CHARACTERISTIC IS DEFINED. THIS
C         CASE INDICATES THE VARIABLE NAME IS A FUNCTION.
C
         LBIT = BTEST(IENAME(12,IRET),9)
         IF(CWORK(37:44) .NE. CBLANK(1:8) .AND. LBIT .AND.
     1      CWORK(37:37) .NE. CBAR .AND. .NOT.BTEST(IENAME(12,IRET),17))
     2      THEN
C
C         IF THE VARIABLE NAME IS DIMENSIONED OR IN COMMON, IT CAN NOT
C         BE A FUNCTION, ENTRY, OR SUBROUTINE DEFINITION NAME
C
            IF(.NOT.(BTEST(IENAME(12,IRET),2) .OR.
     1         BTEST(IENAME(12,IRET),17))) THEN
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),8)
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),10)
            END IF
         END IF
C
C         SET THE BIT TO PREVENT OR FORCE THE VARIABLE NAME TO APPEAR
C         IN THE OUTPUT LISTING
C
         IF(LINCL) THEN
            CONTINUE
         ELSE
C
C         DETERMINE IF THE VARIABLE NAME STARTS WITH C##. THIS IS A
C         REPRESENTATION OF A LITERAL THAT IS NOT TO BE PRINTED IN THE
C         OUTPUT LISTING. IT IS USED TO DESIGNATE A LITERAL ARGUMENT
C         IN A CALL STATEMENT.
C
            IF(CWORK(1:3) .EQ. 'C##') THEN
               JBITS = IBCLR(JBITS,15)
               IENAME(9,IRET) = -1
            ELSE
               JBITS = IBSET(JBITS,15)
               IF(JSTRUC .GT. 0 .AND. .NOT.BTEST(JBITS,6)) THEN
                  JBITS = IBSET(JBITS,6)
                  JBITS = IBCLR(JBITS,13)
               END IF
            END IF
         END IF
         IF(CNAME(IRET)(37:44) .NE. CWORK(37:44)) GO TO 14
         GO TO 19
      END IF
C
C        THE VARIABLE NAME IS NOT IN THE TABLE, INSERT IT
C
 14   IWORK = ISN + 128
C
C         WHEN CWORK HAS NO LENGTH AND TYPE DESIGNATION AND THE
C         VARIABLE NAME IS NOT IN THE CNAME TABLE, SET THE TYPE AND
C         LENGTH TO THE DEFAULT VALUES IN CIMPL, EXCEPT FOR STRUCTURE
C         AND NAMELIST DEFINITION NAMES.
C
      LBIT = BTEST(JBITS,12)
      LBITA = BTEST(JBITS,13)
      IF(.NOT.LBIT .AND. .NOT.LBITA .AND. .NOT.LFORCE) THEN
         IF(CWORK(37:37) .NE. CBAR .AND. (CWORK(37:37) .EQ. CBLANK(1:1)
     1      .OR. CWORK(38:44) .EQ. CBLANK(1:7)) .AND. .NOT.L3) THEN
            IF(.NOT.BTEST(JBITS,17)) CALL SETTL (CWORK)
         END IF
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS AN ENTRY, FUNCTION, OR A
C         SUBROUTINE DEFINITION, AND SET THE CORRECT BIT SWITCHES.
C
 15   CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET3,1000)
      IF(ISUBTB .GT. 0) THEN
C
C         WHEN THE VARIABLE NAME IS A DUMMY ARGUMENT, DO NOT CHANGE
C         ANY BIT SWITCHES
C
         IF(IRET3 .GT. 0 .AND. .NOT.BTEST(JBITS,20)) THEN
            IF(BTEST(JSUBTB(12,IRET3),8)) THEN
               JBITS = IBSET(JBITS,8)
               JBITS = IBCLR(JBITS,9)
               JBITS = IBCLR(JBITS,10)
            ELSE IF(BTEST(JSUBTB(12,IRET3),9)) THEN
               JBITS = IBCLR(JBITS,8)
               JBITS = IBSET(JBITS,9)
               JBITS = IBCLR(JBITS,10)
            ELSE IF(BTEST(JSUBTB(12,IRET3),10)) THEN
               JBITS = IBCLR(JBITS,8)
               JBITS = IBCLR(JBITS,9)
               JBITS = IBSET(JBITS,10)
            END IF
         END IF
      END IF
C
C         COMPUTE THE LENGTH OF A STRUCTURE
C
      IF(JSTRUC .GT. 0 .AND. .NOT.L1) THEN
C
C         COMPUTE THE NUMBER OF DIGITS IN THE LENGTH CHARACTERISTIC OF
C         THE VARIABLE
C
         I3 = 0
         DO 16 I5 = 38,44
         IF(.NOT.(CWORK(I5:I5) .GE. C0 .AND. CWORK(I5:I5) .LE. C9))
     1      I3 = I3 + 1
 16      CONTINUE
         I4 = 7 - I3
         CWK7(1:7) = CBLANK(1:7)
         CWK7(I3+1:7) = CWORK(38:37+I4)
         READ (CWK7,107) I1
C
C        DETERMINE IF THE VARIABLE IS A DEFINED STRUCTURE NAME
C
         CALL TABSRH (CSTR,ISTRUC,36,1,32,CWORK,1,32,IRETA,1000)
         IF(BTEST(JBITS,6) .AND. BTEST(JBITS,13)) JBITS = IBCLR(JBITS,6)
         IF(.NOT.BTEST(JBITS,13) .AND. IRETA .GT. 0 .OR. BTEST(JBITS,6))
     1      THEN
C
C         WHEN A VARIABLE IS DEFINED WITHIN A STRUCTURE DEFINITION,
C         PLACE THE VARIABLE NAME, TYPE, AND LENGTH IN ARRAY CVARST.
C         THIS ARRAY WILL BE USED TO CREATE THE LISTING OF VARIABLE
C         NAMES OF MULTIPLE IDENTICAL NAMES BUT WITH DIFFERNT TYPE
C         AND LENGTH CHARACTERISTICS.
C
C           NVARST = NVARST + 1
            IF(.NOT.L4 .AND. NVARST .GT. 1000) THEN
               IREC0 = IREC0 + 1
               WRITE (0,106) ISN
               L4 = LTRUE
            ELSE
               CWK72(1:32) = CWORK(1:32)
               CWK72(33:64) = CSTRNM(JSTRUC)(1:32)
               CWK72(65:72) = CWORK(37:44)        ! TYPE AND LENGTH
               CALL TBLINS (CVARST,NVARST,72,1,64,CWK72,1,64,IRETB,1000)
            END IF
C
C         COUNT THE LENGTH OF THE VARIABLE NAME TOWARDS THE TOTAL
C         STRUCTURE LENGTH ONLY IF NO UNION STATEMENT IS BEING PROCESSED
C
            IF(JUNION .EQ. 0) THEN
               IF(.NOT.BTEST(JBITS,13) .AND. .NOT.LREC) THEN
                  JSTR(JSTRUC) = JSTR(JSTRUC) + I1
               ELSE IF(IRETA .GT. 0) THEN
                  JSTR(JSTRUC) = JSTR(JSTRUC) + I1
               END IF
               CWK7(1:7) = CBLANK(1:7)
            END IF
         ELSE
C
C          THE VARIABLE IS A STRUCTURE DEFINITION
C
            JSTR(JSTRUC) = JSTR(JSTRUC) + I1
         END IF
      END IF
C
C         TEST IF A UNION VARIABLE
C
      IF(JUNION .GT. 0) THEN
         JBITS = IBSET(JBITS,5)
         I3 = 0
         DO 17 I5 = 38,44
         IF(CWORK(I5:I5) .EQ. CBLANK(1:1)) I3 = I3 + 1
 17      CONTINUE
C
C         COMPUTE THE NUMBER OF DIGITS IN THE LENGTH CHARACTERISTIC OF
C         THE VARIABLE
C
         I4 = 7 - I3
         CWK7(I3+1:7) = CWORK(38:37+I4)
         READ (CWK7,107) I1
         I5 = JMAP(JUNION)
         MAPLEN(JUNION,I5) = MAPLEN(JUNION,I5) + I1
         CWK7(1:7) = CBLANK(1:7)
      END IF
C
C         DETERMINE IF THE NAME IS AN INTRINSIC FUNCTION NAME
C
      CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRETE,143)
C
C         WHEN THE VARIABLE NAME BEING PROCESSED IS FROM A TYPE
C         DEFINITION STATEMENT, TREAT THE NAME AS AN ORDINARY VARIABLE
C         WHEN IT MATCHES AN INTRINSIC FUNCTION NAME.
C
C
C         DETERMINE IF THE VARIABLE NAME IS DIMENSIONED
C
       CALL TABSRH (CDIM,JDIM,104,1,32,CWORK,1,32,IRET3,1000)
C
C         WHEN THE VARIABLE NAME MATCHES AN INTRINSIC FUNCTION NAMEM
C         AND IT IS NOT DIMENSIONED, DO NOT WRITE THE ERROR EMSSAGE.
C
      IF(IRETE .GT. 0 .AND. IRET3 .GT. 0) THEN
C
C         WHEN AN EQUAL SIGN FOLLOWS THE VARIABLE NAME AND THE NAME
C         MATCHES ONE OF THE INTRINSIC FUNCTION NAMES, ISSUE A
C         WARNING MESSAGE.
C
         IF(CSTMTA(NA:NA) .EQ. CEQ(1:1) .AND. .NOT.L5) THEN
C
C         THIS VARIABLE NAME CAN NOT BE AN INTRINSIC FUNCTION NAME
C         WRITE A WARNING DIAGNOSTIC OF NAME CONFLICT
C
            WRITE (0,103) ISN, CWORK(1:32)
            IREC0 = IREC0 + 1
            L5 = LTRUE
         END IF
C
C         IF THE CHARACTER FOLLOWING THE FINAL CHARACTER OF THE VARIABLE
C         NAME IS A LEFT PARENTHESIS, THE VARIABLE NAME MAY BE AN
C         INTRINSIC FUNCTION. WHEN A TYPE CODE EXISTS, OR THE VARIABLE
C         ALREADY EXISTS IN THE CNAME TABLE, DO NOT ISSUE AN ERROR
C         MESSAGE.
C
         IF(CSTMTA(NA:NA) .NE. CLPAR .AND. CWORK(37:37) .EQ. CBLANK(1:1)
     1      .AND. .NOT.LINCL .AND. (IRET .GT. 0 .OR. IRET1 .GT. 0)) THEN
C
C         THIS VARIABLE NAME CAN NOT BE AN INTRINSIC FUNCTION NAME
C         WRITE A WARNING DIAGNOSTIC OF NAME CONFLICT
C
            WRITE (0,103) ISN, CWORK(1:32)
            IREC0 = IREC0 + 1
            L5 = LTRUE
         ELSE
C
C         A LEFT PARENTHESIS FOLLOWS THE VARIABLE NAME. THE VARIABLE
C         NAME IS NOT AN INTRINSIC FUNCTION IF IT IS A DIMENSIONED
C         VARIABLE.
C
C         IF THE VARIABLE NAME IS NOT DIMENSIONED, IT MAY BE AN
C         INTRINSIC FUNCTION
C
            IF(IRET1 .LT. 0) THEN
C
C         TEST IF THE VARIABLE IS IN COMMON, EQUIVALENCE, STRUCTURE,
C         ENTRY, UNION, OR NAMELIST STATEMENTS. AN INTRINSIC FUNCTION
C         MAY NOT OCCUR IN THESE STATEMENTS.
C
               IF(CWORK(37:37) .NE. CBAR) THEN
C
C         DETERMINE IF COMMON OR RECORD
C
                  LBIT = BTEST(JBITS,1)
                  LBITA = BTEST(JBITS,2)
                  IF(.NOT.LBIT .AND. .NOT.LBITA) THEN
C
C         DETERMINE IF EQUIVALENCE OR UNION
C
                     LBIT = BTEST(JBITS,3)
                     LBITA = BTEST(JBITS,5)
                     IF(.NOT.LBIT .AND. .NOT.LBITA) THEN
C
C         DETERMINE IF NAMELIST OR STRUCTURE
C
                        LBIT = BTEST(JBITS,4)
                        LBITA = BTEST(JBITS,6)
                        IF(.NOT.LBIT .AND. .NOT.LBITA) THEN
C
C         DETERMINE IF A SUBROUTINE ARGUMENT OF A SUBROUTINE. SINCE
C         THE VARIABLE NAME IS FROM A NAMELIST OR STRUCTURE, IT CAN
C         NOT BE A SUBROUTINE OR FUNCTION NAME. DO NOT ISSUE THE
C         ERROR MESSAGE USING FORMAT 108.
C
                           LBIT = BTEST(JBITS,7)
                           LBITA = BTEST(JBITS,9)
                           IF(.NOT.L5 .AND. .NOT.LBIT .AND. .NOT.LBITA
     1                        .AND. .NOT.BTEST(JBITS,17)) THEN
C
C         SET THE TYPE AND LENGTH OF THE INTRINISIC FUNCTION
C
                              JBITS = IBSET(JBITS,10)
                              JBITS = IBSET(JBITS,16)
                              CWORK(37:37) = FUNTBL(IRETE)(33:33)
                              IF(FUNTBL(IRETE)(34:34) .NE. CSHARP) THEN
                                 CWORK(38:38) = FUNTBL(IRETE)(34:34)
                              ELSE
C
C         WHEN NO LENGTH SPECIFICATION IS DETERMINED, SET IT TO '?'
C
                                 IF(.NOT.L3) CWORK(38:38) = CQUES(1:1)
                              END IF
                           END IF
                        END IF
                     END IF
                  END IF
               END IF
            ELSE
C
C         THE VARIABLE IS DIMENSIONED & IT IS AN INTRINSIC FUNCTION USED
C         AS A VARIABLE.
C
               IF(.NOT.LINCL) THEN
                  WRITE (0,103) ISN, CWORK(1:32)
                  IREC0 = IREC0 + 1
               END IF
            END IF
         END IF
      END IF
C
C         IF AN INCLUDE FILE STATEMENT IS BEING PROCESSED, SET THE ISN
C         TO -1
C
      IF(LINCL) IWORK = -1
C
C         INSURE PRINTING OF USAGE TYPE F FOR A FUNCTION
C
      IF(.NOT.L5) LBIT = BTEST(JBITS,10)
      IF(LBIT .AND. CWORK(37:37) .EQ. CBAR) CWORK(37:37) = CBLANK(1:1)
C
C         SET THE BIT TO PREVENT OR FORCE THE VARIABLE NAME TO APPEAR
C         IN THE OUTPUT LISTING
C
      IF(LINCL) THEN
C
C         DETERMINE IF THE VARIABLE NAME STARTS WITH C##. THIS IS A
C         REPRESENTATION OF A LITERAL THAT IS NOT TO BE PRINTED IN
C         OUTPUT LISTING. IT IS USED TO DESIGNATE A LITERAL ARGUMENT
C         IN A CALL STATEMENT.
C
         IF(CWORK(1:3) .EQ. 'C##') THEN
            JBITS = IBCLR(JBITS,15)
         END IF
      ELSE
            JBITS = IBSET(JBITS,15)
      END IF
C
C         DETERMINE THE INDEX OF THE VARIABLE NAME IN TABLE CIMPL
C
      I2WK1 = 0
      CI2WK1(1:1) = CWORK(1:1)
      IF(CWORK(1:1) .EQ. CUNDER) THEN
         I2WK1 = 27
      ELSE
         I2WK1 = I2WK1 - ICTN
      END IF
C
C         WHEN NOT IN THE NAME TABLE, DETERMINE THE DEFAULT TYPE AND
C         LENGTH CHARACTERISTICS FROM THE IMPLCIT TABLE, AND INSERT
C         A NEW VARIABLE NAME INTO THE NAME TABLE.
C
      IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
         IF(.NOT.BTEST(JBITS,12) .AND. .NOT.BTEST(JBITS,13)) THEN
            IF(CWORK(38:44) .EQ. CBLANK(1:7) .AND. CWORK(37:37) .NE.
     1         CBAR .AND. .NOT.LFORCE) THEN
               IF(.NOT.BTEST(JBITS,17)) CALL SETTL (CWORK)
            ELSE
               IF(.NOT.L3) CWORK(37:37) = CQUES(1:1)
            END IF
         ELSE
            IF(CWORK(37:37) .EQ. CBLANK(1:1) .AND. CWORK(38:44) .EQ.
     1         CBLANK(1:7) .AND. .NOT.LFORCE) THEN
                  IF(.NOT.BTEST(JBITS,13)) CWORK(38:44) =
     1               CIMPL(I2WK1)(2:8)
            END IF
         END IF
      END IF
C
C         WHEN A VARIABLE NAME BELONGS TO AN INCLUDED FILE, SET THE ISN
C         TO -1
C
 18   IF(IRET2 .GE. 0) THEN
         IF(IRET1 .GE. 0) THEN
            CALL TBLINS (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
         ELSE
            CALL TBLINS (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         END IF
      ELSE
         CALL TBLINS (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
      END IF
      CWK32(1:32) = CNAME(IRET1)(1:32)
C
C         WHEN IRET1 IS ZERO, MORE THAN 4000 VARIABLE NAMES EXIST IN
C         CNAME
C
      IF(IRET1 .EQ. 0) THEN
         WRITE (0,105) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         SAVE THE VARIABLE NAME ON UNIT 7 WHEN THE USE OF THE VARIABLE
C         DOES NOT OCCUR IN AN INCLUDE FILE
C
 19   IF(.NOT.LINCL) THEN
C
C         WRITE THE VARIABLE ONTO THE ISN USAGE FILE, UNIT 7
C
         IF(CWORK(1:8) .NE. CBLANK(1:8) .AND. CWORK(1:3) .NE. 'C##')
     1      THEN
            IWORK = ISN + 128
            IF(LCALL .AND. BTEST(JBITS,7)) JBITS = IBSET(JBITS,20)
            IF(.NOT.LINCL) THEN
               WRITE (7,REC=IREC7) CWORK(1:52)
               IREC7 = IREC7 + 1
            END IF
         END IF
      END IF
C
C         INSURE A FUNCTION OR SUBROUTINE SWITCH IS SET CORRECTLY
C         FOR THE CURRENT VARIABLE NAME
C
      IF(IRET .GT. 0) THEN
         IF(BTEST(IENAME(12,IRET),9) .AND. BTEST(IENAME(12,IRET),10))
     1      THEN
            IF(CNAME(IRET)(37:37) .NE. CBLANK(1:1))
     1         IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
         END IF
         IF(BTEST(IENAME(12,IRET),10)) THEN
            IF(CNAME(IRET)(37:37) .EQ. CBAR .AND. CNAME(IRET)(38:38)
     1         .GE. C0 .AND. CNAME(IRET)(38:38) .LE. C9)
     2         CNAME(IRET)(37:44) = CWORK(37:44)
         END IF
      END IF
      IF(IRET1 .GT. 0) THEN
         IF(BTEST(IENAME(12,IRET1),9) .AND. BTEST(IENAME(12,IRET1),10))
     1      THEN
            IF(CNAME(IRET1)(37:37) .NE. CBLANK(1:1))
     1         IENAME(12,IRET1) = IBCLR(IENAME(12,IRET1),9)
         END IF
         IF(BTEST(IENAME(12,IRET1),10)) THEN
            IF(CNAME(IRET1)(37:37) .EQ. CBAR .AND. CNAME(IRET1)(38:38)
     1         .GE. C0 .AND. CNAME(IRET1)(38:38) .LE. C9)
     2         CNAME(IRET1)(37:44) = CWORK(37:44)
         END IF
      END IF
C
C         RESET ALL BIT SWITCHES TO OFF
C
 20   JBITS = 0
      I = ISAVE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM COMPRESSES THE FORTRAN STATEMENT TO REMOVE
C         ALL UNNECESSARY BLANKS. BLANKS OCCURRING WITHIN LITERALS ARE
C         NOT REMOVED. BOTH STATEMENT NUMBERS AND LITERALS ARE WRITTEN
C         ONTO DISK FILES BY THIS ROUTINE. LITERALS ARE REPLACED WITH
C         A HEX VALUE OF CF TO UNIQUELY IDENTIFY THEM. ALL LOGICAL
C         OPERATORS AND CONSTANTS ARE REMOVED FROM THE STATEMENT AND
C         REPLACED WITH A HEX VALUE OF CD.
C
C     MEANING OF THE VARIABLES
C
C         CAPOS  - CHARACTER VARIABLE, THE CHARACTER: '
C         CAPOSD - CHARACTER VARIABLE, THE CHARACTER: "
C         CBB    - CHARACTER VARIABLE, THE CHARACTER: B
C         CBLANK - CHARACTER VARIABLE, A BLANK CHARACTER
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN OCCURING IN THE
C                  PROGRAM OR SUBPROGRAM
C         CICTN  - CHARACTER VARIABLE, EQUIVALENCED TO ICTN
C         CIFILE - CHARACTER VARIABLE, THE ARRAY OF FILE NAMES OCCURING
C                  IN INCLUDE STATEMENTS
C         CISN   - CHAARCTER VARIABLE, THE INTERNAL STATEMENT NUMBER,
C                  EQUIVALENCED TO ISN
C         CIWK1  - CHARACTER VARIABLE, EQUIVALENCED TO IWK1
C         CIWK2  - CHARACTER VARIABLE, EQUIVALENCED TO IWK2
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CLIT   - CHARACTER VARIABLE, CONTAINS THE LITERAL OCCURRING
C                  IN A STATEMENT. MAXIMUM LENGTH IS 80 BYTES
C                  EQUIVALENCED TO CLITWK
C         CLITLN - CHARACTER VARIABLE, LENGTH OF A LITERAL IN BYTES.
C                  THIS ARRAY WILL CONTAIN ONLY THE LENGTH OF THE
C                  LITERALS OCCURRING IN ONE STATEMENT. THE SEQUENCE OF
C                  ENTRIES IS THE SAME AS THE LITERALS OCCUR FROM LEFT
C                  TO RIGHT IN THE STATEMENT. A MAXIMUM OF 500 LITERALS
C                  MAY OCCUR WITHIN A SINGLE STATEMENT.
C         CLITSA - CHARACTER VARIABLE, SAVE AREA FOR A BINARY, OCTAL, OR
C                  HEXADECIMAL LITERAL THAT MAY REPRESENT A NUMERICAL
C                  VALUE.
C         CLITW  - CHARACTER VARIABLE, SAVE AREA FOR THE CURRENT LITERAL
C                  OCCURRING IN A STATEMENT. MAXIMUM LENGTH IS 80 BYTES.
C                  THIS IS USED TO TEST FOR AN INCLUDE STATEMENT AND IS
C                  USED TO SAVE THE FILE NAME OF CODE TO BE INCLUDED IN
C                  THE PROGRAM BEING ANALYZED.
C         CLITWK - CHARACTER VARIABLE, WORK AREA FOR WRITING THE
C                  LITERALS AND THEIR ISNS
C                  RECORD STRUCTURE
C                  COLS    WORD  DESCRIPTION
C                   1 - 80   20  THE LITERAL CONTENTS
C                  81 - 84   21  THE LENGTH OF THE LITERAL IN COLS. 1-80
C                                + 128 (MAY NOT BE NOT THE TRUE LENGTH)
C                  85 - 88   22  THE ISN OF THE STATEMENT CONTAINING
C                                THE LITERAL IN COLS. 1 - 80
C                  89 - 92   23  THE ARGUMENT NUMBER OF A LITERAL IN A
C                                CALL STATEMENT, SET TO ZERO IF NOT A
C                                CALL STATEMENT.
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         COO    - CHARACTER VARIABLE, THE CHARACTER: O (LETTER)
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CSYMCE - CHARACTER VARIABLE, THE HEX NUMBER: CE; THIS VALUE
C                  REPLACES THE FIRST CHARACTER AFTER INCLUDE IN AN
C                  INCLUDE STATEMENT. IT INDICATES THE LITERAL ARGUMENT
C                  OF THE STATEMENT IS INVALID.
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWK5   - CHARACTER VARIABLE, A FIVE CHARACTER WORK AREA USED
C                  TO DETERMINE IF THE CURRENT STATEMENT IS A SUBPROGRAM
C                  CALL
C         CWR    - CHARACTER VARIABLE, WORK AREA TO WRITE A STATEMENT
C                  NUMBER RECORD ON UNIT 4
C         CXX    - CHARACTER VARIABLE, THE CHARACTER: X
C         CX30   - CHARACTER VARIABLE, THE HEX CHARACTER: 30
C         CX5A   - CHARACTER VARIABLE, THE HEX CHARACTER: 5A
C         CX60   - CHARACTER VARIABLE, THE HEX CHARACTER: 60
C         CX7A   - CHARACTER VARIABLE, THE HEX CHARACTER: 7A
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER: Z
C         C4     - CHARACTER VARIABLE, A FOUR CHARACTER
C         C9     - CHARACTER VARIABLE, A NINE CHARACTER
C         FP     - DOUBLE PRECISION THE VALUE OF A NUMBER RETURNED AS
C                  FLOATING POINT
C         I      - SUBSCRIPT VARIABLE, LOCATION FROM WHICH A CHARACTER
C                  IS TO BE MOVED
C         IA     - SUBSCRIPT VARIABLE, ALSO START OF A FIELD INDEX VALUE
C         IAPOS  - COUNT OF APOSTROPHES IN THE STATEMENT
C         IB     - DO LOOP PARAMETER, END OF A SEARCH FIELD LOCATION
C         IC     - WORK AREA, END OF THE STATEMENT NUMBER FIELD LOCATION
C         ICAPS  - THE VALUE TO SUBTRACT FROM A LOWER CASE ALPHABETIC
C                  CHARACTER TO CONVERT IT TO UPPER CASE FOR ASCII CODE
C         ICTN   - VALUE IN ASCII COMMON WHERE ALPHABETIC TEXT STARTS
C                  IN BOTH ASCII AND EBCDIC CODING SYSTEMS.
C         ID     - LOCATION OF THE FIRST NONNUMERIC CHARACTER IN A
C                  STATEMENT
C         IDXE   - LOCATION OF THE FIRST CHARACTER OF A WORD FOR
C                  CONVERTING BETWEEN UPPER AND LOWER CASE ALPHABETIC
C                  CHARACTERS. THE VALUE IS 1 FOR LITTLE ENDIAN
C                  COMPUTERS, OR 2 FOR BIG ENDIAN COMPUTERS.
C         IE     - WORK AREA
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         IG     - WORK AREA
C         IH     - WORK AREA, LENGTH OF A LITERAL
C         II     - LOCATION OF THE START OF A LITERAL AFTER LEFT
C                  LOCATION ADJUSTMENT, IF ANY; ALSO USED AS THE RETURN
C                  VALUE OF AN INTEGER FROM SUBROUTINE NUMBER.
C         ILISN  - ARRAY OF ISNS
C         ILIT   - COUNT OF THE NUMBER OF LITERALS WRITTEN ON UNIT 9
C         ILITCT - COUNT OF THE NUMBER OF LITERALS IN A CALL STATEMENT
C                  ARGUMENT LIST
C         ILITWK - EQUIVALENCED TO CLITWK
C         ILOC1  - LENGTH OF A LITERAL IN CSTMT, EQUIVALENCED TO
C                  CLITWK
C         ILOC2    THE ISN OF THE STATEMENT CONTAINING THE LITERAL, (128
C                  IS ADDED TO THE ISN VALUE) EQUIVALENCED TO CLITWK
C         ILOC3  - THE NUMBER OF ARGUMENTS IN A CALL STATEMENT
C                  STATEMENT, EQUIVALENCED TO CLITWK
C         ILOC4  - WORK VARIABLE.
C         IP1    - WORK AREA
C         IQ     - WORK AREA
C         IQUOTE - COUNT OF THE NUMBER OF QUOTATION MARKS IN THE
C                  STATEMENT
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IREC9  - COUNT OF THE NUMBER OF LITERAL RECORDS WRITTEN ON
C                  UNIT 9
C         IRET   - A VALUE RETURNED FROM SUBROUTINE COMPRS. SET TO ZERO
C                  TO CONTINUE THE NEXT STATEMENT, SET TO 1 TO EXECUTE
C                  STATEMENT NUMBER 17. SUBROUTINE COMPRS RETURNS A VALUE
C                  OF 1 WHEN AN INCLUDE STATEMENT HAS AN INVALID LITERAL
C                  AS ITS ARGUMENT. THE INCLUDE STATEMENT IS NOT
C                  PROCESSED.
C         ISLASH - LOCATION OF THE INITIAL SLASH IN A DATA STATEMENT
C         ISN    - THE INTERNAL STATEMENT NUMBER, EQUIVALENCED TO CISN
C         ISNUM  - TABLE OF DEFINED STATEMENT NUMBERS FOUND IN THE
C                  PROGRAM; WORD 1 CONTAINS THE STATEMENT
C                  NUMBER VALUE, WORD 2 CONTAINS THE ISN DEFINING
C                  THE STATMENT NUMBER
C         ISTLIT - COUNT OF THE NUMBER OF LITERALS IN A SINGLE FORTRAN
C                  STATEMENT
C         I1     - SUBSCRIPT VARIABLE
C         I2     - LOCATION OF A COMMA TERMINATING AN ARGUMENT
C         I2WK1  - TWO BYTE WORK AREA
C         I3     - START LOCATION OF A DO LOOP TO SCAN FOR HOLLERTH
C                  FIELDS WITHIN A CALL ARGUMENT LIST
C         I4     - COUNTER FOR LEFT AND RIGHT PARENTHESES
C         I4WK1  - FOUR BYTE WORK AREA, CONTAINS THE STATEMENT NUMBER
C                  IN INTEGER FORM
C         I5     - COUNTER FOR THE ARGUMENT NUMBER OF THE HOLLERITH
C                  FIELD IN THE CALL STATEMENT
C         I6     - LOCATION OF THE FIRST CHARACTER OF AN ARGUMENT
C         I7     - SUBSCRIPT VARIABLE
C         I8     - WORK AREA, COUNT OF APOSTROPHES OR QUOTATION MARKS
C         I9     - WORK AREA
C         I0     - WORK AREA
C         J      - SUBSCRIPT VARIABLE, LOCATION TO MOVE A CHARACTER
C         JA     - INDEX OF LITERALS START LOCATION IN ARRAY CLIT
C         JAPOS  - THE LOCATION OF AOSTROPHEES IN A STATEMENT
C         JB     - WORK AREA
C         JBITS  - EQUIVALENCED TO CWORK(45:48) - THE BIT SWITCHES
C         JD     - WORK AREA
C         JE     - COUNT OF THE NUMBER OF QUOTATION MARKS AND ALSO USED
C                  AS A WORK AREA
C         JF     - COUNT OF THE NUMBER OF APOSTROPHES
C         JG     - LOCATION OF THE INITIAL QUOTATION MARK IN A
C                  STATEMENT
C         JH     - LOCATION OF THE INITIAL APOSTROPHE IN A STATEMENT
C                  STATEMENT
C         JI     - LOCATION OF THE INITIAL EXCLAMATION MARK IN A
C                  STATEMENT
C         JINCL  - COUNT OF THE NUMBER OF FILE NAMES IN CIFILE THAT
C                  OCCUR IN AN INCLUDE STATEMENT
C         JLITLN - TRUE LENGTH OF A LITERAL FOR CALL STATEMENT ARGUMENTS
C         JQUOTE - THE LOCATION OF QUOTATION MARKS THAT DELIMIT LITERALS
C         JSLASH - THE LOCATION OF SLASHES IN A STATEMENT
C         JWK1   - WORK AREA
C         JWK2   - WORK AREA
C         J1     - COUNT OF THE NUMBER OF QUOTATION MARKS
C         J2     - COUNT OF THE NUMBER OF APOSTROPHES
C         J3     - LOCATION OF THE START OF A LITERAL
C         J4     - LOCATION OF THE END OF A LITERAL
C         J5     - VALUE OF KB UPON ENTRY TO THIS ROUTINE
C         J6     - COUNT OF THE TOTAL NUMBER OF SLASHES IN THE STATEMENT
C         J7     - COUNT OF THE TOTAL NUMBER OF SLASHES WITHIN A LITERAL
C         KARG   - COUNT OF THE ARGUMENT OF A LITERAL IN A CALL
C                  STATEMENT
C         KB     - END POINTER LOCATION OF THE LAST CHARACTER OF THE
C                  STATEMENT IN ARRAY CSTMT
C         KC     - DO LOOP VARIABLE
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KSLASH - COUNT OF THE NUMBER OF SLASHES IN A STATEMENT
C         L      - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC STATE-
C                  MENT HAS FORMAT AS THE FIRST SIX CHARACTERS, AND AN
C                  EQUAL SIGN OCCURS IN THE STATEMENT, SET FALSE
C                  OTHERWISE
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN TWO SUCCESSIVE QUOTE
C                  OR APOSTROPHES OCCUR WITHIN A LITERAL, SET FALSE
C                  OTHERWISE
C         LAPOS  - LOGICAL VARIABLE, SET TRUE WHEN LITERALS ARE
C                  ENCAPSULATED IN QUOTATION MARKS("); SET FALSE IF
C                  LITERALS ARE ENCAPSULATED IN APOSTROPHES(').
C         LB     - LOGICAL VARIABLE, SET TRUE FOR THE INITIAL STATEMENT
C                  READ OF THE PROGRAM BEING ANALYZED, SET FALSE FOR ALL
C                  SUBSEQUENT STATEMENTS
C         LC     - LOGICAL VARIABLE, INDICATES IF AN APOSTROPHE OCCURS
C                  BEFORE A DOUBLE QUOTATION MARK IN DEFINING A
C                  CHARACTER CONSTANT.
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LD     - LOGICAL VARIABLE, INDICATES IF A QUOTATION MARK
C                  OCCURS BEFORE A DOUBLE QUOTATION MARK IN DEFINING A
C                  CHARACTER CONSTANT.
C         LDATA  - LOGICAL VARIABLE, SET TRUE WHEN A DATA STATEMENT
C                  IS BEING PROCESSED, SET FALSE OTHERWISE
C         LE     - LOGICAL VARIABLE, SET TRUE WHEN COLUMN ONE OF THE
C                  FORTRAN INPUT RECORD IS A DOLLAR SIGN OR A SHARP SIGN
C                  SET FALSE OTHERWISE
C         LERR   - LOGICAL VARIABLE, SET TRUE WHEN AN UNBALANCED
C                  QUOTATION OR APOSTROPHE EXISTS, SET FALSE OTHERWISE
C         LF     - LOGICAL VARIABLE, SET TRUE WHEN AN EXCLAMATION MARK
C                  IS FOUND, SET FALSE OTHERWISE. USED TO PREVENT AN
C                  APOSTROPHE OR DOUBLE QUOTATION MARK BEING INTERPRETED
C                  AS A LITERAL WHEN ONE OCCURS AFTER THE EXCLAMATION
C                  SIGN.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFMT   - LOGICAL VARIABLE, SET TRUE WHEN THE STATEMENT IS A
C                  FORMAT STATEMENT, SET FALSE OTHERWISE
C         LFOR   - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST SIX
C                  CHARACTERS OF A STATEMENT ARE FORMAT, SET FALSE
C                  OTHERWISE
C         LG     - LOGICAL VARIABLE, SET TRUE WHEN THE STATEMENT BEING
C                  COMPRESSED IS A SUBPROGRAM CALL, SET FALSE OTHERWISE.
C                  THIS PERMITS A COUNT OF THE NUMBER OF ARGUMENTS IN A
C                  STATEMENT FOR LITERAL ARGUMENTS AND REMOVES HOLLERITH
C                  ARGUMENTS FROM THE STATEMENT. HOLLERITH ARGUMENTS
C                  WILL BE CONVERTED TO A LITERAL.
C         LH     - LOGICAL VARIABLE, SET TRUE IF AN EQUAL SIGN OCCURS
C                  IN THE STATEMENT, SET FALSE OTHERWISE
C         LI     - LOGICAL VARIABLE, SET TRUE WHEN A STATEMENT NUMBER
C                  EXISTS FOR THE CURRENT STATEMENT, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LRET   - LOGICAL VARIABLE, SET TRUE WHEN SUBROUTINE STMT07 IS
C                  CALLED, SET FALSE OTHERWISE.
C         LSNUM  - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER TO BE
C                  CATALOGED IS A STATEMENT NUMBER, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, USED AS A WORK VARIABLE, RETURNS
C                  THE NUMBER TYPE FROM SUBROUTINE NUMBER. SET TRUE IF
C                  THE NUMBER IS AN INTEGER, SET FALSE IF FLOATING POINT
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE STATEMENT IS TO
C                  COMPRESSED FOR THE SECOND TIME, SET FALSE OTHERWISE.
C         L3     - LOGICAL VARIABLE, SET TRUE TO DETERMINE AN INTEGER
C                  RETURN VALUE FROM ROUTINE NUMBER, SET FALSE TO RETURN
C                  A FLOATING VALUE.
C         L4     - LOGICAL VARIABLE, USED A WORK VARIABLE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A LITERAL LACKS
C                  MATCHING APOSTROPHES OR QUOTATION MARKS, SET FALSE
C                  OTHERWISE.
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A LITERAL TYPE
C                  DESIGNATION IS AT THE END OF THE LITERAL, SET FALSE
C                  OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN NO LITERALS EXIST
C                  IN THE REMAINDER OF A STATEMENT AND HAS NO LITERALS
C                  AFTER A LITERAL HAS BEEN PROCESSED, SET FALSE
C                  OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN AN APOSTROPHE EXISTS
C                  IN THE CURRENT STATEMENT, SET FALSE OTHERWISE.
C                  THIS IS USED TO INSURE THAT HOLLERITH FIELDS
C                  OCCURING WITHIN A LITERAL ARE IGNORED WHEN THEY ARE
C                  DEFINED WITHIN A LITERAL.
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN A QUOTATION MARK
C                  EXISTS IN THE CURRENT STATEMENT, SET FALSE OTHERWISE.
C                  THIS IS USED TO INSURE THAT HOLLERITH FIELDS
C                  OCCURING WITHIN A LITERAL ARE IGNORED WHEN THEY ARE
C                  DEFINED WITHIN A LITERAL.
C         L10    - LOGICAL VARIABLE, SET TRUE TO PREVENT THE MESSAGE
C                  IN FORMAT 101 FROM BEING WRITTEN, SET FALSE TO ALLOW
C                  THE MESSAGE TO BE WRITTEN.
C         L11    - LOGICAL VARIABLE, SET TRUE WHEN ALL LITERALS DEFINED
C                  WITH APOSTROPHES OR QUOTATION MARKS HAVE BEEN
C                  PROCESSED, SET FALSE TO SKIP INITIAL PROCESSING OF
C                  HOLLERITH FIELDS
C         L12    - LOGICAL VARIABLE, SET TRUE WHEN AN ODD NUMBER OF
C                  APOSTROPHES OCCUR, SET FALSE OTHERWISE
C         L13    - LOGICAL VARIABLE, SET TRUE WHEN AN ODD NUMBER OF
C                  QUOTATION MARKS OCCUR, SET FALSE OTHERWISE
C         L14    - LOGICAL VARIABLE, SET TRUE WHEN A RECORD WRITTEN
C                  ON UNIT 7 IN SUBROUTINE TESTR IS A RECORD DEFINTION,
C                  SET FALSE OTHERWISE. THIS IS USED TO PREVENT AN
C                  LOGICAL OPERATOR SYNTAX ERROR MESSAGE WHEN A COMPOUND
C                  VARIABLE NAME HAS MORE THAN ONE RECORD SPECIFICATION.
C         MNUM   - COUNT OF THE NUMBER OF ENTRIES INTO TABLE ISNUM
C
C     COMMENTS
C
C         FORMAT STATEMENTS ARE NOT PROCESSED EXCEPT FOR THE STATEMENT
C         NUMBER.
C
C         LITERALS ARE REMOVED FROM THE STATEMENT AND REPLACED WITH THE
C         CONSTANT HEX CF.  THIS PREVENTS MODIFICATION WHEN ALL LOWER
C         CASE ALPHABETIC CHARACTERS ARE FORCED TO UPPER CASE.
C
C         ALL LOGICAL CONSTANTS AND OPERATORS ARE REMOVED FROM THE
C         STATEMENT AND REPLACED WITH THE CONSTANT HEX CD. THE LOGICAL
C         CONSTANTS AND OPERATORS MAY BE IN EITHER UPPER OR LOWER CASE,
C         BUT THEY MAY NOT BE IN MIXED CASE. EXAMPLE: .OR. AND .or. ARE
C         PROCESSED, BUT .Or. AND .oR. WILL NOT BE PROCESSED.
C
C         ALL TEXT OCCURRING AFTER AN EXCLAMATION SIGN IS CONSIDERED
C         TO BE INLINE COMMENTS AND WILL BE DROPPED FROM THE STATEMENT
C         BY THIS ROUTINE.
C
C         THE HEXADECIMAL CHARACTER VARIABLES CX30, CX5A, CX60, & CX7A
C         ARE CODED FOR ASCII. THEY ARE USED TO SET RANGE LIMITS TO
C         DETERMINE IF A LOGICAL OPERATOR IS CORRECT OR INVALID.
C             CX30 IS A ZERO CHARACTER
C             CX5A IS AN UPPER CASE Z
C             CX60 IS THE ACCENT SYMBOL `
C             CX7A IS THE LOWER CASE z
C         FOR EBCDIC, THESE VALUES MUST BE CHANGED, AND ALL IF
C         STATMENTS USING THEM MUST BE RECODED. FOR EBCDIC COMPUTERS,
C         ADDITIONAL IF STATEMENTS MUST BE ADDED AND ADDITIONAL
C         HEXADECIMAL CONSTANTS DEFINED TO ACCOMPLISH THE VALIDATION OF
C         LOGICAL OPERATORS.
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 121 CHAR-
C                  ACTERS OR LESS
C         9      - LITERALS AND THE ISNS WHERE THEY OCCUR, RECORD LENGTH
C                  IS 92 CHARACTERS
C
C     SUBROUTINES CALLED
C
C         FMTSYN LOGERR NUMBER RBLANK SAPOSH TESTR
C
C     ******************************************************************
C
      SUBROUTINE COMPRS (IRET)
C
C         IMPLICIT STATEMENTS
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ILITWK(23), JAPOS(200), JQUOTE(200), JSLASH(200)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK, CLITWW
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE, CLIT
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*5     CWK5
      CHARACTER*4     CICTN, CISN, CIWK1, CIWK2, CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CX30, CX5A, CX60, CX7A
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 LA, LC, LD, LDATA, LE, LERR, LF, LFMT, LG, LH, LI,
     1          L1, L2, L4, L5, L6, L7, L8, L9, L10, L11, L12, L13, L14
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CLITWK(81:84),ILOC1), (CLITWK(85:88),ILOC2),
     1(CLITWK(89:92),ILOC3), (CLITWK(1:80),CLIT(1:80)), (CLITWK,ILITWK)
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK),
     1(CI4WK1,I4WK1), (CWORK(45:48),JBITS), (CWK8(2:2),CWK7)
      EQUIVALENCE (CISN,IISN), (CNAME(1),IENAME(1,1)), (ICTN,CICTN)
      EQUIVALENCE (IWK1,CIWK1), (IWK2,CIWK2), (KSLASH,ISLASH)
      EQUIVALENCE (CLITWW(81:84),JLOC1), (CLITWW(85:88),JLOC2),
     1(CLITWW(89:92),JLOC3)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CX30/'30'X/, CX5A/'5A'X/, CX60/'60'X/, CX7A/'7A'X/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' UNBALANCED PARENTHESES')
 101  FORMAT(' ISN:',I6,' LITERAL LACKS BALANCED '' OR "')
 102  FORMAT(' ISN:',I6,' MORE THAN 500 LITERALS IN A SINGLE STATEMENT')
 103  FORMAT(' ISN:',I6,' INCLUDE ARGUMENT NOT A LITERAL')
 104  FORMAT(' ISN:',I6,' FORMAT STATEMENT HAS NO STATEMENT NUMBER')
 105  FORMAT(I3)
 106  FORMAT(' ISN:',I6,' FORMAT HAS AN ILLEGAL CHARACTER: ',A9)
 107  FORMAT(' ISN:',I6,' HOLLERITH FIELD EXCEEDS 255 CHARACTERS')
 108  FORMAT(' ISN:',I6,' ILLEGAL STATEMENT NUMBER')
C
C         INITIALIZATION
C
      ID = 1
      JE = 0
      JF = 0
      JG = 0
      JH = 0
      JI = 0
      JLITLN = 0
      J5 = KB
      KARG = 0
      LG = LFALSE
      LH = LFALSE
      LFMT = LFALSE
      L1 = LTRUE
      L2 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      L9 = LFALSE
      L10 = LFALSE
      L11 = LFALSE
      I2WK1 = 0
      I4WK1 = 0
      LA = LFALSE
      LDATA = LFALSE
      LE = LFALSE
      LERR = LFALSE
      LF = LFALSE
      LFOR = LFALSE
      LI = LFALSE
      ILITCT = 0
      ILOC1 = 0
      IRET = 0
      IAPOS = 0
      IQUOTE= 0
      CWK8(1:7) = CBLANK(1:8)
      DO 10 I = 1,500
      CLITLN(I) = CBLANK(1:7)
 10   CONTINUE
C
C         DELETE ALL CHARACTERS BEYOND THE LOCATION SPECIFIED BY KB
C         IN CSTMT
C
      IF(KB .GT. 0) THEN
         DO 11 I = KB+1,6606
         CSTMT(I:I) = CBLANK(1:1)
 11      CONTINUE
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *                SEARCH FOR A STATEMENT NUMBER                   *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF A STATEMENT NUMBER IS VALID WHEN ONE EXISTS
C         CASE 1: ALL FIVE FIRST CHARACTERS ARE BLANK
C
      IF(CSTMT(1:5) .EQ. CBLANK(1:1)) THEN
         CONTINUE
C
C         CASE 2:
C         COLUMN ONE IS NOT A BLANK OR A NUMERICAL DIGIT, THERE
C         IS NO VALID STATEMENT NUMBER. THE STATEMENT'S COLUMN ONE
C         MAY CONTAIN OPERATING SYSTEM OR COMPILER DIRECTIVES
C
      ELSE IF(CSTMT(1:1) .NE. CBLANK(1:1) .OR. .NOT.(CSTMT(1:1) .LE. C0
     1   .AND. CSTMT(1:1) .LE. C9)) THEN
         CONTINUE
C
C        CASE 3:
C        VERIFY THAT COLUMNS 1 THROUGH FIVE CONTAIN A NUMERICAL VALUE
C
      ELSE
         DO I = 1,5
C
C         LOCATE THE FIRST DIGIT IN THE STATEMENT NUMBER FIELD
C
         IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9) THEN
C
C         LOCATE THE LAST DIGIT IN THE STATEMENT NUMBER FIELD
C
            DO IA = 5,I,-1
            IF(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9) THEN
C
C         WHEN MORE THAN 2 DIGITS EXIST, VERIFY THE STATEMENT NUMBER
C
               IF(IA - I .GT. 1) THEN
                  DO IB = I,IA
C
C         DETECT NON-NUMERIC CHARACTERS WITHIN THE STATEMENT NUMBER
C
                  IF(.NOT.(CSTMT(IB:IB) .GE. C0 .AND. CSTMT(IB:IB) .LE.
     1               C9)) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,108) ISN
C
C         REPLACE THE ERRONEOUS STATEMENT NUMBER WITH BLANKS
C
                     CSTMT(I:IA) = CBLANK(1:IA-I+1)
                     GO TO 111
                  END IF
                  END DO
               END IF
            END IF
            END DO
         END IF
         END DO
      END IF
C
C        WHEN A STATEMENT NUMBER EXISTS, IT IS STORED IN ARRAY ISNUM,
C        AND THE NUMBER IS REMOVED FROM THE FORTRAN STATEMENT.
C
 111  DO 14 I = ID,KB
C
C         TEST IF A DIGIT FOUND
C
      IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9) THEN
         LI = LTRUE
         GO TO 12
      ELSE
         LI = LFALSE
C
C         DETERMINE IF COLUMN 1 OF THE RECORD IS A $ OR A # SYMBOL.
C         THEY INDICATE COMPILER DIRECTIVES AND ARE NOT FORTRAN
C         STATEMENTS.
C
         IF(CSTMT(I:I) .EQ. CDOL .OR. CSTMT(I:I) .EQ. CSHARP) THEN
            LE = LTRUE
            GO TO 35
         END IF
C
C         TEST FOR AN ALPHABETIC CHARACTER, SET THE LOCATION FOR THE
C         START OF THE STATEMENT
C
         IF(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ .OR.
     1      CSTMT(I:I) .GE. CAS .AND. CSTMT(I:I) .LE. CZS .OR.
     2      CSTMT(I:I) .EQ. CUNDER) THEN
            KF = I
            I7 = I
            GO TO 15
         END IF
         GO TO 14
      END IF
C
C         LOCATE THE LAST NUMERIC CHARACTER OF THE STATEMENT NUMBER
C
 12   DO 13 IA = I,KB
      IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9)) THEN
C
C         CONVERT THE STATEMENT NUMBER TO AN INTEGER
C
         IC = IA - 1
         LSNUM = LTRUE
         L1 = LTRUE
         CALL NUMBER (CSTMT,L1,I,I4WK1,FP,IFP)
         LSNUM = LFALSE
         IF(.NOT.LINCL) THEN
            MNUM = MNUM + 1
            ISNUM(1,MNUM) = I4WK1
            ISNUM(2,MNUM) = ISN
            IF(IA .LT. 7) CSTMT(1:IA) = CBLANK(1:IA)
         END IF
         LI = LTRUE
         ID = IA
         KF = 7
         GO TO 15
      END IF
 13   CONTINUE
 14   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE IF THIS IS A FORMAT OR DATA STATEMENT. A FORMAT    *
C     *   IS PROCESSED TO OBTAIN ITS STATEMENT NUMBER, WHICH IS DONE   *
C     *   IN THE ABOVE SEGMENT.                                        *
C     *                                                                *
C     ******************************************************************
C
 15   CWK7(1:7) = CSTMT(KF:KF+5)//CBLANK(1:1)
      CI2WK1(1:2) = CBLANK(1:2)
      IF(CSTMT(KF:KF) .EQ. CDD) THEN
         CWK7(1:4) = CSTMT(KF:KF+3)//CBLANK(1:3)
C
C         DETERMINE IF THIS IS A DATA STATEMENT
C
         IF(CWK7(1:4) .EQ. 'DATA') THEN
            LDATA = LTRUE
            L4 = LFALSE
            GO TO 18
         END IF
      END IF
      DO 17 IA = KF,KB
      IF(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ .AND.
     1   CSTMT(IA:IA) .NE. CFF) THEN
         GO TO 18
      ELSE
         CWK7(1:7) = CSTMT(IA:IA+5)//CBLANK(1:1)
C
C         FORCE TO UPPER CASE FOR FORMAT TEST
C
         DO 16 I = 1,6
         CI2WK1(1:1) = CWK7(I:I)
         IF(CI2WK1(1:1) .GE. CAS .AND. CI2WK1(1:1) .LE. CZS) THEN
            I2WK1 = I2WK1 - ICAPS
            CWK7(I:I) = CI2WK1(1:1)
         END IF
 16      CONTINUE
C
C         DETERMINE IF THIS IS A FORMAT STATEMENT OR AN ARITHMETIC
C         STATEMENT WITH FORMAT AS A VARIABLE NAME
C
         CWK7(1:7) = CSTMT(IA:IA+5)//CBLANK(1:1)
         IF(CWK7(1:6) .EQ. 'FORMAT') THEN
C
C         SET DO LOOP START LOCATION TO SEARCH FOR HOLLERITH FIELDS
C
            I7 = 8
C
C         SEARCH FOR AN EQUAL SIGN NOT ENCAPSULATED WITHIN A LEFT AND
C         A RIGHT PARENTHESIS
C
            I1 = 0
            LH = LFALSE
            DO 160 I = 7,KB
            IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
            IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               LH = LTRUE
               GO TO 161
            END IF
 160        CONTINUE
 161        IF(LH) THEN
               IF(I1 .EQ. 0) THEN
                  LFMT = LFALSE
                  LFOR = LFALSE
               ELSE
                  LFMT = LTRUE
                  LFOR = LTRUE
               END IF
            ELSE
               LFMT = LTRUE
               LFOR = LTRUE
            END IF
            LH = LFALSE
C
C         DETERMINE IF A STATEMENT NUMBER EXISTS FOR A FORMAT STATEMENT
C         AND WRITE A MESSAGE IF NONE EXISTS
C
            IF(.NOT.LINCL .AND. .NOT.LI .AND. LFOR) THEN
               WRITE (0,104) ISN
               IREC0 = IREC0 + 1
               LI = LFALSE
            END IF
            GO TO 18
         END IF
      END IF
 17   CONTINUE
C
C         DETERMINE IF THE CURRENT STATEMENT CONTAINS AN APOSTROPHE, A
C         QUOTATION MARK, OR AN EXCLAMATION MARK
C
 18   DO 19 I = 7,KB
      IF(CSTMT(I:I) .EQ. CEXCL(1:1) .AND. .NOT.LF) THEN
         JI = I
         LF = LTRUE
      END IF
      IF(CSTMT(I:I) .EQ. CAPOS(1:1)) THEN
         JH = I
         L8 = LTRUE
         GO TO 20
      END IF
      IF(CSTMT(I:I) .EQ. CAPOSD(1:1)) THEN
         IQUOTE = IQUOTE + 1
         JG = I
         L9 = LTRUE
         GO TO 20
      END IF
 19   CONTINUE
C
C         COUNT THE NUMBER OF APOSTROPHES AND QUOTATION MARKS
C
 20   KSLASH = 0
      DO 21 I = 7,KB
C
C         COUNT APOSTROPHES
C
      IF(L8 .AND. CSTMT(I:I) .EQ. CAPOS) THEN
         IAPOS = IAPOS + 1
         JAPOS(IAPOS) = I
      END IF
C
C         COUNT QUOTATION MARKS
C
      IF(L9 .AND. CSTMT(I:I) .EQ. CAPOSD) THEN
         IQUOTE = IQUOTE + 1
         JQUOTE(IQUOTE) = I
      END IF
C
C         COUNT SLASHES
C
      IF(CSTMT(I:I) .EQ. CSLASH) THEN
          KSLASH = KSLASH + 1
          JSLASH(KSLASH) = I
      END IF
 21   CONTINUE
C
C         SET SWITCHES WHEN AN ODD NUMBER OF APOSTROPHES OR QUOTATION
C         MARKS OCCUR
C
      IF(MOD(IAPOS,2) .GT. 0) THEN
         L12 = LTRUE
      ELSE
         L12 = LFALSE
      END IF
      IF(MOD(IQUOTE,2) .GT. 0) THEN
         L13 = LTRUE
      ELSE
         L13 = LFALSE
      END IF
C
C         WHEN AN EXCLAMATION MARK EXISTS AND AN APOSTROPHE OR A
C         QUOTATION MARK EXIST, DETERMINE IF THE APOSTROPHE OR
C         QUOTATION MARK FOLLOWS THE EXCLAMATION MARK.
C
      IF(LF) THEN
         IF(JI .GT. 0) THEN
            IF(L8 .OR. L9) L10 = LTRUE
         END IF
      END IF
C
C         WHEN A SINGLE APOSTROPHE OR QUOTATION MARK OCCURS, THERE CAN
C         NOT BE ANY LITERALS. SEARCH FOR POSSIBLE HOLLERITH FIELDS.
C
C     *****************************************************************
C     *                                                               *
C     *  SEARCH FOR HOLLERITH FIELDS                                  *
C     *                                                               *
C     *****************************************************************
C
C         SET DO LOOP TO SEARCH FOR H OR h OCCURRING IN THE STATEMENT.
C         THIS MAY BE A HOLLERITH FIELD. IF IT IS A HOLLERITH FIELD, THE
C         FIELD IS REPLACED WITH ITS LITERAL EQUIVALENT. FORMAT
C         STATEMENTS ARE NOT PROCESSED BY THIS LOOP.
C
C         HOLLERITH FIELDS MAY OCCUR ONLY IN DATA, CALL STATEMENTS, AND
C         OUTPUT FORMAT STATEMENTS.
C
 22   L11 = LTRUE
      DO 28 I = I7,KB
C
C         WHEN AN ASTERISK IS FOUND, DETERMINE IF IT IS THE LENGTH
C         SPECIFICATION FOR A TYPE STATEMENT
C
      IF(CSTMT(I:I) .EQ. CASTER) THEN
         IF(CSTMT(I7:I7+8) .EQ. 'CHARACTER') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'COMPLEX') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'INTEGER') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'LOGICAL') GO TO 32
         IF(CSTMT(I7:I7+8) .EQ. 'PRECISION') GO TO 32
         IF(CSTMT(I7:I7+8) .EQ. 'character') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'complex') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'integer') GO TO 32
         IF(CSTMT(I7:I7+6) .EQ. 'logical') GO TO 32
         IF(CSTMT(I7:I7+8) .EQ. 'precision') GO TO 32
         IF(CSTMT(I7:I7+3) .EQ. 'real') GO TO 32
C
C         WHEN AN ASTERISK EXISTS IN A STATEMENT AND IT IS NOT THE
C         LENGTH SPECIFICATION OF A TYPE DEFINITION STATEMENT, DETERMINE
C         IF IT MAY OCCUR IN A FORMAT STATEMENT.
C
         I9 = 7
         DO WHILE (I9 .LT. KB)
            IF(CSTMT(I9:I9+5) .EQ. 'FORMAT' .OR. CSTMT(I9:I9+5) .EQ.
     1         'format') THEN
               I1 = I9 + 6
               DO WHILE (I1 .LT. KB)
                  IF(CSTMT(I1:I1) .EQ. CLPAR(1:1)) THEN
                     LFOR = LTRUE
                     LFMT = LTRUE
                     GO TO 220
                  ELSE
                     I1 = I1 + 1
                  END IF
               END DO
            END IF
C
C         DETERMINE IF THE ASTERISK IS THE REPEAT INDICATOR FOR A DATA
C         STATEMENT HOLLERITH FIELD
C
            IF(CSTMT(I9:I9+3) .EQ. 'DATA' .OR. CSTMT(I9:I9+3) .EQ.
     1         'data') THEN
               I1 = I + 1
               DO WHILE (I1 .LT. KB)
               IF(CSTMT(I1:I1) .EQ. CHH .OR. CSTMT(I1:I1) .EQ. 'h' .AND.
     1            CSTMT(I1-1:I1-1) .GE. C0 .AND. CSTMT(I1-1:I1-1) .LE.
     2            C9) GO TO 23
               I1 = I1 + 1
               END DO
            END IF
            I9 = I9 + 1
         END DO
      END IF
C
C         WHEN AN H OR AN h IS FOUND, DETERMINE IF IT A NUMERICAL
C         DIGIT PRECEDES THE H OR h.
C
 220  IF(CSTMT(I:I) .EQ. CHH .OR. CSTMT(I:I) .EQ. 'h') THEN
C
C         DETERMINE IF THE H OCCURS BETWEEN TWO APOSTROPHES.
C
         IF(IAPOS .GT. 0 .AND. MOD(IAPOS,2) .EQ. 0) THEN
            DO I10 = 1,IAPOS,2
            IF(I .GT. JAPOS(I10) .AND. I .LT. JAPOS(I10+1))
     1         GO TO 29
            END DO
         END IF
C
C         DETERMINE IF THE H OCCURS BETWEEN TWO QUOTATION MARKS
C
         IF(IQUOTE .GT. 0 .AND. MOD(IQUOTE,2) .EQ. 0) THEN
            DO I10 = 1,IQUOTE,2
            IF(I .GT. JQUOTE(I10) .AND. I .LT. JQUOTE(I10+1))
     1         GO TO 29
            END DO
         END IF
C
C         WHEN THE FIRST CHARACTER OF THE STATEMENT IS H OR h, THIS CAN
C         NOT BE A HOLLERITH FIELD
C
         IF(I. EQ. I7) GO TO 28
C
C         WHEN THIS IS A DATA STATEMENT, AN H OCCURING AFTER A SLASH
C         IS SKIPPED
C
         IF(LDATA .AND. ISLASH .GT. I) GO TO 28
         IF(LDATA .AND. ISLASH .GT. I .AND. ISLASH .NE. KB) GO TO 28
C
C         WHEN THE STATEMENT CONTAINS .H OR .( OR A BLANK, SKIP THE
C         CURRENT CHARACTER
C
         IF(CSTMT(I-1:I-1) .EQ. CDOT .OR. CSTMT(I-1:I-1) .EQ. CLPAR .OR.
     1      CSTMT(I-1:I-1) .EQ. CBLANK(1:1)) GO TO 28
C
C         DETERMINE IF THE H OCCURS BETWEEN SLASHES WHEN THE STATEMENT
C         IS A DATA STATEMENT
C
         IF(LDATA .AND. KSLASH .GT. 1) THEN
            DO I9 = 1,KSLASH
            IF(I .LT. JSLASH(I9)) THEN
               IF(I .GT. JSLASH(I9-1)) THEN
                  IF(IAPOS .GT. 1) THEN
                     DO I10 = 1,IAPOS
                     IF(I .LT. JAPOS(I10)) THEN
                        IF(I10 .GT. 1 .AND. I .GT. JAPOS(I10-1))
     1                     GO TO 28
                     END IF
                     END DO
                  END IF
                  IF(IQUOTE .GT. 1 .AND. MOD(IQUOTE,2) .GT. 0) THEN
                     DO I10 = 1,IQUOTE
                     IF(I .LT. JAPOS(I10)) THEN
                        IF(I .GT. JAPOS(I10-1)) GO TO 28
                     END IF
                     END DO
                  END IF
               END IF
            END IF
            END DO
         END IF
         IF(CSTMT(I-1:I-1) .GE. C0 .AND. CSTMT(I-1:I-1) .LE. C9) THEN
            IF(L8 .AND. I .LT. JH) GO TO 23
C
C         LOCATE THE CHARACTER THAT TERMINATES THE NUMERIC FIELD
C         PRECEDING THE H OR h
C
            I9 = I - 1
            DO WHILE (CSTMT(I9:I9) .GE. C0 .AND. CSTMT(I9:I9) .LE. C9)
               I9 = I9 - 1
            END DO
C
C         WHEN A COMMA, A SLASH, A LEFT PARENTHESIS, OR A BLANK IS
C         THE LEFT BOUNDARY OF THE NUMERICAL FIELD, THIS IS A HOLLERITH
C         FIELD
C
            IF(CSTMT(I9:I9) .EQ. CSLASH .OR. CSTMT(I9:I9) .EQ. COMMA
     1         .OR. CSTMT(I9:I9) .EQ. CLPAR .OR. CSTMT(I9:I9) .EQ.
     2         CBLANK(1:1)) GO TO 23
         ELSE
C
C         LOCATE THE PRIOR CHARACTER PRECEDING THE CURRENT CHARACTER
C         WHEN THE CHARACTER IS NOT NUMERIC
C
            IF(CSTMT(I-1:I-1) .EQ. CBLANK(1:1)) THEN
               I9 = I - 1
               DO WHILE (CSTMT(I9:I9) .EQ. CBLANK(1:1))
               I9 = I9 - 1
               END DO
            END IF
C
C         WHEN THE CHARACTER PRECEDING THE H OR h IS NOT A DIGIT, THIS
C         CAN NOT BE A HOLLERITH FIELD
C
            IF(CSTMT(I9:I9) .EQ. COMMA) GO TO 28
         END IF
         IF(L8 .AND. JH .LT. I) GO TO 28
         IF(L9 .AND. JG .LT. I) GO TO 28
      END IF
C
C         WHEN AN H OR AN h IS FOUND, IT MUST BE PRECEDED BY A NUMBER
C         TO BE CONSIDERED AS A POSSIBLE HOLLERITH FIELD
C
 23   IF(CSTMT(I:I) .EQ. CHH .OR. CSTMT(I:I) .EQ. 'h') THEN
         IF(CSTMT(I-1:I-1) .GE. C0 .AND. CSTMT(I-1:I-1) .LE. C9 .OR.
     1      CSTMT(I-1:I-1) .EQ. CBLANK(1:1)) THEN
C
C         SCAN BACKWARDS TO DETERMINE IF THE CHARACTER H AT LOCATION I
C         REALLY REPRESENTS A HOLLERITH FIELD. I IS THE LOCATION OF H.
C
            I9 = I - 1
            DO WHILE (I9 .GE. I7)
            IF(CSTMT(I9:I9) .GE. CAA .AND. CSTMT(I9:I9) .LE. CZZ .OR.
     1         CSTMT(I9:I9) .EQ. CPLUS .OR. CSTMT(I9:I9) .EQ. CMINUS
     2         .OR. CSTMT(I9:I9) .EQ. CEQ) GO TO 28
            IF(CSTMT(I9:I9) .EQ. CASTER .OR. CSTMT(I9:I9) .EQ. CSLASH)
     1         THEN
               IF(CSTMT(I9+1:I9+1) .GE. C0 .AND. CSTMT(I9+1:I9+1) .LE.
     1            C9) GO TO 230
            END IF
            IF(CSTMT(I9:I9) .EQ. CBLANK(1:1) .OR. CSTMT(I9:I9) .EQ.
     1         COMMA(1:1) .OR. CSTMT(I9:I9) .EQ. CLPAR(1:1)) GO TO 230
               I9 = I9 - 1
            END DO
         ELSE
            GO TO 28
         END IF
C
C         SCAN BACKWARDS FOR AN APOSTROPHE OR QUOTATION MARK IF THE
C         CHARACTERS ", FOLLOW THE H. IF AN ASTERISK OCCURS, THE
C         NUMERIC VALUE IS A LENGTH SPECIFICATION OF A TYPE STATEMENT
C
 230     IF(CSTMT(I+1:I+2) .EQ. ''',' .OR. CSTMT(I+1:I+2) .EQ. '",')
     1      THEN
            I2 = I - 1
            DO 24 I7 = I2,7,-1
            IF(L8) THEN
               IF(CSTMT(I7:I7) .EQ. CAPOS .OR. CSTMT(I7:I7) .EQ. CAPOSD)
     1            GO TO 28
            END IF
            IF(CSTMT(I7:I7) .EQ. CASTER) THEN
               IF(LFMT) THEN
                  WRITE (0,106) ISN,CSTMT(I7-4:I7+4)
                  IREC0 = IREC0 + 1
               ELSE
                  GO TO 32
               END IF
            END IF
 24         CONTINUE
         ELSE
C
C         NO APOSTROPHE OR QUOTATION MARKS EXIST
C
            IF(CSTMT(I9:I9) .EQ. CBLANK(1:1) .OR. CSTMT(I9:I9) .EQ.
     1         COMMA(1:1) .OR. CSTMT(I9:I9) .EQ. CLPAR(1:1)) THEN
            END IF
         END IF
         I2 = I - 1
         DO 26 I1 = I9,7,-1
C
C         WHEN A NON NUMERIC CHARACTER IS FOUND, IT LOCATES THE START
C         OF THE LENGTH FIELD OF THE HOLLERITH FIELD.
C
         IF(.NOT.(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9)) THEN
             I3 = I1 + 1
             GO TO 27
         END IF
C
C         WHEN A BLANK CHARACTER PRECEDES AN H BEFORE A NUMERICAL DIGIT
C         IS FOUND, SKIP OVER THE BLANK CHARACTER. L4 IS SET TRUE
C         WHEN A DIGIT PRECEDES THE H.
C
         IF(.NOT.L4 .AND. CSTMT(I1:I1) .EQ. CBLANK(1:1)) GO TO 26
C
C         DETERMINE IF A DIGIT HAS BEEN FOUND
C
         IF(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9) THEN
            IF(.NOT.L4) THEN
               L4 = LTRUE
               IF(I1 .EQ. 7) THEN
                  I3 = 7
                  GO TO 27
               ELSE IF(I1 .GT. 7) THEN
                  GO TO 26
               END IF
            END IF
         ELSE
C
C         WHEN THE CHARACTER PRECEDING AN H IS AN ALPHABETIC CHARACTER,
C         THE H CHARACTER DOES NOT DESIGNATE A HOLLERITH FIELD.
C
            IF(CSTMT(I1:I1) .GE. CAA .AND. CSTMT(I1:I1) .LE. CZZ)
     1         GO TO 28
C
C         THE CURRENT CHARACTER IS NOT A DIGIT. ANY CHARACTER OTHER THAN
C         A LEFT PARENTHESIS, SLASH, ASTERISK, COMMA, OR A BLANK
C         TERMINATES THIS FIELD; IT CAN NOT BE A HOLLERITH FIELD.
C
            IF(CSTMT(I1:I1) .EQ. CLPAR .OR. CSTMT(I1:I1) .EQ. COMMA .OR.
     1         CSTMT(I1:I1) .EQ. CSLASH .OR. CSTMT(I1:I1) .EQ.
     2         CBLANK(1:1) .OR. CSTMT(I1:I1) .EQ. CASTER) THEN
               IF(L4) THEN
C
C         DETERMINE IF THE PRECEDING CHARACTERS TO THE CURRENT ONE
C         MAY BE A LITERAL START
C
                  IF(CSTMT(I1-2:I1-1) .EQ. ',''' .OR. CSTMT(I1-2:I1-1)
     1               .EQ. ',"') THEN
                     DO 25 IG = I1,KB
                     IF(CSTMT(I1-1:I1-1) .EQ. CAPOS) THEN
                        IF(CSTMT(IG:IG) .EQ. CAPOS) GO TO 29
                     END IF
                     IF(CSTMT(I1-1:I1-1) .EQ. CAPOSD) THEN
                        IF(CSTMT(IG:IG) .EQ. CAPOSD) GO TO 29
                     END IF
 25                  CONTINUE
                  END IF
                  I3 = I1 + 1   ! LOCATION OF FIELD LENGTH'S FIRST DIGIT
                  L4 = LFALSE
                  GO TO 27
               ELSE
                  GO TO 29
               END IF
               GO TO 26
            END IF
            GO TO 29
         END IF
 26      CONTINUE
C
C         DETERMINE THE LOCATION OF THE END OF THE HOLLERITH STRING.
C         AT THIS POINT I3 IS THE LOCATION OF THE FIRST DIGIT OF THE
C         STRING'S LENGTH; I IS THE LOCATION OF H OR h .
C
 27      I4 = I - I1 - 1           ! NUMBER OF DIGITS IN FIELD LENGTH
         CWK5(1:5) = CBLANK(1:5)
         CWK5(1:I-1) = CSTMT(I3:I-1)
         READ (CWK5,105) I2WK1
C
C         DETERMINE IT A HOLLERITH FIELD EXCEEDS 255 CHARACTERS
C
         IF(I2WK1 .GT. 255) THEN
            WRITE (0,107) ISN
            IREC0 = IREC0 + 1
            I2WK1 = 255
         END IF
         JLITLN = I2WK1
         I5 = I + I2WK1            ! DATA FIELD LENGTH END LOCATION
C
C         DETERMINE IF THE POSSIBLE HOLLERITH FIELD IS TERMINATED BY
C         A COMMA, A SLASH, A RIGHT PARENTHESIS, A BLANK, OR A DIGIT
C
         I7 = I5 + 1                     ! FOLLOWING CHARACTER LOCATION
         IF(CSTMT(I7:I7) .EQ. COMMA .OR. CSTMT(I7:I7) .EQ. CSLASH .OR.
     1      CSTMT(I7:I7) .EQ. CRPAR .OR. CSTMT(I7:I7) .EQ. CBLANK(1:1)
     2      .OR. (CSTMT(I7:I7) .GE. C0 .AND. CSTMT(I7:I7) .LE. C9))
     2      THEN
            CALL SAPOSH (CSTMT,I3,I,I5,KB,ISN)
C
C         IF AN APOSTROPHE OCCURED IN THE HOLLERITH FIELD JUST
C         PROCESSED, RESET L8 FOR THE NEXT HOLLERITH FIELD
C
            L8 = LFALSE
            L4 = LFALSE
C
C         AN ILLEGAL CHARACTER EXISTS IN A FORMAT
C
         ELSE
            IF(LFMT) THEN
               WRITE (0,106) ISN,CSTMT(I7-4:I7+4)
               IREC0 = IREC0 + 1
               CALL SAPOSH (CSTMT,I3,I,I5,KB,ISN)
            END IF
         END IF
         IF(CSTMT(I7:I7) .EQ. COMMA) THEN
            I7 = I7 + 1
            GO TO 22
         END IF
C
C         DETERMINE IF THE END OF THE CURRENT STATEMENT HAS BEEN
C         REACHED
C
         IF((CSTMT(I7:I7) .EQ. CSLASH .AND. I7+1 .GE. KB) .OR.
     1      (CSTMT(I7:I7+1) .EQ. '))' .AND. I7+1 .GE. KB)) THEN
            IF(LFMT) THEN
               GO TO 32
            ELSE
               GO TO 29
            END IF
         END IF
C
C         ADJUST I7 WHEN NO NORMAL SEPARATOR EXISTS IN A FORMAT
C         STATEMENT
C
         GO TO 20
      END IF
 28   CONTINUE
C
C         DETERMINE IF THIS IS A CALL STATEMENT
C
 29   DO 31 I = KF,KB
      IF(CSTMT(I:I+3) .EQ. 'CALL') THEN
         IF(CSTMT(I+4:I+4) .GE. CAA .AND. CSTMT(I+4:I+4) .LE. CZZ .OR.
     1      CSTMT(I+4:I+4) .EQ. CUNDER .OR. CSTMT(I+4:I+4) .GE. C0 .AND.
     2      CSTMT(I+4:I+4) .LE. C9 .OR. CSTMT(I+4:I+4) .EQ. CBLANK(1:1))
     3      THEN
            LG = LTRUE
            I4 = 0
            DO 30 IA = I,KB
            IF(CSTMT(IA:IA) .EQ. CLPAR) I4 = I4 + 1
            IF(CSTMT(IA:IA) .EQ. CRPAR) I4 = I4 - 1
            IF(CSTMT(IA:IA) .EQ. CEQ) THEN
               IF(I4 .EQ. 0) LG = LFALSE
            END IF
 30         CONTINUE
         END IF
         GO TO 32
      END IF
 31   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *   SCAN THE ENTIRE STATEMENT FOR QUOTATION MARKS AND            *
C     *   APOSTROPHES IDENTIFING CHARACTER CONSTANTS (LITERALS).       *
C     *                                                                *
C     ******************************************************************
C
C         REMOVE ALL LINE COMMENTS IN THE COMPLETE FORTRAN STATEMENT
C         BEFORE PROCESSING LITERALS ENCAPSULATED BY APOSTROPHES OR
C         QUESTION MARKS.
C
 32   CALL DELCOM
C
C         UPON RETURN FROM ROUTINE DELCOM, ALL LINE COMMENTS HAVE BEEN
C         REMOVED FROM THE STATEMENT.
C
C         THE FOLLOWING CODE WILL WRITE ALL LITERALS ON UNIT 9 AND
C         WILL HAVE THE ENTIRE LITERAL REPLACED WITH THE HEXADECIMAL
C         VALUE 'CF'X IN THE FORTRAN STATEMENT.
C
      IH = 0
      J1 = 0
      J2 = 0
      J6 = 0
      DO 33 I = ID,KB
C
C         COUNT THE TOTAL NUMBER OF QUOTATION MARKS AND APOSTROPHES
C
      IF(CSTMT(I:I) .EQ. CAPOSD) J1 = J1 + 1
      IF(CSTMT(I:I) .EQ. CAPOS) J2 = J2 + 1
C
C         COUNT THE TOTAL NUMBER OF SLASHES. WHEN J6 BECOMES GREATER
C         THAN TWO, A LITERAL MAY CONTAIN A SLASH
C
      IF(CSTMT(I:I) .EQ. CSLASH) J6 = J6 + 1
 33   CONTINUE
      DO 34 I = ID,KB
C
C         COUNT A QUOTATION MARK ONLY WHEN IT IS NOT A LITERAL. THIS IS
C         THE QUOTATION MARK CASE.
C
      IF(CSTMT(I:I) .EQ. CAPOSD) THEN
         JE = JE + 1
         IF(JG .EQ. 0) JG = I
      END IF
C
C         COUNT AN APOSTROPHE ONLY WHEN IT IS NOT A LITERAL. THIS IS
C         THE APOSTROPHE CASE.
C
      IF(CSTMT(I:I) .EQ. CAPOS) THEN
         JF = JF + 1
         IF(JH .EQ. 0) JH = I
      END IF
C
C         MOVE THE FIRST FIVE NON BLANK CHARACTERS TO THE WORK AREA
C
      IF(IH .LE. 5 .AND. CSTMT(I:I) .NE. CBLANK(1:1)) THEN
         IH = IH + 1
         CWK5(IH:IH) = CSTMT(I:I)
      END IF
C
C         DETERMINE IF AN EQUAL SIGN OCCURS IN THE STATEMENT
C
      IF(CSTMT(I:I) .EQ. CEQ) LH = LTRUE
 34   CONTINUE
C
C         DETERMINE IF QUOTATION MARKS OCCUR
C
      IF(JE .GT. 0) THEN
C
C         DETERMINE IF AN EVEN NUMBER OF QUOTATION MARKS OCCUR
C
         IF(MOD(JE,2) .GT. 0) THEN
C
C         WHEN AN APOSTROPHE OCCURS BEFORE A QUOTATION MARK, THE
C         QUOTATION MARK MUST BE PART OF A LITERAL
C
            IF(JH .LT. JG) JE = JE - 1
         END IF
      END IF
C
C         DETERMINE IF APOSTROPHES OCCUR
C
      IF(JF .GT. 0) THEN
C
C         DETERMINE IF AN EVEN NUMBER OF APOSTROPHES MARKS OCCUR
C
         IF(MOD(JF,2) .GT. 0) THEN
C
C         WHEN A QUOTATION MARK OCCURS BEFORE AN APOSTROPHE, THE
C         QUOTATION MARK MUST BE PART OF A LITERAL
C
            IF(JG .LT. JH) JE = JE - 1
         END IF
      END IF
C
C         WRITE DIAGNOSTIC IF UNMATCHED QUOTATION MARKS OR APOSTROPHES
C
      IF(MOD(JE,2) .NE. 0 .OR. MOD(JF,2) .NE. 0 .AND. .NOT.LINCL) THEN
         IF(.NOT.L10) THEN
            WRITE (0,101) ISN
            IREC0 = IREC0 + 1
            LERR = LTRUE
         END IF
      END IF
C
C         SEARCH FOR LITERALS IN THE STATEMENT
C
      J = KF
      ILOC3 = 0
      ILOC4 = 0
 35   DO 52 I = J,KB
C
C         WHEN THE CHARACTER IS A COMMA OR SLASH, SKIP OVER IT
C
      IF(CSTMT(I:I) .EQ. COMMA .OR. CSTMT(I:I) .EQ. CSLASH .OR.
     1   CSTMT(I:I) .EQ. CBLANK) THEN
C
C         DETERMINE IF THE SECOND CHARACTER IS A COMMA AND THE FIRST
C         CHARACTER IS A QUOTATION MARK
C
         IF(I .GT. J) THEN
            IF(CSTMT(I:I) .EQ. COMMA .AND. CSTMT(I-1:I-1) .EQ. CAPOSD)
     1         THEN
               CONTINUE
            ELSE
               GO TO 52
            END IF
         ELSE
            GO TO 52
         END IF
      END IF
C
C         TEST IF AN EXCLAMATION SIGN HAS OCCURRED. NO APOSTROPHES OR
C         QUOTATION SIGNS MAY BE TREATED AS A LITERAL AFTER THE LOCATION
C         OF THE EXCLAMATION SIGN IF THEY ARE NOT PART OF A LITERAL.
C
      IF(LF .OR. CSTMT(I:I) .EQ. CEXCL) THEN
C
C         SCAN BACKWARDS TO LOCATE THE FINAL CHARACTER OF THE STATEMENT
C
         DO 37 I2WK1 = KB,1,-1
         IF(CSTMT(I2WK1:I2WK1) .NE. CBLANK) THEN
            KB = I2WK1
            GO TO 53
         END IF
 37      CONTINUE
      END IF
C
C         SCAN FOR A QUOTATION MARK. WHEN A QUOTATION MARK OCCURS, IT
C         MAY BE THE START OF A LITERAL. IF SO, ALL APOSTORPHES ARE
C         TREATED AS NORMAL CHARACTERS.
C
      IF(CSTMT(I:I) .EQ. CAPOSD) THEN
C
C         THE START OF A LITERAL HAS BEEN FOUND, LOCATE THE END OF THE
C         LITERAL
C
         J1 = 1
         J3 = I
         J7 = 0
         IF(ILOC3 .EQ. 0) ILOC3 = I
         IB = I + 1
         DO 38 IA = IB,KB
C
C         SKIP OVER ALL CHARACTERS OTHER THAN A COMMA, SLASH, OR
C         QUOTATION MARKS
C
         IF(CSTMT(IA:IA) .EQ. COMMA) THEN
            CONTINUE
         ELSE IF(CSTMT(IA:IA) .EQ. CSLASH) THEN
            CONTINUE
         ELSE IF(CSTMT(IA:IA) .EQ. CAPOSD) THEN
            J4 = IA
         ELSE
            GO TO 38
         END IF
C
C         TEST FOR QUOTATION MARKS
C
         IF(CSTMT(IA:IA) .EQ. CAPOSD) THEN
            JE = JE + 1
            ILOC1 = IA - I + 1
C
C         DETERMINE IF THIS QUOTATION MARK IS THE END OF THE LITERAL
C
            IF(CSTMT(IA-1:IA-1) .NE. CAPOSD .AND. CSTMT(IA+1:IA+1)
     1         .NE. CAPOSD) THEN
               ILOC3 = I
               ILOC4 = IA
               JE = IA
               GO TO 40
            END IF
C
C         SKIP DOUBLE QUOTATION MARKS
C
            IF(CSTMT(IA+1:IA+1) .EQ. CAPOSD) THEN
               JE = JE - 1
               GO TO 38
            ELSE
               IF(MOD(JE,2) .EQ. 0) THEN
                  JE = IA
                  IE = IA
                  GO TO 40
               END IF
            END IF
            IF(CSTMT(IA-1:IA-1) .EQ. CAPOSD) GO TO 38
            IF(MOD(JE,2) .EQ. 0) THEN
               JE = IA
               IE = IA
               GO TO 40
            END IF
         ELSE
C
C         DETERMINE IF A COMMA IS PART OF THE LITERAL
C
            IF(CSTMT(IA:IA) .EQ. COMMA) THEN
               IF(CSTMT(IA+1:IA+1) .NE. CAPOSD .AND.
     1            CSTMT(IA+1:IA+1) .NE. CAPOS) THEN
                  IE = IA - 1
                  IF(J1 .EQ. 2) THEN
                     GO TO 40
                  ELSE
                     GO TO 38
                  END IF
               END IF
            END IF
            IF(CSTMT(IA:IA) .EQ. CSLASH) THEN
               IE = IA - 1
               J7 = J7 + 1
               IF(IA .EQ. KB) GO TO 40
               IF(J6 .GT. 2) GO TO 38
            END IF
            IF(CSTMT(IA-1:IA-1) .EQ. CAPOSD) THEN
               IF(MOD(JE,2) .EQ. 0) THEN
                  IE = IA - 1
                  IF(J6 .EQ. 2) THEN
                     GO TO 40
                  ELSE
                     GO TO 38
                  END IF
                  GO TO 40
               END IF
            END IF
         END IF
 38      CONTINUE
      END IF
C
C         SCAN FOR AN APOSTROPHE. WHEN A QUOTATION MARK OCCURS, IT IS
C         TREATED AS A NORMAL CHARACTER.
C
      IF(CSTMT(I:I) .EQ. CAPOS .OR. CSTMT(I:I) .EQ. CAPOSD) THEN
C
C         THE START OF A LITERAL HAS BEEN FOUND, LOCATE ITS END
C
         JE = 1
         ILOC3 = I
         IB = I + 1
         DO 39 IA = IB,KB
C
C         DETERMINE THE END OF THE STATEMENT
C
         IF(IA .EQ. KB .AND. LERR) GO TO 58
C
C         TEST FOR DOUBLE APOSTROPHES
C
         IF(CSTMT(IA:IA) .EQ. CAPOS) THEN
            JE = JE + 1
C
C         SKIP DOUBLE APOSTROPHES
C
            IF(CSTMT(IA+1:IA+1) .EQ. CAPOS) THEN
               JE = JE - 2
               GO TO 39
            ELSE
               IF(MOD(JE,2) .EQ. 0) THEN
                  IE = IA
                  ILOC4 = IA
                  GO TO 40
               END IF
            END IF
            IF(CSTMT(IA-1:IA-1) .EQ. CAPOS) GO TO 39
            IF(MOD(JE,2) .EQ. 0) THEN
               IE = IA
               GO TO 40
            END IF
         ELSE
            IF(CSTMT(IA-1:IA-1) .EQ. CAPOS) THEN
               IF(MOD(JE,2) .EQ. 0) THEN
                  IE = IA - 1
                  GO TO 40
               END IF
            END IF
         END IF
 39      CONTINUE
      ELSE
         IF(ILOC3 .NE. 0 .AND. ILOC4 .NE. 0) THEN
            GO TO 40
         ELSE
            GO TO 48
         END IF
      END IF
C
C         TEST IF THE LEFT OR RIGHT BOUNDARY OF THE LITERAL. THIS WILL
C         REQUIRE LOCATION ADJUSTMENT FOR BINARY, OCTAL, OR HEXADECIMAL
C         SPECIFICATIONS.
C
 40   IF(ILOC3 .GT. 0 .AND. ILOC4 .GT. 0) THEN
         II = ILOC3
         IE = ILOC4
         ILOC1 = ILOC4 - ILOC3 + 1
      ELSE
         II = JE + 1
      END IF
C
C         DETERMINE IF A COMMA OR A SLASH FOLLOWS THE LITERAL. THIS
C         INDICATES AN ARGUMENT LIST OR A CONCANTIATION OPERATOR FOLLOWS
C         THE END OF THE LITERAL.
C
      IF(CSTMT(II:II) .EQ. COMMA .OR. CSTMT(II:II) .EQ. CSLASH)
     1   GO TO 41
C
C         DETERMINE IF THE LITERAL TYPE DESIGNATION PRECEDES THE LITERAL
C         A C OR c CHARACTER MAY NOT PRECEDE A LITERAL TO INDICATE THAT
C         IT IS LITERAL THAT ADDS A NULL CHARACTER AT THE END.
C
      IF(CSTMT(II:II) .EQ. CAPOS .OR. CSTMT(II:II) .EQ. CAPOSD) THEN
         IF(CSTMT(II-1:II-1) .EQ. CBB .OR. CSTMT(II-1:II-1) .EQ. COO
     1      .OR. CSTMT(II-1:II-1) .EQ. CZZ .OR. CSTMT(II-1:II-1) .EQ.
     2      CXX) THEN
            II = II - 1
            ILOC3 = ILOC3 - 1
         ELSE
            IF(CSTMT(II-1:II-1) .EQ. 'b') THEN
               CSTMT(II-1:II-1) = CBB(1:1)
               II = II - 1
               ILOC3 = ILOC3 - 1
            ELSE IF(CSTMT(II-1:II-1) .EQ. 'o') THEN
               CSTMT(II-1:II-1) = COO(1:1)
               II = II - 1
               ILOC3 = ILOC3 - 1
            ELSE IF(CSTMT(II-1:II-1) .EQ. 'x') THEN
               CSTMT(II-1:II-1) = CXX(1:1)
               II = II - 1
               ILOC3 = ILOC3 - 1
            ELSE IF(CSTMT(II-1:II-1) .EQ. 'z') THEN
               CSTMT(II-1:II-1) = CZZ(1:1)
               II = II - 1
               ILOC3 = ILOC3 - 1
            END IF
         END IF
      END IF
C
C         TEST IF THE LITERAL TYPE DESIGNATION FOLLOWS THE LITERAL. A C
C         OR c CHARACTER DESIGNATES A NULL TERMINATED LITERAL WITH THE
C         NULL CHARACTER NOT SHOWN IN THE LITERAL.

      II = JE
      IE = IE + 1
      L6 = LFALSE
      IF(IE .GT. KB) GO TO 41
      IF(CSTMT(IE:IE) .EQ. CBB .OR. CSTMT(IE:IE) .EQ. COO .OR.
     1   CSTMT(IE:IE) .EQ. CZZ .OR. CSTMT(IE:IE) .EQ. CXX .OR.
     2   CSTMT(IE:IE) .EQ. CCC) THEN
         L6 = LTRUE
      ELSE
         IF(CSTMT(IE:IE) .EQ. 'b') CSTMT(IE:IE) = CBB(1:1)
         IF(CSTMT(IE:IE) .EQ. 'o') CSTMT(IE:IE) = COO(1:1)
         IF(CSTMT(IE:IE) .EQ. 'x') CSTMT(IE:IE) = CXX(1:1)
         IF(CSTMT(IE:IE) .EQ. 'z') CSTMT(IE:IE) = CZZ(1:1)
         IF(CSTMT(IE:IE) .EQ. 'c') CSTMT(IE:IE) = CCC(1:1)
         IF(CSTMT(IE:IE) .EQ. CBB .OR. CSTMT(IE:IE) .EQ. COO .OR.
     1      CSTMT(IE:IE) .EQ. CXX .OR. CSTMT(IE:IE) .EQ. CZZ .OR.
     2      CSTMT(IE:IE) .EQ. CCC) THEN
            L6 = LTRUE
         ELSE
            L6 = LFALSE
         END IF
      END IF
      IF(.NOT.L6) THEN
         IE = IE - 1
      ELSE
         L6 = LFALSE
      END IF
C
C         PLACE THE LITERAL IN THE WORK AREA AND SAVE IT ON UNIT 9.
C         A LITERAL LONGER THAN 80 BYTES WILL BE TRUNCATED
C
C
C         TEST IF A MISMATCHED APOSTROPHE OR QUOTATION MARKS FOUND.
C         WHEN THIS CONDITION EXISTS, FORCE THE FINAL CHARACTER TO BE
C         THE END OF A LITERAL TO PREVENT PROGRAM FAILURE.
C
 41   IF(IE .GT. II) THEN
         IF(ILOC3 .GT. 0 .AND. ILOC4 .GT. 0) IH = ILOC1
         IF(.NOT.LA) THEN
            IF(.NOT.LERR .AND. .NOT.LINCL) THEN
               IF(LAPOS) THEN
                  IF(MOD(J1,2) .NE. 0) THEN
                     IF(.NOT.L10) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                  END IF
               ELSE
                  IF(MOD(J2,2) .NE. 0) THEN
                     IF(.NOT.L10) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                   END IF
                END IF
            END IF
            DO 42 I1 = II,KB
            IF(CSTMT(I1:I1) .EQ. CAPOSD) THEN
               IH = II - I + 1
            END IF
            IF(CSTMT(I1:I1) .EQ. COMMA) THEN
               IH = I1 - I
               GO TO 43
            END IF
            IF(I1 .EQ. KB) IH = KB - I
 42         CONTINUE
            JE = KB
         END IF
      END IF
C
C         WHEN THE LITERAL TYPE DESIGNATION IS A Z, DETERMINE IF IT
C         REPRESENTS A TRUE LITERAL; PREVENT PLACING THE TEXT AS A
C         LITERAL IN THIS CASE.
C
 43   IF(CSTMT(IE:IE) .EQ. CZZ .AND. (CSTMT(IE-1:IE-1) .NE. CAPOS .OR.
     1   CSTMT(IE-1:IE-1) .NE. CAPOSD)) GO TO 52
C
C         SAVE THE ASCII VALUE OF THE LITERAL LENGTH
C
      WRITE (CWK7,105) JLITLN
      IF(JLITLN .NE. 0) IH = JLITLN
      ILITCT = ILITCT + 1
      I2WK1 = 0
      DO 44 I7 = 1,7
      IF(CWK7(I7:I7) .EQ. CBLANK(1:1)) GO TO 44
      IF(I2WK1 .GT. 500) THEN
         IREC0 = IREC0 + 1
         WRITE (0,102) ISN
      ELSE
         I2WK1 = I2WK1 + 1
         CLITLN(ILITCT)(I2WK1:I2WK1) = CWK7(I7:I7)
      END IF
 44   CONTINUE
      IG = 0
C
C         SET THE ISN FOR THE LITERAL RECORD ON UNIT 9
C
      ILOC2 = ISN + 128
C
C         SET UP AN ENTRY FOR THE LITERAL TABLE
C
      CLIT(1:48) = CBLK52(1:48)
      CLIT(49:80) = CBLK52(1:32)
      JE = IE
      IF(CSTMT(JE:JE) .EQ. CAPOS .OR. CSTMT(JE:JE) .EQ. CAPOSD) THEN
         IH = JE - ILOC3 + 1
      ELSE IF(CSTMT(JE:JE) .EQ. CBB .OR. CSTMT(JE:JE) .EQ. CCC .OR.
     1   CSTMT(JE:JE) .EQ. COO .OR. CSTMT(JE:JE) .EQ. CXX) THEN
         IH = JE - ILOC3 + 1
      ELSE
         IH = JE - ILOC3
      END IF
      JLITLN = IH
      IF(IH .GT. 80) THEN
         ILOC1 = 80
         IE = ILOC4
         IH = 80
      ELSE
         IF(JLITLN .GT. 0) THEN
            IF(JLITLN .GT. 80) THEN
               ILOC1 = 80
               IH = 80
            ELSE
               ILOC1 = JLITLN
               IH = JLITLN
            END IF
         END IF
      END IF
      IF(IH .LT. 3) THEN
         IH = 3
         ILOC1 = 3
         JLITLN = IH
      ELSE
         IF(JLITLN .EQ. 0) THEN
            JLITLN = IH
         END IF
      END IF
      CLIT(1:IH) = CSTMT(ILOC3:JE)
      ILOC1 = JLITLN
      IF(LG) THEN
         IF(LH) THEN
            ILOC3 = 0
         ELSE
            ILOC3 = KARG
         END IF
      END IF
      ILOC1 = ILOC1 + 128
      IF(.NOT.LINCL) THEN
         ILIT = ILIT + 1
         IF(.NOT.LINCL) THEN
            WRITE (9,REC=ILIT) CLIT(1:80),ILOC1,ILOC2,ILOC3
            READ (9,REC=ILIT) CLITWW(1:92)
            IREC9 = IREC9 + 1
         END IF
      END IF
C
C         DETERMINE THE TRUE LENGTH OF THE LITERAL WHEN IT IS AN
C         ARGUMENT IN A CALL STATEMENT
C
      IF(LG) JLITLN = JE - I - 1
C
C         REPLACE THE LITERAL WITH A HEX VALUE OF CF AND BLANK THE
C         REMAINDER OF THE LITERAL FIELD. THIS WILL SIMPLIFY AND SPEED
C         STATEMENT ANALYSIS LATER.
C
      DO 45 IA = I,JE
      IF(IA .EQ. I) THEN
         CSTMT(I:I) = CSYMCF
         IF(CSTMT(I-1:I-1) .EQ. CBB .OR. CSTMT(I-1:I-1) .EQ. COO .OR.
     1      CSTMT(I-1:I-1) .EQ. CXX .OR. CSTMT(I-1:I-1) .EQ. CZZ)
     2      CSTMT(I-1:I-1) = CBLANK(1:1)
         IF(CSTMT(I-1:I-1) .EQ. 'b' .OR. CSTMT(I-1:I-1) .EQ. 'o' .OR.
     1      CSTMT(I-1:I-1) .EQ. 'x' .OR. CSTMT(I-1:I-1) .EQ. 'z')
     2      CSTMT(I-1:I-1) = CBLANK(1:1)
         GO TO 45
      END IF
      IF(IA .EQ. JE) THEN
         IF(CSTMT(IA+1:IA+1) .EQ. CBB .OR. CSTMT(IA+1:IA+1) .EQ. COO
     1      .OR. CSTMT(IA+1:IA+1) .EQ. CXX .OR. CSTMT(IA+1:IA+1) .EQ.
     2      CZZ .OR. CSTMT(IA+1:IA+1) .EQ. CCC .OR. CSTMT(IA+1:IA+1)
     3      .EQ. 'b' .OR.  CSTMT(IA+1:IA+1) .EQ. 'o' .OR.
     4      CSTMT(IA+1:IA+1) .EQ. 'x' .OR. CSTMT(IA+1:IA+1) .EQ. 'z'
     5      .OR. CSTMT(IA+1:IA+1) .EQ. 'c') CSTMT(IA+1:IA+1) =
     6       CBLANK(1:1)
         IF(CSTMT(IA:IA) .NE. CSLASH .AND. CSTMT(IA:IA) .NE. CRPAR .AND.
     1      CSTMT(IA:IA) .NE. COMMA) CSTMT(IA:IA) = CBLANK(1:1)
         IF(IA + 1 .GE. KB) GO TO 53
         GO TO 46
      END IF
      CSTMT(IA:IA) = CBLANK(1:1)
 45   CONTINUE
C
C         TEST IF THE FINAL FIELD OF A STATEMENT IS A LITERAL
C
 46   IF(IE .LT. KB) THEN
         ID = IE + 1
      ELSE IF(IE .GT. KB) THEN
         GO TO 48
      END IF
C
C         SET NEW LOOP START VALUE
C
      IF(I .NE. KB) THEN
         J = IE + 1
         JE = J
C
C         LOOP TO LOCATE THE NEXT APOSTROPHE OR QUOTATION MARK
C
         DO 47 I1 = IE,KB
         IF(CSTMT(I1:I1) .EQ. CAPOSD .OR. CSTMT(I1:I1) .EQ. CAPOS .OR.
     1      CSTMT(I1:I1) .EQ. COMMA) THEN
            J = I1
            JE = J
            ILOC3 = 0
            ILOC4 = 0
            GO TO 35
         END IF
 47      CONTINUE
C
C         WHEN NO APOSTROPHE OR QUOTATION MARK IS FOUND IN THE
C         REMAINING CHARACTERS OF THE STATEMENT, NO MORE LITERALS
C         EXIST IN THE STATEMENT.
C
         L7 = LTRUE
         IF(LFMT) GO TO 560
      END IF
C
C         DETERMINE IF THE CHARACTERS IMMEDIATELY FOLLOWING THE END OF
C         THE LITERAL ARE TWO SEQUENTIAL SLASHES INDICATING A CHARACTER
C         EXPRESSION EXISTS.
C
      IF(CSTMT(JE+1:JE+2) .EQ. '//') THEN
         IF(JE+2 .LT. KB) J = JE + 3
         IE = J
         JE = J
         ILOC3 = 0
         ILOC4 = 0
         GO TO 35
      ELSE
         CONTINUE
      END IF
C
C         TEST FOR A LEFT BRACKET; IF FOUND, THE CHARACTERS BETWEEN
C         THE LEFT AND RIGHT BRACKETS WILL BE DELETED AND NOT
C         PROCESSED.
C
 48   IF(CSTMT(I:I) .EQ. '[') THEN
C
C         FIND THE MATCHING RIGHT BRACKET
C
         DO 51 IE = I,KB
         IF(CSTMT(IE:IE) .EQ. ']') THEN
C
C         BLANK THE PORTION OF THE STATEMENT BETWEEN BRACKETS
C
            IB = IE
            CSTMT(I:IE) = CBLK52(1:IB)
C
C         DETERMINE OF A COMMA OR A LEFT PARENTHESIS FOLLOWS INDICATING
C         ANOTHER VARIABLE NAME
C
            DO 50 IA = IE,KB
            IF(CSTMT(IA:IA) .EQ. COMMA .OR. CSTMT(IA:IA) .EQ. CLPAR)
     1          THEN
C
C         DETERMINE IF THE CHARACTER FOLLOWING THE COMMA IS A POSSIBLE
C         ADDITIONAL ARGUMENT
C
               IF(CSTMT(IA+1:IA+1) .GE. CAA .AND. CSTMT(IA+1:IA+1)
     1            .LE. CZZ .OR. CSTMT(IA+1:IA+1) .EQ. CUNDER) THEN
                  J = IA + 1
                  IB = IA - I
               ELSE
C
C         DETERMINE IF AN INHERITED DIMENSION FOLLOWS A LEFT PARENTHESIS
C
                  IF(CSTMT(IA:IA) .EQ. CLPAR) THEN
                     IF(CSTMT(IA:IA+2) .EQ. '(:)') THEN
                        J = IA + 3
                        GO TO 52
                     END IF
                  END IF
C
C         TEST IF THE END OF THE STATEMENT OCCURS
C
                  IF(IA .EQ. KB) THEN
                     IB = IA - I
                     GO TO 49
                  ELSE
                     GO TO 50
                  END IF
                  GO TO 50
               END IF
C
C         BLANK THE PORTION OF THE STATEMENT
C
 49            CSTMT(I:I+IB-1) = CBLK52(1:IB)
               J = IA
               IF(IA .LT. KB) GO TO 50
            END IF
 50         CONTINUE
         END IF
 51      CONTINUE
      END IF
      IF(L7) GO TO 53
 52   CONTINUE
C
C         PROCESS POSSIBLE HOLLERITH FIELDS AFTER ALL LITERALS DEFINED
C         BY APOSTROPHES OR QUESTION MARKS ARE PROCESSED
C
      IF(.NOT.L11) THEN
         L10 = LTRUE
         GO TO 22
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   SCAN TO LOCATE ALL LOGICAL OPERATORS AND REPLACE THEM WITH   *
C     *   THE HEXADECIMAL VALUE 'CD'X.                                 *
C     *                                                                *
C     ******************************************************************
C
C         ANY REMAINING PERIODS WILL BE DECIMAL POINTS IN
C         NUMERICAL FIELDS OR THE SEPARATOR PERIODS OCURRING IN COMPOUND
C         VARIABLE NAMES AFTER THE LOGICAL OPERATORS AND CONSTANTS
C         ARE REMOVED.
C
 53   KC = KF
C
C         REMOVE BLANKS FROM THE STATMENT BEFORE SCANNING FOR LOGICAL
C         OPERATORS AND CONSTANTS. THIS WILL PREVENT A LOGICAL
C         EXPRESSION SUCH AS:  (L .AND .LL) FROM BEING DESIGNATED AS
C         AN ILLEGAL EXPRESSION IN ROUTINE EXPR.
C
      IF(LG) THEN
         L4 = LTRUE
      ELSE
         L4 = LFALSE
      END IF
      IF(KB .EQ. 0) KB = NCOLS
      CALL RBLANK (LF,L4,JLITLN,IG)
C
C         WHEN THIS IS A FORMAT STATEMENT, NO LOGICAL OPERATORS CAN
C         OCCUR.
C
      IF(LFMT) GO TO 58
C
C         SCAN FOR LOGICAL OPERATORS AND REPLACE THEM WITH HEX CD;
C         ALSO SCAN FOR AN ASTERISK AND ISSUE AN ERROR MESSAGE WHEN
C         IT OCCURS IN A FORMAT STATEMENT. AT THIS STAGE OF PROCESSING,
C         NO ASTERISK IS LEGAL IN A FORMAT STATEMENT.
C
      DO 54 I = KC,KB
C
C         DETERMINE IF AN ASTERISK OCCURS WITHIN A FORMAT STATEMENT
C
C         IF THE STATEMENT IS A FORMAT STATEMENT, AN ASTERISK IS AN
C         ILLEGAL CHARACTER
C
      IF(CSTMT(I:I) .EQ. CASTER(1:1)) THEN
         IF(LFMT) THEN
            WRITE (0,106) ISN,CSTMT(I-4:I+4)
            IREC0 = IREC0 + 1
            RETURN
         END IF
      END IF
C
C         DETERMINE IF THE CHARACTER IS HEX CF REPRESENTING A LITERAL.
C         SKIP OVER THIS CHARACTER.
C
      IF(CSTMT(I:I) .EQ. CSYMCF) GO TO 54
C
C         DETERMINE IF A PERIOD HAS BEEN FOUND
C
      IF(CSTMT(I:I) .EQ. CDOT) THEN
C
C         TEST FOR FOUR CHARACTER LOGICAL OPERATORS
C
         IQ = I + 3
         IF(CSTMT(I:IQ) .EQ. '.EQ.' .OR. CSTMT(I:IQ) .EQ. '.GE.' .OR.
     1      CSTMT(I:IQ) .EQ. '.GT.' .OR. CSTMT(I:IQ) .EQ. '.LE.' .OR.
     2      CSTMT(I:IQ) .EQ. '.LT.' .OR. CSTMT(I:IQ) .EQ. '.NE.' .OR.
     3      CSTMT(I:IQ) .EQ. '.OR.' .OR.
     4      CSTMT(I:IQ) .EQ. '.eq.' .OR. CSTMT(I:IQ) .EQ. '.ge.' .OR.
     5      CSTMT(I:IQ) .EQ. '.gt.' .OR. CSTMT(I:IQ) .EQ. '.le.' .OR.
     6      CSTMT(I:IQ) .EQ. '.lt.' .OR. CSTMT(I:IQ) .EQ. '.ne.' .OR.
     7      CSTMT(I:IQ) .EQ. '.or.') THEN
            CSTMT(I:IQ) = CSYMCD//CBLANK(1:3)
            GO TO 54
         END IF
C
C         TEST FOR FIVE CHARACTER LOGICAL OPERATORS
C
         IQ = I + 4
         IF(CSTMT(I:IQ) .EQ. '.AND.' .OR. CSTMT(I:IQ) .EQ. '.EQV.' .OR.
     1      CSTMT(I:IQ) .EQ. '.NOT.' .OR. CSTMT(I:IQ) .EQ. '.XOR.' .OR.
     2      CSTMT(I:IQ) .EQ. '.and.' .OR. CSTMT(I:IQ) .EQ. '.eqv.' .OR.
     3      CSTMT(I:IQ) .EQ. '.not.' .OR. CSTMT(I:IQ) .EQ. '.xor.') THEN
            CSTMT(I:IQ) = CSYMCD//CBLANK(1:4)
            GO TO 54
         END IF
C
C         TEST FOR SIX CHARACTER LOGICAL OPERATORS
C
         IQ = I + 5
         IF(CSTMT(I:IQ) .EQ. '.NEQV.' .OR. CSTMT(I:IQ) .EQ. 'neqv.' .OR.
     1      CSTMT(I:IQ) .EQ. '.TRUE.' .OR. CSTMT(I:IQ) .EQ. '.true.')
     2      THEN
            CSTMT(I:IQ) = CSYMCD//CBLANK(1:5)
            GO TO 54
         END IF
C
C         TEST FOR SEVEN CHARACTER LOGICAL OPERATORS
C
         IQ = I + 6
         IF(CSTMT(I:IQ) .EQ. '.FALSE.' .OR. CSTMT(I:IQ) .EQ. '.false.')
     1      CSTMT(I:IQ) = CSYMCD//CBLANK(1:6)
      END IF
 54   CONTINUE
C
C         ALL VALID LOGICAL OPERATORS SHOULD NOW BE REPLACED WITH
C         CSYMCD. SCAN THE STATEMENT AGAIN TO LOCATE POSSIBLE MISPELLED
C         LOGICAL OPERATORS. ANY REMAINING PERIODS SHOULD BE PART
C         OF A FLOATING POINT NUMBER IN REAL OR SCIENTIFIC FORM, OR
C         OR A SPECIFICATION OF A STRUCTURE OR RECORD VARIABLE NAME.
C         SEARCH FOR INVALID LOGICAL OPERATORS.
C
      DO 56 I = KC,KB
C
C         DETERMINE IF A PERIOD MAY BE A LOGICAL OPERATOR. THIS IS
C         POSSIBLE WHEN THE CHARACTER FOLLOWING THE PERIOD IS ONE OF
C         FOLLOWING CHARACTERS: A, E, F, G, L, N, O, T, OR X.
C
      IF(CSTMT(I:I) .EQ. CDOT) THEN
C
C         DETERMINE IF A RIGHT TERMINATING PERIOD IS MISSING FOR A
C         LOGICAL OPERATOR
C
         IQ = I + 1
         IF(CSTMT(IQ:IQ) .EQ. CAA .OR. CSTMT(IQ:IQ) .EQ. 'a') THEN
            IF(CSTMT(IQ:IQ+2) .EQ. 'AND' .OR. CSTMT(IQ:IQ+2) .EQ. 'and')
     1      THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,3,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CEE .OR. CSTMT(IQ:IQ) .EQ. 'e') THEN
            IF(CSTMT(IQ:IQ+1) .EQ. CEE .OR. CSTMT(IQ:IQ+1) .EQ. 'e' .OR.
     1         CSTMT(IQ:IQ+1) .EQ. CQQ .OR. CSTMT(IQ:IQ+1) .EQ. 'q')
     2         THEN
               IF(CSTMT(IQ:IQ+2) .EQ. 'EQV') THEN
                  IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
                  IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,3,0,
     1               CSTMT)
                  GO TO 56
               END IF
               IF(CSTMT(IQ:IQ+1) .EQ. 'EQ') THEN
                  IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
                  IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,2,0,
     1               CSTMT)
                  GO TO 56
               END IF
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CFF .OR. CSTMT(IQ:IQ) .EQ. 'f') THEN
            IF(CSTMT(IQ:IQ+4) .EQ. 'FALSE' .OR. CSTMT(IQ:IQ+4) .EQ.
     1         'false') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C6,5,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CGG .OR. CSTMT(IQ:IQ) .EQ. 'g') THEN
            IF(CSTMT(IQ:IQ+1) .EQ. 'GT' .OR. CSTMT(IQ:IQ+1) .EQ. 'gt')
     1         THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,2,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CLL .OR. CSTMT(IQ:IQ) .EQ. 'l') THEN
            IF(CSTMT(IQ:IQ+1) .EQ. 'LE' .OR. CSTMT(IQ:IQ+1) .EQ. 'le'
     1         .OR. CSTMT(IQ:IQ+1) .EQ. 'LT' .OR. CSTMT(IQ:IQ+1) .EQ.
     2         'lt') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,2,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CNN .OR. CSTMT(IQ:IQ) .EQ. 'n') THEN
            IF(CSTMT(IQ:IQ+3) .EQ. 'NEQV' .OR. CSTMT(IQ:IQ+3) .EQ.
     1         'neqv') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C5,4,0,
     1            CSTMT)
               GO TO 56
            END IF
            IF(CSTMT(IQ:IQ+2) .EQ. 'NOT' .OR. CSTMT(IQ:IQ+2) .EQ.
     1         'not') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,3,0,
     1            CSTMT)
               GO TO 56
            END IF
            IF(CSTMT(IQ:IQ+1) .EQ. 'NE' .OR. CSTMT(IQ:IQ+1) .EQ. 'ne')
     1         THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,2,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. COO .OR. CSTMT(IQ:IQ) .EQ. 'o') THEN
            IF(CSTMT(IQ:IQ+1) .EQ. 'OR' .OR. CSTMT(IQ:IQ+1) .EQ. 'or')
     1         THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,2,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CTT .OR. CSTMT(IQ:IQ) .EQ. 't') THEN
            IF(CSTMT(IQ:IQ+3) .EQ. 'TRUE' .OR. CSTMT(IQ:IQ+3) .EQ.
     1         'true') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C5,4,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
         IF(CSTMT(IQ:IQ) .EQ. CXX .OR. CSTMT(IQ:IQ) .EQ. 'x') THEN
            IF(CSTMT(IQ:IQ+3) .EQ. 'XOR' .OR. CSTMT(IQ:IQ+3) .EQ.
     1         'xor') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,3,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
C
C         DETERMINE IF A LEFT STARTING PERIOD IS MISSING FOR A
C         LOGICAL OPERATOR
C
         IQ = I - 2
         IP1 = I - 1
         IF(CSTMT(IQ:IP1) .EQ. 'EQ') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,0,2,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'GT' .OR. CSTMT(IQ:IP1) .EQ. 'gt') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,0,2,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'LE' .OR. CSTMT(IQ:IP1) .EQ. 'le' .OR.
     1      CSTMT(IQ:IP1) .EQ. 'LT' .OR. CSTMT(IQ:IP1) .EQ. 'lt') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,0,2,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'NE' .OR. CSTMT(IQ:IP1) .EQ. 'ne')
     1      THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14) CALL LOGERR (I,C3,0,2,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'OR' .OR. CSTMT(IQ:IP1) .EQ. 'or') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C3,0,2,CSTMT)
            GO TO 56
         END IF
         IQ = I - 3
         IF(CSTMT(IQ:IP1) .EQ. 'AND' .OR. CSTMT(IQ:IP1) .EQ. 'and') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,0,3,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'EQV') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,0,3,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'NOT' .OR. CSTMT(IQ:IP1) .EQ. 'not') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,0,3,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'XOR' .OR. CSTMT(IQ:IP1) .EQ. 'xor') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,0,3,CSTMT)
            GO TO 56
         END IF
         IQ = I - 4
         IF(CSTMT(IQ:IP1) .EQ. 'NEQV' .OR. CSTMT(IQ:IP1) .EQ. 'neqv')
     1      THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C5,0,4,CSTMT)
            GO TO 56
         END IF
         IF(CSTMT(IQ:IP1) .EQ. 'TRUE' .OR. CSTMT(IQ:IP1) .EQ.
     1      'true') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C5,0,4,CSTMT)
            GO TO 56
         END IF
         IQ = I - 5
         IF(CSTMT(IQ:IP1) .EQ. 'FALSE' .OR. CSTMT(IQ:IP1) .EQ.
     1      'false') THEN
            IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
            IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C6,0,5,CSTMT)
            GO TO 56
         END IF
C
C         DETERMINE IF A LOGICAL OPERATOR IS MISPELLED FOR A FOUR
C         CHARACTER OPERATOR: .XX.
C
C         NOTE THAT THE HEXADECIMAL CONSTANTS USED BELOW MUST BE
C         CHANGED FOR AN EBCDIC COMPUTER. THE TESTS BELOW MUST BE
C         CHANGED TO REPRESENT THE SAME EXCLUSION AND INCLUSION
C         VALUES. ADDITONAL IF STATEMENTS WILL BE REQUIRED FOR EBCDIC
C         COMPUTERS BECAUSE OF A DIFFERENT COLLATING SEQUENCE.
C
         IQ = I + 3
         IF(CSTMT(IQ:IQ) .EQ. CDOT) THEN
C
C         PREVENT ERROR MESSAGE WHEN NOT A POSSIBLE LOGICAL OPERATOR
C
            IF(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9
     1         .OR. CSTMT(IQ-1:IQ-1) .GT. C0 .AND. CSTMT(IQ-1:IQ-1)
     2         .LE. C9  .OR. CSTMT(IP1:IP1) .GE. C0 .AND. CSTMT(IP1:IP1)
     3         .LE. C9 ) GO TO 56
            IF(CSTMT(I+1:I+1) .LT. CX30 .OR. CSTMT(IQ-1:IQ-1) .LT.
     1         CX30) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX5A .AND. CSTMT(I+1:I+1) .LE.
     1         CX60 .OR. CSTMT(IQ-1:IQ-1) .GT. CX5A .AND.
     2         CSTMT(IP1-1:IP1-1) .LE. CX60) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX7A .AND. CSTMT(I-1:I-1) .GT.
     1         CX7A) GO TO 56
            IF(CSTMT(I+1:IQ-1) .NE. 'EQ' .AND. CSTMT(I+1:IQ-1) .NE.
     1         'eq' .AND. CSTMT(I+1:IP1-1) .NE. 'GE' .AND.
     2         CSTMT(I+1:IQ-1) .NE. 'ge' .AND. CSTMT(I+1:IQ-1) .NE.
     3         'GT' .AND. CSTMT(I+1:IP1-1) .NE. 'gt' .AND.
     4         CSTMT(I+1:IQ-1) .NE. 'LE' .AND. CSTMT(I+1:IQ-1) .NE.
     5         'le' .AND. CSTMT(I+1:IP1-1) .NE. 'LT' .AND.
     6         CSTMT(I+1:IQ-1) .NE. 'lt' .AND. CSTMT(I+1:IQ-1) .NE.
     7         'NE' .AND. CSTMT(I+1:IP1-1) .NE. 'ne' .AND.
     8         CSTMT(I+1:IQ-1) .NE. 'OR' .AND. CSTMT(I+1:IQ-1) .NE.
     9         'or') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C4,3,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
C
C         DETERMINE IF A LOGICAL OPERATOR IS MISPELLED FOR A FIVE
C         CHARACTER OPERATOR: .XXX.
C
         IQ = I + 4
         IF(CSTMT(IQ:IQ) .EQ. CDOT) THEN
C
C         PREVENT ERROR MESSAGE WHEN NOT A POSSIBLE LOGICAL OPERATOR
C
            IF(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9
     1         .OR. CSTMT(IQ-1:IQ-1) .GT. C0 .AND. CSTMT(IQ-1:IQ-1)
     2         .LE. C9  .OR. CSTMT(IP1:IP1) .GE. C0 .AND. CSTMT(IP1:IP1)
     3         .LE. C9 ) GO TO 56
            IF(CSTMT(I+1:I+1) .LT. CX30 .OR. CSTMT(IQ-1:IQ-1) .LT.
     1         CX30) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX5A .AND. CSTMT(I+1:I+1) .LE.
     1         CX60 .OR. CSTMT(IQ-1:IQ-1) .GT. CX5A .AND.
     2         CSTMT(IP1-1:IP1-1) .LE. CX60) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX7A .AND. CSTMT(I-1:I-1) .GT.
     1         CX7A) GO TO 56
            IF(CSTMT(I+1:IQ-1) .NE. 'AND' .AND. CSTMT(I+1:IQ-1) .NE.
     1         'and' .AND. CSTMT(I+1:IP1-1) .NE. 'EQV' .AND.
     2         CSTMT(I+1:IQ-1) .NE. 'eqv' .AND. CSTMT(I+1:IQ-1) .NE.
     3         'NOT' .AND. CSTMT(I+1:IP1-1) .NE. 'not' .AND.
     4         CSTMT(I+1:IQ-1) .NE. 'XOR' .AND. CSTMT(I+1:IQ-1) .NE.
     5         'xor') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C5,4,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
C
C         DETERMINE IF A LOGICAL OPERATOR IS MISPELLED FOR A SIX
C         CHARACTER OPERATOR: .XXXX.
C
         IQ = I + 5
         IF(CSTMT(IQ:IQ) .EQ. CDOT) THEN
C
C         PREVENT ERROR MESSAGE WHEN NOT A POSSIBLE LOGICAL OPERATOR
C
            IF(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9
     1         .OR. CSTMT(IQ-1:IQ-1) .GT. C0 .AND. CSTMT(IQ-1:IQ-1)
     2         .LE. C9  .OR. CSTMT(IP1:IP1) .GE. C0 .AND. CSTMT(IP1:IP1)
     3         .LE. C9 ) GO TO 56
            IF(CSTMT(I+1:I+1) .LT. CX30 .OR. CSTMT(IQ-1:IQ-1) .LT.
     1         CX30) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX5A .AND. CSTMT(I+1:I+1) .LE.
     1         CX60 .OR. CSTMT(IQ-1:IQ-1) .GT. CX5A .AND.
     2         CSTMT(IQ-1:IQ-1) .LE. CX60) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX7A .AND. CSTMT(I-1:I-1) .GT.
     1         CX7A) GO TO 56
            IF(CSTMT(I+1:IP1-1) .NE. 'NEQV' .AND. CSTMT(I+1:IQ-1) .NE.
     1         'neqv' .AND. CSTMT(I+1:IQ-1) .NE. 'TRUE' .AND.
     2         CSTMT(I+1:IQ-1) .NE. 'true') THEN
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C6,5,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
C
C         DETERMINE IF A LOGICAL OPERATOR IS MISPELLED FOR A SEVEN
C         CHARACTER OPERATOR: .XXXXX.
C
         IQ = I + 6
         IF(CSTMT(IP1:IP1) .EQ. CDOT) THEN
C
C         PREVENT ERROR MESSAGE WHEN NO A POSSIBLE LOGICAL OPERATOR
C
            IF(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9
     1         .OR. CSTMT(IQ-1:IQ-1) .GT. C0 .AND. CSTMT(IQ-1:IQ-1)
     2         .LE. C9  .OR. CSTMT(IP1:IP1) .GE. C0 .AND. CSTMT(IP1:IP1)
     3         .LE. C9 ) GO TO 56
            IF(CSTMT(I+1:I+1) .LT. CX30 .OR. CSTMT(IP1-1:IP1-1) .LT.
     1         CX30) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX5A .AND. CSTMT(I+1:I+1) .LE.
     1         CX60 .OR. CSTMT(IQ-1:IQ-1) .GT. CX5A .AND.
     2         CSTMT(IQ-1:IQ-1) .LE. CX60) GO TO 56
            IF(CSTMT(I+1:I+1) .GT. CX7A .AND. CSTMT(I-1:I-1) .GT.
     1         CX7A) GO TO 56
            IF(CSTMT(I+1:IQ-1) .NE. 'FALSE' .AND. CSTMT(I+1:IQ-1) .NE.
     1         'FALSE') THEN
C
C         DETERMINE IF AN ARITHMETIC OPERATOR OR A CHARACTER
C         CONCANTINATION OPERATOR OCCURS BETWEEN THE TWO PERIODS.
C
               DO IB = I+1,IP1-1
               IF(CSTMT(IB:IB) .EQ. CEQ .OR. CSTMT(IB:IB) .EQ. CPLUS
     1            .OR. CSTMT(IB:IB) .EQ. CMINUS .OR. CSTMT(IB:IB) .EQ.
     2            CASTER .OR. CSTMT(IB:IB) .EQ. CSLASH) GO TO 56
               END DO
               IF(IRECD .GT. 0) CALL TESTR (CSTMT,I,L14)
               IF(.NOT.L14 .AND. .NOT.LINCL) CALL LOGERR (I,C7,6,0,
     1            CSTMT)
               GO TO 56
            END IF
         END IF
      END IF
 56   CONTINUE
C
C         BEGIN THE STATEMENT COMPRESSION
C
 560  KF = 1
      CALL RBLANK (LF,LG,JLITLN,IG)
      J = 1
C
C         SET THE NEW VALUE FOR THE LOCATION OF THE FINAL CHARACTER
C
C         WRITE UNBALANCED PARENTHESES MESSAGE
C
      IF(IG .NE. 0) THEN
         IE = ISN - 1
         L5 = LTRUE
         IF(.NOT.LFMT .AND. .NOT.LINCL .AND. ISN .GT. 0) THEN
           WRITE (0,100) ISN
           IREC0 = IREC0 + 1
         END IF
      END IF
C
C         TEST IF A FORMAT STATEMENT
C
 58   KF = 1
      IF(LFMT) THEN
         LC = LFALSE
         LD = LFALSE
C
C         PERFORM A SYNTAXICAL ANALYSIS OF A FORMAT STATEMENT
C
         CALL FMTSYN
      END IF
C
C         DETERMINE IF THIS IS AN INCLUDE STATEMENT
C
      I2WK1 = 0
      DO 60 I1 = 1,7
C
C         FORCE LOWER CASE CHARACTERS TO UPPER CASE
C
      IF(CSTMT(I1:I1) .GE. CAS .AND. CSTMT(I1:I1) .LE. CZS) THEN
         CI2WK1(IDXE:IDXE) = CSTMT(I1:I1)
         I2WK1 = I2WK1 - ICAPS
         CSTMT(I1:I1) = CI2WK1(IDXE:IDXE)
      END IF
 60   CONTINUE
      IF(CSTMT(KF:KF+6) .EQ. 'INCLUDE') THEN
C
C         DETERMINE IF THE LITERAL DEFINING THE FILE NAME IN THE
C         INCLUDE STATEMENT LACKS BALANCED APOSTROPHES
C
         IF(CSTMT(KF+7:KF+7) .EQ. CSYMCF) THEN
C
C         WHEN THIS IS AN INCLUDE STATEMENT, SAVE THE FILE NAME IN THE
C         INCLUDE FILE NAME TABLE
C
            JINCL = JINCL + 1
            CIFILE(JINCL)(1:80) = CBLK52(1:50)//CBLK52(1:30)
            CIFILE(JINCL)(1:IH-2) = CLITWK(2:ILOC1-1)
         ELSE
C
C         THE LITERAL DEFINING THE FILE NAME IN THE INCLUDE STATEMENT
C         LACKS BALANCED APOSTROPHES
C
            IREC0 = IREC0 + 1
            WRITE (0,103) ISN
            IRET = 1
C
C         INDICATE THE INCLUDE FILE NAME LITERAL IS INVALID
C
            CSTMT(KF+7:KF+7) = CSYMCE(1:1)
            CSTMT(9:KB) = CBLK52(1:50)//CBLK52(1:14)
            GO TO 61
         END IF
      END IF
C
C         ROUTINE EXIT
C
 61   RETURN IRET
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE REMOVES ALL BLANK CHARACTERS FROM THE FORTRAN
C         SOURCE STATEMENT. ALL CHARACTERS TO THE RIGHT OF A BLANK ARE
C         MOVED ONE CHARACTER TO THE LEFT. WHEN GLOBAL ANALYSIS IS TO
C         BE PERFORMED, A SYNTHETIC VARIABLE NAME C##XXX IS CREATED
C         AND ENTERED IN ARRAY CNAME. THIS WILL ALLOW THE LENGTH OF A
C         LITERAL TO BE KNOWN WHEN CHECKING DEFINED AND CALLED
C         ARGUMENTS OF CALL, ENTRY, FUNCTION, AND SUBROUTINE STATEMENTS.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANK CHARACTERS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEXCL  - CHARACTER VARIABLE, AN EXCLAMATION SIGN: !
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS: (
C         CLITLN - LENGTH OF A LITERAL IN BYTES. THIS ARRAY WILL CONTAIN
C                  ONLY THE LENGTH OF LITERALS OCCURRING IN A CALL
C                  STATEMENT
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS: )
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWK4   - CHARACTER VARIABLE, USED TO CREATE THE TEXT FORM OF
C                  XXX IN C##XXX
C         CWK7   - CHARACTER VARIABLE, USED TO CREATE THE TEXT FORM OF A
C                  LITERAL CALL ARGUMENT'S LENGTH
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         IA     - SUBSCRIPT VARIABLE, ALSO START OF A FIELD INDEX VALUE
C         IE     - COMPUTED SUBSCRIPT VALUE
C         IG     - COUNT OF PARENTHESES
C         IJ     - SUBSCRIPT VARIABLE
C         ILITCT - COUNT OF THE NUMBER OF LITERALS IN A CALL STATEMENT
C                  ARGUMENT LIST
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE VARIABLE NAME WAS
C                  PLACED IN CNAME, AND THE VALUE IS THE INDEX WHERE THE
C                  VARIABLE WAS INSERTED IN CNAME.
C                  WHEN IRET .EQ. 0, THE NAME TABLE EXCEEDS 4000 ENTRIES.
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - SUBSCRIPT VARIABLE, LOCATION TO MOVE A CHARACTER
C         JLITCT - COUNT OF THE NUMBER OF LITERALS IN A CALL STATEMENT
C         JLITLN - TRUE LENGTH OF A LITERAL FOR CALL STATEMENT ARGUMENTS
C         JLOC   - SUBSCRIPT VARIABLE, LOCATION FROM WHICH A CHARACTER
C                  IS TO BE MOVED
C         KB     - END POINTER LOCATION OF THE LAST CHARACTER OF THE
C                  STATEMENT IN ARRAY CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KG     - WORK VARIABLE, USED TO SAVE THE VALUE OF KB WHEN THIS
C                  ROUTINE IS ENTERED
C         KLITCT - COUNTER TO DETERMINE THE VALUE OF XXX IN C##XXX;
C                  THE FINAL VALUE IS THE TOTAL COUNT OF LITERALS
C                  OCCURRING IN CALL STATEMENTS ARGUMENT LISTS WHEN
C                  GLOBAL ANALYSIS IS TO BE PERFORMED. ALTHOUGH THERE
C                  IS NO LIMIT THE NUMBER OF LIMITS IN A PROGRAM MODULE
C                  A MAXIMUM OF 1000 LITERALS MAY OCCUR IN
C         LF     - LOGICAL VARIABLE, SET TRUE WHEN AN EXCLAMATION SIGN
C                  IS FOUND, SET FALSE OTHERWISE. USED TO PREVENT AN
C                  APOSTROPHE OR DOUBLE QUOTATION MARK BEING INTERPRETED
C                  AS A LITERAL WHEN ONE OCCURS AFTER THE EXCLAMATION
C                  SIGN.
C         LG     - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE OTHERWISE. WHEN SET TRUE,
C                  ANY LITERAL REPRESENTATED BY CSYMCF WILL HAVE THAT
C                  VALUE REPLACED BY A VARIABLE NAMED: C##XXX, WHERE
C                  THE XXX WITH BE A NUMERICAL COUNTER FROM 1 - 999.
C                  THIS SYNTHETIC VARIABLE NAME WILL ALLOW LENGTH AND
C                  TYPE CHECKING OF LITERAL ARGUMENTS FOR ALL CALL
C                  STATEMENTS PERFORMED BY ROUTINE ARGCHK.
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IT
C                  TO BE PERFORMED, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C
C     SUBROUTINES CALLED
C
C         IBCLR TBLINS
C
C     ******************************************************************
C
      SUBROUTINE RBLANK (LF,LG,JLITLN,IG)
C
C         IMPLICIT STATEMENTS
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CLITLN, CWK7
      CHARACTER*4     CWK4
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LF, LG
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (CWORK(45:48),JBITS),
     1(CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' MORE THAN 1000 LITERALS IN CALL STATEMENTS')
C
C         REMOVE BLANKS FROM THE SOURCE STATEMENT
C
      J1 = 1
      IG = 0
      JLITCT = ILITCT
      KG = KB
      CWK7(1:7) = CBLANK(1:7)
C
C         SUBSCRIPT JLOC IS THE CURRENT LOCATION IN THE STATEMENT.
C         SUBSCRIPT J IS THE NEW LOCATION OF THE BYTE IN THE
C         LOCATION DETERMINED BY JLOC.
C
      DO 10 JLOC = KF,KG
C
C         COUNT THE PARENTHESES
C
      IF(CSTMT(JLOC:JLOC) .EQ. CLPAR) IG = IG + 1
      IF(CSTMT(JLOC:JLOC) .EQ. CRPAR) IG = IG - 1
C
C         DETERMINE IF AN EXCLAMATION POINT EXISTS OUTSIDE OF A LITERAL
C         THE REST OF THE RECORD IS A LINE COMMENT AND IS IGNORED
C
      IF(CSTMT(JLOC:JLOC) .EQ. CEXCL) THEN
         LF = LTRUE
         IA = KB - JLOC + 1
C
C         TEST IF THE LENGTH OF THE LINE COMMENT EXCEEDS 52 CHARACTERS
C
         IF(IA .GT. 52) THEN
            IE = 52
            CSTMT(JLOC-1:JLOC+51) = CBLK52(1:IE)
            IE = IA - 52
            CSTMT(JLOC+52:KB) = CBLK52(1:IE)
         ELSE
            CSTMT(JLOC-1:KB) = CBLK52(1:IA)
         END IF
         GO TO 11
      END IF
C
C         TEST FOR A BLANK; THIS INCREMENTS SUBSCRIPT JLOC BUT NOT J
C
      IF(CSTMT(JLOC:JLOC) .EQ. CBLANK(1:1)) GO TO 10
C
C         DO NOT MOVE A CHARACTER WHEN JLOC = J1
C
      IF(JLOC .EQ. J1) THEN
         J1 = J1 + 1
         GO TO 10
      END IF
C
C         MOVE A CHARACTER ONLY WHEN JLOC > J
C
      IF(JLOC .GT. J1) THEN
         CSTMT(J1:J1) = CSTMT(JLOC:JLOC)
         J1 = J1 + 1
C
C         DETERMINE IF THE MOVED CHARACTER WAS A BLANK
C
         IF(CSTMT(JLOC:JLOC) .NE. CBLANK(1:1)) THEN
C
C         BLANK THE CHARACTER MOVED
C
            CSTMT(JLOC:JLOC) = CBLANK(1:1)
C
C         DETERMINE IF THE MOVED CHARACTER IS THE FINAL CHARACTER IN THE
C         STATEMENT
C
            IF(JLOC .EQ. KB) GO TO 10
C
C         REPLACE THE MOVED CHARACTER WITH A BLANK ONLY WHEN I > J
C
C              GO TO 10
C           END IF
         END IF
      END IF
 10   CONTINUE
C
C         DETERMINE IF ANY LITERAL OR HOLLERITH ARGUMENTS EXIST FOR A
C         CALL STATEMENT
C
 11   IF(LGLOBL .AND. JLITCT .EQ. 0) GO TO 15
C
C         DETERMINE IF THIS IS A CALL STATEMENT AND GLOBAL ANALYSIS IS
C         REQUESTED
C
      IF(LGLOBL .AND. LG) THEN
C
C         SET DO LOOP PARAMETERS
C
         JE = 1
         JF = KG
C
C         SET LOOP TO LOCATE ANY LITERALS IN THE CALL STATEMENT'S
C         ARGUMENTS
C
 12      DO 14 JLOC = JE,JF
C
C         DETERMINE IF AN LITERALS OCCURRED IN THE ARGUMENTS OF THIS
C         CALL STATEMENT
C
         IF(CSTMT(JLOC:JLOC) .EQ. CSYMCF) THEN
C
C         SHIFT ALL CHARACTERS IN CSTMT TO THE RIGHT 5 CHARACTERS TO
C         MAKE SPACE FOR THE C##XXX VARIABLE TO BE INSERTED INTO THE
C         MASTER VARIABLE NAME TABLE, CNAME.
C
            DO 13 IJ = KB,JLOC,-1
            CSTMT(IJ+5:IJ+5) = CSTMT(IJ:IJ)
 13         CONTINUE
C
C         BLANK ALL CHARACTERS IN CSTMT FROM KB+1 TO JG
C
            KB = KB + 5
C
C         COUNT THE LITERAL AND CREATE THE TEXT FORM OF THE COUNT VALUE
C
            KLITCT = KLITCT + 1
            CWK4(1:4) = CBLANK(1:4)
            WRITE (CWK4,'(I4)') KLITCT
C
C         PLACE THE SYNTHETIC VARIABLE C##XXX IN THE COMPRESSED CALL
C         STATEMENT ARGUMENT LIST
C
            CSTMT(JLOC:JLOC+2) = 'C##'
            IF(KLITCT .LT. 10) THEN
               CSTMT(JLOC+3:JLOC+5) = C0//C0//CWK4(4:4)
            ELSE IF(KLITCT .LT. 100) THEN
               CSTMT(JLOC+3:JLOC+5) = C0//CWK4(3:4)
            ELSE IF(KLITCT .LT. 1000) THEN
               CSTMT(JLOC+3:JLOC+5) = CWK4(2:4)
            ELSE IF(KLITCT .LT. 1000) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
               GO TO 14
            END IF
C
C         PLACE THE SYNTHETIC VARIABLE C##XXX IN THE MASTER NAME TABLE
C
            CWORK(1:52) = CBLK52(1:52)
            CWORK(1:6) = CSTMT(JLOC:JLOC+5)
            IWORK = -1
            CWORK(37:37) = CCC
            IF(LG) THEN
               WRITE (CWK7,'(I7)') JLITLN
               CLITLN(ILITCT)(1:7) = CWK7(1:7)
            END IF
C
C         SET THE LENGTH VALUE FOR THE MASTER NAME FILE TABLE RECORD
C
            IF(JLITLN .LT. 9) THEN
               CWORK(38:38) = CWK7(1:1)
            ELSE IF(JLITLN .LT. 100) THEN
               CWORK(38:39) = CWK7(1:2)
            ELSE IF(JLITLN .LT. 1000) THEN
               CWORK(38:40) = CWK7(1:3)
            ELSE IF(JLITLN .LT. 10000) THEN
               CWORK(38:41) = CWK7(1:4)
            ELSE IF(JLITLN .LT. 100000) THEN
               CWORK(38:42) = CWK7(1:5)
            ELSE IF(JLITLN .LT. 1000000) THEN
               CWORK(38:43) = CWK7(1:6)
            ELSE
               CWORK(38:44) = CWK7(1:7)
            END IF
            JBITS = 0
            JBITS = IBCLR(JBITS,15)
            IVCNT = 6
            CALL TBLINS (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            JF = KB
            GO TO 12
         END IF
 14      CONTINUE
      END IF
C
C         SET THE FINAL VALUE OF THE LOCATION OF THE THE LAST CHARACTER
C
 15   DO 16 JLOC = KB,1,-1
      IF(CSTMT(JLOC:JLOC) .NE. CBLANK(1:1)) THEN
         KB = JLOC
         GO TO 17
      END IF
 16   CONTINUE
C
C         ROUTINE EXIT
C
 17   KC = 1
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE DETERMINES IF A POSSIBLE LOGICAL OPERATOR IS A
C         RECORD NAME USED IN A COMPOUND VARIABLE NAME.
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE LETTER: A
C         CASTER - CHARACTER VARIABLE, AN ASTERISK, *
C         CDOL   - CHARACTER VARIABLE, A DOLLAR SIGN, $
C         CDOT   - CHARACTER VARIABLE, A PERIOD, .
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN, =
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS, (
C         COLON  - CHARACTER VARIABLE, A COLON, :
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN;, -
C         COMMA  - CHARACTER VARIABLE, A COMMA, ,
C         CPERC  - CHARACTER VARIABLE, A PERCENTAGE SIGN, %
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN, +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS, )
C         CSTMTA - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSLASH - CHARACTER VARIABLE, A SLASH, /
C         CUNDER - CHARACTER VARIABLE, AN UNDERSCORE, _
C         CZZ    - CHARACTER VARIABLE, THE LETTER: Z
C         C0     - CHARACTER VARIABLE, THE NUMERAL: 0
C         C9     - CHARACTER VARIABLE, THE NUMERAL: 9
C         IDOTKT - COUNT OF THE NUMBER OF PERIODS OR PERCENTAGE SIGNS
C         IDX    - LOCATION OF A PERIOD IN A VARIABLE NAME
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINITIONS
C         J1     - SUBSCRIPT VARIABLE
C         J2     - DO LOOP PARAMETER
C         J3     - DO LOOP PARAMETER
C         J4     - DO LOOP PARAMETER
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A RECORD IS WRITTEN
C                  ON UNIT 7, SET FALSE OTHERWISE
C
C     ******************************************************************
C
      SUBROUTINE TESTR (CSTMTA,IDX,L1)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK, CWK52
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1
      INTEGER*2       ISRECL, I2WK1
      REAL*8          FCONFT, FP
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWK52(33:36),ISNWK), (CWK52(45:48),JBITS),
     1            (CWK52(49:52),IVCNT), (CRECTB,JRECTB),
     2            (CNAME,IENAME)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DETERMINE IF ANY RECORD STATEMENTS EXIST
C
      IF(IRECD .EQ. 0) GO TO 15
      L1 = LFALSE
C
C         DETERMINE THE LOCATION OF THE START OF THE CURRENT FIELD
C
      J2 = IDX - 1
      DO 10 J1 = J2,1,-1
      IF(.NOT.(CSTMTA(J1:J1) .GE. CAA .AND. CSTMTA(J1:J1) .LE. CZZ)
     1   .AND. .NOT.(CSTMTA(J1:J1) .GE. C0 .AND. CSTMTA(J1:J1) .LE. C9)
     2   .AND. CSTMTA(J1:J1) .NE. CUNDER .AND. CSTMTA(J1:J1) .NE. CDOL
     3   .AND. CSTMTA(J1:J1) .NE. CDOT) THEN
         J3 = J1 + 1
         GO TO 11
      END IF
 10   CONTINUE
      J3 = 1
C
C         DETERMINE THE LOCATION THE END OF THE CURRENT FIELD
C
 11   DO 12 J1 = J3,KB
      IF(CSTMTA(J1:J1) .EQ. CLPAR  .OR. CSTMTA(J1:J1) .EQ. CRPAR  .OR.
     1   CSTMTA(J1:J1) .EQ. COMMA  .OR. CSTMTA(J1:J1) .EQ. CEQ    .OR.
     2   CSTMTA(J1:J1) .EQ. CPLUS  .OR. CSTMTA(J1:J1) .EQ. CMINUS .OR.
     3   CSTMTA(J1:J1) .EQ. CASTER .OR. CSTMTA(J1:J1) .EQ. CSLASH .OR.
     4   CSTMTA(J1:J1) .EQ. COLON  .OR. CSTMTA(J1:J1) .EQ. CBLANK(1:1)
     5   .OR. CSTMTA(J1:J1) .EQ. CDOT) THEN
         IF(J1 .EQ. KB) THEN
            J4 = J1 - 1
         ELSE
            J4 = J1
         END IF
         GO TO 13
      END IF
 12   CONTINUE
C
C         DETERMINE IF THIS IS A COMPOUND VARIABLE NAME BY COUNTING THE
C         NUMBER OF PERIODS OR PERCENTAGE SIGNS WITHIN THE CURRENT FIELD
C
 13   IDOTKT = 0
      DO 14 J1 = J3,J4
      IF(CSTMT(J1:J1) .EQ. CDOT .OR. CSTMT(J1:J1) .EQ. CPERC) THEN
         IDOTKT = IDOTKT + 1
      END IF
 14   CONTINUE
C
C         WHEN IDOTKT IS NOT ZERO, THIS FIELD IN A COMPOUND VARIABLE
C         NAME
C
      IF(IDOTKT .GT. 0) L1 = LTRUE
C
C         R0UTINE EXIT
C
 15   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE CREATES AN ERROR MESSAGE WHEN LOGICAL OPERATOR
C         SYNTAX IS ILLEGAL
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CF100  - FORMAT STATEMENT FOR LOGICAL SYNTAX ERROR
C         CNUM   - CHARACTER VARIABLE, THE TEXT FORM OF THE DIGIT TO
C                  BE PLACED IN CF100
C         IDX    - LOCATION OF A PERIOD IN THE LOGICAL OPERATOR. IT WILL
C                  USUALLY BE THE INITIAL OCCURENCE
C         INUM   - THE ARITHMETIC VALUE TO LOCATE THE RIGHT BOUNDARY OF
C                  THE LOGICAL OPERATOR FIELD TO BE FILLED WITH BLANKS
C         IREC0  - COUNT OF THE NUMBER OR RECORDS ON UNIT ZERO
C                  ADDRESS FILES ON UNIT 7 (VARIABLE NAMES)
C         I1     - LOCATION OF THE START OF A VARIABLE NAME FIELD
C         I2     - LOCATION OF THE END OF A VARIABLE NAME FIELD
C         I3     - LOCATION OF THE START OF A VARIABLE NAME
C         I4     - LOCATION OF THE END OF A VARIABLE NAME
C         JDX    - SUBSCRIPT VARIABLE
C         JNUM   - THE ARITHMETIC VALUE TO LOCATE THE LEFT BOUNDARY OF
C                  THE LOGICAL OPERATOR FIELD TO BE FILLED WITH BLANKS
C         J1     - LOCATION OF A CHARACTER TO BE MOVED
C         J2     - DO LOOP PARAMETER
C         J3     - DO LOOP PARAMETER
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KC     - LOCATION OF THE START OF THE DO LOOP TO SCAN FOR
C                  LOGICAL OPERATORS IN SUBROUTINE C0MPRS
C         KNUM   - NUMBER OF CHARACTERS TO BE FILLED WITH BLANKS
C
C     ******************************************************************
C
      SUBROUTINE LOGERR (IDX,CNUM,INUM,JNUM,CSTMT)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*92    CLITWK
      CHARACTER*50    CF100
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*1     CNUM
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      INTEGER*2       ISRECL, I2WK1
      REAL*8          FP
C
C         COMMON STATEMENTS
C
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
C
C         DATA STATEMENTS
C
      DATA CF100 /'('' ISN:'',I6,'' LOGICAL OPERATOR SYNTAX ERROR: '',AX
     1)'/
C
C       SAVE STATEMENT
C
      SAVE
C
C         DO NOT WRITE THE ERROR MESSAGE WHEN IT OCCURS IN AN INCLUDE
C         FILE
C
      IF(LINCL) GO TO 11
C
C         CREATE THE ERROR FORMAT AND WRITE THE ERROR MESSAGE
C
      I1 = IDX - JNUM
      I2 = IDX + INUM
      IF(INUM .NE. 0 .AND. JNUM .EQ. 0) KNUM = I2
      IF(INUM .EQ. 0 .AND. JNUM .NE. 0) KNUM = I1
      CF100(47:47) = CNUM
      WRITE (0,CF100) ISN,CSTMT(I1:I2)
      IREC0 = IREC0 + 1
      CSTMT(I1:I2) = CBLANK(1:KNUM)
      CSTMT(IDX:IDX) = CSYMCD
C
C        COMPRESS THE STATEMENT TO REMOVE BLANKS
C
      DO 10 JDX = IDX+1,KB
      CSTMT(JDX:JDX) = CSTMT(JDX+INUM:JDX+INUM)
 10   CONTINUE
      CSTMT(KB-INUM+1:KB) = CBLANK(1:INUM)
      KB = KB - INUM
C
C         R0UTINE EXIT
C
 11   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE CREATES AN ERROR MESSAGE WHEN A DEFINITION
C         STATMENT OCCURS AFTER THE FIRST EXECUTABLE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CF100  - CHARACTER VARIABLE, THE ERROR MESSAGE FORMAT STATEMENT
C         ISN    - THE ISN OF THE CURRENT STATEMENT FOR WHICH A MESSAGE
C                  IS TO BE WRITTEN
C         ISNK   - THE ISN OF THE LAST PRIOR STATEMENT FOR WHICH AN
C                  ERROR MESSAGE WAS WRITTEN
C         IREC0  - COUNT OF THE NUMBER OR RECORDS ON UNIT ZERO
C         J2     - DO LOOP PARAMETER
C         J3     - DO LOOP PARAMETER
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE INITIAL
C                  EXECUTABLE STATEMENT OCCURS
C
C     ******************************************************************
C
      SUBROUTINE LOCERR (LSTART,ISN,IREC0)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
C     DIMENSION CF100(71)
C
C         TYPE STATEMENTS
C
      CHARACTER*71  CF100
      LOGICAL*1     LSTART
C
C         DATA STATEMENTS
C
      DATA CF100 /'('' ISN:'',I6,'' THIS STATEMENT OCCURS AFTER FIRST EX
     1ECUTABLE STATEMENT'')'/
C
C       SAVE STATEMENT
C
      SAVE
C
C         DETERMINE IF ISNK IS TO BE INITIALIZED
C
      IF(.NOT.LSTART) THEN
         ISNK = 0
         GO TO 10
      END IF
C
C         WRITE THE ERROR MESSAGE ONLY ONCE FOR THE SAME STATEMENT
C
      IF(ISN .EQ. ISNK) GO TO 10
C
C         SAVE THE CURRENT ISN; THIS WILL BE USED TO ALLOW ONLY ONE
C         MESSAGE PER ISN.
C
      ISNK = ISN
C
C         WRITE THE LOCATION ERROR MESSAGE
C
      IREC0 = IREC0 + 1
      WRITE (0,CF100) ISN
C
C         R0UTINE EXIT
C
 10   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE PROCESSES A COMPOUND VARIABLE NAME WHEN IT OCCURS
C         AS AN ARGUMENT IN A CALL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CDOT   - CHARACTER VARIABLE, A PERIOD: .
C         CPERC  - CHARACTER VARIABLE, A PERCENTAGE SIGN: %
C         CQUES  - CHARACTER VARIABLE, A QUESTION MARK: ?
C         CRECTB - CHARACTER VARIABLE, TABLE OF RECORD VARIABLE NAMES
C                  AND THEIR LENGTH. A MAXIMUM OF 1000 RECORD VARIABLE
C                  NAME DEFINITIONS ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE VARIABLE NAME CONTAINING
C                                   THE RECORD VARIABLE
C                 33 - 64 A*32  16  RECORD VARIABLE NAME
C                 65 - 68 I*4   17  INTEGER VALUE OF THE LENGTH OF
C                                   THE RECORD DEFINITION
C         CWK80  - CHARACTER VARIABLE, BUFFER CONTAINING THE VARIABLE
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         IE     - THE FINAL CHARACTER IN THE VARIABLE NAME FIELD
C         IREC0  - COUNT OF THE RECORDS ON UNIT 0
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINITIONS
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IS     - THE INITIAL CHARACTER IN THE VARIABLE NAME FIELD
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         IVCNT  - LENGTH OF A RECORD NAME, EQUIVALENCED TO CWORK(49:52)
C         IWORK  - THE ISN + 128, EQUIVLALENCED TO CWORK(33:36)
C         JBITS  - BIT SWITCHES, EQUIVLAENCED TO CWORK(45:48)
C         JRECTB - EQUIVALENCED TO CRECTB
C         J1     - SUBSCRIPT VARIABLE
C         J2     - DO LOOP START VALUE
C         J3     - LOCATION OF THE FINAL CHARACTER IN THE VARIABLE NAME
C                  TO BE PROCESSED BY ROUTINE VSETUP. THIS WILL BE A
C                  RECORD NAME.
C         J4     - WORK AREA AND SUBSCRIPT
C         J5     - WORK AREA
C         J6     - LOCATION OF PERIOD OR PERCENTAGE SIGN
C         J7     - LOCATION OF THE START OF A NAME FIELD
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN LCALL IS TRUE, SET
C                  FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE VARIABLE NAME
C                  IS %LOC, &REF, OR %VA, SET FALSE OTHERWISE. THIS IS
C                  ALWAYS FALSE FOR THIS ROUTINE.
C
C     SUBROUTINES CALLED
C
C         IBSET TABSRH
C
C     ******************************************************************
C
      SUBROUTINE CSETUP (CWK80,IS,IE)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CFILEB(10), CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100),
     2CSREC(20), CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500),
     3CSUBTB(1000), CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100), JRECTB(17,1000)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE, CFILEB, CWK80
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CWK8, CIMPL
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1, L2
      INTEGER*2       ISRECL
      INTEGER*4       ICONIT, IOUTC, ISNUM, JCONFT, JSTR
      REAL*8          FCONFT
C
C       SAVE STATEMENT
C
      SAVE
C
C         COMMON STATEMENTS
C
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /INFILE/ JFILES, CFILEB
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (CWORK(45:48),JBITS),
     1            (CWORK(49:52),IVCNT), (CRECTB,JRECTB),
     2            (CNAME(1),IENAME(1,1))
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NOT A RECORD DEFINITION: ',A32)
 101  FORMAT(I8)
C
C        LOCATE THE A PERIOD DELINEATING THE END OF A RECORD NAME WITHIN
C        THE NAME FIELD
C
      J2 = IS + 1
      J6 = 0
      J7 = 1
      L2 = LFALSE
      IF(LCALL) THEN
         L1 = LTRUE
      ELSE
         L1 = LFALSE
      END IF
 10   DO 11 J1 = J2,IE
      IF(CWK80(J1:J1) .EQ. CDOT .OR. CWK80 .EQ. CPERC) THEN
C
C         SAVE LOCATION OF THE END OF A RECORD OR VARIABLE NAME
C
         J6  = J1
         IF(J1 .LT. IE) THEN
            J3 = J1 - 1
         ELSE
            J3 = IE
         END IF
C
C         CREATE CWORK FOR A RECORD NAME
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         IVCNT = J6 - J7
         IF(J2 .EQ. IS + 1) THEN
            CWORK(1:IVCNT) = CWK80(J2-1:J3)
         ELSE
            CWORK(1:IVCNT) = CWK80(J2:J3)
         END IF
         CALL TABSRH (CRECTB,IRECD,68,33,64,CWORK,1,32,IRET,1000)
         IF(IRET .GT. 0) THEN
            CWORK(1:32) = CRECTB(IRET)(33:64)
            IWORK = ISN + 128
            J5 = JRECTB(17,IRET)
            CWORK(37:37) = CQUES
            WRITE (CWK8,101) J5
            J5 = 0
            DO J4 = 1,8
            IF(CWK8(J4:J4) .NE. CBLK52(1:1)) THEN
               J5 = J5 + 1
               IF(J5 .LE. 7) CWORK(J5+37:J5+37) = CWK8(J4:J4)
            END IF
            END DO
            JBITS = IBSET(JBITS,2)
            JBITS = IBSET(JBITS,7)
            IF(.NOT.LINCL) THEN
               JBITS = IBSET(JBITS,15)
               WRITE (7,REC=IREC7) CWORK(1:52)
               IREC7 = IREC7 + 1
            END IF
         ELSE
C
C         DETERMINE IF THE VARIABLE IS AN ARGUMENT OR DIMENSIONED
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0 .AND. .NOT.BTEST(IENAME(9,IRET),7) .AND.
     1         .NOT.BTEST(IENAME(9,IRET),17)) THEN
               IREC0 = IREC0 + 1
               WRITE (0,100) ISN,CWORK(1:32)
              GO TO 12
            END IF
         END IF
         J2 = J6 + 1
         J7 = J2
         GO TO 10
      END IF
 11   CONTINUE
C
C         AFTER ALL RECORD NAMES ARE PROCESSED, PROCESS THE TYPED
C         VARIABLE NAME DEFINED IN A STRUCTURE. J6 WILL CONTAIN THE
C         LOCATION OF THE LAST OCCURRING PERIOD OR PRECENTAGE SIGN.
C
C         CREATE THE CWORK RECORD FOR THE TYPED VARIABLE NAME
C         TERMINATING THE COMPLEX VARIABLE NAME. IT MUST BE A VARIABLE
C         DEFINED IN A STRUCTURE.
C
      CWORK(1:52) = CBLK52(1:52)
      IVCNT = IE - J6
      JBITS = 0
      CWORK(1:IVCNT) = CWK80(J6+1:IE)
      IWORK = ISN + 128
      JBITS = IBSET(JBITS,6)
      JBITS = IBSET(JBITS,7)
      IF(.NOT.LINCL) THEN
         JBITS = IBSET(JBITS,15)
         WRITE (7,REC=IREC7) CWORK(1:52)
         IREC7 = IREC7 + 1
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE SEPARATES A STRUCTURE COMPOUND VARIABLE NAME
C         INTO ITS COMPONENTS, AND THE SETS UP THE WORK AREA TO PROCESS
C         ALL COMPONENT NAMES IN SUBROUTINE CHKNME.
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDOT   - CHARACTER VARIABLE, A PERIOD
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A CHARACTER
C                  DEFINITION
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRECTB - TABLE OF RECORD VARIABLE NAMES AND THEIR LENGTH.
C                  A MAXIMUM OF 1000 RECORD VARIABLE NAME DEFINITIONS
C                  ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE VARIABLE NAME CONTAINING
C                                   THE RECORD VARIABLE
C                 33 - 64 A*32  16  RECORD VARIABLE NAME
C                 65 - 68 I*4   17  INTEGER VALUE OF THE LENGTH OF
C                                   THE RECORD DEFINITION
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE FORTRAN STATEMENT BEING
C                  PROCESSED WHERE THE VARIABLE NAME IS LOCATED
C         CSTMTA - CHARACTER VARIABLE, THE PORTION OF THE CURRENT
C                  FORTRAN STATEMENT BEING ANALYZED
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CTYLEN - CHARACTER VARIABLE, SAVE AREA FOR THE TYPE AND LENGTH
C                  CHARACTERISTICS OF A VARIABLE
C         CUSED  - CHARACTER VARIABLE, THE USAGE CODES OF A VARIABLE
C         CUSE4  - CHARACTER VARIABLE, SAVE AREA FOR THE USAGE BIT
C                  SWITCHES OF A VARIABLE
C         CVARST - CHARACTER VARIABLE, AN ARRAY OF VARIABLE NAMES THAT
C                  ARE DEFINED WITHIN A STRUCTURE.
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32    8 VARIABLE NAME DEFINED IN THE
C                                   STRUCTURE NAMES IN COLS 33-64
C                 33 - 64 A*32   16 NAME OF THE STRUCTURE WHERE THE
C                                   VARIABLE IN COLS 1-32 IS DEFINED
C                 65 - 72 A*8    18 TYPE AND LENGTH CHARACTERISTICS
C                                   OF THE VARIABLE IN COLS 1-32.
C         CWORK  - CHARACTER VARIABLE, THE WORK AREA TO PROCESS THE
C                  VARIABLE NAME IN ROUTINE CHKNME
C         CWK7   - CHARACTER VARIABLE, USED TO CONVERT INTEGER TO ASCII
C         CWK32  - CHARACTER VARIABLE, USED TO SAVE THE RECORD NAME OF
C                  A COMPOUND VARIABLE
C         CWK32V - CHARACTER VARIABLE, USED TO SAVE THE VARIABLE NAME OF
C                  A COMPOUND VARIABLE
C         FUNTBL - A TABLE OF STANDARD FORTRAN INTRINSIC FUNCTIONS
C                  COLS  1-32 THE FUNCTION NAME
C                  COLS 33-35 THE TYPE AND LENGTH OF FUNCTION'S RETURN
C                             VALUE AS NUMERIC CHARACTERS. A # IN COLUMN
C                             34 INDICATES THE LENGTH IS DEPENDENT UPON
C                             ARGUMENTS OF THE FUNCTION.
C
C                  TYPE CODES USED ARE:
C
C                  B - SINGLE PRECISION COMPLEX
C                  C - CHARACTER
C                  D - DOUBLE PRECISION REAL
C                  E - DOUBLE PRECISION COMPLEX
C                  I - INTEGER (ALL LENGTHS)
C                  L - LOGICAL (ALL LENGTHS)
C                  R - SINGLE PRECISION REAL
C         II     - SUBSCRIPT VARIABLE
C         I1     - SUBSCRIPT VARIABLE
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN CODE FROM TABSRH; >0 - MATCH FOUND; <0 - NO
C                  MATCH FOUND
C         IRET1  - RETURN CODE FROM TABSRH; >0 - MATCH FOUND; <0 - NO
C                  MATCH FOUND
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         JAA    - LOCATION OF THE START OF A VARIABLE NAME OR THE
C                  COMPONENT OF A COMPOUND NAME
C         JBB    - THE END LOCATION OF A VARIABLE NAME OR THE COMPONENT
C                  OF A COMPOUND NAME
C         JCC    - THE LENGTH OF THE VARIABLE NAME OR THE COMPONENT OF
C                  A NAME
C         JDD    - WORK AREA
C         JEE    - DO LOOP START VALUE. THIS IS RESET WHEN A LOGICAL
C                  OPERATOR EXISTS.
C         JFINAL - THE END LOCATION OF THE VARIABLE NAME FIELD IN CSTMT
C         JSTART - THE START LOCATION OF THE VARIABLE NAME FIELD IN
C                  CSTMT
C         JY     - SUBSCRIPT VARIABLE
C         JZ     - SUBSCRIPT VARIABLE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IS
C                  TO BE PERFORMED, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE VARIABLE IS A
C                  COMPOUND VARIABLE, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE VARIABLE IS AN
C                  ARGUMENT OF A CALL STATEMENT, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN %LOC, %REF, OR %VAL
C                  ADDRESSING OPERATORS OCCUR, SET FALSE OTHERWISE.
C                  WHEN TRUE, THIS PREVENTS ERROR MESSAGES THAT THESE
C                  OPERATORS BELONG TO STRUCTURE AND RECORD DEFINITIONS.
C         MA     - START LOCATION OF THE RECORD NAME OF A COMPOUND
C                  VARIABLE
C         MB     - END LOCATION OF THE RECORD NAME OF A COMPOUND
C                  VARIABLE
C         NA     - WORK AREA
C         NVARST - COUNT OF THE NUMBER OF ENTRIES IN ARRAY CVARST
C
C     COMMENTS
C
C         A SUBROUTINE, ENTRY, OR FUNCTION NAME CAN NOT BE A COMPOUND
C         VARIABLE NAME.
C
C         THIS ROUTINE NEED NOT BE CALLED WHEN A VARIABLE IS NOT A
C         COMPOUND NAME.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         CHKNME IBCLR INSET ITOC SETTL TANSRH
C
C     ******************************************************************
C
      SUBROUTINE VSETUP (JSTART,JFINAL,JCC,L2,L3,CSTMTA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION FUNTBL(143), CLITLN(500), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION JRECTB(17,1000), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32, CWK32V
      CHARACTER*8     CBLANK, CIMPL, CTYLEN, CWK8
      CHARACTER*7     CLITLN, CWK7
      CHARACTER*4     CUSE4
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
      LOGICAL*1       L1, L2, L3
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK),
     1(CWORK(49:52),IVCNT), (CWORK(45:48),JBITS), (CWK8(2:2),CWK7),
     2(CNAME(1),IENAME(1,1)), (CRECTB,JRECTB)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' VARIABLE NAME EXCEEDS 32 CHARACTERS: ',A32)
 101  FORMAT(' ISN:',I6,' VARIABLE NAME IS NOT DEFINED AS A RECORD: ',
     1A32)
 102  FORMAT(' ISN:',I6,' VARIABLE NAME IS NOT DEFINED IN A STRUCTURE: '
     1,A32)
C
C         INITIALIZE LOGICAL SWITCH AND DO LOOP START VALUE
C
      L1 = LFALSE
      JEE = JSTART
C
C         SAVE AND SET THE INITIAL START LOCATION OF THE VARIABLE NAME
C
      IF(CSTMTA(JSTART:JSTART) .EQ. CSLASH .OR. CSTMTA(JSTART:JSTART)
     1   .EQ. CLPAR) THEN
         JAA = JSTART + 1
      ELSE
         JAA = JSTART
      END IF
C
C         SAVE THE TYPE AND LENGTH CODES , IF ANY
C
      CTYLEN(1:8) = CWORK(37:44)
C
C         SAVE THE USAGE BIT CODES, IF ANY
C
      CUSE4(1:4) = CWORK(45:48)
C
C         SET THE ISN VALUE
C
      IWORK = ISN + 128
C
C         LOOP TO LOCATE THE END OF A VARIABLE NAME. THE NAME WILL BE
C         TERMINATED BY A PERIOD, A PERCENT SIGN, ARITHMETIC OPERATOR,
C         A LEFT OR RIGHT PARENTHESIS, A LOGICAL OPERATOR, OR END OF
C         THE FIELD.
C
      DO 16 II = JEE,JFINAL
C
C         DETERMINE IF A PERIOD, OR A PERCENT SIGN IS A SEPARATOR FOR A
C         COMPOUND VARIABLE NAME, OR IF A LOGICAL OPERATOR IS A
C         DELIMITER
C
      IF(CSTMTA(II:II) .EQ. CDOT .OR. CSTMTA(II:II) .EQ. CPERC .OR.
     1  CSTMTA(II:II) .EQ. CSYMCD) THEN
C
C         THE PERIOD, PERCENT SIGN, OR A LOGICAL OPERATOR IS THE END OF
C         A RECORD NAME
C
         L1 = LTRUE
         IVCNT = II - JEE
         CWORK(1:IVCNT) = CSTMTA(JEE:II-1)
         JEE = II + 1
         GO TO 10
      END IF
C
C         SEARCH FOR THE END OF THE VARIABLE NAME
C         FIELD
C
      IF(II .EQ. JFINAL) THEN
         IF(L1) THEN
            CONTINUE
         ELSE
            L1 = LFALSE
         END IF
         IVCNT = JFINAL - JEE + 1
         JZ = JFINAL - 1
         CWORK(1:IVCNT) = CSTMTA(JEE:JZ)
         GO TO 10
      END IF
      GO TO 16
C
C         SET VARIABLE NAME MOVE PARAMETERS IF A PERIOD OR PERCENT
C         SEPARATOR OR THE END OF THE NAME HAS OCCURRED; THE PERIOD
C         OR PERCENT OCCUR ONLY IN A STRUCTURE COMPOUND VARIABLE NAME
C         OR IN A LOGICAL OPERATOR EXPRESSION WHICH MAY EMULATE A
C         COMPOUND VARIABLE NAME. HOWEVER, ROUTINE COMPRS REMOVES ALL
C         LOGICAL CONSTANTS AND OPERATORS FROM THE FORTRAN SOURCE
C         STATEMENT AND REPLACES THEM WITH THE HEX CHARACTER CD.
C         CONSEQUENTLY, ONLY REAL NUMBERS AND STRUCTURE VARIABLES WILL
C         CONTAIN PERIODS (OR DECIMAL POINTS) AFTER ROUTINE COMPRS.
C
 10   NA = II + 1
      JDD = II - JAA
      IF(II .EQ. JFINAL) THEN
         CWORK(1:IVCNT) = CSTMTA(JEE:JZ)
         JCC = JDD + 1
         JBB = JFINAL
C
C         DO NOT INITIALIZE CWORK WHEN THE VARIABLE IS AN ENTRY,
C         FUNCTION, OR SUBROUTINE NAME
C
         IF(.NOT.BTEST(JBITS,8) .AND. .NOT.BTEST(JBITS,9) .AND.
     1      .NOT.BTEST(JBITS,10)) THEN
            CWORK(1:32) = CBLK52(1:32)
            JBITS = 0
         END IF
         CWORK(1:JCC) = CSTMTA(II:JBB)
C
C         WHEN THIS IS A COMPOUND VARIABLE, SET THE LENGTH AND TYPE
C         CHARACTERISTICS OF THE VARIABLE FROM THE CVARST ARRAY. THIS
C         INSURES THE CORRECT VALUES ARE USED.
C
         IF(L1) THEN
C
C         SCAN TO LOCATE THE END OF THE RECORD NAME FOR THIS VARIABLE
C
            DO 12 JZ = JFINAL,JSTART,-1
            IF(CSTMTA(JZ:JZ) .EQ. CDOT .OR. CSTMTA(JZ:JZ) .EQ. CPERC)
     1         THEN
               MB = JZ - 1
               CWK32(1:32) = CBLK52(1:32)
               JBITS = 0
               CWK32V(1:32) = CBLK52(1:32)
C
C         SCAN TO LOCATE THE START OF THE RECORD NAME FOR THIS VARIABLE
C
               DO 11 JY = MB,JSTART,-1
C
C         WHEN THE START OF THE COMPOUND NAME OCCURS, THE START OF THE
C         RECORD IS DETERMINED
C
               IF(JY .EQ. JSTART) THEN
                  MA = JY
                  GO TO 13
               END IF
C
C         WHEN THE A PERIOD OR A PERCENT SIGN OCCURS, THE COMPOUND NAME
C         START OF THE RECORD NAME IS DETERMINED
C
               IF(CSTMTA(JY:JY) .EQ. CDOT .OR. CSTMTA(JY:JY) .EQ.
     1            CPERC) THEN
                  MA = JY + 1
                  GO TO 13
               END IF
 11            CONTINUE
            END IF
 12         CONTINUE
C
C         SAVE THE RECORD NAME OF THE COMPOUND VARIABLE
C
 13         MC = MB - MA + 1
            CWK32(1:MC) = CSTMTA(MA:MB)
            CWK32V(1:JFINAL-JZ) = CSTMTA(JZ+1:JFINAL)
C
C         DETERMINE THE STRUCTURE NAME DEFINING THE FINAL NODE OF THE
C         COMPOUND VARIABLE
C
            CALL TABSRH (CRECTB,IRECD,68,33,64,CWK32,1,32,IRET,1000)
            IF(IRET .GT. 0) THEN
C
C         THE RECORD NAME MATCHES A TABLE ENTRY; SAVE THE STRUCTURE
C         NAME TO LOCATE THE VARIABLE NAME DEFINED IN THE STRUCTURE
C         TO OBTAIN ITS TYPE AND LENGTH DEFINITIONS.
C
               DO 14 JZ = 1,NVARST
               IF(CVARST(JZ)(1:32) .EQ. CWK32V(1:32) .AND.
     1            CRECTB(IRET)(1:32) .EQ. CVARST(JZ)(33:64)) THEN
                  CWORK(37:44) = CVARST(JZ)(65:72)
                  L1 = LFALSE
                  JBITS = IBSET(JBITS,6)
                  JBITS = IBCLR(JBITS,13)
                  GO TO 15
               END IF
 14            CONTINUE
            END IF
         END IF
 15      CONTINUE
      ELSE
         JCC = JDD
         JBB = II - 1
      END IF
C
C         DETERMINE IF THE VARIABLE NAME LENGTH IS WITHIN ITS ALLOWED
C         RANGE
C
      IF(JCC .GT. 32) THEN
         JBB = JAA + 30
         JCC = 32
         IF(.NOT.LINCL) THEN
            WRITE (0,100) ISN,CSTMTA(JAA:JBB)
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         SET UP WORK AREA FOR THE NAME SAVE ROUTINE
C
      CWORK(1:32) = CBLK52(1:32)
      CWORK(1:JCC) = CSTMTA(JAA:JBB)
      IVCNT = JCC
C
C         SET THE TYPE AND LENGTH CODE
C
      IF(CWORK(37:37) .EQ. CBLANK(1:1)) CALL SETTL (CWORK)
C
C         SET THE TYPE AND LENGTH CHARACTERISTICS FOR A COMPOUND
C         VARIABLE
C
      IF(L1) THEN
         CALL TABSRH (CRECTB,IRECD,68,33,64,CWORK,1,32,IRET,1000)
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED AS A RECORD
C
         CWK7(1:7) = CBLK52(1:7)
         IF(IRET .GT. 0) THEN
            CALL ITOC (JRECTB(17,IRET),CWK7,1,7)
            CWORK(37:44) = CQUES(1:1)//CWK7(1:7)
            JBITS = IBSET(JBITS,2)
         ELSE
C
C         DETERMINE IF THE CURRENT VARIABLE NAME IS THE FINAL NAME IN A
C         COMPOUND NAME. IF TRUE IT MUST HAVE BEEN DEFINED WITHIN A
C         STRUCTURE DEFINITION.
C
            IF(JBB .EQ. JFINAL) THEN
C
C         DETERMINE IF THE VARIABLE IS DEFINED IN A STRUCTURE
C
               CALL TABSRH (CVARST,NVARST,72,1,32,CWORK,1,32,IRET1,1000)
               IF(IRET1 .GT. 0) THEN
                  IF(BTEST(IENAME(12,IRET1),6)) CWORK(37:44) =
     1               CNAME(IRET)(37:44)
               ELSE
                  IF(.NOT.L3) THEN
                     WRITE (0,102) ISN,CWORK(1:32)
                     IRET0 = IRET0 + 1
                     CALL SETTL (CWORK)
                  END IF
               END IF
            ELSE
C
C         THE CURRENT VARIABLE NAME SHOULD BE A RECORD NAME, BUT IT IS
C         NOT DEFINED AS A RECORD NAME.
C
               IF(.NOT.L3) THEN
                  WRITE (0,101) ISN,CWORK(1:32)
                  IREC0 = IREC0 + 1
                  CALL SETTL (CWORK)
               END IF
            END IF
         END IF
      END IF
C
C         WHEN THE VARIABLE IS AN ARGUMENT IN A CALL STATEMENT, SET
C         BIT 7
C
      IF(L2) JBITS = IBSET(JBITS,7)
      IF(L3) THEN
         CWORK(37:38) = 'I4'
         IF(CWORK(1:32) .NE. CBLK52(1:32)) CALL CHKNME (CSTMTA)
      ELSE
C
C         DETERMINE IF THE VARIABLE IS DEFINED WITHIN A STRUCTURE
C
         IF(L1) THEN
            CALL TABSRH (CVARST,NVARST,72,1,32,CWORK,1,32,IRET,1000)
         END IF
C
C         SET THE TYPE AND LENGTH IF THIS VARIABLE IS NOT A STRUCTURE
C         DEFINED VARIABLE
C
         IF(.NOT.L1) THEN
C
C         LOCATE THE VARIABLE NAME IN TABLE CNAME
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0 .AND. .NOT. LINCL) THEN
               CWORK(37:44) = CNAME(IRET)(37:44)
               CWORK(45:48) = CNAME(IRET)(45:48)
            END IF
            IF(IRET .GT. 0 .AND. BTEST(IENAME(12,IRET),6)) THEN
C
C         SEARCH CNAME FOR A VARIABLE NAME THAT IS NOT DEFINED IN A
C         STRUCTURE. THERE CAN BE ONLY ONE ENTRY IN CNAME FOR THIS
C         SITUATION.
C
               DO 17 JZ = IRET,INAME
               IF(CWORK(1:32) .EQ. CNAME(JZ)(1:32)) THEN
                  IF(BTEST(IENAME(12,JZ),6)) THEN
                     CONTINUE
                  ELSE
                     CWORK(37:44) = CNAME(JZ)(37:44)
                  END IF
               ELSE
                  GO TO 18
               END IF
 17            CONTINUE
            END IF
C
C         DETERMINE IF THE VARIABLE NAME IS AN INTRINSIC FUNCTION
C
            IF(IRET .GT.0) THEN
               IF(BTEST(IENAME(12,IRET),16)) THEN
                  CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRET1,143)
                  IF(IRET1 .GT. 0) THEN
                     IF(FUNTBL(IRET1)(34:34) .EQ. CSHARP) THEN
                        CWORK(37:39) = FUNTBL(IRET1)(33:33)//'? '
                     ELSE
                        CWORK(37:39) = FUNTBL(IRET1)(33:35)
                     END IF
                  END IF
C
C         DETERMINE IF THE VARIABLE NAME IS A DEFINED FUNCTION
C
               ELSE IF(BTEST(IENAME(12,IRET),10)) THEN
                  CWORK(37:44) = CNAME(IRET)(37:44)
               END IF
            END IF
         END IF
 18      CALL CHKNME (CSTMTA)
      END IF
      JAA = II + 1
      IF(LGLOBL) THEN
         CWK8(1:8) = CWORK(37:44)
         IF(.NOT.LCALL) CWORK(37:44) = CBLK52(1:8)
      END IF
 16   CONTINUE
C
C         RESTORE THE TYPE AND LENGTH CODES , IF ANY
C
      IF(CTYLEN(1:6) .NE. CBLANK(1:6)) CWORK(37:44) = CTYLEN(1:8)
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE SETS THE TYPE AND LENGTH CHARACTERISTICS FROM
C         THE DEFAULT VALUES DETERMINED BY THE STANDARD DEFAULT VALUES
C         OF FORTRAN MODIFIED BY ANY IMPLICIT STATEMENTS.
C
C     MEANING OF THE VARIABLES
C
C         CIMPL  - CHARACTER VARIABLE, A TABLE OF THE DEFAULT TYPE AND
C                  LENGTH CHARACTERISTICS AS MODIFIED BY IMPLICIT
C                  STATEMENTS FOR FORTRAN VARIABLES.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CWERK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER UNDERSCORE, _
C         ICTN   - THE VALUE TO ADD TO AN INTEGER DIGIT TO CONVERT IT
C                  TO A TEXT DIGIT, OT TO SUBTRACT FROM A TEXT DIGIT
C                  TO CONVERT IT TO AN INTEGER DIGIT.
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IRET   - A VALUE RETURNED FROM SUBROUTINE TABSRH. SET TO ZERO
C                  IF NO MATCH FOUND, SET TO THE TABLE INDEX LOCATION
C                  IN CNAME WHEN A MATCH IS FOUND.
C         I2WK1  - USED TO CONVERT A CHARACTER NUMERIC VALUE TO AN
C                  INTEGER VALUE, EQUIVALENCED TO CI2WK1.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C
C     ******************************************************************
C
      SUBROUTINE SETTL (CWERK)
C
C         IMPLICIT STATEMENTS
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  ICONTL(2,100), IOUTC(100), ISNUM(2,1000), JCONFT(4000), JSTR(20)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB
      CHARACTER*56    CSUBTB
      CHARACTER*52    CNAME, CPARAM
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*(*)   CWERK
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      INTEGER*2       I2WK1, ISRECL
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*4       ICONIT, IOUTC, ISNUM, JCONFT, JSTR
      REAL*8          FCONFT, FP
C
C         COMMON STATEMENTS
C
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CI2WK1,I2WK1), (CNAME,IENAME)
C
C       SAVE STATEMENT
C
      SAVE
C
C         PLACE THE TYPE AND LENGTH CHARACTERISTICS IN CWERK
C
      IF(CWERK(1:1) .EQ. CUNDER) THEN
         I2WK1 = 27
      ELSE
         I2WK1 = ICHAR(CWERK(1:1))
         I2WK1 = I2WK1 - ICTN
      END IF
C
C         DETERMINE IF AN INCLUDE FILE IS BEING PROCESSED
C
      IF(LINCL) THEN
C
C         DETERMINE IF THE CURRENT VARIABLE NAME HAS ALREADY BEEN
C         PLACED IN CNAME, THE TABLE OF ALL VARIABLES
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWERK,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         PLACE THE TYPE AND LENGTH CHARACTERISITICS FOR THE CWERK
C         VARIABLE FROM THE TABLE CNAME, SINCE THE VARIABLE HAS ALREADY
C         BEEN DETECTED.
C
            CWERK(37:44) = CNAME(IRET)(37:44)
         ELSE
C
C         PLACE THE TYPE AND LENGTH CHARACTERISTICS FOR THE CWERK
C         VARIABLE FROM TABLE CIMPL, THE DEFAULT VALUES.
C
            CWERK(37:44) = CIMPL(I2WK1)(1:8)
         END IF
      ELSE
C
C         PLACE THE TYPE AND LENGTH CHARACTERISTICS FOR THE CWERK
C         VARIABLE FROM TABLE CIMPL, THE DEFAULT VALUES.
C
         CWERK(37:44) = CIMPL(I2WK1)(1:8)
      END IF
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THE ROUTINE WILL CONVERT AN ASCII NUMERICAL FIELD TO A
C         FLOATING POINT OR INTEGER FORM
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDOT   - CHARACTER VARIABLE, A PERIOD OR DECIMAL POINT
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CFMT   - CHARACTER VARIABLE, FORMAT TO CONVERT A NUMBER
C         CF100  - CHARACTER VARIABLE, THE FORMAT FOR INTEGER
C                  CONVERSION
C         CF101  - CHARACTER VARIABLE, THE FORMAT FOR REAL CONVERSION
C         CI2WK2 - CHARACTER VARIABLE OVERLAY OF I2WK2
C         CI2WK3 - CHARACTER VARIABLE OVERLAY OF I2WK3
C         CI4WK4 - CHARACTER VARIABLE OVERLAY OF I4WK4
C         CJ2WK1 - CHARACTER VARIABLE OVERLAY OF J2WK1
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN
C         CNBUF  - CHARACTER VARIABLE, WORK BUFFER TO CONVERT THE TEXT
C                  FORM OF THE NUMBER TO EITHER INTEGER OF REAL FORM
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         COLON  - CHARACTER VARIABLE, THE CHARACTER: : (COLON)
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMTA - CHARACTER VARIABLE, THE PORTION OF THE CURRENT
C                  FORTRAN STATEMENT BEING ANALYZED
C         C0     - CHARACTER VARIABLE, A ZERO CHARACTER
C         C9     - CHARACTER VARIABLE, A NINE CHARACTER
C         FP     - DOUBLE PRECISION, THE VALUE OF A NUMBER RETURNED AS
C                  FLOATING POINT WHEN VARIABLE LA IS FALSE
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - VALUE OF THE EXPONENT SPECIFIED IN SCIENTIFIC FORM:
C                  .XXXXEYY OR .XXXXDYY
C         ID     - LOCATION OF THE LAST BYTE IN THE NUMBER FIELD
C         IDTN   - THE VALUE TO CHANGE A CHARACTER DIGIT TO AN ALGEBRAIC
C                  DIGIT OR FROM AN ALGEBRAIC NUMERIC VALUE TO A
C                  CHARACTER DIGIT FOR ASCII CODE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - THE VALUE OF A NUMBER AS AN INTEGER WHEN VARIABLE LA
C                  IS TRUE
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN CODE FROM TABSRH; LESS THAN ZERO NOT IN TABLE,
C                  GREATER THAN ZERO IS IN TABLE
C         I1     - ENDING SUBSCRIPT LOCATION OF THE NUMERIC FIELD IN THE
C                  WORK BUFFER
C         I2     - LENGTH OF THE NUMERICAL FIELD, INCLUDING THE DECIMAL
C                  POINT IF ANY
C         I2WK2  - LENGTH 2 INTEGER VARIABLE. USED AS A WORK AREA
C         I2WK3  - LENGTH 2 INTEGER VARIABLE. USED AS A WORK AREA
C         I3     - NUMBER OF DIGITS TO THE RIGHT OF THE DECIMAL POINT
C         I4     - LOCATION OF A DECIMAL POINT IF ONE OCCURS
C         I4WK1  - WORK AREA, USED TO DETERMINE THE TOTAL VALUE OF THE
C                  NUMBER
C         I4WK2  - WORK AREA, USED TO DETERMINE THE INTEGER VALUE OF THE
C                  NUMBER TO THE LEFT OF THE DECIMAL POINT
C         I4WK3  - WORK AREA, THE VALUE OF THE DIGITS TO THE RIGHT OF
C                  DECIMAL POINT AS A SEPARATE NUMBER; USED TO DETERMINE
C                  THE PLACEMENT OF THE DECIMAL POINT WHEN THE DIGITS
C                  TO THE RIGHT OF THE DECIMAL POINT ARE ALL ZEROS.
C         I4WK4  - WORK AREA, USED FOR ALGEBRAIC NUMBER TO ASCII
C                  CONVERSION
C         JJ     - LOCATION OF THE FIRST BYTE IN THE NUMBER FIELD
C         J1     - START LOCATION OF THE NUMERIC FIELD
C         J2     - END LOCATION OF THE NUMERIC FIELD
C         J2WK1  - A DIGIT OF THE NUMBER BEING CONVERTED FROM CHARACTER
C                  TO BINARY
C         KB     - LOCATION OF THE LAST CHARACTER IN CSTMTA
C         KK     - SUBSCRIPT VARIABLE AND LOCATION OF THE LAST BYTE IN
C                  THE NUMBER FIELD
C         K1     - THE VALUE OF KK + 1
C         K2     - DO LOOP PARAMETER
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER CONVER-
C                  SION IS TO INTEGER, SET FALSE IF FLOATING POINT.
C                  THE VALUE MAY BE CHANGED BY THIS ROUTINE.
C         LC     - LOGICAL VARIABLE, SET TRUE IF EXPONENT VALUE IN
C                  SCIENTIFIC NOTATION IS POSITIVE, FALSE IF NEGATIVE
C         LD     - LOGICAL VARIABLE, SET TRUE WHEN A FLOATING NUMBER IS
C                  IN SCIENTIFIC FORMAT, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LSNUM  - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER TO BE
C                  CATALOGED IS A STATEMENT NUMBER, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A DECIMAL POINT IS
C                  FOUND IN THE NUMBER FIELD
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A 'D' TYPE REAL
C                  NUMBER IS SPECIFIED
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMERIC FIELD
C                  IS A STATEMENT NUMBER, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE LOCATION OF THE
C                  FINAL DIGIT OF THE NUMBER IS SET, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE FOR AN 'E' TYPE REAL
C                  NUMBER IS SPECIFIED
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A REAL NUMBER IN
C                  SCIENTIFIC NOTATION IS SPECIFIED AND A PLUS OR
C                  MINUS SIGN FOLLOWS THE D OR E, SET FALSE OTHERWISE
C         X1     - WORK AREA TO COMPUTE THE VALUE OF THE NUMERIC VALUE
C                  OF THE NUMBER TO THE LEFT OF THE DECIMAL POINT
C         X2     - WORK AREA TO COMPUTE THE VALUE OF THE NUMERIC VALUE
C                  OF THE NUMBER TO THE RIGHT OF THE DECIMAL POINT
C
C     COMMENTS
C
C         THIS ROUTINE DOES NOT PLACE A NUMBER IN THE INTEGER OR
C         FLOATING SAVE TABLES.  IT ONLY CONVERTS FROM TEXT TO
C         EITHER INTEGER OR FLOATING FORMATS.
C
C         A LITERAL CAN NOT PRECEDE OR FOLLOW A NUMERICAL FIELD
C
C     ******************************************************************
C
      SUBROUTINE NUMBER (CSTMTA,LA,JJ,II,FP,IFP)
C
C         IMPLICIT STATEMENTS
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CNBUF, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*7     CF100
      CHARACTER*5     CF101
      CHARACTER*4     CI4WK4, CFMT
      CHARACTER*2     CI2WK1, CI2WK3, CJ2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP, FFP
      INTEGER*2       ISRECL, I2WK1, I2WK2, I2WK3, J2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 LA, LC, LD, L1, L2, L3, L4, L5, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/ FFP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (J2WK1,CJ2WK1), (CWORK(33:36),IWORK),
     1            (CWK8(2:2),CWK7), (CNAME(1),IENAME(1,1)), (I4WK4,
     2            CI4WK4), (CI2WK3,I2WK3)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CF100/'(Dxx.0)'/, CF101/'(Inn)'/, CFMT/'(I2)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' REAL EXPONENT EQUALS OR EXCEEDS 308')
C
C         INITIALIZATION
C
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      LC = LTRUE
      LD = LFALSE
      ID = 0
      IFP = 0
      I4WK3 = 0
      K2 = 0
      J1 = 0
      J2 = 0
      CNBUF(1:32) = CBLK52(1:32)
C
C         SCAN TO DETERMINE THE END OF THE NUMERIC FIELD
C
      DO 10 KK = JJ,KB
C
C       DETERMINE IF THE NUMERIC FIELD IS A SINGLE DIGIT
C
      IF(JJ .EQ. KB) THEN
         LA = LTRUE
         J1 = JJ
         J2 = JJ
         GO TO 11
      END IF
C
C         WHEN THE CHARACTER IS A NUMERICAL DIGIT, DETERMINE IF AN
C         ARITHMETIC SIGN PRECEDES OR FOLLOWS IT.
C
      IF(CSTMT(JJ:JJ) .GE. C0 .AND. CSTMT(JJ:JJ) .LE. C9) THEN
         IF((CSTMT(JJ-1:JJ-1) .EQ. CPLUS .OR. CSTMT(JJ-1:JJ-1) .EQ.
     1      CMINUS .OR. CSTMT(JJ-1:JJ-1) .EQ. CASTER .OR.
     2      CSTMT(JJ-1:JJ-1) .EQ. CSLASH) .AND. (CSTMT(JJ+1:JJ+1) .EQ.
     3      CPLUS .OR. CSTMT(JJ+1:JJ+1) .EQ. CMINUS .OR.
     3      CSTMT(JJ+1:JJ+1) .EQ. CASTER .OR. CSTMT(JJ+1:JJ+1) .EQ.
     4      CSLASH)) THEN
            LA = LTRUE
            J1 = JJ
            J2 = JJ
            GO TO 11
         END IF
      END IF
C
C         PROCESS THE FIRST CHARACTER OF THE NUMERIC FIELD
C
      IF(KK .EQ. JJ) THEN
C
C         DETERMINE IF THE FIRST CHARACTER OF THE FIELD IS A MINUS SIGN
C
         IF(CSTMTA(JJ:JJ) .EQ. CMINUS) THEN
            L5 = LFALSE
            J1 = KK
            GO TO 10
         END IF
C
C         DETERMINE IF THE FIRST CHARACTER OF THE FIELD IS A PLUS SIGN
C
         IF(CSTMTA(JJ:JJ) .EQ. CPLUS) THEN
            J1 = KK
            GO TO 10
         END IF
C
C         DETERMINE IF THE FIRST CHARACTER OF THE FIELD IS PRECEDED BY
C         A MINUS SIGN
C
         IF(CSTMTA(JJ-1:JJ-1) .EQ. CMINUS) THEN
            J1 = JJ - 1
            IF(CSTMTA(JJ-2:JJ-2) .EQ. COMMA .OR. CSTMTA(JJ-2:JJ-2) .EQ.
     1         COLON .OR. CSTMTA(JJ-2:JJ-2) .EQ. CLPAR .OR.
     2         CSTMTA(JJ-2:JJ-2) .EQ. CRPAR .OR. CSTMTA(JJ-2:JJ-2) .EQ.
     3         CEQ .OR. CSTMTA(JJ-2:JJ-2) .EQ. CSYMCD) THEN
               L5 = LFALSE
               IF(CSTMTA(JJ-2:JJ-2) .EQ. CEQ) THEN
                  J1 = JJ -1
               ELSE
                  J1 = JJ
               END IF
               GO TO 10
            END IF
         END IF
C
C       DETERMINE IF THE FIRST CHARACTER IS PRECEDED BY A PLUS SIGN
C
         IF(CSTMTA(JJ-1:JJ-1) .EQ. CPLUS) THEN
            J1 = JJ - 1
            IF(CSTMTA(JJ-2:JJ-2) .EQ. COMMA .OR. CSTMTA(JJ-2:JJ-2) .EQ.
     1         COLON .OR. CSTMTA(JJ-2:JJ-2) .EQ. CLPAR .OR.
     2         CSTMTA(JJ-2:JJ-2) .EQ. CRPAR .OR. CSTMTA(JJ-2:JJ-2) .EQ.
     3         CEQ .OR. CSTMTA(JJ-2:JJ-2) .EQ. CSYMCD) THEN
               GO TO 10
            END IF
         END IF
C
C         DETERMINE IF THE FIRST CHARACTER IS A DECIMAL POINT
C
         IF(CSTMTA(KK:KK) .EQ. CDOT) THEN
            J1 = KK
            LA = LFALSE
            L1 = LTRUE
            GO TO 10
         END IF
C
C         DETERMINE IF THE FIRST CHARACTER IS A NUMERICAL DIGIT
C
         IF(CSTMTA(KK:KK) .GE. C0 .AND. CSTMTA(KK:KK) .LE. C9) THEN
            J1 = KK
            GO TO 10
         END IF
      END IF
C
C         WHEN THE FIELD IS A STATEMENT NUMBER, PROCESS THE VALUE.
C         NO MORE THAN FIVE DIGITS MAY BE USED
C
      IF(LSNUM .AND. KK .GE. 6) THEN
         J1 = JJ
         J2 = KK - 1
         GO TO 11
      END IF
C
C         PROCESS THE REMAINING DIGITS OF THE NUMERICAL FIELD
C
C         TEST FOR LOGICAL OPERATORS
C
      IF(CSTMTA(KK:KK) .EQ. CSYMCD) THEN
         J2 = KK - 1
         L4 = LTRUE
         GO TO 11
C
C         TEST FOR A DECIMAL POINT
C
      ELSE IF(CSTMTA(KK:KK) .EQ. CDOT) THEN
         LA = LFALSE
         L1 = LTRUE
         GO TO 10
C
C         CHECK FOR A D OR E FLOATING VALUE FOR A NUMBER
C
      ELSE IF(CSTMTA(KK:KK) .EQ. CDD .OR. CSTMTA(KK:KK) .EQ. CEE) THEN
         IF(CSTMT(KK+1:KK+1) .EQ. COMMA) THEN
            J2 = KK - 1
            GO TO 11
         END IF
         IF(CSTMTA(KK:KK) .EQ. CDD) THEN
            IF((CSTMTA(KK+1:KK+1) .GE. C0 .AND. CSTMTA(KK+1:KK+1) .LE.
     1      C9) .OR. CSTMTA(KK+1:KK+1) .EQ. CPLUS .OR. CSTMTA(KK+1:KK+1)
     2      .EQ. CMINUS) L2 = LTRUE
         END IF
         IF(CSTMTA(KK:KK) .EQ. CEE) THEN
            IF((CSTMTA(KK+1:KK+1) .GE. C0 .AND. CSTMTA(KK+1:KK+1) .LE.
     1      C9) .OR. CSTMTA(KK+1:KK+1) .EQ. CPLUS .OR. CSTMTA(KK+1:KK+1)
     2      .EQ. CMINUS) L5 = LTRUE
         END IF
C
C         WHEN THE CHARACTER PRECEDING A D OR AN E IS AN ALPHABETIC
C         CHARACTER, THIS TERMINATES THE NUMERIC FIELD
C
         IF(CSTMTA(KK-1:KK-1) .GE. CAA .AND. CSTMTA(KK-1:KK-1) .LE.
     1      CZZ .OR. CSTMTA(KK-1:KK-1) .EQ. CUNDER .OR.
     2      CSTMTA(KK-1:KK-1) .EQ. CDOL) GO TO 11
C
C         WHEN THE CHARACTER FOLLOWING A D OR AN E IS AN ALPHABETIC
C         CHARACTER, THIS TERMINATES THE NUMERIC FIELD
C
        IF(CSTMTA(KK+1:KK+1) .GE. CAA .AND. CSTMTA(KK+1:KK+1) .LE.
     1      CZZ .OR. CSTMTA(KK+1:KK+1) .EQ. CUNDER .OR.
     2      CSTMTA(KK+1:KK+1) .EQ. CDOL) THEN
            J2 = KK - 1
            GO TO 11
         END IF
C
C         WHEN THE CHARACTER FOLLOWING D OR E IS A PLUS OR MINUS SIGN,
C         SET A SWITCH TO PREVENT TERMINATING THE SEARCH FOR THE END
C         OF THE NUMERIC FIELD.
C
         IF(CSTMTA(KK+1:KK+1) .EQ. CPLUS .OR. CSTMTA(KK+1:KK+1) .EQ.
     1      CMINUS .OR. CSTMTA(KK+1:KK+1) .GE. C0 .AND.
     2      CSTMTA(KK+1:KK+1) .LE. C9) THEN
            LA = LFALSE
            LD = LTRUE
C
C         SET THE LOGICAL SWITCH FOR A 'D' SPECIFICATION
C
         IF(CSTMTA(KK:KK) .EQ. CDD .AND. CSTMTA(KK+1:KK+1) .GE. C0 .AND.
     1      CSTMTA(KK+1:KK+1) .LE. C9) L2 = LTRUE
C
C         SET THE LOGICAL SWITCH FOR AN 'E' SPECIFICATION
C
         IF(CSTMTA(KK:KK) .EQ. CEE .AND. CSTMTA(KK+1:KK+1) .GE. C0 .AND.
     1      CSTMTA(KK+1:KK+1) .LE. C9) L5 = LTRUE
         LA = LFALSE
         GO TO 10
         END IF
      END IF
C
C         WHEN THE CURRENT CHARACTER IS A PLUS OR MINUS SIGN, AND LD
C         IS SET TRUE, THIS INDICATES ADDITIONAL CHARACTERS MUST BE
C         SCANNED TO DETERMINE THE FINAL CHARACTER OF A SCIENTIFIC
C         NOTATION NUMBER.
C
      IF((CSTMTA(KK:KK) .EQ. CPLUS .OR. CSTMTA(KK:KK) .EQ. CMINUS) .AND.
     1   LD) THEN
         IF(L2 .OR. L5) THEN
           IF(CSTMT(KK-1:KK-1) .EQ. CDD .OR. CSTMT(KK-1:KK-1) .EQ. CEE)
     1        GO TO 10
           J2 = KK - 1
           GO TO 11
         END IF
         GO TO 10
      END IF
C
C         TEST IF THE END OF THE NUMERIC FIELD WHEN OTHER SYMBOLS OCCUR
C
      IF(CSTMTA(KK:KK) .EQ. COMMA .OR. CSTMTA(KK:KK) .EQ. CRPAR .OR.
     1   CSTMTA(KK:KK) .EQ. CLPAR .OR. CSTMTA(KK:KK) .EQ. CPLUS .OR.
     2   CSTMTA(KK:KK) .EQ. CMINUS .OR. CSTMTA(KK:KK) .EQ. CASTER .OR.
     3   CSTMTA(KK:KK) .EQ. CSLASH .OR. CSTMTA(KK:KK) .EQ. COLON .OR.
     4   CSTMTA(KK:KK) .EQ. CBLANK(1:1) .OR. CSTMTA(KK:KK) .EQ. CSYMCD
     5   .OR. CSTMTA(KK:KK) .EQ. CPERC .OR. CSTMTA(KK:KK) .EQ. CEQ) THEN
         J2 = KK - 1
         IFP = J2
         L4 = LTRUE
         GO TO 11
      END IF
C
C         TEST IF AN ALPHABETIC CHARACTER; THIS TERMINATES THE NUMERIC
C         FIELD
C
      IF(CSTMTA(KK:KK) .GE. CAA .AND. CSTMTA(KK:KK) .LE. CZZ .OR.
     1   CSTMTA(KK:KK) .EQ. CUNDER .OR. CSTMTA(KK:KK) .EQ. '$') THEN
         J2 = KK - 1
         GO TO 11
      END IF
C
C         TEST IF THE FINAL CHARACTER OF THE STATEMENT
C
      IF(KK .EQ. KB) THEN
         J2 = KK
         GO TO 11
      END IF
C
C         TEST FOR A DIGIT
C
      K1 = KK + 1
      IF(CSTMTA(K1:K1) .GE. C0 .AND. CSTMTA(K1:K1) .LE. C9)
     1      J2 = KK
 10   CONTINUE
C
C         WHEN THE DO LOOP EXITS NORMALLY, SET J2 TO THE VALUE OF KB
C
      J2 = KB
C
C         MOVE THE NUMERIC FIELD TO THE WORK BUFFER
C
 11   IF(CSTMTA(J2:J2) .LT. C0 .OR. CSTMTA(J2:J2) .GT. C9) THEN
         I1 = J2 - J1
      ELSE
         I1 = J2 -J1 + 1
      END IF
      CNBUF(1:I1) = CSTMTA(J1:J2)
C
C         SET THE END OF THE NUMERICAL FIELD RETURN VALUE
C
      IFP = J2
C
C         DETERMINE IF THE NUMBER DIGITS IN THE NUMERICAL FIELD
C         EXCEEDS 10
C
      IF(LA .AND. .NOT.LD .AND. I1 .GE. 10) THEN
         IF(CNBUF(1:10) .GT. '2147483647') THEN
            I1 = 9
            IF(CNBUF(1:9) .GT. '2147483647') I1 = 8
         ELSE
            I1 = 10
            END IF
      END IF
C
C         CREATE THE FIELD LENGTH FOR THE FORMAT STATEMENT
C
      CI2WK3(1:2) = CBLANK(1:2)
      WRITE (CI2WK3,CFMT) I1
C
C         DETERMINE IF A SCIENTIFIC NOTATION NUMBER HAS AN EXPONENT
C         GREATER THAN 307
C
      IF(L2 .OR. L5) THEN
         L6 = LFALSE
         IF(CNBUF(I1-4:I1-4) .EQ. CEE .OR. CNBUF(I1-4:I1-4) .EQ. CDD)
     1      THEN
            IF(CNBUF(I1-3:I1-3) .EQ. CPLUS .OR. CNBUF(I1-3:I1-3) .EQ.
     1         CMINUS) I2WK2 = 3
               I2WK2 = 3
         ELSE IF(CNBUF(I1-3:I1-3) .EQ. CEE .OR. CNBUF(I1-3:I1-3) .EQ.
     1      CDD) THEN
            IF(CNBUF(I1-2:I1-2) .EQ. CPLUS .OR. CNBUF(I1-2:I1-2) .EQ.
     1         CMINUS) THEN
               I2WK2 = 2
            ELSE
               I2WK2 = 3
            END IF
         ELSE IF(CNBUF(I1-2:I1-2) .EQ. CEE .OR. CNBUF(I1-2:I1-2) .EQ.
     1      CDD) THEN
            IF(CNBUF(I1-1:I1-1) .EQ. CPLUS .OR. CNBUF(I1-1:I1-1) .EQ.
     1         CMINUS) THEN
               I2WK2 = 1
            ELSE
               I2WK2 = 2
            END IF
         ELSE IF(CNBUF(I1-1:I1-1) .EQ. CEE .OR. CNBUF(I1-1:I1-1) .EQ.
     1      CDD) THEN
            I2WK2 = 1
         END IF
C
C         DETERMINE IF THE EXPONENT VALUE IS EQUAL TO OR GREATER THAN
C         308 OR IS EQUAL TO OR LESS THAN -308
C
         IF(I2WK2 .EQ. 3) THEN
            IF(CNBUF(I1-2:I1-2) .GE. C4) THEN
               CNBUF(I1-2:I1)  = C3//C0//C7
               GO TO 12
            ELSE
               READ (CNBUF(I1-2:I1),'(I3)') I4WK4
               IF(I4WK4 .GE. 308) THEN
                  CNBUF(I1-2:I1) = C3//C0//C7
                  GO TO 12
               ELSE
                  GO TO 13
               END IF
            END IF
 12         WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
 13   IF(LA) THEN
C
C         FORMAT FOR INTEGER NUMBERS
C
         IF(CI2WK3(1:1) .EQ. CBLANK(1:1)) THEN
            CF101(3:3) = CI2WK3(2:2)
            CF101(4:4) = CBLANK(1:1)
         ELSE
            CF101(3:4) = CI2WK3(1:2)
         END IF
         READ (CNBUF,CF101) II
         GO TO 14
      ELSE
C
C         FORMAT FOR REAL NUMBERS
C
         IF(L2) CF100(2:2) = CDD(1:1)
         IF(L5) CF100(2:2) = CEE(1:1)
         IF(.NOT.L2 .AND. .NOT.L5) CF100(2:2) = CFF(1:1)
         IF(CI2WK3(1:1) .EQ. CBLANK(1:1)) THEN
            CF100(3:3) = CI2WK3(2:2)
            CF100(4:4) = CDOT(1:1)
            CF100(5:6) = C0(1:1)//CBLANK(1:2)
         ELSE
            CF100(3:6) = CI2WK3(1:2)//'.0'
         END IF
         READ (CNBUF(1:I1),CF100) FP
      END IF
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     ******************************************************************
C
C         THIS SUBPROGRAM PROCESSES THE UNIT OF AN INPUT-OUTPUT CONTROL
C         LIST VARIABLE NAME OR NUMBER
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK, *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CI2    - CHARACTER VARIABLE, EQUIVALENCED TO I2
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         COUTC  - ARRAY OF INPUT-OUTPUT UNITS DEFINED AS AN INTEGER,
C                  EQUIVALENCED TO IOUTC
C         COUTV  - CHARACTER VARIABLE, ARRAY OF INPUT-OUTPUT UNITS
C                  DEFINED AS A VARIABLE
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE FORTRAN STATEMENT BEING
C                  PROCESSED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C40    - CHARACTER VARIABLE, 40 BYTE WORK AREA FOR WRITING
C                  THE UNIT NAME ON UNIT 1.
C                  TOTAL LENGTH IS 40 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32    8 THE UNIT VARIABLE NAME IN TEXT
C                                   FORMAT
C                 33 - 36 I*4     9 THE ISN + 128 WHERE THE UNIT IS USED
C                 37 - 40 I*4    10 THE LENGTH OF THE VARIABLE NAME +
C                                   128
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT NUMBER (NOT USED BY THIS ROUTINE)
C         II     - SUBSCRIPT VARIABLE
C         IOUTC  - ARRAY OF INPUT-OUTPUT UNITS DEFINED AS AN INTEGER,
C                  EQUIVALENCED TO COUTC
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN IOUTC
C         IOUTNV - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN COUTV
C         IREC8  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 8 (INPUT-OUTPUT VARIABLE
C                  NAMES)
C         IREC0  - COUNT OFTHE NUMBER OF RECORDS ON UNIT 0
C         IREC12 - COUNT OFTHE NUMBER OF RECORDS ON UNIT 12
C         IRET   - RETURN CODE FROM THE TABLE INSERT ROUTINE
C         IRET1  - RETURN CODE FROM THE TABLE SEARCH ROUTINE
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - COUNTER FOR PARENTHESES, A LEFT PARENTHESIS ADDS ONE,
C                  A RIGHT PARENTHESIS SUBTRACTS ONE.
C         I2     - SUBSCRIPT VARIABLE, ALSO USED TO CONVERT ASCII DIGITS
C                  TO AN INTEGER, EQUIVALENCED TO CI2
C         I3     - DO LOOP PARAMETER, START LOCATION FOR A DO LOOP
C         I4     - LOCATION OF THE END OF THE VARIABLE UNIT NAME FIELD
C         I5     - LOCATION OF THE END OF THE UNIT FIELD IN CSTMT
C         I6     - THE VALUE OF I2 + 1 WHEN SUBROUTINE NUMBER IS CALLED
C         I7     - SUBSCRIPT VARIABLE
C         I8     - WORK AREA
C         I9     - WORK AREA
C         J      - LOCATION OF THE CURRENT CHARACTER IN CSTMT
C         JA     - THE START LOCATION OF A FIELD
C         JB     - THE END LOCATION OF A FIELD
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         JC     - DO LOOP VARIABLE
C         JD     - THE LOCATION OF END OF THE UNIT DESIGNATION
C         JE     - THE VALUE OF THE ISN + 128. THIS AVOIDS THE PROBLEM
C                  OF INTERPRETING THE ISN AS AN ASCII COMMAND
C         JF     - THE STARTING LOCATION OF THE UNIT VARIABLE NAME, OR
C                  IF THE UNIT NAME IS SUBSCRIPTED, THE START OF A
C                  SUBSCRIPT VARIABLE NAME
C         JG     - THE INTEGER VALUE OF THE LENGTH OF THE VARIABLE
C                  NAME + 128; EQUIVALENCED TO C40.
C         KB     - LOCATION OF THE FINAL CHARACTER IN CSTMT
C         L      - LOGICAL VARIABLE, SET TRUE TO INDICATE A UNIT
C                  DESIGNATION IS PROCESSED, SET FALSE OTHERWISE
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN UNIT= OCCURS, SET
C                  FALSE OTHERWISE
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE UNIT
C                  ALREADY EXISTS IN THE COUTV ARRAY, SET FALSE OTHER-
C                  WISE
C         LC     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE UNIT END
C                  IS LOCATED, SET FALSE OTHERWISE
C         LD     - LOGICAL VARIABLE, SET TRUE IF A UNIT IS A VARIABLE
C                  NAME, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE FOR AN INTEGER NUMBER,
C                  SET FALSE FOR A FLOATING POINT NUMBER
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A COLON OCCUR
C                  WITHIN PARENTHESES, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A UNIT VARIABLE NAME
C                  IS PLACED IN TABLE COUTV, SET FALSE OTHERWISE
C                  SET FALSE FOR A FLOATING POINT NUMBER
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         2      - THE LIST OF NUMERIC INPUT-OUTPUT UNITS AND THEIR
C                  ISNS, RECORD LENGTH IS 40 CHARACTERS
C
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32    8 THE UNIT AS A VARIABLE NAME
C                 33 - 36 I*4     9 THE ISN + 128 WHERE THE UNIT IS USED
C                 37 - 40 I*4    10 THE LENGTH + 128 OF THE VARIABLE
C                                   NAME IN COLS 1 - 32
C         8      - INPUT-OUTPUT NUMERIC UNITS, RECORD LENGTH IS 10
C                  CHARACTERS
C
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1  - 4 I*4     1 THE UNIT NUMBER AS AN INTEGER + 128.
C                  5  - 8 I*4     2 THE ISN + 128 WHERE THE UNIT IS USED
C                  9 - 10 A*2       THE UNIT NUMBER IN TEXT FORM
C        10      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C
C     SUBROUTINES CALLED
C
C         EXPR IBSET INSERT ITABIN NUMBER TABINS TABSRH VSETUP
C
C     ******************************************************************
C
      SUBROUTINE CUNIT
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTC(100), COUTV(100),
     2CSREC(20), CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500),
     3CSUBTB(1000), CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI2, COUTC
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*40 C40
      LOGICAL*1    LA, LB, LC, LD, L1, L2, L5
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(49:52),
     1IVCNT), (C40(33:36),JE), (C40(37:40),JG), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (COUTC(1),IOUTC(1)), (CI2,I2), (CWORK(45:48),
     3JBITS)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' INVALID I/O UNIT',1X,A3)
 101  FORMAT(' ISN:',I6,' MORE THAN 100 INTEGER UNIT NUMBERS')
 102  FORMAT(' ISN:',I6,' VARIABLE INPUT-OUTPUT UNIT MUST BE EITHER CHAR
     1ACTER OR INTEGER')
C
C         TEST IF THE INITIAL CHARACTER IS A LEFT PARENTHESIS
C
      LA = LFALSE
      LB = LFALSE
      C40(1:32) = CBLK52(1:32)
      JE = 0
      JG = 0
      IF(CSTMT(J:J) .EQ. CLPAR) J = J + 1
      JA = J
      I4 = 0
      I5 = 0
C
C         TEST IF UNIT= IS SPECIFIED
C
      IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
         J = J + 5
         LA = LTRUE
      END IF
C
C         COMPUTE THE NUMBER OF CHARACTERS IN THE UNIT DESIGNATION AND
C         TEST IF THE UNIT DESIGNATION IS NUMERIC, ALPHABETIC, OR AN
C         ASTERISK
C
      L = LFALSE
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9 .OR.
     1   CSTMT(J:J) .EQ. CASTER) THEN
C
C    *******************************************************************
C    *                                                                 *
C    *    THE UNIT IS A NUMERIC VALUE OR AN ASTERISK                   *
C    *                                                                 *
C    *******************************************************************
C
         LD = LFALSE
C
C         WHEN THE UNIT IS DESINATED AS AN ASTERISK, SET THE UNIT NUMBER
C         TO ZERO
C
         IF(CSTMT(J:J) .EQ. CASTER) CSTMT(J:J) = C0(1:1)
C
C         DETERMINE THE END OF THE UNIT FIELD FOR A NUMERIC UNIT
C         DESIGNATION
C
         DO 14 II = J,KB
C
C         TEST IF THE FINAL CHARACTER OF THE STATEMENT
C
         IF(II .EQ. KB) THEN
            JA = KB
            JB = II - J
            IF(JB .EQ. 0) JB = 1
C
C         TEST IF THE FINAL CHARACTER IS NUMERIC
C
            IF(CSTMT(KB:KB) .GE. C0 .AND. CSTMT(KB:KB) .LE. C9) THEN
               JD = II
             ELSE
               JD = II - 1
            END IF
            GO TO 10
         END IF
C
C         TEST IF THE CHARACTER IS NUMERIC OR AN ASTERISK
C
         IF(CSTMT(II:II) .GE. C0 .AND. CSTMT(II:II) .LE. C9 .OR.
     1      CSTMT(II:II) .EQ. CASTER) THEN
            GO TO 14
         END IF
C
C         THE CHARACTER BEING SCANNED IS NOT NUMERIC OR AN ASTERISK,
C         THIS MUST BE THE END OF THE UNIT DESIGNATION
C
         JB = II - J
         JD = II - 1
C
C         WHEN THE FIELD LENGTH IS TOO LONG, THE NUMBER IS GREATER
C         THAN 99.
C
 10      IF(JB .GT. 2) THEN
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN,CSTMT(J:II)
               IREC0 = IREC0 + 1
            END IF
            J = II
            GO TO 28
         END IF
C
C         DETERMINE IF THIS IS THE INITIAL ENTRY INTO THE INPUT-OUTPUT
C         UNIT NUMBER TABLE
C
         IF(IOUTNC .EQ. 0) THEN
C
C         THIS IS THE INITIAL TABLE ENTRY
C
C           IOUTNC = 1
            L1 = LTRUE
            CALL NUMBER (CSTMT,L1,J,I2,FP,IFP)
C
C         CONVERT THE UNIT NUMBER TO TEXT FORMAT
C
            CALL ITABIN (IOUTC,IOUTNC,4,1,4,I2,1,4,IRET,100)
            IF(IOUTNC .GT. 100) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
            END IF
C
C         PLACE THE THE NUMERICAL FORM OF THE UNIT NUMBER IN ITS
C         SAVE ARRAY
C
            JE = I2 + 128
            JG = ISN + 128
            WRITE (8,REC=IREC8) JE,JG,CI2WK1
            IREC8 = IREC8 + 1
            L = LTRUE
            J = II
            GO TO 28
         ELSE
C
C         LOOP TO SEARCH THE TABLE FOR A MATCH AND CREATE AN ENTRY ON
C         UNIT 8 FOR ALL SUBSEQUENT NUMERIC INPUT OUTPUT UNIT OCCURENCES
C
            L1 = LTRUE
            CALL NUMBER (CSTMT,L1,J,I2,FP,IFP)
            DO 11 I8 = 1,IOUTNC
            IF(IOUTC(I8) .EQ. I2) GO TO 12
 11         CONTINUE
            IOUTNC = IOUTNC + 1
            IOUTC(IOUTNC) = I2
 12         DO 13 JC = 1,IOUTNC
            IF(IOUTC(JC) .EQ. I2) THEN
               CI2WK1(1:2) = CBLANK(1:2)
               IF(J .EQ. IFP) THEN
                  CI2WK1(1:1) = CSTMT(J:J)
               ELSE
                  CI2WK1(1:2) = CSTMT(J:IFP)
               END IF
               JE = I2 + 128
               JG = ISN + 128
               WRITE (8,REC=IREC8) JE,JG,CI2WK1
               IREC8 = IREC8 + 1
               IF(JB .EQ. 2) J = J + 1
               J = II
               GO TO 28
            END IF
 13         CONTINUE
C
C         NO TABLE ENTRY FOR THIS UNIT FOUND; INSERT IT IN THE TABLE
C
            IF(JB .EQ. JD - J + 1) THEN
               IOUTNC = IOUTNC + 1
               L1 = LTRUE
               CALL NUMBER (CSTMT,L1,J,I2,FP,IFP)
               IF(JB .EQ. 1) THEN
                  JD = J
               ELSE
                  JD = J + JB - 1
               END IF
            END IF
            IOUTC(IOUTNC) = I2
            CI2WK1(1:2) = CBLANK(1:2)
            IF(J .EQ. IFP) THEN
               CI2WK1(1:1) = CSTMT(J:J)
            ELSE
               CI2WK1(1:2) = CSTMT(J:IFP)
            END IF
            JE = I2 + 128
            JG = ISN + 128
            WRITE (8,REC=IREC8) JE,JG,CI2WK1
            IREC8 = IREC8 + 1
            J = II
            L = LTRUE
            GO TO 28
         END IF
 14      CONTINUE
      ELSE
C
C    *******************************************************************
C    *                                                                 *
C    *    THE UNIT IS AN ALPHABETIC SPECIFICATION                      *
C    *                                                                 *
C    *******************************************************************
C
C         THE INITIAL CHARACTER IS ALPHABETIC OR AN ASTERISK.
C         THE UNIT IS A VARIABLE, LOCATE THE END OF THE VARIABLE NAME
C
         LD = LTRUE
         LC = LFALSE
         JF = J
         CWORK(1:32) = CBLK52(1:32)
         DO 16 II = J,KB
C
C         TEST IF THE END OF THE RECORD IS THE END OF THE VARIABLE
C         NAME FIELD
C
         IF(II .EQ. KB) THEN
            I4 = KB
            LC = LTRUE
         END IF
C
C         THE END OF THE RECORD HAS NOT BEEN REACHED, TEST IF THE UNIT
C         FIELD IS TERMINATED BY A COMMA, A LEFT OR RIGHT PARENTHESIS,
C         COLON, OR AN ARITHMETIC OPERATOR
C
         IF(CSTMT(II:II) .EQ. CLPAR .OR. CSTMT(II:II) .EQ. CRPAR
     1      .OR. CSTMT(II:II) .EQ. COMMA .OR. CSTMT(II:II) .EQ. COLON
     2      .OR. CSTMT(II:II) .EQ. CPLUS .OR. CSTMT(II:II) .EQ. CMINUS
     3      .OR. CSTMT(II:II) .EQ. CASTER .OR. CSTMT(II:II) .EQ. CSLASH)
     4      THEN
            I4 = II - 1
            I5 = II
            LC = LTRUE
            GO TO 17
         END IF
         IF(LC) GO TO 17
 16      CONTINUE
C
C         PROCESS THE VARIABLE NAME
C
 17      JB = I4 - JF + 1
C
C         SET UP CWORK WHEN THE VARIABLE NAME ALREADY EXISTS IN CNAME
C
         CWORK(1:JB) = CSTMT(JF:I4)
         IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
            IWORK = ISN + 128
            CWORK(37:44) = CNAME(IRET)(37:44)
            CWORK(45:48) = CNAME(IRET)(45:48)
            IVCNT = JB
         END IF
         CALL VSETUP (JF,I4,JB,LFALSE,LFALSE,CSTMT)
         L = LTRUE
         I5 = I4 + 1
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
C
C         VERIFY THE VARIABLE UNIT DESIGATION IS EITHER A CHARACTER OR
C         INTEGER VARIABLE
C
         IF(CNAME(IRET)(37:37) .NE. CCC .AND. CNAME(IRET)(37:37) .NE.
     1      CII) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         SAVE THE UNIT VARIABLE NAME AND ISN ON UNIT 2. ALL UNITS
C         DEFINED AS A VARIABLE NAME HAVE THE INTEGER VALUE OF THE UNIT
C         NUMBER SET TO ZERO.
C
         C40(1:36) = CWORK(1:36)
         JE = IWORK
         JG = JB + 128
         IREC2 = IREC2 + 1
         WRITE (2,REC=IREC2) C40(1:40)
C
C         TEST IF THE UNIT VARIABLE NAME HAS ALREADY BEEN PLACED IN
C         THE TABLE
C
         L5 = LFALSE
C        IF(IOUTNV .EQ. 0) GO TO 19
C
C         DETERMINE IF THE CURRENT VARIABLE UNIT IS IN THE COUTV ARRAY
C
         CALL TABSRH (COUTV,IOUTNV,32,1,32,C40,1,32,IRET1,100)
C
C         WHEN THE THE UNIT VARIABLE NAME IS NOT IN THE TABLE, PLACE
C         IT IN THE TABLE
C
         IF(IRET1 .LT. 0) THEN
            CALL TABINS (COUTV,IOUTNV,32,1,32,C40,1,32,IRET,100)
            GO TO 19
         ELSE
            L5 = LTRUE
            LB = LTRUE
            GO TO 20
         END IF
C
C         PLACE THE UNIT VARIABLE NAME IN THE VARIABLE UNIT TABLE
C
 19   CONTINUE
 20      J = II
C
C         TEST IF A LEFT PARENTHESIS TERMINATED THE UNIT VARIABLE FIELD
C         IF TRUE, THEN THE VARIABLE IS SUBSCRIPTED OR HAS CHARACTER
C         RANGE SPECIFICATIONS
C
         I1 = 0
         I3 = II + 1
         JF = I3
         IF(CSTMT(II:II) .EQ. CLPAR) THEN
            I1 = I1 + 1
            L2 = LFALSE
            DO 27 I2 = I3,KB
C
C         DETERMINE IF A NUMERICAL DIGIT FOLLOWS THE LEFT PARENTHESIS.
C         THIS INDICATES THE FIRST RANGE SPECIFICATION IS NUMERIC.
C
            IF(I2 .EQ. I3) THEN
               IF(CSTMT(I2:I2) .GE. C0 .AND. CSTMT(I2:I2) .LE. C9) THEN
                  L1 = LTRUE
                  CALL NUMBER (CSTMT,L1,I2,II,FP,IFP)
                  CALL INSERT (II)
                  GO TO 27
               END IF
            END IF
C
C         DETERMINE IF MULTIPLE LEFT PARENTHESES FOLLOW THE UNIT
C         ARGUMENT
C
            IF(CSTMT(I2:I2+1) .EQ. '((') GO TO 27
C
C         DETERMINE IF SUBSCRIPTED VARIABLE STARTS WITH '(:'
C         THIS MEANS THE FIRST ARGUMENT IS MISSING AND SHOULD NOT BE
C         PROCESSED
C
            IF(CSTMT(I2:I2+1) .EQ. '(:') GO TO 27
            IF(CSTMT(I2-1:I2) .EQ. '(:') JF = I2 + 1
C
C         DETERMINE IF SUBSCRIPTED VARIABLE STARTS WITH '):'
C         THIS MEANS THE END OF AN ARGUMENT AND SHOULD NOT BE PROCESSED
C
            IF(CSTMT(I2-1:I2) .EQ. '):') JF = I2 + 1
C
C         DETERMINE IF SUBSCRIPTED VARIABLE STARTS WITH ':'
C         THE UPPER BOUND OF A CHARCTER RANGE SPECIFICATION EXISTS.
C
            IF(L2) THEN
               JF = I2
               L2 = LFALSE
            END IF
C
C         FIND THE END OF A SUBSCRIPT VARIABLE NAME
C
            IF(CSTMT(I2:I2) .EQ. COMMA .OR. CSTMT(I2:I2) .EQ. CRPAR .OR.
     1         CSTMT(I2:I2) .EQ. COLON .OR. CSTMT(I2:I2) .EQ. CPLUS .OR.
     2         CSTMT(I2:I2) .EQ. CMINUS .OR. CSTMT(I2:I2) .EQ. CASTER
     3         .OR. CSTMT(I2:I2) .EQ. CSLASH) THEN
C
C         IF THE CHARACTER IS A COLON, DETERMINE THE END OF THE VARIABLE
C         NAME
C
               IF(CSTMT(I2:I2) .EQ. COLON) THEN
C
C         DOES AN ALPHABETIC CHARACTER FOLLOW THE LEFT PARENTHESIS. THIS
C         INDICATES A VARIABLE NAME IS THE FIRST RANGE SPECIFICATION.
C
                  IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I3:I3)
     1               .LE. CZZ .OR. CSTMT(I3:I3) .EQ. CUNDER) THEN
                     L1 = LFALSE
                     CWORK(1:52) = CBLK52(1:52)
                     JBITS = 0
                     JBITS = IBSET(JBITS,15)
                     CALL VSETUP (I3,I2-1,I2-I3,L1,L1,CSTMT)
                  END IF
                  I4 = 0
                  DO I7 = I2+1,KB
                  IF(CSTMT(I7:I7) .EQ. CPLUS .OR. CSTMT(I7:I7) .EQ.
     1               CMINUS .OR. CSTMT(I7:I7) .EQ. CASTER .OR.
     2               CSTMT(I7:I7) .EQ. CSLASH .OR. CSTMT(I7:I7) .EQ.
     3               CRPAR .AND. I4 .EQ. 0) THEN
                     I4 = I7 - 1
                  END IF
                  IF(CSTMT(I7:I7) .EQ. CRPAR) THEN
                     I10 = I2 + 1
                     I11 = I7 - 1
                     CALL EXPR (I10,I11,LFALSE,CSTMT)
                     I5 = I7 + 1
                     J = I5
                     GO TO 28
                  END IF
                  END DO
               ELSE
                  I4 = I2 - 1
               END IF
               IF(I2 .EQ. KB) I4 = KB - 1
            ELSE
               IF(I2 .EQ. KB) I4 = KB
               GO TO 27
            END IF
C
C         DETERMINE IF A VARIABLE NAME IS THE CURRENT FIELD
C
            IF(CSTMT(JF:JF) .GE. CAA .AND. CSTMT(JF:JF) .LE. CZZ .OR.
     1         CSTMT(JF:JF) .EQ. CUNDER) THEN
C
C         SET UP CWORK WHEN THE VARIABLE NAME ALREADY EXISTS IN CNAME
C
               CWORK(1:32) = CSTMT(JF:I4)//CBLK52(1:32-I4+JF+1)
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
               IF(IRET .GT. 0) THEN
                  IWORK = ISN + 128
                  CWORK(37:44) = CNAME(IRET)(37:44)
                  CWORK(45:48) = CNAME(IRET)(45:48)
                  IVCNT = I4 - JF + 1
                  CWORK(49:52) = CNAME(IRET)(49:52)
                  JB = IVCNT
               END IF
               CALL VSETUP (JF,I4,JB,LFALSE,LFALSE,CSTMT)
            END IF
            IF(CSTMT(JF:JF) .GE. C0 .AND. CSTMT(JF:JF) .LE. C9) THEN
               L1 = LTRUE
               CALL NUMBER (CSTMT,L1,JF,II,FP,IFP)
               CALL INSERT (II)
               IFP = IFP + 1
            END IF
            I1 = I2 + 1
            IF(I2 .EQ. KB) GO TO 28
            IF(CSTMT(I2:I1) .EQ. ':)') THEN
               J = I1 + 2
               I5 = I1
               GO TO 28
            END IF
C
C         WHEN A RIGHT PARENTHESIS OCCURS, IT MAY BE THE END OF A
C         SUBSCRIPT VARIABLE NAME
C
            IF(CSTMT(I2:I2) .EQ. CRPAR) THEN
C
C         END OF THE SUBSCRIPT
C
               IF(CSTMT(I1:I1) .EQ. COMMA) THEN
                  J = I1
                  I5 = I1
                  GO TO 28
               END IF
C
C         WHEN A LEFT PARENTHESIS FOLLOWS, CHARACTER RANGE
C         SPECIFICATION EXISTS
C
               IF(CSTMT(I1:I1) .EQ. CLPAR) THEN
                  J = I1
 23               DO 26 JC = I1,KB
C
C         PROCESS NUMERICAL RANGE SPECIFICATIONS
C
                  IF(CSTMT(JC:JC) .GE. C0 .AND. CSTMT(JC:JC) .LE. C9)
     1               THEN
                     L1 = LTRUE
                     CALL NUMBER (CSTMT,L1,JC,II,FP,IFP)
                     CALL INSERT (II)
                     IFP = IFP + 1
                     IF(CSTMT(IFP:IFP) .EQ. COLON) THEN
                        I1 = IFP + 1
                        GO TO 23
                     END IF
                     IF(CSTMT(IFP:IFP) .EQ. CRPAR) THEN
                        J = IFP + 1
                        GO TO 28
                     END IF
                  END IF
C
C         PROCESS VARIABLE NAME RANGE SPECIFICATIONS
C
                  I9 = 0
                  IF(CSTMT(JC:JC) .GE. CAA .AND. CSTMT(JC:JC) .LE. CZZ
     1               .OR. CSTMT(JC:JC) .EQ. CUNDER) THEN
 24                  IF(I9 .GT. 0) I10 = I9
                     DO 25 I7 = I10,KB
                     IF(CSTMT(I7:I7) .EQ. COLON) THEN
                        JB = I7 - 1
                        I8 = JC - I7
C
C         SET UP CWORK WHEN THE VARIABLE NAME ALREADY EXISTS IN CNAME
C
                        CWORK(1:IVCNT) = CSTMT(JF:I4)
                        CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,
     1                               IRET,4000)
                        IF(IRET .GT. 0) THEN
                           IWORK = ISN + 128
                           CWORK(37:44) = CNAME(IRET)(37:44)
                           CWORK(45:48) = CNAME(IRET)(45:48)
                           IVCNT = JB
                        END IF
                        CALL VSETUP (JC,JB,I8,LFALSE,LFALSE,CSTMT)
                        IF(CSTMT(I7:I7) .EQ. CRPAR) THEN
                           J = I7 + 1
                           GO TO 28
                        END IF
                        I9 = JB + 1
                        GO TO 24
                     END IF
 25                  CONTINUE
                  END IF
 26               CONTINUE
                  GO TO 28
               END IF
            END IF
C
C         MULTIPLE SUBSCRIPTS ARE USED WITH THE UNIT VARIABLE NAME
C
            IF(CSTMT(I2:I2) .EQ. COMMA) THEN
              JF = I1
              GO TO 27
            END IF
C
C         DETERMINE IF AN ARITHMETIC OPERATOR WAS THE END OF THE FIELD
C
            IF(CSTMT(I2:I2) .EQ. CPLUS .OR. CSTMT(I2:I2) .EQ. CMINUS
     1         .OR. CSTMT(I2:I2) .EQ. CASTER .OR. CSTMT(I2:I2) .EQ.
     2         CSLASH) THEN
C
C         DETERMINE IF A DIGIT FOLLOWS THE ARITHMETIC OPERATOR
C
               IF(CSTMT(I2+1:I2+1) .GE. C0 .AND. CSTMT(I2+1:I2+1)
     1            .LE. C9) THEN
                  L1 = LTRUE
                  I6 = I2+1
                  CALL NUMBER (CSTMT,L1,I6,II,FP,IFP)
                  CALL INSERT (II)
                  I3 = IFP + 1
                  J = I3
                  GO TO 28
               END IF
            END IF
C
C         DETERMINE IF THE CURRENT CHARACTER IS A COLON
C
            IF(CSTMT(I2:I2) .EQ. COLON) L2 = LTRUE
 27         CONTINUE
         END IF
      END IF
C
C         INSURE J DOES NOT EXCEED KB IN VALUE
C
 28   IF(J .GE. KB) THEN
         J = KB
         JB = KB
      END IF
C
C         CORRECT THE LOCATION COUNTER OF CSTMT IF UNIT= OCCURS AND THE
C         UNIT IS A VARIABLE NAME
C
      IF(I5 .GT. 0 .AND. LA) THEN
         J = I5
         JB = I5
      END IF
C
C         EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM WILL PROCESS THE LIST OF VARIABLES IN DATA, BYTE,
C        TYPE, COMMON, DIMENSION, OR RECORD STATEMEMENTS.
C
C     MEANING OF THE VARIABLES
C
C         CAPOS  - CHARACTER VARIABLE, THE CHARACTER: '
C         CAPOSD - CHARACTER VARIABLE, THE CHARACTER: "
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABEL, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 C*32 8  VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97- 100 I*4 25  NUMBER OF WORDS OF MEMORY FOR THE
C                                  VARIABLE NAME IN COLS 1-32
C                 101- 104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CDOT   - CHARACTER VARIABLE, A DECIMAL POINT OR PERIOD
C         CI1    - CHARACTER VARIABLE, EQUIVALENCED TO II
C         CI4WK2 - CHARACTER VARIABLE, CONTAINS THE LENGTH OF A
C                  STRUCTURE DEFINITION. EQUIVALENCED TO I2WK4.
C         CI6    - CHARACTER VARIABLE, EQUIVALENCED TO I6
C         CLEN   - CHARACTER VARIABLE, THE LENGTH VALUE FOR THE ENTIRE
C                  TYPE STATEMENT
C         CLENSV - CHARACTER VARIABLE, SAVE AREA FOR THE LENGTH VALUE
C                  FOR THE ENTIRE TYPE STATEMENT WHEN A DERIVED LENGTH
C                  SPECIFICATION OCCURS
C         CLENWK - CHARACTER VARIABLE, WORK AREA TO SHIFT THE LENGTH
C                  SPECIFICATION DERIVED FROM A PARAMETER VARIABLE TO
C                  THE START OF CLEN AFTER CONVERSION TO TEST FORM
C         CLITWK - CHARACTER VARIABLE, WORK AREA FOR WRITING THE
C                  LITERALS AND THEIR ISNS
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 C*32   8  STRUCTURE VARIABLE NAME
C                 33 - 64 C*32  16  RECORD VARIABLE NAME
C                 65 - 68 I*4   17  INTEGER VALUE OF THE LENGTH OF
C                                   THE RECORD
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSTR   - TABLE OF ALL STRUCTURES DEFINED IN THE MODULE BEING
C                  CURRENTLY PROCESSED. A MAXIMUM OF 1000 UNIQUE
C                  STRUCTURES MAY OCCUR.
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 C*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CSYMCE - CHARACTER VARIABLE, THE HEX NUMBER: CE; THIS IS USED
C                  TO REPLACE ALL NUMERCAL CONSTANTS, EXCEPT FOR FORMAT
C                  STATEMENTS, IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT
C         CTEST  - CHARACTER VARIABLE, IN A DATA STATEMENT, A CHARCATER
C                  THAT SEPARATES MULTIPLE SPECIFICATIONS WITHIN A
C                  GROUP OF CONSTANTS FOR HEXIDECIMAL, OCTAL, AND BINARY
C                  CONSTANTS WITHOUT APOSTROPHES
C         CTYPE  - CHARACTER VARIABLE, THE DATA TYPE CODE FOR A
C                  PARTICULAR VARIABLE WITH A LENGTH SPECIFCATION
C                  DIFFERENT FROM THE LENGTH FOR THE ENTIRE STATEMENT
C         CTYPED - CHARACTER VARIABLE, THE DATA TYPE CODE FOR THE ENTIRE
C                  STATEMENT
C                  VALUE IS ONE OF THE FOLLOWING
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C         CWKK32 - SAVE WORK AREA OF A DIMENSION SIZE VARIABLE NAME TO
C                  DETERMINE IF IT IS A PARAMETER VARIABLE
C         CWK104 - CHARACTER VARIABLE, WORK AREA TO CREATE AN ENTRY FOR
C                  UNIT 11 AND CDIM TABLE. IT HAS THE SAME RECORD
C                  STRUCTURE AS CDIM.
C         CWK44  - CHARACTER VARIABLE, WORK AREA TO CREATE A RECORD FOR
C                  OUTPUT UNIT 11; RECORD STRUCTURE IS:
C                  COLS TYPE WORD DESCRIPTION
C                  1-32 C*32   8  VARIABLE NAME
C                 33-36 I*4    9  LENGTH OF THE VARIABLE NAME IN COLS
C                                 1-32; SET NEGATIVE FOR THE COMMON
C                                 BLOCK NAME; SET POSITIVE FOR VARIABLE
C                                 NAMES BELONGING TO THE BLOCK.
C                    37 C*1       THE VARIABLE DATA TYPE IN COLS. 1-32
C                 38-44 C*7   11  THE VARIABLE'S LENGTH CHARACTERISTIC
C         CWK52  - CHARACTER VARIABLE, WORK AREA TO CREATE AN ENTRY FOR
C                  DIMENSIONED VARIABLE NAME FOR THE CNAME TABLE
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE. THIS WORK
C                  AREA MUST BE INTIALIZED BEFORE ENTRY TO THIS ROUTINE.
C                  RECORD STRUCTURE:
C                  COLS TYPE WORD DESCRIPTION
C                  1-32 C*32   8  VARIABLE NAME
C                 33-36 I*4    9  ISN VALUE
C                 37-44 C*8   11  DATA TYPE & LENGTH
C                 45-48 I*4   12  BIT SWITCHES
C                 49-52 I*4   13  LENGTH OF THE VARIABLE NAME IN COLS
C                                 1 - 32
C
C                  COLUMN 37 CONTAINS THE FOLLOWING CODES TO INDICATE
C                  DATA TYPE
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - DOUBLE PRECISION VALUE OF A FLOATING POINT NUMBER
C                  CONVERTED FROM ASCII
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - SUBSCRIPT VARIABLE
C         IC     - THE LENGTH OF THE VARIABLE NAME
C         ID     - INDEX VALUE OF THE START OF THE NUMERICAL FIELD IN
C                  A LENGTH SPECIFICATION
C         IE     - LENGTH OF A DIMENSION VARIABLE
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         IJ     - SUBSCRIPT VARIABLE
C         ILEN   - LENGTH OF THE VARIABLE NAME, EQUIVALENCED TO CWK104
C         ILIT   - COUNT OF THE NUMBER OF LITERALS IN THE LITERAL TABLE
C         ILOC1  - EQUIVALENCED TO CLITWK(81:84), NUMBER OF CHARACTERS
C                  IN A LITERAL
C         ILOC2  - EQUIVALENCED TO CLITWK(85:88), THE ISN WHERE A
C                  OCCURS
C         ILOC3  - EQUIVALENCED TO CLITWK(89:92), THE ARGUMENT NUMBER
C                  OF A CALL STATEMENT
C         INAME  - NUMBER OF VARIABLE NAMES IN CNAME
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES WRITTEN ON UNIT 0
C         IREC11 - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 11
C         IRET   - RETURN CODE FROM TABLE SEARCH ROUTINE. 0> THE INDEX
C                  LOCATION VALUE; 0< NOT FOUND
C         IRETA  - RETURN CODE FROM TABLE SEARCH ROUT1NE. 0> THE INDEX
C                  LOCATION VALUE; 0< NOT FOUND
C         IRET1  - RETURN CODE FROM TABLE SEARCH ROUT1NE. 0> THE INDEX
C                  LOCATION VALUE; 0< NOT FOUND
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISTRUC - COUNT OF THE NUMBER OF STRUCTURE STATEMENTS. THIS
C                  VALUE IS THE TOTAL NUMBER OF STRUCTURE STATEMENTS
C                  DEFINED IN TABLE CSTR.
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWK52
C         I1     - COUNT OF PARENTHESES IN THE DIMENSION SPECIFICATION;
C                  ONE IS ADDED FOR LEFT PARENTHESIS, ONE IS SUBTRACTED
C                  FOR A RIGHT PARENTHESIS.  WHEN THE VALUE IS ZERO,
C                  PARENTHESES ARE BALANCED.
C         I2     - COUNT OF THE NUMBER OF SLASHES
C         I2WK1  - COUNT OF THE NUMBER OF SLASHES NOT ENCAPSULATED
C                  WITHIN PARENTHESES. WHEN THE VALUE IS ZERO, NO DATA
C                  SPECIFICATION EXISTS FOR THE VARIABLE BEING PROCESSED
C         I3     - SUBSCRIPT VARIABLE
C         I4     - LOCATION OF THE INITIAL DIGIT OF A NUMBER IN A DATA
C                  SPECIFICATION
C         I4WK1  - WORK AREA TO COMPUTE THE DIMENSION SIZE FOR A
C                  VARIABLE
C         I4WK2  - WORK AREA TO RETRIEVE THE LENGTH OF A STRUCTURE
C                  VARIABLE, EQUIVALENCED TO CI4WK2
C         I4WK3  - SUBSCRIPT VARIABLE, USED TO MOVE THE VARIABLE NAME
C                  LENGTH IN CHARACTER FORM TO CLEN
C         I4WK4  - WORK AREA TO SAVE THE TOTAL WORD LENGTH OF A
C                  DIMENSIONED VARIABLE WHEN IT IS DEFINED WITHIN A
C                  STRUCTURE, UINION, OR RECORD STATEMENT
C         I5     - LOCATION OF THE FIRST CHARACTER OF A NUMERIC FIELD
C         I6     - VALUE OF THE ISN + 128
C         I7     - SUBSCRIPT VARIABLE
C         I8     - DO LOOP PARAMETER
C         I9     - LOCATION OF THE LAST CHARACTER OF A HOLLERITH FIELD.
C                  WHEN THE VALUE OF I3 IS LESS THAN I9, ALL CHARACTERS
C                  BETWEEN I3 AND I9 ARE SKIPPED SINCE THEY WILL HAVE
C                  ALREADY BEEN PROCESSED.
C         I10    - LOCATION OF A COMMA SEPARATING DATA SPECIFICATIONS
C         I11    - LOCATION OF A Z INDICATION THE START OF A HEXADECIMAL
C                  CONSTANT OF THE FORM Znn.
C         I12    - START LOCATION FOR MOVING THE LENGTH SPECIFICATION OF
C                  THE FORM *(N) WHERE N IS A SET OF DIGITS
C         I13    - START LOCATION OF THE PARAMETER VARIABLE NAME
C                  DEFINING THE LENGTH OF A CHARACTER VARIABLE
C         I14    - END LOCATION OF THE PARAMETER VARIABLE NAME DEFINING
C                  THE LENGTH OF A CHARACTER VARIABLE
C         I15    - SUBSCRIPT VARIABLE
C         I16    - NUMBER OF CHARACTERS IN THE LENGTH SPECIFICATION OF
C                  PARAMETER VARIABLE LENGTH
C         I17    - WORK AREA FOR PLACING THE LENGTH TEXT CORRECTLY
C         I18    - SAVE AREA OF THE LOCATION OF A COLON IN A DIMENSION
C                  SPECIFICATION
C         I19    - SUBSCRIPT VARIABLE
C         I20    - COUNT OF LEFT AND RIGHT PARENTHESES IN A LENGTH
C                  SPECIFICATION; ONE IS ADDED FOR A LEFT PARENTHESIS;
C                  ONE IS SUBRACTED FOR A RIGHT PARENTHESIS.
C         J      - LOCATION OF THE CURRENT CHARACTER BEING PROCESSED
C         JARG   - BINARY VALUE OF THE LENGTH SPECIFICATION OF A
C                  PARAMETER DEFINED VARIABLE
C         JB     - LOCATION OF THE END OF A FIELD
C         JBEGIN - LOCATION OF THE START OF A NUMERIC FIELD
C         JD     - LOCATION OF THE INITIAL NUMERIC CHARACTER OF LENGTH
C                  SPECIFICATION OR OF A DIMENSION SPECIFICATION
C         JDIM   - COUNT OF THE NUMBER OF ENTRIES INTO THE CDIM TABLE
C         JE     - THE END OF A DIMENSION SPECIFICATION LOCATION
C         JEND   - VALUE OF THE UPPER VALUE OF A RANGE DIMENSION
C                  SPECIFICATION
C         JF     - COUNT OF THE NUMBER OF DIMENSIONS
C         JISN   - EQUIVALENCED TO CWK104(101:104). THE ISN OF A
C                  DIMENSION STATEMEMT.
C         JJ     - INDEX VALUE OF THE DIMENSION NUMBER BEING PROCESSED
C         JLEN   - LENGTH OF A DIMENSIONED VARIABLE WITH A DIMENSION
C                  VALUE SPECIFIED AS A VARIABLE NAME; USED TO COMPUTE
C                  THE LENGTH OF A STRUCTURE OR UNION DEFINITION WHEN
C                  A VARIABLE DEFINED WITHIN A STRUCTURE OR UNION IS
C                  DIMENSIONED.
C         JLOC1  - LOCATION OF THE ENCAPSULATING LEFT SLASH OF A DATA
C                  SPECIFICATION GROUP
C         JLOC2  - LOCATION OF THE ENCAPSULATING RIGHT SLASH OF A DATA
C                  SPECIFICATION GROUP
C         JLOC3  - LOCATION OF A DATA FIELD START
C         JLOC4  - LOCATION OF A DATA FIELD END
C         JLOC5  - LOCATION OF THE FIRST PLUS SIGN IN A NUMERIC FIELD
C         JLOC6  - LOCATION OF THE SECOND PLUS SIGN IN A NUMERIC FIELD
C         JLOC8  - LOCATION OF THE FIRST MINUS IN A DATA NUMERIC FIELD
C         JLOC9  - LOCATION OF THE SECOND MINUS SIGN IN A DATA NUMERIC
C                  FIELD
C         JLOC10 - LOCATION OF THE LEFT PARENTHESIS IN A COMPLEX NUMBER
C                  DATA FIELD
C         JLOC11 - LOCATION OF THE RIGHT PARENTHESIS IN A COMPLEX NUMBER
C                  DATA FIELD
C         JLOC12 - LOCATION OF THE COMMA SEPARATING THE TWO VALUES THAT
C                  SPECIFY A COMPLEX NUMBER
C         JLOC14 - LOCATION OF AN E CHARACTER WTHIN A NUMERIC FIELD
C         JLOC15 - LOCATION OF A D CHARACTER WTHIN A NUMERIC FIELD
C         JLOC16 - LOCATION OF A DECIMAL POINT WITHIN THE NUMERIC FIELD
C         JLOC17 - LOCATION OF AN ASTERISK TERMINATING A REPEAT FACTOR
C         JLOC1X - LOCATION OF A TERMINATING COMMA OF A DATA NUMERIC
C                  FIELD
C         JLOC1X - LOCATION OF A TERMINATING SLASH IN A DATA NUMERIC
C                  FIELD
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT FOR A GIVEN NEST
C                  LEVEL OF THE UNION. SUBSCRIPT 1 DESIGNATES THE UNION
C                  LEVEL, SUBSCRIPT 2 DESIGNATES THE MAP LEVEL
C         JNUM1  - NUMBER OF SUBSCRIPTS SPECIFIED FOR A DIMENSIONED
C                  VARIABLE IN A COMMON STATEMENT, EQUIVALENCED TO
C                  CWK104; VALUE IS SAME AS JNUM.
C         JTERM  - LOCATION OF THE END OF A NUMERIC FIELD
C         JSTART - THE STARTING VALUE OF A SUBSCRIPT RANGE FOR EACH
C                  SUBSCRIPT DEFINED FOR A VARIABLE.  DEFAULT VALUE IS 1
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUCT
C         JSTRUC - STRUCTURE NEST LEVEL INDEX VALUE
C         JUNION - UNION NEST LEVEL INDEX VALUE
C         JWORK  - THE DIMENSION SPECIFICATION FOR A VARIABLE, EQUIV-
C                  ALENCED TO CWK104, COLS. 97 - 100; THE TOTAL AMOUNT
C                  OF MEMORY REQUIRED IN WORDS OF THE TYPE LENGTH
C                  SPECIFIED.
C         J1     - START LOCATION OF A VARIABLE, ITS DIMENSION, LENGTH,
C                  AND DATA SPECIFICATIONS; SEE COMMENTS BELOW; THE
C                  LOCATION SPECIFIED BY J1 IN CSTMT WILL ALWAYS
C                  CONTAIN THE INITIAL CHARACTER OF THE VARIABLE NAME.
C         J2     - END LOCATION OF A VARIABLE AND ITS DIMENSION,
C                  LENGTH, AND DATA SPECIFICATIONS; THIS LOCATION DOES
C                  INCLUDE THE TERMINATING COMMA IF ONE EXISTS.
C                  SEE COMMENTS BELOW.
C         J3     - START LOCATION OF A VARIABLE NAME
C         J4     - END LOCATION OF A VARIABLE NAME
C         J5     - START LOCATION OF A DIMENSION SPECIFICATION; THIS
C                  SPECIFIES THE LEFT PARENTHESIS LOCATION
C         J6     - END LOCATION OF A DIMENSION SPECIFICATION; THIS
C                  SPECIFIES THE RIGHT PARENTHESIS LOCATION
C         J7     - START LOCATION OF A LENGTH SPECIFICATION
C         J8     - END LOCATION OF A LENGTH SPECIFICATION
C         J9     - START LOCATION OF A DATA SPECIFICATION; THIS
C                  SPECIFIES THE STARTING SLASH LOCATION
C         J10    - END LOCATION OF A DATA SPECIFICATION; THIS SPECIFIES
C                  THE FINAL SLASH LOCATION
C         J11    - START LOCATION OF A VARIABLE NAME USED AS A DIMENSION
C                  SPECIFICATION
C         J12    - START LOCATION OF A DIMENSION SPECIFICATION FOR THE
C                  LOWER OR UPPER BOUND
C         J13    - START LOCATION OF THE LOWER BOUND OF A DIMENSION
C                  SPECIFICATION
C         J14    - END LOCATION FOR THE LOWER OR UPPER BOUND OF A
C                  DIMENSION SPECIFICATION
C         J15    - START LOCATION FOR EVALUATING A VARIABLE USED AS A
C                  DIMENSION SPECIFICATION WHEN IT IS NOT PART OF AN
C                  EXPRESSION
C         J16    - WORK VARIABLE
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KDNUM  - THE VALUE OF A DIMENSION SPECIFICATION, A MAXIMUM
C                  OF SEVEN MAY OCCUR. THIS VALUE MAY BE MODIFIED BY
C                  IFLL WHEN A DIMENSION RANGE IS SPECIFIED;
C                  EQUIVALENCED TO CWK104
C         KLEN     EQUIVALENCED TO CWK44(33:36), THE NUMBER OF
C                  CHARACTERS IN COLS. 1-32 IN CWK44, THE VARIABLE
C                  NAME
C         K1     - START INDEX VALUE FOR SCANNING THE STATEMENT BEING
C                  ANALYZED
C         K2     - END INDEX VALUE FOR SCANNING THE STATEMENT BEING
C                  ANALYZED
C         K3     - WORK AREA USED TO CORRECT THE END LOCATION OF AN
C                  EXPRESSION TO BE EVALUATED IN SUBROUTINE PARAEV
C         K4     - END LOCATION OF A LENGTH SPECIFICATION
C         K5     - WORK AREA USED TO SAVE THE INDEX OF THE LEVEL OF MAP
C                  SIZE CURRENTLY BEING PROCESSED
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER CONVER-
C                  SION IS TO INTEGER, SET FALSE IF FLOATING POINT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT, JSTRUC, RETURNS TO ZERO.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME
C                  EXISTS, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A DIMENSION
C                  SPECIFICATION EXISTS, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH
C                  SPECIFICATION EXISTS, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A DATA SPECIFICATION
C                  EXISTS, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME USED
C                  AS A DIMENSION SPECIFICATION EXISTS, SET FALSE
C                  OTHERWISE; USED TO SAVE THE LOCATION OF THE INITIAL
C                  CHARACTER OF A VARIABLE NAME THAT IS A DIMENSION
C                  SIZE SPECIFICATION.
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER USED AS A
C                  DIMENSION SPECIFICATION EXISTS, SET FALSE OTHERWISE;
C                  USED TO SAVE THE LOCATION OF THE INITIAL CHARACTER
C                  OF THE NUMBER THAT IS A DIMENSION SIZE SPECIFICATION.
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN A COLON IS FOUND
C                  INDICATING A DIMENSION RANGE SPECIFICATION EXISTS,
C                  SET FALSE TO INDICATE THE UPPER BOUND OF THE RANGE
C                  IS TO BE PROCESSED AND THAT A RANGE DOES NOT EXIST
C                  OR THAT THE LOWER BOUND HAS ALREADY BEEN PROCESSED
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN AN A COMMA OR RIGHT
C                  PARENTHESIS TERMINATES DIMENSION SPECIFCATIONS, SET
C                  FALSE OTHERWISE
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN A DATA SPECIFICATION
C                  STARTS WITH A PLUS OR MINUS SIGN, SET FALSE OTHERWISE
C         L10    - LOGICAL VARIABLE, SET TRUE WHEN A DATA SPECIFICATION
C                  STARTS WITH A DIGIT
C         L11    - LOGICAL VARIABLE, SET TRUE WHEN THE A NUMBER IS
C                  PROCESSED BY ROUTINE NUMBER; SET FALSE OTHERWISE.
C                  THIS PREVENTS THE DIGITS FOLLOWING THE INITIAL DIGIT
C                  FROM BEING TREATED AS A NEW NUMBER.
C         L12    - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL CHARACTER
C                  OF THE VARIABLE SPECIFICATION IS PART OF A VARIABLE
C                  NAME, SET FALSE OTHERWISE
C         L13    - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK OCCURS
C                  OUTSIDE OF PARENTHESES OR SLASHES INDICATING THE
C                  START OF A LENGTH SPECIFICATION FOR THE VARIABLE,
C                  SET FALSE OTHERWISE
C         L14    - LOGICAL VARIABLE, SET TRUE WHEN J4, THE END LOCATION
C                  OF A VARIABLE NAME, IS SET; SET FALSE OTHERWISE.
C         L15    - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER HAS BEEN
C                  PROCESSED. THIS CAUSES ALL DIGITS OF THE SAME FIELD
C                  TO BE SKIPPED UNTIL A FOLLOWING SEPARATOR IS FOUND.
C                  SET FALSE OTHERWISE.
C         L16    - LOGICAL VARIABLE, SET TRUE WHEN THE END LOCATION OF
C                  A VARIABLE NAME IS SET FOR VARIABLE J4 THAT IS
C                  FOLLOWED BY AN ASTERISK, SET FALSE OTHERWISE
C         L17    - LOGICAL VARIABLE, SET TRUE WHEN THE LENGTH
C                  SPECIFICATION FOR A CHARACTER VARIABLE IS (*). SET
C                  FALSE OTHERWISE.
C         L18    - LOGICAL VARIABLE, SET TRUE WHEN SEARCHING FOR A
C                  LENGTH SPECIFICATION OF A HOLLERITH FIELD, SET FALSE
C                  OTHERWISE
C         L19    - LOGICAL VARIABLE, SET TRUE WHEN A HOLLERITH FIELD OF
C                  LENGTH 1 IS A COMMA, BLANK, OR SLASH, SET FALSE
C                  OTHERWISE
C         L20    - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST SLASH FOUND
C                  OF THE DATA SPECIFICATION HAS BEEN COUNTED, SET FALSE
C                  OTHERWISE
C         L21    - LOGICAL VARIABLE, SET TRUE WHEN A HEXADECIMAL, OCTAL,
C                  OR BINARY CONSTANT HAS BEEN SPECIFIED AS A DATA
C                  CONSTANT, SET FALSE OTHERWISE
C         L22    - LOGICAL VARIABLE, SET TRUE A HEXADICMAL, OCTAL, OR
C                  BINARY CONSTANT HAS BEEN PLACED IN THE LITERAL TABLE,
C                  SET FALSE OTHERWISE
C         L23    - LOGICAL VARIABLE, SET TRUE WHEN A COMMA SEPARATES A
C                  MULTIPLE SET OF DATA VALUES OCCURRING BETWEEN
C                  MATCHING SLASHES, SET FALSE OTHERWISE
C         L24    - LOGICAL VARIABLE, SET TRUE WHEN A Z, O, X, OR B
C                  FOLLOWS THE FIRST SLASH OF A DATA SPECIFICATION, SET
C                  FALSE OTHERWISE
C         L25    - LOGICAL VARIABLE, SET TRUE WHEN A CHARACTER VARIABLE
C                  HAS A PARAMETER VARIABLE FOR ITS LENGTH SPECIFICATION
C                  SET FALSE OTHERWISE
C         L26    - LOGICAL VARIABLE, SET TRUE WHEN THE LENGTH FOR AN
C                  ENTIRE TYPE STATEMENT IS AN EXPRESSSION, SET FALSE
C                  OTHERWISE THIS MEANS ARITHMETIC OPERATORS OCCUR IN
C                  THE LENGTH SPECIFICATION
C         L27    - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR OCCURS IN A DIMENSION SIZE DEFINITION, SET
C                  FALSE OTHERWISE
C         L28    - LOGICAL VARIABLE, SET TRUE WHEN THE BOTTOM VALUE OF A
C                  DIMENSON RANGE HAS BEEN PLACED IN ITS SAVE AREA, SET
C                  SET FALSE OTHEREWISE
C         L29    - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH EXPRESSION
C                  HAS BEEN EVALUATED, SET FALSE OTHERWISE. THIS IS USED
C                  TO ALLOW THE EVALUATION ONLY ONCE.
C         L30    - LOGICAL VARIABLE, SET TRUE TO FORCE RESTORATION OF
C                  THE LENGTH FOR AN ENTIRE STATEMENT AFTER CLEN IS USED
C                  TO SET A TEMPORARY LENGTH FOR A SINGLE VARIABLE IN A
C                  LENGTH SPECIFICATION, SET FALSE OTHERWISE
C         L31    - LOGICAL VARIABLE, SET TRUE WHEN A RANGE SPECIFICATION
C                  IS A VARIABLE NAME, SET FALSE OTHERWISE
C         L32    - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE OCCURS IN
C                  A COMMON OR RECORD STATEMENT, SET FALSE OTHERWISE
C         L33    - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER HAS BEEN
C                  PROCESSED, SET FALSE OTHERWISE. PREVENTS INSERTING
C                  A NUMBER IN THE CONSTANT NUMBER TWICE.
C         L35    - LOGICAL VARIABLE, SET TRUE WHEN A DECIMAL POINT
C                  EXISTS IN A NUMERIC FIELD, SET FALSE OTHERWISE
C         L36    - LOGICAL VARIABLE, SET TRUE WHEN A TYPE STATEMENT
C                  VARIABLE IS DIMENSIONED, SET FALSE OTHERWISE
C         L37    - LOGICAL VARIABLE, SET TRUE WHEN TO PREVENT CALLING
C                  SUBROUTINE CHKNME WHEN A NUMERICAL SUSBCRIPT EXISTS
C                  FOR A VARIABLE THAT IS USED TO SPECIFY A DIMENSION
C                  FOR A VARIABLE, SET FALSE OTHERWISE
C         MD     - LOCATION OF A COMMA DELINEATING EACH DIMENSION
C                  SPECIFICATION. THE FINAL ENTRY IN THIS TABLE IS THE
C                  LOCATION OF THE FINAL RIGHT PARENTHESIS OF THE
C                  DIMENSION SPECIFICATIONS.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C          9 - TABLE OF LITERALS
C         10 - MESSAGES FILE
C         11 - COMMON VARIABLES DATA FOR ROUTINE PCOMM
C
C                  COLS  1 - 32 VARIABLE NAME
C                  COLS 33 - 36 LENGTH OF THE VARIABLE NAME IN COLS 1-32
C                  COLS 37 - 44 VARIABLE TYPE AND LENGTH DEFINITIONS
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS ARE AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         EXAMPLE:
C
C         VARNME(3,2)*8/5*1.D0,2.D0/
C
C         NOT ALL THE ABOVE SPECIFICATIONS MAY OCCUR IN A PARTICULAR
C         STATEMENT PROCESSED BY THIS ROUTINE.
C
C          STATEMENT NAME DIMENSION LENGTH DATA
C
C          CHARACTER YES     YES      YES  YES
C          COMMON    YES     YES       NO   NO
C          COMPLEX   YES     YES      YES  YES
C          DATA      YES      NO       NO  YES
C          DIMENSION YES     YES       NO   NO
C          INTEGER   YES     YES      YES  YES
C          LOGICAL   YES     YES      YES  YES
C          REAL      YES     YES      YES  YES
C          RECORD    YES      NO       NO   NO
C
C         CWORK MUST BE INITIALIZED TO BLANKS BEFORE THIS ROUTINE IS
C         CALLED.
C
C         A DIMENSION STATEMENT VARIABLE WILL HAVE ITS TYPE AND LENGTH
C         ASSIGNED ACCORDING TO THE IMPLICIT DEFINITI0NS AS THE DEFAULT;
C         HOWEVER, ANY TYPE STATEMENT WILL MODIFY THIS DEFINITION OF
C         THE VARIABLE NAME TYPE AND LENGTH CHARACTERISTICS.
C
C         IF A HOLLERITH FIELD EXISTS IN DATA SPECIFICATIONS, THE
C         HOLLERITH FIELD IS TREATED AS A LITERAL ENCAPSULATED WITHIN
C         APOSTROPHES, AND IS ENTERED IN THE LITERAL TABLE SAVED ON
C         UNIT 9.
C
C         IF A HEXADECIMAL CONSTANT IS SPECIFIED IN THE FORM Znn, WHERE
C         nn ARE HEXADECIMAL DIGITS, THE NUMBER IS TREATED AS A LITERAL
C         ENCAPSULATED WITHIN APOSTROPHES, AND IS ENTERED AS A LITERAL
C         WITHOUT CHANGE SAVED ON UNIT 9.
C
C     SUBROUTINES CALLED
C
C        BTEST CHKNME FCHECK INSET INSERRT ITOC NUMBER PARAEV SETTL
C        STMT29 TABINS TABSRH TBLSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE TYPLST (CTYPED,CLEN,J1,J2,L36)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION JEND(7), L31(7), JSTART(7), KDNUM(7), MD(7)
      DIMENSION JMAP(20), MAPLEN(20,20)
      DIMENSION NDIM(26,1000), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK, CWK52
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*104 CWK104
      CHARACTER*44  CWK44
      CHARACTER*32  CWKK32
      CHARACTER*7   CLEN, CLENSV, CLENWK
      CHARACTER*4   CI1, CI6, CI4WK2
      CHARACTER*1   CTEST
      LOGICAL*1     LA, L1, L2, L3, L4, L5, L6, L7, L8, L9, L10, L11,
     1              L12, L13, L14, L15, L16, L17, L20, L21,
     2              L22, L23, L24, L25, L26, L27, L28, L29, L30, L31,
     3              L32, L33, L36, L37
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /MUS/ JMAP, MAPLEN
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CLITWK(81:84),ILOC1), (CLITWK(85:88),ILOC2),
     1(CLITWK(89:92),ILOC3)
      EQUIVALENCE (CWK52(33:36),IWORK), (I2WK1,CI2WK1), (CWK52(49:52),
     1IVCNT), (CNAME(1),IENAME(1,1)), (CWORK(45:48),JBITS),
     2(CWK52(45:48),KBITS)
      EQUIVALENCE (CWK104(33:36),ILEN), (CWK104(37:40),JNUM1),
     1(CWK104(41:44),KDNUM(1)), (CWK104(69:72),JSTART(1)),
     2(CWK104(97:100),JWORK), (CWK104(101:104),JISN), (CI1,II),
     3(CI6,I6)
      EQUIVALENCE (I4WK2,CI4WK2), (CWK8(2:2),CWK7)
      EQUIVALENCE (CWK44(33:36),KLEN)
      EQUIVALENCE (CDIM,NDIM)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' DIMENSION SPECIFICATION LACKS BALANCED PARENTH
     1ESES')
 101  FORMAT(' ISN:',I6,' DATA SPECIFICATION LACKS BALANCED SLASHES:',
     1A9)
 102  FORMAT(' ISN:',I6,' VARIABLE NAME IS MULTI-DIMENSIONED: ',A32)
 103  FORMAT(' ISN:',I6,' LOWER LIMIT IS GREATER THAN THE UPPER LIMIT FO
     1R A DIMENSION RANGE',4X)
 104  FORMAT(' ISN:',I6,' DIMENSION SPECIFICATION IS REAL: ',E15.8E3)
 105  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION IS REAL: ',E15.8E3)
 106  FORMAT(' ISN:',I6,' MORE THAN 7 DIMENSION PARAMETERS SPECIFIED',
     126X)
 107  FORMAT(' ISN:',I6,' BYTE VARIABLE HAS ILLEGAL LENGTH')
 108  FORMAT(' ISN:',I6,' COMPLEX VARIABLE HAS ILLEGAL LENGTH')
 109  FORMAT(' ISN:',I6,' INTEGER VARIABLE HAS ILLEGAL LENGTH')
 110  FORMAT(' ISN:',I6,' LOGICAL VARIABLE HAS ILLEGAL LENGTH')
 111  FORMAT(' ISN:',I6,' REAL VARIABLE HAS ILLEGAL LENGTH')
 113  FORMAT(I7)
 114  FORMAT(' ISN:',I6,' CHARACTER VARIABLE HAS ILLEGAL LENGTH',30X)
 115  FORMAT(' ISN:',I6,' MORE THAN 1000 DIMENSIONED VARIABLES USED',
     126X)
 116  FORMAT(' ISN:',I6,' DIMENSION SUBSCRIPT VARIABLE NAME IS NOT AN IN
     1TEGER.'/11X,'SUBSCRIPT NAME IS: ',A32)
 117  FORMAT(' ISN:',I6,' DATA STATEMENT HAS ILLEGAL SYNTAX: ',A9)
 118  FORMAT(' ISN:',I6,' VARIABLE DEFINED WITHIN A STRUCTURE IS DIMENSI
     1ONED: ',A32)
C
C         INITIALIZATION
C
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      L6 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      L9 = LFALSE
      L10 = LFALSE
      L11 = LFALSE
      L12 = LFALSE
      L13 = LFALSE
      L14 = LFALSE
      L15 = LFALSE
      L16 = LFALSE
      L17 = LFALSE
      L20 = LFALSE
      L21 = LFALSE
      L22 = LFALSE
      L23 = LFALSE
      L24 = LFALSE
      L25 = LFALSE
      L26 = LFALSE
      L29 = LFALSE
      L30 = LFALSE
      L33 = LFALSE
      I1 = 0
      I2 = 0
      I10 = 0
      I13 = 0
      J3 = 0
      J4 = 0
      J5 = 0
      J6 = 0
      J7 = 0
      J8 = 0
      J9 = 0
      J10 = 0
      IC = 0
      I4WK4 = 0
      CTEST(1:1) = CBLANK(1:1)
      CWK104(1:104) = CBLK52(1:52)//CBLK52(1:52)
      CWK44(1:44) = CBLK52(1:44)
      CLENSV(1:7) = CLEN(1:7)
      CLENWK(1:7) = CBLANK(1:7)
      DO 10 IA = 1,7
      JSTART(IA) = 0
      JEND(IA) = 0
      KDNUM(IA) = 0
      L31(IA) = LFALSE
 10   CONTINUE
C
C         LOCATE THE START AND END OF A VARIABLE NAME, DIMENSION,
C         LENGTH, OR DATA SPECIFICATIONS IF THEY EXIST
C
      K1 = J1
      K2 = J2
      K4 = 0
 11   DO 22 IA = K1,K2
C
C         SKIP OVER CHARACTERS SPECIFING A LENGTH WHEN THEY ARE ALREADY
C         PROCESSED
C
      IF(L29) THEN
         IF(IA .LE. K4) GO TO 22
         L29 = LFALSE
      END IF
C
C         WHEN THE END OF THE VARIABLE NAME CHARACTERISTICS
C         SPECIFICATION OCCURS, ONLY THE VARIABLE NAME IS PRESENT.
C         SET THE VALUE OF J4.
C
      IF(IA .EQ. J2) THEN
         IF(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ .OR.
     1      CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9 .OR.
     2      CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(IA:IA) .EQ. CDOL) THEN
            IF(.NOT.L14 .AND. .NOT.L16) J4 = J2
            L12 = LTRUE
            IF(.NOT.L13 .AND. J1 .LT. J2) GO TO 22
         END IF
      END IF
C
C         SKIP OVER VARIABLE NAME CHARACTERS AFTER THE INITIAL CHARACTER
C         IS PROCESSED
C
      IF(.NOT.L1) THEN
C
C         TEST FOR A VARIABLE NAME CHARACTER
C
          IF(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ .OR.
     1      CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9 .OR.
     2      CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(IA:IA) .EQ. '$') THEN
            IF(IA .EQ. J1) THEN
               J3 = IA
               L1 = LTRUE
            END IF
            GO TO 22
         END IF
      END IF
C
C         TEST FOR THE START OF DIMENSION SPECIFICATIONS. THE START
C         LOCATION IS THE FIRST LEFT PARENTHESIS NOT ENCASPULATED
C         BETWEEN TWO SLASHES OR PRECEDED BY AN ASTERISK.
C
      IF(CSTMT(IA:IA) .EQ. CLPAR .AND. L1 .AND. .NOT.L2 .AND. .NOT.L4)
     1   THEN
C
C         WHEN AN ASTERISK PRECEDES A LEFT PARENTHESIS, A LENGTH
C         SPECIFICATION EXISTS RATHER A DIMENSION SPECIFICATION
C
         IF(CSTMT(IA-1:IA-1) .EQ. CASTER) THEN
            L13 = LTRUE
C
C         DETERMINE IF AN ASTERISK FOLLOWS THE LEFT PARENTHESIS
C
            IF(CSTMT(IA+1:IA+1) .EQ. CASTER) THEN
C
C         THE LENGTH SPECIFICATION IS OF THE FORM *(*)
C
               CLENSV(1:7) = CLEN(1:7)
               L17 = LTRUE
               GO TO 22
            END IF
C
C         DETERMINE IF A NUMERIC CHARACTER DIGIT FOLLOWS THE LEFT
C         PARENTHESIS
C
            IF(CSTMT(IA+1:IA+1) .GE. C0(1:1) .AND. CSTMT(IA+1:IA+1)
     1         .LE. C9(1:1) .OR. (CSTMT(IA+1:IA+1) .GE. CAA .AND.
     2         CSTMT(IA+1:IA+1) .LE. CZZ) .OR. CSTMT(IA+1:IA+1) .EQ.
     3         CUNDER) THEN
C
C         SEARCH FOR THE CLOSING RIGHT PARENTHESIS
C
               I7 = IA+1
               DO 13 I8 = I7,KB
C
C         DETERMINE IF ANY ARITHMETIC OPERATORS EXIST BETWEEN THE
C         NUMERIC CHARACTER FOLLOWING THE ASTERISK AND THE CLOSING
C         PARENTHESES, IF ANY
C
               IF(CSTMT(I8:I8) .EQ. CPLUS(1:1) .OR. CSTMT(I8:I8) .EQ.
     1            CMINUS(1:1) .OR. CSTMT(I8:I8) .EQ. CASTER(1:1) .OR.
     2            CSTMT(I8:I8) .EQ. CSLASH(1:1)) L27 = LTRUE
               IF(CSTMT(I8:I8) .EQ. CRPAR(1:1)) THEN
                  CLENSV(1:7) = CLEN(1:7)
                  IF(L27) THEN
C
C         DETERMINE IF CORRECTIONS ARE REQUIRED FOR THE START AND END
C         VALUES LOCATIONS OF THE EXPRESSION
C
                     IF(CSTMT(I8:I8) .EQ. CRPAR) THEN
                        IF(CSTMT(I7:I7) .NE. CLPAR) THEN
                           K3 = I8 - 1
                        ELSE
                           K3 = I8
                        END IF
                     END IF
                     CALL PARAEV (I7,K3,JARG)
                     WRITE (CLENWK,113) JARG
                     DO 12 IB = 1,7
                     IF(CLENWK(IB:IB) .GE. C0(1:1) .AND.
     1                  CLENWK(IB:IB) .LE. C9(1:1)) THEN
                        I17 = 8 - IB
                        CLEN(1:I17) = CLENWK(IB:7)
                        CLENWK(1:7) = CLEN(1:7)
                        J = I7 + 2
C
C         DETERMINE IF THE RIGHT PARENTHESIS IS THE FINAL CHARACTER OF
C         THE STATEMENT
C
                        IF(I8 .EQ. KB) THEN
                           GO TO 23
                        ELSE
                           GO TO 22
                        END IF
                     END IF
 12                  CONTINUE
                     GO TO 22
                  END IF
                  I12 = I8 - I7
                  CLEN(1:I12) = CSTMT(I7:I8-1)
                  GO TO 22
               END IF
 13            CONTINUE
            END IF
         END IF
         IF(.NOT.L16) J4 = IA - 1
         IF(L1 .AND. L3 .AND. .NOT.L2) J8 = IA - 1
         J5 = IA
         I1 = I1 + 1
         IF(CSTMT(IA+1:IA+1) .EQ. CLPAR) I1 = I1 + 1
C
C         DETERMINE IF THE LEFT AND RIGHT PARENTHESIS DEFINE A DIMENSION
C         SPECIFICATION
C
         IF(.NOT.L17 .AND. .NOT.L27 .OR. CSTMT(IA-1:IA-1) .NE.
     1      CASTER(1:1)) THEN
            L2 = LTRUE
            JBITS = IBSET(JBITS,17)
         END IF
         L14 = LTRUE
         IF(CSTMT(IA:IA) .EQ. CLPAR) GO TO 130
         GO TO 22
      END IF
C
C         COUNT A LEFT PARENTHESIS WHEN A DIMENSION SPECIFICATION EXISTS
C
C
C         DETERMINE IF AN ARITHMETIC OPERATOR OCCURS
C
 130  IF(CSTMT(IA:IA) .EQ. CPLUS .OR. CSTMT(IA:IA) .EQ. CMINUS .OR.
     1   CSTMT(IA:IA) .EQ. CSLASH .OR. CSTMT(IA:IA) .EQ. CASTER) THEN
C
C         DETERMINE IF PARENTHESES EXIST
C
         IF(I1 .GT. 0) L27 = LTRUE
      END IF
C
C         COUNT PARENTHESES FOR DIMENSION SPECIFICATION. RIGHT
C         PARENTHESES WILL BE IGNORED WHEN ENCAPSULATED WITHIN SLASHES.
C
      IF(CSTMT(IA:IA) .EQ. CRPAR .AND. L1 .AND. L2 .AND. .NOT.L4) THEN
         IF(CSTMT(IA+1:IA+1) .EQ. CSLASH .AND. .NOT.L27) THEN
            L4 = LTRUE
            I2 = I2 + 1
            J9 = IA + 1
            L20 = LTRUE
         END IF
         I1 = I1 - 1
         J6 = IA
C
C         DETERMINE IF DATA SPECIFICATIONS FOLLOWS THE DIMENSION
C         SPECIFICATIONS
C
         IF(CSTMT(IA+1:IA+1) .EQ. CSLASH) L4 = LTRUE
         GO TO 22
      END IF
      IF(CSTMT(IA:IA) .EQ. CRPAR .AND. L1 .AND. L2 .AND. L4) THEN
         I1 = I1 - 1
         J6 = IA
      END IF
C
C         COUNT FINAL SLASH
C
      IF(IA .EQ. J2 .AND. CSTMT(IA:IA) .EQ. CSLASH .AND. L20) THEN
         I2 = I2 + 1
         L20 = LFALSE
      END IF
C
C         WHEN AN ASTERISK OCCURS, IT IS THE START OF LENGTH
C         SPECIFICATIONS IF OUTSIDE OF ENCAPSULATING PARENTHESES AND
C         SLASHES. ASTERISKS ENCAPSULATED WITHIN PARENTHESES DO NOT
C         DESIGNATE A LENGTH SPECIFICATION. SLASHES NOT ECAPSULATED
C         WITHIN PARENTHESES DESIGNATE DATA SPECIFICATIONS, WHILE
C         SLASHES WITHIN PARENTHESES ARE ARITHMETIC OPERATORS.
C
      IF(CSTMT(IA:IA) .EQ. CASTER) THEN
C
C         DETERMINE IF ANY PARENTHESES OR SLASHES OCCUR
C
         IF(I1 .EQ. 0 .AND. I2 .EQ. 0) THEN
            IF(.NOT.L13) THEN
               IF(IA .EQ. KB) THEN
                  J7 = IA
               ELSE
                  J7 = IA + 1
               END IF
            END IF
C
C         SET END LOCATION OF A VARIABLE NAME
C
            IF(L1 .AND. .NOT.L2 .AND. .NOT.L3) THEN
               J4 = IA - 1
               L16 = LTRUE
            END IF
            L3 = LTRUE
            L13 = LTRUE
C
C         SET LENGTH CHARACTERISTIC IF A NUMERIC VALUE IS NOT
C         ENCAPSULATED WITHIN PARENTHESES
C
            I3 = IA + 1
            IF(CSTMT(I3:I3) .GE. C0 .AND. CSTMT(I3:I3) .LE. C9) THEN
               LA = LTRUE
               CALL NUMBER (CSTMT,LA,I3,II,FP,IFP)
               L33 = LTRUE
               IF(.NOT.LINCL) CALL INSERT (II)
C
C         SET TYPE CODE WHEN NECESSARY FOR REAL*4 OR REAL*8
C
               IF(CTYPED .EQ. CRR .AND. CLEN(1:1) .EQ. C8) CTYPED(1:1)
     1           = CDD
               IF(CTYPED .EQ. CDD .AND. CLEN(1:1) .EQ. C4) CTYPED(1:1)
     1           = CEE
               CLENWK(1:7) = CLEN(1:7)
               CLEN(1:7) = CBLANK(1:7)
               CLEN(1:IFP-I3+1) = CSTMT(I3:IFP)
            END IF
C
C         SET LENGTH CHARACTERISTIC IF A NUMERIC VALUE IS ENCAPSULATED
C         WITHIN PARENTHESES
C
            IF(CSTMT(I3:I3) .EQ. CLPAR) THEN
               IF(CSTMT(I3+1:I3+1) .GE. C0 .AND. CSTMT(I3+1:I3+1)
     1            .LE. C9) THEN
C
C         DETERMINE IF ANY ARITHMETIC OPERATORS EXIST
C
                  DO 14 I8 = I3,KB
C
C         DETERMINE IF AN ARITHMETIC OPERATOR OCCURS
C
                  IF(CSTMT(I8:I8) .EQ. CPLUS .OR. CSTMT(I8:I8) .EQ.
     1               CMINUS .OR. CSTMT(I8:I8) .EQ. CASTER .OR.
     2               CSTMT(I8:I8) .EQ. CSLASH) L26 = LTRUE
C
C         DETERMINE IF A LEFT PARENTHESIS OR A COMMA FOLLOWS A DIGIT.
C         WHEN A COMMA OR A LEFT PARENTHESIS OCCURS BEFORE AN ARITHMETIC
C         OPERATOR, A COMMA TERMINATES THE LENGTH SPECIFICATION; WHILE A
C         LEFT PARENTHESIS TERMINATES THE LENGTH SPECIFICATION AND
C         INDICATES A DIMENSION SPECIFICATION FOLLOWS.
C
                  IF(CSTMT(I8:I8) .EQ. COMMA) THEN
                     L3 = LTRUE
                     J7 = I3
                     J8 = I8 - 1
                     GO TO 15
                  END IF
                  IF(CSTMT(I8:I8) .EQ. CLPAR .AND. CSTMT(I8-1:I8-1) .NE.
     1               CASTER) THEN
                     IF(.NOT.L26) L2 = LTRUE
                     L3 = LTRUE
                     J5 = I8
                     J8 = I8 - 1
                     CLEN(1:J8-J7+1) = CSTMT(J7:J8)
                     GO TO 16
                  END IF
C
C         WHEN A SLASH OCCURS BEFORE AN ARITHMETIC OPERATOR, A DATA
C         SPECIFICATION EXISTS
C
                  IF(CSTMT(I8:I8) .EQ. CSLASH) THEN
                     L4 = LTRUE
                     IF(I8 .EQ. KB) THEN
                        GO TO 22
                     ELSE
                        GO TO 15
                     END IF
                  END IF
C
C         DETERMINE IF ANY ARITHMETIC OPERATORS EXIST
C
                  IF(CSTMT(I8:I8) .EQ. CPLUS(1:1) .AND. CSTMT(I8:I8)
     1               .EQ. CMINUS(1:1) .OR. CSTMT(I8:I8) .EQ. CASTER(1:1)
     2               .AND. CSTMT(I8:I8) .EQ. CSLASH(1:1)) THEN
                     L26 = LTRUE
                     GO TO 15
                  END IF
 14               CONTINUE
 15               IF(CSTMT(J2:J2) .GE. C0(1:1) .AND. CSTMT(J2:J2)
     1               .LE. C9(1:1)) THEN
                     I4WK3 = J2 - IA
                  ELSE
                     I4WK3 = J2 - IA - 1
                  END IF
                  IF(.NOT.L26) CLEN(1:I4WK3) = CSTMT(IA+1:IA+I4WK3)
                  L26 = LFALSE
               END IF
            END IF
C
C       WHEN THE LENGTH SPECIFICATION STARTS WITH A LEFT PARENTHESIS,
C       COUNT THE PARENTHESES TO INSURE MATCHED LEFT AND RIGHT PAIRS
C       OCCUR
C
 16         IF(CSTMT(I3:I3) .EQ. CLPAR) THEN
C
C         IF THE FIELD IS *(*) THEN THIS IS AN INHERITED LENGTH
C
               IF(CSTMT(I3-1:I3+2) .EQ. '*(*)') THEN
                  CLENSV(1:7) = CLEN(1:7)
                  CLEN(1:3) = '(*)'
                  L17 = LTRUE
                  J = I3 + 3
C
C         DETERMINE IF THE RIGHT PARENTHESIS IS THE FINAL CHARACTER OF
C         THE STATEMENT
C
                  IF(J .EQ. KB) THEN
                     GO TO 23
                  ELSE
                     GO TO 22
                  END IF
               END IF
               I20 = 0
               DO 18 IJ = I3,KB
C
C         COUNT ANY PARENTHESES
C
               IF(CSTMT(IJ:IJ) .EQ. CLPAR) I20 = I20 + 1
               IF(CSTMT(IJ:IJ) .EQ. CRPAR) I20 = I20 - 1
               IF(I20 .NE. 0) GO TO 18
C
C         DETERMINE IF ANY ARITHMETIC OPERATORS EXIST
C
               IF(CSTMT(IJ:IJ) .EQ. CPLUS .OR. CSTMT(IJ:IJ) .EQ. CMINUS
     1            .OR. CSTMT(IJ:IJ) .EQ. CASTER .OR. CSTMT(IJ:IJ) .EQ.
     2            CSLASH) L26 = LTRUE
               IF(CSTMT(IJ:IJ) .EQ. COMMA .OR. IJ .EQ. KB .OR. (I20 .EQ.
     1            0 .AND. CSTMT(IJ:IJ) .EQ. CRPAR)) THEN
                  IF(IJ .EQ. KB) THEN
                     K3 = IJ
                  ELSE
                     K3 = IJ - 1
                  END IF
                  IF(I20 .EQ. 0) K3 = IJ
                  K4 = K3
                  CALL PARAEV (I3,K3,JARG)
                  WRITE (CLENWK,113) JARG
                  L3 = LFALSE
                  L29 = LTRUE
                  L30 = LTRUE
                  I17 = 0
                  CLEN(1:7) = CBLANK(1:7)
                  DO 17 IB = 1,7
                  IF(CLENWK(IB:IB) .EQ. CBLANK) GO TO 17
                  I17 = I17 + 1
                  CLEN(I17:I17) = CLENWK(IB:IB)
 17               CONTINUE
                  CLENWK(1:7) = CLEN(1:7)
                  J = I7 + 2
C
C         DETERMINE IF THE RIGHT PARENTHESIS IS THE FINAL CHARACTER OF
C         THE STATEMENT
C
                  IF(K3 .EQ. KB) THEN
                     GO TO 23
                  ELSE
                     GO TO 22
                  END IF
               END IF
 18            CONTINUE
            END IF
C
C         SET LENGTH CHARACTERISTIC IF ALPHABETIC INDICATING A PARAMETER
C         VARIABLE NAME LENGTH SPECIFICATION
C
            IF(I3 .LT. KB .AND. CSTMT(I3:I3) .NE. CLPAR) I3 = I3 + 1
            IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I3:I3) .LE. CZZ .OR.
     1         CSTMT(I3:I3) .EQ. CUNDER) THEN
C
C         DETERMINE IF THE LENGTH EXPRESSION HAS ALREADY BEEN CALCULATED
C
               IF(L26) THEN
                  L26 = LFALSE
                  GO TO 22
               END IF
C
C         FIND THE END OF THE PARAMETER VARIABLE NAME
C
               DO 21 IJ = I3,KB
               IF(CSTMT(IJ:IJ) .EQ. CRPAR(1:1)) THEN
                  CALL PARAEV (I3,IJ-1,JARG)
                  I14 = IJ
                  K1 = I14 + 1
C
C         DETERMINE VARIABLE BEING PROCESSED TYPE
C
                  IF(CTYPED(1:1) .EQ. CAA) THEN
                     IF(JARG .EQ. 1) THEN
                        CLEN(1:1) = C1           ! BYTE
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,107) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CBB) THEN
                     IF(JARG .EQ. 8) THEN
                        CLEN(1:1) = C8           ! COMPLEX
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,108) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CCC) THEN
                     WRITE (CLENWK,113) JARG
                     DO 19 I15 = 1,7
                     IF(CLENWK(I15:I15) .GE. C0(1:1) .AND.
     1                  CLENWK(I15:I15) .LE. C9(1:1)) THEN
                        I16 = 8 - I15
                        CLEN(1:I16) = CLENWK(I15:7)   ! CHARACTER
                        GO TO 20
                     END IF
 19                  CONTINUE
 20                  IF(JARG .EQ. 0 .AND. .NOT.LINCL) THEN
                        WRITE (0,114) ISN
                        IREC0 = IREC0 + 1
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CDD) THEN
                     IF(JARG .EQ. 8) THEN
                        CLEN(1:1) = C8           ! REAL*8
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,111) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CEE) THEN
                     IF(JARG .EQ. 16) THEN
                        CLEN(1:2) = '16'         ! COMPLEX*16
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,108) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CII) THEN
                     IF(JARG .EQ. 1) THEN
                        CLEN(1:1) = C1           ! INTEGER*1
                     ELSE IF(JARG .EQ. 2) THEN
                        CLEN(1:1) = C2           ! INTEGER*2
                     ELSE IF(JARG .EQ. 4)  THEN
                        CLEN(1:1) = C4           ! INTEGER*4
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,109) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CLL) THEN
                     IF(JARG .EQ. 1) THEN
                        CLEN(1:1) = C1           ! LOGICAL*1
                        L25 = LFALSE
                     ELSE IF(JARG .EQ. 2) THEN
                             L25 = LFALSE
                             CLEN(1:1) = C2      ! LOGICAL*2
                     ELSE IF(JARG .EQ. 4) THEN
                             L25 = LFALSE
                             CLEN(1:1) = C4      ! LOGICAL*4
                     ELSE
                        IF(.NOT.LINCL) THEN
                           WRITE (0,110) ISN
                           IREC0 = IREC0 + 1
                        END IF
                     END IF
                     GO TO 11
                  END IF
                  IF(CTYPED(1:1) .EQ. CQQ .AND. JARG .EQ. 16)
     1               CLEN(1:2) = '16'
                  IF(CTYPED(1:1) .EQ. CDD .AND. JARG .EQ. 8)
     1               CLEN(1:1) = C8
                  IF(CTYPED(1:1) .EQ. CRR .AND. JARG .EQ. 4)
     1               CLEN(1:1) = C4
                  IF(CTYPED(1:1) .NE. CRR .AND. CTYPED(1:1) .NE. CDD
     1               .AND. CTYPED(1:1) .NE. CQQ) THEN
                     IF(.NOT.LINCL) THEN
                        WRITE (0,111) ISN
                        IREC0 = IREC0 + 1
                     END IF
                  END IF
                  K1 = I14 + 1
                  GO TO 11
               END IF
 21            CONTINUE
               GO TO 11
            END IF
            GO TO 22
         END IF
      END IF
C
C         IF AN ASTERISK DESIGNATING A LENGTH SPECIFICATION EXISTS,
C         THE NEXT CHARACTERS MUST BE DIGITS OR *(*). IF THERE IS NO
C         DATA SPECIFICATION, THEN THE FINAL CHARACTER OF ALL SPECIF-
C         ICATIONS FOR THE VARIABLE IS ALSO THE FINAL DIGIT OF THE
C         LENGTH.
C
C         THE FIRST NON-DIGIT CHARACTER FOLLOWING THE ASTERISK
C         DETERMINES THE END OF THE LENGTH SPECIFICATION WHEN THE
C         ASTERISK IS NOT ENCAPSULATED WITHIN SLASHES OR PARENTHESES
C
      IF(L13) THEN
C
C         TEST FOR A CHARACTER VARIABLE
C
         IF(CTYPED(1:1) .EQ. CCC) THEN
C
C         IF THE LENGTH IS SPECIFIED AS *(*), THE LENGTH IS DERIVED FROM
C         A CALLING SUBPROGRAM FOR THIS VARIABLE. A VARIABLE THAT IS AN
C         ARGUMENT IN A SUBROUTINE STATEMENT CAN NOT BE IN COMMON.
C
            IF(CSTMT(IA:IA+3) .EQ. '*(*)') THEN
               CLENSV(1:7) = CLEN(1:7)
               CLEN(1:3) = '(*)'
               J7 = IA + 1
               L17 = LTRUE
               GO TO 22
            END IF
C
C         DETERMINE IF A CHARACTER VARIABLE HAS A PARAMETER DEFINITION
C         AS IT LENGTH SPECIFICATION
C
            IF(CSTMT(IA:IA+1) .EQ. '*(' .AND. CSTMT(IA+3:IA+3) .GE. CAA
     1         .AND. CSTMT(IA+3:IA+3) .LE. CZZ .OR. CSTMT(IA+3:IA+3)
     2          .EQ. CUNDER) THEN
               I13 = IA
               L17 = LTRUE
               GO TO 22
            END IF
C
C         TEST IF ALL CHARACTERS ARE TO BE SKIPPED UNTIL A RIGHT
C         PARENTHESIS OCCURS
C
            IF(L17 .AND. CSTMT(IA:IA) .EQ. CRPAR(1:1)) THEN
               L17 = LFALSE
               GO TO 22
            END IF
         END IF
C
C         TEST FOR A CHARACTER THAT IS NOT A DIGIT
C
         IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9))
     1      THEN
            IF(J8 .EQ. 0) J8 = IA - 1
            L13 = LFALSE
         END IF
C
C         IF THE END OF THE LENGTH SPECIFICATION IS A DIGIT AND IS ALSO
C         THE FINAL CHARACTER OF ALL THE VARIABLE'S SPECIFICATION, SET
C         THE END VALUE OF THE LENGTH
C
         IF(IA .EQ. J2) THEN
            IF(J8 .EQ. 0) J8 = J2
            L13 = LFALSE
            GO TO 24
         END IF
C
C         SET THE END OF THE LENGTH FIELD WHEN A COMMA OCCURS OR THE
C         END OF THE FIELD OCCURS
C
         IF(CSTMT(IA:IA) .EQ. COMMA .OR. IA .EQ. KB) THEN
            IF(CSTMT(IA:IA) .EQ. COMMA) J8 = IA - 1
            IF(IA .EQ. KB) J8 = KB
         END IF
      END IF
C
C         WHEN A SLASH OCCURS, IT IS THE START OF DATA SPECIFICATIONS.
C         SLASHES CAN NOT OCCUR IN THE VARIABLE NAME, OR LENGTH
C         SPECIFICATIONS. A SLASH MAY OCCUR IN A DIMENSION SPECIFICATION
C         WITHIN AN EXPRESSION OF PARAMETER VALUES AND CONSTANTS
C         DEFINING THE DIMENSION SIZE.
C
      IF(CSTMT(IA:IA) .EQ. CSLASH) THEN
         IF(L20) THEN
            J10 = IA
            I2 = I2 + 1
         ELSE
            IF(I2 .EQ. 0 .AND. IA .GT. J6) THEN
               J9 = IA
               L4 = LTRUE
               I2 = I2 + 1
               L20 = LTRUE
               GO TO 22
            END IF
         END IF
C
C         WHEN A SECOND SLASH OCCURS, IT MUST BE FOLLOWED BY EITHER A
C         BLANK OR A COMMA. WHEN A SECOND SLASH IS NOT FOLLOWED BY
C         EITHER, THEN THE SLASH MUST BELONG TO A HOLLERITH FIELD.
C
         IF(MOD(I2,2) .EQ. 0) THEN
            IF(CSTMT(IA+1:IA+1) .EQ. CBLANK(1:1) .OR. CSTMT(IA+1:IA+1)
     1         .EQ. COMMA) THEN
               J10 = IA
               GO TO 22
            END IF
         ELSE
            GO TO 22
         END IF
         IF(I2 .NE. 0) I2 = I2 + 1
      END IF
C
C         WHEN A COMMA OCCURS AND NO VARIABLE CHARACTERISTICS EXIST,
C         TERMINATE THE LOOP; THIS INDICATES ONLY THE VARIABLE NAME
C         IS SPECIFIED, FOLLOWED BY THE COMMA.
C
      IF(CSTMT(IA:IA) .EQ. COMMA) THEN
         IF(L1 .AND. .NOT.L2 .AND. .NOT.L3 .AND. .NOT.L4) THEN
            J4 = IA - 1
            GO TO 24
         END IF
         IF(.NOT.L1 .AND. .NOT.L2 .AND. .NOT.L3 .AND. L4) J10 = IA
      END IF
 22   CONTINUE
      L26 = LFALSE
C
C     ******************************************************************
C     *                                                                *
C     *                SINGLE VARIABLE NAME PROCESSING                 *
C     *                                                                *
C     ******************************************************************
C
C         WHEN THE LOOP TERMINATES NORMALLY AND NO DIMENSION, LENGTH,
C         OR DATA SPECIFICATIONS ARE MADE, THE ENTRY IS A SINGLE
C         VARIABLE NAME WITHOUT ANY OTHER CHARACTERS FOLLOWING IT.
C
C         WHEN J4 IS SET BY THIS LOOP, L14 IS TRUE
C
 23   IF(L12 .OR. L14) THEN
         L12 = LFALSE
         L14 = LFALSE
         GO TO 24
      END IF
      IF(L1 .AND. .NOT.L2 .AND. .NOT.L3 .AND. .NOT.L4 .AND. .NOT.L16)
     1J4 = J2 - 1
C
C         WHEN ANY OF THE VARIABLE CHARACTERISTICS EXIST, DETERMINE
C         THE END OF THE VARIABLE NAME
C
      IF(J4 .EQ. 0) THEN
C
C         THE CASE WHEN ALL THREE CHARACTERISTICS DEFINITIONS EXIST
C
         IF(J5 .NE. 0 .AND. J7 .NE. 0 .AND. J9 .NE. 0) THEN
            IF(J5 .LT. J7 .AND. J5 .LT. J9) THEN
               J4 = J5 - 1
            ELSE IF(J7 .LT. J5 .AND. J7 .LT. J9) THEN
               J4 = J7 - 1
            ELSE
               IF(J9 .LT. J5 .AND. J9 .LT. J7) J4 = J9 - 1
            END IF
            GO TO 24
         END IF
C
C         THE CASE WHEN ONLY TWO OF THE CHARACTERISTIC DEFINITIONS
C         EXIST
C
         IF(J5 .NE. 0 .AND. J7 .NE. 0 .AND. J9 .EQ. 0) THEN
            IF(J5 .LT. J7) THEN
               J4 = J5 - 1
            ELSE
               J4 = J7 - 1
            END IF
            GO TO 24
         END IF
         IF(J5 .NE. 0 .AND. J7 .EQ. 0 .AND. J9 .NE. 0) THEN
            IF(J5 .LT. J9) THEN
               J4 = J5 - 1
            ELSE
               J4 = J9 - 1
            END IF
            GO TO 24
         END IF
         IF(J5 .EQ. 0 .AND. J7 .NE. 0 .AND. J9 .NE. 0) THEN
            IF(J7 .LT. J9) THEN
               J4 = J7 - 1
            ELSE
               J4 = J9 - 1
            END IF
            GO TO 24
         END IF
C
C         THE CASE WHEN ONLY ONE OF THE CHARACTERISITIC DEFINITIONS
C         EXIST
C
         IF(J5 .NE. 0 .AND. J7 .EQ. 0 .AND. J9 .EQ. 0) J4 = J5 -1
         IF(J5 .EQ. 0 .AND. J7 .NE. 0 .AND. J9 .EQ. 0) J4 = J7 -1
         IF(J5 .EQ. 0 .AND. J7 .EQ. 0 .AND. J9 .NE. 0) J4 = J9 -1
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *                 VARIABLE NAME PROCESSING                       *
C     *                                                                *
C     ******************************************************************
C
C         TEST IF A VARIABLE NAME EXISTS
C
 24   IF(.NOT.L1) GO TO 25
C
C          COMPUTE THE LENGTH OF THE VARIABLE NAME
C
      IC = J4 - J3 + 1
C
C          PLACE VARIABLE NAME IN THE WORK AREA
C
      CWK104(1:IC) = CSTMT(J3:J4)
      CWORK(1:32) = CBLK52(1:32)
      CWORK(1:IC) = CSTMT(J3:J4)
      IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
C
C         SET THE TYPE CODE IN CWORK WHEN CTYPED IS DEFINED
C
         IF(CTYPED(1:1) .NE. CBLANK(1:1)) CWORK(37:44) = CTYPED(1:1)//
     1      CLENSV(1:7)
C
C         DETERMINE IF THE VARIABLE ALREADY EXISTS IN THE MASTER NAME
C         TABLE
C
         IF(LSTRUC) THEN
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         ELSE
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         END IF
         IF(IRET .GT. 0) THEN
            IF(.NOT.BTEST(IENAME(12,IRET),6)) THEN
               IF(LFORCE) THEN
                  CNAME(IRET)(37:44) = CWORK(37:44)
               ELSE
                  IF(.NOT.BTEST(JBITS,17)) CWORK(37:44) = CNAME(IRET)
     1               (37:44)
               END IF
            END IF
         ELSE
            IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
               IF(.NOT.BTEST(JBITS,17)) CALL SETTL (CWORK)
               CTYPED(1:1) = CWORK(37:37)
               CLEN(1:7) = CWORK(38:44)
            END IF
         END IF
      ELSE
         CWORK(37:37) = CTYPED(1:1)
      END IF
      IF(CLEN(1:7) .EQ. CBLANK(1:7) .AND. CTYPED(1:1) .EQ. CCC)
     1   CLEN(1:1) = C1
      IF(CWORK(38:44) .EQ. CBLANK(1:7)) CWORK(38:44) = CLEN(1:7)
      ILEN = IC
      IVCNT = IC
C
C         DETERMINE IF THE VARIABLE NAME OCCURS WITHIN A UNION RANGE
C
      IF(JUNION .GT. 0) JBITS = IBSET(JBITS,5)
C
C         TEST IF THIS IS A FUNCTION STATEMENT WITH A SPECIFIED TYPE
C
      ID = J + 7
      IF(CSTMT(J:ID) .EQ. 'FUNCTION') THEN
         KF = J
         CALL STMT29 (CTYPED,CLEN)
         GO TO 24
      END IF
C
C       SET DEFAULT LENGTH FOR A CHARACTER VARIABLE WITH NO LENGTH
C       SPECIFICATION
C
      IF(CTYPED(1:1) .EQ. CCC .AND. CLEN(1:7) .EQ. CBLANK(1:7))
     1   CLEN(1:1) = C1
C
C         DETERMINE IF A REAL*8 EXISTS AND CHANGE THE TYPE CODE TO
C         DOUBLE PRECISION
C
      IF(CLEN(1:1) .EQ. C8 .AND. CTYPED(1:1) .EQ. CRR) THEN
         CWORK(37:37) = CDD
      END IF
C
C         DETERMINE IF A REAL*4 EXISTS AND CHANGE THE TYPE CODE TO
C         SINGLE PRECISION
C
      IF(CLEN(1:1) .EQ. C4 .AND. CTYPED(1:1) .EQ. CDD) THEN
         CWORK(37:37) = CRR
      END IF
C
C         DETERMINE IF THIS VARIABLE NAME IS FROM A RECORD STATEMENT
C
      L32 = BTEST(JBITS,2)             ! RECORD
      IF(L32) THEN
C
C         OBTAIN THE STRUCTURE DEFINING THE LENGTH THE RECORD VARIABLE
C
        CALL TABSRH (CSTR,ISTRUC,36,1,32,CWK68,1,32,IRET,1000)
C
C         PLACE THE STRUCTURE LENGTH IN THE RECORD VARIABLE WORK AREA
C
         IF(IRET .GT. 0 .AND. CWK68(1:32) .NE. CWK68(33:64)) THEN
            CWK68(1:32) = CSTR(IRET)(1:32)
            CWK68(33:64) = CWORK(1:32)
            CWK68(65:68) = CSTR(IRET)(33:36)
C
C         SET THE CORRECT LENGTH FOR THE RECORD VARIABLE NAME IN CWORK
C
            CI4WK2(1:4) = CSTR(IRET)(33:36)
            CALL ITOC (I4WK2,CWORK,38,44)
         END IF
      ELSE
C
C         SET THE WORK BUFFER DATA TYPE CODE AND LENGTH
C
         CWORK(37:37) = CTYPED
         IF(CWORK(38:44) .EQ. CBLANK(1:7)) CWORK(38:44) = CLEN(1:7)
      END IF
C
C         SAVE THE VARIABLE NAME IN CNAME, THE TABLE OF ALL VARIABLE
C         NAMES FOR THE PROGRAM OR SUBPROGRAM BEING PROCESSED
C
C         DETERMINE IF THE VARIABLE IS FROM A CHARACTER STATEMENT WITH
C         AN INHERITED LENGTH
C
      CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
      IF(CWORK(37:40) .EQ. 'C(*)') THEN
C
C         DETERMINE IF THE VARIABLE NAME IS ALREADY IN CNAME. IF NOT,
C         INSERT THE VARIABLE NAME INTO THE MASTER NAME TABLE
C
         IF(IRET1 .LE. 0) THEN
            JBITS = IBSET(JBITS,15)
            CALL VSETUP (J3,J4,IC,LFALSE,LFALSE,CSTMT)
         ELSE
            CNAME(IRET1)(37:44) = CWORK(37:44)
         END IF
      ELSE
C
C         DETERMINE IF THE CURRENT VARIABLE NAME IS ALSO A COMMON BLOCK
C         DEFINITION NAME AND SET THE TYPE AND LENGTH CODE
C
         IF(CWORK(37:44) .EQ. CBLANK(1:8)) THEN
            IF(.NOT.LFORCE) THEN
               IF(CNAME(IRET1)(37:37) .EQ. CBAR) THEN
                  CALL SETTL (CWORK)
               ELSE
                  IF(IRET1 .GT. 0) THEN
                     CWORK(37:44) = CNAME(IRET1)(37:44)
                  ELSE
                     CALL SETTL (CWORK)
                  END IF
               END IF
            END IF
         ELSE
C
C         A TYPE STATEMENT VARIABLE REQUIRES BIT SWITCHES TO BE
C         INITIALIZED WHEN IT IS NOT IN THE MASTER NAME TABLE AND A
C         TYPE AND LENGTH EXIST
C
            IF(IRET1 .LT. 0) THEN
               IF(.NOT.BTEST(JBITS,17))  JBITS = 0
               IF(LSTRUC) JBITS = IBSET(JBITS,6)
               JBITS = IBSET(JBITS,15)
            ELSE
C
C         WHEN THE VARIABLE NAME ALREADY EXISTS IN CNAME, CORRECT THE
C         TYPE AND LENGTH CODE IN CNAME WHEN LFORCE IS SET TRUE AND
C         THE VARIABLE IS NOT USED WITHIN A STRUCTURE
C
               IF(CNAME(IRET1)(1:32) .EQ. CWORK(1:32) .AND. LFORCE) THEN
                  IF(.NOT.BTEST(IENAME(12,IRET1),6)) THEN
                     IF(CNAME(IRET1)(37:44) .NE. CWORK(37:44))
     1                  CNAME(IRET1)(37:44) = CWORK(37:44)
                  END IF
               END IF
            END IF
         END IF
         IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C         DETERMINE IF THE VARIABLE NAME IS ALREADY IN THE MASTER
C         VARIABLE NAME TABLE
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
C
C         WHEN THE VARIABLE NAME IS IN THE MASTER NAME TABLE, SET THE
C         TYPE AND LENGTH CHARACTERISTICS TO THOSE IN THE TABLE UNLESS
C         IT IS A COMMON, RECORD, OR STRUCTURE NAME
C
         IF(IRET .GT. 0) THEN
            IF(CNAME(IRET)(37:37) .EQ. CBAR) THEN
               CALL SETTL (CWORK)
            ELSE
               IF(.NOT.LSTRUC .AND. IRET .GT. 0) THEN
                  IF((CWORK(37:37) .EQ. CBLANK(1:1) .OR.
     1               CWORK(38:38) .EQ. CBLANK(1:1)) .AND.
     2               CNAME(IRET)(37:44) .NE. CBLANK(1:8)) THEN
                     CWORK(37:44) = CNAME(IRET)(37:44)
                  ELSE IF(CWORK(37:44) .NE. CNAME(IRET)(37:44) .AND.
     1               .NOT.BTEST(IENAME(12,IRET),6)) THEN
                     CWORK(37:44) = CNAME(IRET)(37:44)
                  END IF
               END IF
            END IF
         ELSE
            IF(CWORK(38:44) .EQ. CBLANK(1:7)) CWORK(38:44) = CLEN(1:7)
         END IF
C
C         CATALOG THE VARIABLE NAME IN THE MASTER NAME TABLE. IF THE
C         VARIABLE IS DEFINED WITHIN A STRUCTURE, CALL CHKNME DIRECTLY
C         SINCE THE VARIABLE NAME CAN NOT BE PART OF A COMPOUND VARIABLE
C         SPECIFICATION. IF A DIMENSION STATEMENT IS BEING PROCESSED,
C         TYPE AND LENGTH CHARACTERISTICS ARE UNKNOWN.
C
         IF(LSTRUC) THEN
            CALL CHKNME (CNAME)
         ELSE
C
C         IF A DIMENSION STATEMENT IS BEING PROCESSED, TYPE AND LENGTH
C         CHARCTERISTICS ARE UNKNOWN; USE CHKNME INSTEAD OF VSETUP.
C
            IF(.NOT.BTEST(JBITS,17)) THEN
               CALL VSETUP (J3,J4,IC,LFALSE,LFALSE,CSTMT)
            ELSE
               CALL CHKNME (CNAME)
            END IF
         END IF
      END IF
C
C       WHEN THE VARIABLE NAME LENGTH DEFINITION IS NOT BLANK, DO NOT
C       CHANGE IT
C
      IF(CLEN(1:7) .EQ. CBLANK(1:7)) THEN
         IF(CLENWK(1:7) .EQ. CBLANK(1:7)) THEN
            CLEN(1:7) = CLENSV(1:7)
         ELSE
            CLEN(1:7) = CLENWK(1:7)
         END IF
      END IF
C
C         INITIALIZE THE ARITHMETIC OPERATOR LOGICAL SWITCH
C
      L27 = LFALSE
C
C         SET NAME AND LENGTH OF A COMMON VARIABLE FOR UNIT 11 OUTPUT
C         WHEN IT IS IN COMMON
C
      L32 = BTEST(JBITS,1)             ! COMMON
      IF(L32 .AND. .NOT.LINCL) THEN
         CWK44(1:32) = CBLK52(1:32)
         CWK44(1:IC) = CSTMT(J3:J4)
         CALL TABSRH (CNAME,INAME,52,1,32,CWK44,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
            IF(CNAME(IRET)(49:52) .NE. CBLANK(1:4)) THEN
               CWK44(33:36) = CNAME(IRET)(49:52)
            ELSE
               CWK44(33:36) = CWORK(49:52)
            END IF
            IF(CNAME(IRET)(37:44) .NE. CBLANK(1:8)) THEN
               CWK44(37:44) = CNAME(IRET)(37:44)
            ELSE
               CWK44(37:44) = CWORK(37:44)
            END IF
         END IF
         IF(.NOT.BTEST(IENAME(12,IRET),1)) THEN
            IF(.NOT.LINCL) THEN
               WRITE (11,REC=IREC11) CWK44(1:44)
               IREC11 = IREC11 + 1
            END IF
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *                DIMENSION PROCESSING                            *
C     *                                                                *
C     *******************************************************A**********
C
C         DETERMINE IF ANY DIMENSION SPECIFICATIONS EXIST
C
 25   IF(.NOT.L2) THEN
         IF(.NOT.L3) THEN
            IF(.NOT.L4) GO TO 59
            GO TO 45
         END IF
         GO TO 41
      END IF
C
C         INITIALIZE LOGICAL SWITCH FOR DIMENSION RANGE SPECIFICATION
C
      L28 = LFALSE
C
C         DETERMINE IF THE CALLING ROUTINE INDICATES THE VARIABLE IS
C         DIMENSIONED
C
      IF(L36) JBITS = IBSET(JBITS,17)
C
C         CHECK IF ANY UNMATCHED PARENTHESES EXIST FOR THE DIMENSION
C         SPECIFICATION
C
      I1 = 0
      DO 26 IA = J5,J6
      IF(CSTMT(IA:IA) .EQ. CLPAR) I1 = I1 + 1
      IF(CSTMT(IA:IA) .EQ. CRPAR) I1 = I1 - 1
 26   CONTINUE
C
C         WHEN UNBALANCED PARENTHESES OCCURS AND I1 IS NOT ZERO,
C         A SYNTAX ERROR EXISTS
C
      IF(I1 .GT. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         SET THE SWITCH TO INDICATE THIS VARIABLE IS A DIMENSION
C         DEFINITION
C
      JBITS = IBSET(JBITS,17)         ! DIMENSIONED
C
C         PLACE THE ISN IN THE DIMENSION TABLE RECORD
C
      JISN = ISN
C
C         INITIALIZE ARRAY OF LOCATIONS FOR COMMAS DEFINING THE
C         SPECIFICATIONS FOR EACH DIMENSION DEFINED
C
      DO 27 IB = 1,7
      MD(IB) = 0
 27   CONTINUE
C
C         INDICATE THE DIMENSIONED VARIABLE NAME HAS NOT BEEN PROCESSED
C
      L5 = LFALSE
C
C         DETERMINE IF THE INITIAL CHARACTER IS A LEFT PARENTHESIS. THIS
C         OCCURS ONLY WHEN SPECIFICATIONS ARE PROVIDED AS PART OF A TYPE
C         STATEMENT OR A PARAMETER VARIABLE.
C
      IF(CSTMT(J5:J5) .EQ. CLPAR) THEN
         JE = J5 + 1
         GO TO 29
      END IF
C
C         DETERMINE THE LOCATION OF THE END OF THE DIMENSIONED VARIABLE
C         NAME
C
      DO 28 IB = J5,J6
      IF(CSTMT(IB:IB) .EQ. CLPAR) THEN
C
C         THE END OF THE DIMENSIONED VARIABLE NAME HAS BEEN FOUND
C
         JE = IB - 1
         IE = IB - J5
         CALL VSETUP (J5,JE,IE,LFALSE,LFALSE,CSTMT)
         JE = IB + 1
         GO TO 29
      END IF
 28   CONTINUE
C
C         WHEN THE DO LOOP TERMINATES NORMALLY, SET THE START LOCATION
C         OF THE DIMENSION SPECIFICATIONS. THIS IS THE FIRST CHARACTER
C         AFTER THE LEFT PARAENTHESIS.
C
      JE = JE + 1
C
C         COUNT THE NUMBER OF DIMENSION SPECIFICATIONS FOR A SINGLE
C         VARIABLE
C
 29   JF = 0
      DO 30 IB = JE,J6
      IF(CSTMT(IB:IB) .EQ. COMMA) THEN
         JF = JF + 1
         MD(JF) = IB
      END IF
 30   CONTINUE
C
C         IF NO COMMAS, A SINGLE DIMENSION SPECIFICATION EXISTS
C
      IF(JF .EQ. 0) THEN
         JF = 1
      ELSE
         JF = JF + 1
      END IF
      MD(JF) = J6
C
C         VERIFY THE NUMBER OF DIMENSIONS IS LESS THAN 8
C
      IF(JF .GT. 7) THEN
         WRITE (0,106) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         SET THE START VALUE FOR PROCESSING DIMENSION SPECIFICATIONS
C
      JJ = 1
      J12 = JE
C
C     ******************************************************************
C     *                                                                *
C     *   INDIVIDUAL DIMENSION SPECIFICATION PROCESSING                *
C     *   DETERMINE IF ALL DIMENSION SPECIFICATIONS ARE PROCESSED      *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE OF THE DIMENSION NUMBER IS LOWER THAN THE TOTAL
C         NUMBER OF ALL DIMENSIONS DEFINED FOR THIS VARIABLE
C
 31   L7 = LFALSE
      IF(JJ .GT. JF) GO TO 37
C
C         SCAN FOR A COLON TO DETERMINE IF A DIMENSION SPECIFICATION
C         IS A RANGE
C
      DO 32 IB = J12,MD(JJ)
      IF(CSTMT(IB:IB) .EQ. COLON) THEN
C
C         SET PARAMETERS TO PROCESS THE LOWER BOUND WHEN A COLON EXISTS
C         IN THE DIMENSION SPECIFICATION
C
         L7 = LTRUE
         L28 = LTRUE
         I18 = IB
         J12 = JE
         J14 = IB - 1
         GO TO 33
      END IF
 32   CONTINUE
C
C         A RANGE SPECIFICATION DOES NOT EXIST; FOR THIS CASE, THE
C         DIMENSION SPECIFICATION OF THE LOWER BOUND VALUE IS SET TO
C         ONE, AND THE UPPER BOUND VALUE IS THE SPECIFIED VALUE.
C
      IF(.NOT.L7) THEN
         IF(JF .EQ. JJ) THEN
            J14 = J6 - 1
         ELSE
            J14 = MD(JJ) - 1
         END IF
         JSTART(JJ) = 1
      END IF
C
C         PROCESS THE LOWER OR UPPER BOUND VALUE OF THE RANGE
C         SCAN BACKWARDS FOR AN ARITHMETIC OPERATOR
C
 33   DO 34 IB = J14,J12,-1
C
C         WHEN A PLUS OR MINUS SIGN OCCURS AS THE FIRST CHARACTER OF THE
C         LOWER OR UPPER RANGE AND NO OTHER ARITHMETIC OPERATOR OCCURS,
C         THE LOWER OR UPPER BOUND IS NOT AN ARITHMETIC EXPRESSION.
C
      IF(.NOT.L27) THEN
         IF(IB .EQ. J12) GO TO 35
      ELSE
C
C         WHEN AN ARITHMETIC OPERATOR EXISTS AND THE FINAL CHARACTER
C         IS BEING PROCESSED AND A COLON EXISTS, THE LOWER OR UPPER
C         RANGE IS AN EXPRESSION
C
         IF(IB .EQ. J12) THEN
C
C         EVALUATE THE EXPRESSION TO DETERMINE THE DIMENSION VALUE
C
            CALL PARAEV (J12,J14,II)
C
C         SET THE VALUE OF THE LOWER BOUND OR THE TOTAL NUMBER OF WORDS
C         THE DIMENSION SPECIFICATION REQUIRES
C
            IF(L7) THEN
               JSTART(JJ) = II
            ELSE
               JEND(JJ) = II
               KDNUM(JJ) = II - JSTART(JJ) + 1
               IF(KDNUM(JJ) .EQ. 0) KDNUM(JJ) = 1
            END IF
            GO TO 36
         END IF
      END IF
C
C         DETERMINE IF AN ASTERISK IS USED TO INDICATE THE DIMENSION
C         VALUE IS INHERITED. THIS CASE IS DETERMINED BY THE CHARACTER
C         IMMEDIATELY PRECEDING THE ASTERISK BEING A COMMA, A COLON, OR
C         A LEFT PARENTHESIS. NO TOTAL LENGTH WILL BE COMPUTED FOR THIS
C         DIMENSION SINCE IT CAN ONLY BE DETERMINED AT EXECUTION TIME.
C
      IF(CSTMT(IB:IB) .EQ. CASTER) THEN
         IF(CSTMT(IB-1:IB-1) .EQ. COMMA .OR. CSTMT(IB-1:IB-1) .EQ.
     1      CLPAR .OR. CSTMT(IB-1:IB-1) .EQ. COLON) GO TO 39
      END IF
C
C         DETERMINE IF AN ARITHMETIC OPERATOR EXISTS
C
      IF(CSTMT(IB:IB) .EQ. CPLUS .OR. CSTMT(IB:IB) .EQ. CMINUS .OR.
     1   CSTMT(IB:IB) .EQ. CASTER .OR. CSTMT(IB:IB) .EQ. CSLASH)
     2   L27 = LTRUE
 34   CONTINUE
C
C         DETERMINE IF A VARIABLE NAME OR A CONSTANT SPECIFIES THE
C         LOWER OR UPPER RANGE VALUE
C
 35   J13 = J14
      J15 = J12
C
C         DETERMINE IF THE FIRST CHARACTER IS A PLUS OR MINUS SIGN
C
      IF(CSTMT(J12:J12) .EQ. CPLUS .OR. CSTMT(J12:J12) .EQ. CMINUS) THEN
          J11 = J12 + 1
      ELSE
          J11 = J12
      END IF
C
C         DETERMINE IF THE LOWER OR UPPER BOUND IS A VARIABLE NAME THAT
C         IS NOT PART OF AN EXPRESSION
C
      IF(CSTMT(J11:J11) .GE. CAA .AND. CSTMT(J11:J11) .LE. CZZ .OR.
     1   CSTMT(J11:J11) .EQ. CUNDER) THEN
         CWKK32(1:32) = CBLK52(1:32)
         CWKK32(1:J13-J11+1) = CSTMT(J11:J13)
C
C         OBTAIN THE LOCATION OF THE DIMENSION SPECIFICATION VARIABLE
C         NAME FROM THE MASTER VARIABLE NAME TABLE
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWKK32,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         VERIFY IF THE TYPE CODE OF THE VARIABLE NAME IS INTEGER
C
            IF(CNAME(IRET)(37:37) .EQ. CBLANK(1:1)) THEN
               IF(CNAME(IRET)(37:37) .NE. CI1 .AND. CNAME(IRET)(37:37)
     1            .NE. CBLANK(1:1)) THEN
                  WRITE (0,116) ISN,CNAME(IRET)(1:32)
                  IREC0 = IREC0 + 1
               END IF
            END IF
         END IF
C
C         DETERMINE IF THE VARIABLE NAME USED TO SPECIFY A DIMENSION
C         VALUE IS DEFINED BY A PARAMETER STATEMENT VARIABLE
C
         IF(IRET .GT. 0) THEN
C
C         CREATE RECORD FOR UNIT 7 OF THE DIMENSIONING VARIABLE
C
            CWK52(1:52) = CBLK52(1:52)
            CWK52(1:52) = CNAME(IRET)(1:52)
            IWORK = ISN + 128
            KBITS = IBSET(KBITS,14)
            WRITE (7,REC=IREC7) CWK52(1:52)
            IREC7 = IREC7 + 1
            CWK32(1:32) = CNAME(IRET1)(1:32)
            CALL PARAEV (J15,J13,II)
         ELSE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            IWORK = ISN + 128
            CWORK(33:36) = CWK52(33:36)
            IVCNT = J13 - J11 + 1
            CWORK(49:52) = CWK52(49:52)
C
C         DETERMINE IF THE VARIABLE SPECIFYING THE DIMENSIION VALUE HAS
C         A SUBSCRIPT
C
            L37 = LFALSE
            J16 = 0
            DO I8 = 1,32
            IF(CWKK32(I8:I8) .EQ. CLPAR) THEN
               IF(CWKK32(I8+1:I8+1) .GT. C0 .AND. CWKK32(I8+1:I8+1) .LE.
     1            C9) THEN
                  J16 = I8
                  L37 = LTRUE
                  LA = LTRUE
                  CALL NUMBER (CWKK32,LA,I8+1,II,FP,IFP)
                  IF(LA) CALL INSERT (II)
               END IF
            END IF
            END DO
            IF(J16 .GT. 0 .AND. CWKK32(J16:J16) .EQ. CLPAR) THEN
               IVCNT = J16 - 1
               CWORK(1:IVCNT) = CWKK32(1:IVCNT)
            ELSE
               IVCNT = J13 - J11 + 1
               CWORK(1:IVCNT) = CWKK32(1:IVCNT)
            END IF
            IF(.NOT.L37) CALL CHKNME (CSTMT)
            L31(JJ) = LTRUE
         END IF
         IF(L7) THEN
            JSTART(JJ) = II
         ELSE
            JEND(JJ) = II
            KDNUM(JJ) = II - JSTART(JJ) + 1
         END IF
      END IF
C
C         DETERMINE IF THE LOWER OR UPPER BOUND FIRST CHARACTER IS A
C         DIGIT
C
      IF(CSTMT(J11:J11) .GE. C0 .AND. CSTMT(J11:J11) .LE. C9) THEN
         LA = LTRUE
         L11 = LTRUE
         CALL NUMBER (CSTMT,LA,J15,II,FP,IFP)
         IF(.NOT.LA) THEN
            IF(.NOT.LINCL) THEN
               WRITE (0,104) ISN,FP
               IREC0 = IREC0 + 1
            END IF
            IF(.NOT.LINCL) CALL FCHECK
            II = FP
         END IF
         CALL INSERT (II)
         IF(L7) THEN
            JSTART(JJ) = II
         ELSE
            JEND(JJ) = II
            KDNUM(JJ) = II - JSTART(JJ) + 1
         END IF
      END IF
C
C         DETERMINE IF THE UPPER BOUND REQUIRES PROCESSING AND SET
C         PARAMETERS IF REQUIRED
C
      IF(L7) THEN
         J12 = I18 + 1
         J14 = MD(JJ) - 1
         L7 = LFALSE
         GO TO 33
      END IF
C
C         DETERMINE IF ALL DIMENSION SPECIFICATIONS HAVE BEEN PROCESSED
C         FOR THE CURRENT DIMENSIONED VARIABLE
C
 36   IF(JJ .LT. JF) THEN
         J12 = MD(JJ) + 1
         JE = J12
         JJ = JJ + 1
         GO TO 31
      END IF
C
C         WHEN THE DIMENSION SPECIFICATIONS ARE COMPLETE, COMPUTE THE
C         TOTAL MEMORY REQUIRED BY THE DIMENSION SPECIFICATIONS (IN
C         WORDS OF THE DEFINED LENGTH FOR THE VARIABLE).
C
 37   IF(JJ .EQ. 1) THEN
         JWORK = KDNUM(JJ)
         GO TO 39
      END IF
      JWORK = KDNUM(1)
      DO 38 IB = 2,JJ
      JWORK = JWORK * KDNUM(IB)
 38   CONTINUE
C
C         DETERMINE IF THE UPPER DIMENSION RANGE OF VALUE EACH VARIABLE
C         IS HIGHER THAN THE LOWER RANGE VALUE
C
  39  DO 40 IB = 1,JJ
      IF(.NOT.L31(IB) .AND. L28) THEN
         IF(JEND(IB) .LT. JSTART(IB)) THEN
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
 40   CONTINUE
C
C         ALL DIMENSION SPECIFICATIONS ARE NOW PROCESSED. ENTER THE
C         INFORMATION INTO THE DIMENSION SAVE ARRAY, CDIM
C
C         TABINS WILL AUTOMATICALLY MAINTAIN ALPHABETICAL SEQUENCE
C
      JNUM1 = JF
      CALL TABINS (CDIM,JDIM,104,1,32,CWK104,1,32,IRET,1000)
      IF(IRET .EQ. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,115) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         TEST IF THE VARIABLE IS ALREADY DIMENSIONED
C
      IF(IRET .LT. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,102) ISN,CWK104(1:100)
         IREC0 = IREC0 + 1
      END IF
C
C         DETERMINE IF THE DIMENSIONED VARIABLE IS DEFINED IN A UNION
C         STRUCTURE, AND SAVE THE TOTAL MEMORY WORD SIZE FOR THE
C         DIMENSIONED VARIABLE TO BE USED AFTER THE VARIABLE LENGTH
C         CHARACTERISTIC IS DETERMINED.
C
      IF(JSTRUC .NE. 0 .OR. JUNION .NE. 0) I4WK4 = JWORK
C
C     ******************************************************************
C     *                                                                *
C     *                LENGTH SPECIFICATIONS PROCESSING                *
C     *                                                                *
C     ******************************************************************
C
C         CHECK IF A LENGTH SPECIFCIATION FOR THE INDIVIDUAL VARIABLE
C         EXISTS; IF NOT, USE ONE DEFINED FOR THE ENTIRE STATEMENT.
C
 41   IF(.NOT.L3) THEN
         IF(CLEN(1:7) .NE. CBLANK(1:7)) THEN
            CALL TABSRH (CNAME,INAME,52,1,32,CWK104,1,32,IB,4000)
            IF(IB .GT. 0) THEN
               IF(CNAME(IB)(38:40) .EQ. '(*)') THEN
                  I4WK1 = 4
               ELSE
                  READ (CLEN,'(I7)') I4WK1
               END IF
            ELSE
               CALL SETTL (CWORK)
            END IF
            IF(IB .GT. 0 .AND. CNAME(IB)(38:I4WK1+37) .EQ. CBLANK(1:7))
     1         THEN
               I4WK1 = J8 - J7 + 1
               IF(CNAME(IB)(38:38) .EQ. CBLANK(1:1)) THEN
                  CNAME(IB)(38:I4WK1+37) = CLEN(1:I4WK1)
               END IF
               IF(CNAME(IB)(37:37) .EQ. CBLANK(1:1)) THEN
                  CNAME(IB)(37:37) = CTYPED(1:1)
               END IF
            END IF
            GO TO 44
         ELSE
            CALL SETTL (CWORK)
            CLEN(1:7) = CWORK(38:44)
         END IF
         GO TO 44
      END IF
C
C         DETERMINE IF THE LENGTH OF A SINGLE VARIABLE IS INHERITED
C
      IF(CSTMT(J7:J7+2) .EQ. '(*)') THEN
         CLEN(1:3) = '(*)'
         CWORK(38:40) = '(*)'
         J8 = J7 + 3
         GO TO 44
      END IF
C
C         DETERMINE IF THE LENGTH SPECIFICATION FOR AN INDIVIDUAL
C         VARIABLE IS A SINGLE DIGIT
C
      IF(J7 .EQ. J8) THEN
         IF(CSTMT(J7:J7) .GE. C0 .AND. CSTMT(J7:J7) .LE. C9) THEN
            JD = J7
            LA = LTRUE
            IF(.NOT.L33) CALL NUMBER (CSTMT,LA,JD,II,FP,IFP)
            IF(.NOT.LA) THEN
               IF(.NOT.LINCL) THEN
                  WRITE (0,105) ISN,FP
                  IREC0 = IREC0 + 1
               END IF
               IF(.NOT.LINCL) CALL FCHECK
               II = FP
            END IF
            CALL INSERT (II)
            I4WK1 = 1
C
C         DETERMINE IF TYPE SPECIFIED IS CORRECT
C
            IF(CLEN(1:1) .EQ. C4 .AND. CTYPED(1:1) .EQ. CDD)
     1         CTYPED(1:1) = CRR
            GO TO 44
         END IF
      ELSE
         GO TO 44
      END IF
C
C         LOOP TO DETERMINE THE LENGTH SPECIFICATION THAT EXISTS FOR
C         THE INDIVIDUAL VARIABLE
C
      DO 43 IB = J7,J8
C
C         TEST FOR AN ASTERISK INDICATING THE START OF A LENGTH
C         DEFINITION FOR THE VARIABLE
C
      IF(CSTMT(IB:IB) .EQ. CASTER) THEN
         J7 = IB
         GO TO 42
      END IF
C
C         DETERMINE IF A DIGIT OCCURS NEXT, INDICATING A LENGTH
C         SPECIFICATION CONTINUES
C
      IF(L2 .AND. CSTMT(IB:IB) .GE. C0 .AND. CSTMT(IB:IB) .LE. C9)
     1   GO TO 42
C
C         WHEN A SLASH OCCURS OR A COMMA, THIS TERMINATES THE LENGTH
C         SPECIFICATION
C
      IF(CSTMT(IB:IB) .EQ. CSLASH .OR. CSTMT(IB:IB) .EQ. COMMA) THEN
         J8 = IB - 1
         J9 = IB
         L3 = LTRUE
         GO TO 43
      END IF
 42   CONTINUE
C
C         DETERMINE THE NUMERICAL LENGTH SPECIFICATION FOR A VARIABLE
C
 43   IF(CSTMT(J7:J7) .GE. C0 .AND. CSTMT(J7:J7) .LE. C9)
     1   JD = J7
      IF(CSTMT(J7:J7) .EQ. CASTER) THEN
         JD = J7 + 1
         J8 = JD
      END IF
      LA = LTRUE
      CALL NUMBER (CSTMT,LA,JD,II,FP,IFP)
      IF(.NOT.LA) THEN
         IF(.NOT.LINCL) THEN
            WRITE (0,105) ISN,FP
            IREC0 = IREC0 + 1
         END IF
         IF(.NOT.LINCL) CALL FCHECK
         II = FP
      END IF
      CALL INSERT (II)
C
C         VERIFY THE LENGTH FOR THE DECLARED DATA TYPE IS CORRECT
C
      IF(CLEN(1:1) .NE. CBLANK(1:1)) THEN
         IF(CTYPED .EQ. CAA) THEN
            IF(II .NE. 1 .AND. .NOT.LINCL) THEN
               WRITE (0,107) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
         IF(CTYPED .EQ. CBB) THEN
            IF(.NOT.(II .EQ. 8 .OR. II .EQ. 16) .AND. .NOT.LINCL) THEN
               WRITE (0,108) ISN
               IREC0 = IREC0 + 1
            END IF
            IF(II .EQ. 16) CTYPED(1:1) = CEE
         END IF
         IF(CTYPED .EQ. CDD) THEN
            IF(II .NE. 8 .AND. .NOT.LINCL) THEN
               WRITE (0,111) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
         IF(CTYPED .EQ. CEE) THEN
            IF(II .NE. 16 .AND. .NOT.LINCL) THEN
               WRITE (0,108) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
         IF(CTYPED .EQ. CII) THEN
            IF(.NOT.(II .EQ. 1 .OR. II .EQ. 2 .OR. II .EQ. 4) .AND.
     1         .NOT.LINCL) THEN
               WRITE (0,109) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
         IF(CTYPED .EQ. CLL) THEN
            IF(.NOT.(II .EQ. 1 .OR. II .EQ. 2 .OR. II .EQ. 4) .AND.
     1         .NOT.LINCL) THEN
               WRITE (0,110) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
         IF(CTYPED .EQ. CRR) THEN
            IF(.NOT.(II .EQ. 4 .OR. II .EQ. 8) .AND. .NOT.LINCL) THEN
               WRITE (0,111) ISN
               IREC0 = IREC0 + 1
            END IF
            IF(II .EQ. 8) CTYPED = CDD
         END IF
C
C         NO SPECIFIC LENGTH PROVIDED, SET THE LENGTH TO THE DEFAULT
C
      ELSE
         IF(CTYPED .EQ. CAA) CLEN(1:1) = C1
         IF(CTYPED .EQ. CBB) CLEN(1:1) = C8
         IF(CTYPED .EQ. CCC) CLEN(1:1) = C1
         IF(CTYPED .EQ. CDD) CLEN(1:1) = C8
         IF(CTYPED .EQ. CEE) CLEN(1:2) = C1//C6
         IF(CTYPED .EQ. CII) CLEN(1:1) = C4
         IF(CTYPED .EQ. CLL) CLEN(1:1) = C4
         IF(CTYPED .EQ. CRR) CLEN(1:1) = C4
      END IF
C
C         PLACE THE LENGTH SPECIFICATION IN THE CNAME ARRAY
C
      I4WK1 = J8 - J7 + 1
      CALL TABSRH (CNAME,INAME,52,1,32,CWK104,1,32,IRET,4000)
      IF(IRET .GT. 0 .AND. .NOT.BTEST(JBITS,20)) THEN
C        IF(BTEST(IENAME(12,IRET),9) .AND. (.NOT.BTEST(IENAME(12,IRET),
C    1      2) .OR. .NOT.BTEST(IENAME(12,IRET),5) .OR.
C    2      .NOT.BTEST(IENAME(12,IRET),6))) THEN
C           IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
C           IENAME(12,IRET) = IBSET(IENAME(12,IRET),10)
C           CWORK(37:44) = CNAME(IRET)(37:44)
C        END IF
         CNAME(IB)(37:I4WK1+37) = CWORK(37:I4WK1+37)
         CWK104(37:I4WK1+37) = CWORK(37:I4WK1+37)
      END IF
C
C         DETERMINE IF THE VARIABLE NAME HAS BEEN DIMENSIONED IN A
C         UNION OR STRUCTURE STATEMENT.
C
 44   IF(I4WK4 .NE. 0) THEN
C
C         OBTAIN THE NUMERICAL FORM OF THE LENGTH OF THE DIMENSIONED
C         VARIABLE
C
         LA = LTRUE
         CALL NUMBER (CLEN,LA,1,JLEN,FP,IFP)
         IF(.NOT.LREC) CALL INSERT (JLEN)
C
C         DETERMINE THE TOTAL MEMORY SIZE FOR THE VARIABLE WHEN IT IS
C         DIMENSIONED, AND IT OCCURS IN EITHER A STRUCTURE OR UNION
C         STATEMENT. THE LENGTH CHARACTERISTIC OF THE DIMENSIONED
C         VARIABLE MUST BE SUBTRACTED FROM THE STRUCTURE OR UNION LENGTH
C         SINCE IT HAS ALREADY BEEN ADDED TO THE LENGTH WHEN THE
C         VARIABLE NAME WAS PROCESSED IN SUBROUTINE CHKNME.
C
         JWORK = JWORK * JLEN - JLEN
C
C         PLACE THE TOTAL LENGTH IN THE UNION MAP COUNT IF A UNION IS
C         BEING PROCESSED
C
         IF(JUNION .GT. 0) THEN
C
C         OBTAIN THE MAP INDEX VALUE AND COUNT THE MAP LENGTH
C
            K5 = JMAP(JUNION)
            MAPLEN(JUNION,K5) = MAPLEN(JUNION,K5) + JWORK
            GO TO 45
         END IF
C
C         PLACE THE TOTAL LENGTH IN THE STRUCTURE COUNT IF A STRUCTURE
C         IS BEING PROCESSED
C
         IF(JSTRUC .GT. 0) THEN
C
C         COUNT THE TOTAL MEMORY LENGTH TOWARDS THE STRUCTURE LENGTH
C
            JSTR(JSTRUC) = JSTR(JSTRUC) + JWORK
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *                DATA DEFINITIONS PROCESSING                     *
C     *                                                                *
C     ******************************************************************
C
C         TEST IF DATA DEFINITIONS EXIST
C
 45   IF(.NOT.L4) GO TO 59
C
C         PROCESS DATA DEFINITIONS ENCAPSULATED BY SLASHES
C
C         DATA DEFINITIONS CONSIST OF FIXED OR FLOATING POINT NUMBERS,
C         LITERALS, HOLLERITH FIELD DEFINITIONS, HEXADECIMAL, LOGICAL,
C         OCTAL, AND BINARY NUMBERS. ASTERISKS, LEFT AND RIGHT PARENTH-
C         ESES, COMMAS, DECIMAL POINTS, AND PLUS OR MINUS SIGNS MAY
C         OCCUR WITHIN INDIVIDUAL DATA SPECIFICATION FIELDS. HOLLERITH,
C         LITERAL, AND LOGICAL CONSTANT FIELDS HAVE BEEN REMOVED FROM
C         THE FORTRAN STATEMENT IN SUBROUTINE COMPRS AND DO NOT OCCUR
C         AT THIS STAGE OF PROCESSING.
C
      I1 = 0
      I9 = 0
      I10 = J10
      IFP = 0
C
C         START LOOP TO LOCATE AND PROCESS ALL DATA SPECIFICATIONS IN
C         THE CURRENT STATEMENT. THIS LOOP IS FOR DATA GROUPS
C         ENCAPSULATED BY SLASHES.
C
      DO 58 IB = J9,J10
C
C         SEARCH TO LOCATE THE LEFT AND RIGHT SLASHES BOUNDING A SET
C         OF DATA SPECIFICATIONS FOR A SINGLE GROUP. THIS LOOP IS USED
C         PROCESS ALL DATA SPECIFICATION FIELDS BETWEEN THE BOUNDING
C         LEFT AND RIGHT SLASHES.
C
      JLOC1 = 0
      JLOC2 = 0
      DO 48 IA = J9,KB
      IF(CSTMT(IA:IA) .EQ. CSLASH) THEN
         IF(I1 .EQ. 0) THEN
            I1 = I1 + 1
            JLOC1 = IA                      ! LOCATION OF FIRST SLASH
         ELSE
            I1 = 0
            JLOC2 = IA                      ! LOCATION OF SECOND SLASH
            I7 = JLOC1 + 1                  ! PROCESSING START LOCATION
            GO TO 49
         END IF
      END IF
 48   CONTINUE
C
C         WHEN NO MATCHING BOUNDING SLASH EXISTS, WRITE ERROR MESSAGE
C
      IF(JLOC1 .GT. 0 .AND. JLOC2 .LT. 0) THEN
         WRITE (0,101) ISN,CSTMT(JLOC1-4:JLOC4+4)
         IREC0 = IREC0 + 1
         GO TO 59                           ! EXIT
      END IF
C
C         BEGIN PROCESSING THE INDIVIDUAL DATA SPECIFICATION FIELDS
C
C         ANY DATA SPECIFICATION FIELD MAY BE PRECEDED BY AN ASTERISK.
C         THIS INDICATES A REPEAT FACTOR EXISTS FOR THIS FIELD.
C
C     ******************************************************************
C     *                                                                *
C     *   LITERAL OR LOGICAL CONSTANTS                                 *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF THE FIELD IS A LITERAL OR A LOGICAL CONSTANT.
C         THE FIELD IS SKIPPED. ONLY A COMMA OR A SLASH TERMINATES A
C         DATA FIELD. ANY OTHER CHARACTER IS A STNTAX ERROR. LITERALS
C         AND LOGICAL CONSTANTS ARE REMOVED FROM THE FORTRAN STATEMENT
C         IN SUBROUTINE COMPRS.
C
 49   IF(CSTMT(I7:I7) .EQ. CSYMCF .OR. CSTMT(I7:I7) .EQ. CSYMCD) THEN
         IF(CSTMT(I7+1:I7+1) .EQ. CSLASH) THEN
            IF(CSTMT(I7+2:I7+2) .EQ. COMMA) THEN
               J9 = I7 + 3                  ! PROCESS THE NEXT GROUP
               GO TO 59
            ELSE
C
C         A COMMA DOES NOT FOLLOW THE ENDING SLASH OF A DATA FIELD.
C         DETERMINE IF THE SLASH IS THE END OF THE STATEMENT.
C
               IF(I7+1 .EQ. KB) THEN
                  GO TO 59                  ! EXIT
               ELSE
                  WRITE (0,117) ISN,CSTMT(I7-4:I7+4)
                  IRET = IRET + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
         ELSE
C
C         A SLASH DOES NOT FOLLOW THE LITERAL OR LOGICAL CONSTANT. THE
C         CHARACTER MUST BE A COMMA.
C
            IF(CSTMT(I7+1:I7+1) .EQ. COMMA) THEN
C
C         ANOTHER DATA FIELD FOLLOWS. SET THE START LOCATION.
C
               I7 = I7 + 2                  ! PROCESS THE NEXT FIELD
               GO TO 49
            ELSE
               WRITE (0,117) ISN,CSTMT(I7-4:I7+4)
               IREC0 = IREC0 + 1
               GO TO 59                     ! EXIT
            END IF
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   BINARY, HEXADECIMAL, OR OCTAL CONSTANTS                      *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF A HEXADECIMAL, OCTAL, OR BINARY DATA CONSTANT.
C         THIS CASE PRESUMES THE START OF THE FIELD IS B, O,OR Z. THE
C         DATA IS OF THE FORM: Z1234, O123, OR B110011001100. THESE
C         DATA SPECIFICATIONS ARE TREATED AS LITERALS AND ARE WRITTEN
C         ON UNIT 9.
C
C         THE DATA FORMS: 1234Z, 123O, AND 110011001100B ARE NOT
C         LEGAL SYNTAX; HOWEVER, '1234'Z, '123'O, AND '110011001100'B
C         ARE LEGAL SYNTAX, BUT THEY ARE PROCESSED IN SUBROUTINE COMPRS.
C
      IF(CSTMT(I7:I7) .EQ. CZZ .OR. CSTMT(I7:I7) .EQ. COO .OR.
     1   CSTMT(I7:I7) .EQ. CBB) THEN
C
C         INITIALIZE THE WORK BUFFER TO USED TO CREATE AN OUTPUT
C         RECORD FOR UNIT 9
C
         CLITWK(1:50) = CBLK52(1:50)
         CLITWK(51:80) = CBLK52(1:30)
C
C         SEARCH TO LOCATE THE END OF THE FIELD. ONLY A COMMA OR A
C         SLASH MAY TERMINATE THIS FIELD. A RIGHT PARENTHESIS CAN NOT
C         TERMINATE THESE TYPES OF FIELDS.
C
         JLOC3 = I7                         ! LOCATION OF FIELD START
         DO 50 I3 = I7,KB
         IF(CSTMT(I3:I3) .EQ. COMMA .OR. CSTMT(I3:I3) .EQ. CSLASH) THEN
            JLOC4 = I3 - 1                  ! LOCATION OF FIELD END
            GO TO 51
         END IF
 50      CONTINUE
C
C         NO SLASH OR COMMA TERMINATES THIS FIELD
C
         WRITE (0,117) ISN,CSTMT(KB-4:KB+4)
         IREC0 = IREC0 + 1
         GO TO 59                           ! EXIT
C
C         CREATE THE B, O, OR Z FIELD IN CLITWK TO WRITE ON UNIT 9
C
 51      ILOC1 = JLOC4 - JLOC3 + 1          ! DATA FIELD LENGTH
         CLITWK(1:ILOC1) = CSTMT(JLOC3:JLOC4)  ! DATA FIELD CONTENTS
         ILOC1 = ILOC1 + 128
         ILOC2 = ISN + 128                  ! ISN
         ILOC3 = 0                          ! NOT A CALL STATEMENT
         IF(.NOT.LINCL) THEN
            ILIT = ILIT + 1                    ! RECORD COUNT
            WRITE (9,REC=ILIT) CLITWK(1:92)
         END IF
C
C         DETERMINE IF A SLASH FOLLOWS THE END OF THE FIELD. THIS
C         TERMINATES THE DATA SPECIFICATION FOR THE CURRENT DATA GROUP.
C
         IF(CSTMT(JLOC4+1:JLOC4+1) .EQ. CSLASH) THEN
C
C         DETERMINE IF THE END OF THE STATEMENT
C
            IF(JLOC4+1 .EQ. KB) GO TO 59    ! EXIT
C
C         DETERMINE IF A COMMA FOLLOWS THE SLASH
C
            IF(CSTMT(JLOC4+2:JLOC4+2) .EQ. COMMA) THEN
               J9 = JLOC4 + 3               ! NEXT GROUP
               GO TO 59
            ELSE
               WRITE (0,117) ISN,CSTMT(JLOC4-4:JLOC4+4)
               IREC0 = IREC0 + 1
               GO TO 59                     ! EXIT
            END IF
         ELSE
C
C         THE SLASH IS NOT THE END OF THE FIELD, A COMMA TERMINATES THE
C         FIELD. SETUP FOR THE NEXT DATA FIELD.
C
            IF(CSTMT(JLOC4+1:JLOC4+1) .NE. COMMA) THEN
               WRITE (0,117) ISN,CSTMT(JLOC4-4:JLOC4+4)
               IREC0 = IREC0 + 1
               GO TO 59                     ! EXIT
            END IF
            I7 = JLOC4 + 2
            GO TO 49                        ! NEXT FIELD
         END IF
      END IF
C
C         INITIALIZE THE LOCATION VALUES OF THE NON-NUMERIC CHARACTERS
C         IN A NUMERIC DATA FIELD
C
      JLOC5 = 0
      JLOC6 = 0
      JLOC8 = 0
      JLOC9 = 0
      JLOC10 = 0
      JLOC11 = 0
      JLOC12 = 0
      JLOC14 = 0
      JLOC15 = 0
      JLOC16 = 0
      JLOC17 = 0
C
C     ******************************************************************
C     *                                                                *
C     *   COMPLEX NUMBER                                               *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF A LEFT PARENTHESIS STARTS THE FIELD INDICATING
C         THIS IS A COMPLEX NUMBER DATA SPECIFICATION FIELD.
C
      IF(CSTMT(I7:I7) .EQ. CLPAR) THEN
C
C         DETERMINE THE LOCATION OF THE CLOSING RIGHT PARENTHESIS
C
         JLOC10 = I7
         DO 52 I3 = JLOC10+1,KB
         IF(CSTMT(I3:I3) .EQ. CRPAR) THEN
            JLOC11 = I3 - 1
            IF(JLOC12 .EQ. 0) THEN
               WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
               IREC0 = IREC0 + 1
               GO TO 59                     ! EXIT
            END IF
            I7 = JLOC10 + 1                 ! START OF THE NUMBER FIELD
            GO TO 53
         ELSE IF(CSTMT(I3:I3) .EQ. COMMA) THEN
            JLOC12 = I3
         END IF
 52      CONTINUE
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   INTEGER OR REAL NUMBERS                                      *
C     *                                                                *
C     ******************************************************************
C
 53   JLOC3 = 0
      JLOC4 = 0
      JLOC5 = 0
      JLOC6 = 0
      JLOC8 = 0
      JLOC9 = 0
      JLOC14 = 0
      JLOC15 = 0
      JLOC16 = 0
C
C         DETERMINE IF THIS IS A NUMERIC VALUE FIELD. THE FIELD MAY
C         START WITH A NUMERICAL DIGIT, A PLUS SIGN, A MINUS SIGN, OR
C         A DECIMAL POINT.
C
      IF((CSTMT(I7:I7) .GE. C0 .AND. CSTMT(I7:I7) .LE. C9) .OR.
     1   CSTMT(I7:I7) .EQ. CPLUS .OR. CSTMT(I7:I7) .EQ. CMINUS .OR.
     2   CSTMT(I7:I7) .EQ. CDOT) THEN
C
C         SEARCH TO LOCATE THE END OF THE FIELD. ONLY A COMMA, A SLASH,
C         A RIGHT PARENTHESIS (IF A COMPLEX NUMBER), OR AN ASTERISK MAY
C         TERMINATE THIS FIELD.
C
         JLOC3 = I7
         JLOC16 = 0
         DO 54 I3 = I7,KB
C
C         WHEN AN ASTERISK IS FOUND, THE CHARACTERS FROM THE CHARACTER
C         AT THE LOCATION SPECIFIED BY I7 TO THE CHARACTER IMMEDIATELY
C         BEFORE THE ASTERISK IS THE REPEAT FACTOR NUMBER. ONLY
C         NUMERICAL DIGITS MAY OCCUR WITHIN THIS LOCATION RANGE. A
C         REPEAT FACTOR CAN NOT USE PARENTHESES TO REPEAT MULTIPLE
C         DATA FIELDS. SYNTAX SUCH AS  5*(1.,2.) IS ILLEGAL.
C
         IF(CSTMT(I3:I3) .EQ. CASTER) THEN
            CALL NUMBER (CSTMT,LTRUE,I7,II,FP,IFP)
            CALL INSERT (II)
            I7 = I3 + 1
            JLOC17 = I3
            GO TO 49                        ! CONTINUE FOR DATA FIELD
         END IF
C
C         DETERMINE THE END OF THE NUMERICAL FIELD
C
         IF(CSTMT(I3:I3) .EQ. COMMA .OR. CSTMT(I3:I3) .EQ. CSLASH .OR.
     1      (JLOC11 .GT. 0 .AND. CSTMT(I3:I3) .EQ. CRPAR)) THEN
            JLOC4 = I3 - 1
            GO TO 55
         END IF
 54      CONTINUE
C
C         DETERMINE IF THE NUMERIC FIELD DETERMINES AN INTEGER, OR A
C         FLOATING POINT NUMBER VALUE.
C
C         DETERMINE IF THE FIRST CHARACTER OF THE FIELD IS NUMERIC, A
C         DECIMAL POINT, A PLUS SIGN, OR A MINUS SIGN. THE FIELD MAY
C         SEPCIFY AN INTEGER, REAL, OR A REAL NUMBER IN SCIENTIFIC
C         NOTATION.  AN ASTERISK MAY NOT OCCUR WITHIN THE REMAINDER OF
C         NUMERIC DATA FIELD.
C
 55      IF((CSTMT(I7:I7) .GE. C0 .AND. CSTMT(I7:I7) .LE. C9) .OR.
     1      CSTMT(I7:I7) .EQ. CDOT .OR. CSTMT(I7:I7) .EQ. CPLUS .OR.
     2      CSTMT(I7:I7) .EQ. CMINUS) THEN
C
C         LOOP TO LOCATE A POSSIBLE DECIMAL POINT, AN E, OR A D WITHIN
C         THE DATA FIELD
C
            DO 56 I3 = I7,KB
C
C         DETERMINE IF THE FIELD CONTAINS A DECIMAL POINT
C
            IF(CSTMT(I3:I3) .EQ. CDOT) THEN
               IF(JLOC16 .EQ. 0 ) THEN
                  JLOC16 = I3
                  GO TO 56
               ELSE
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
C
C         DETERMINE IF THE FIELD CONTAINS THE CHARACTER E
C
            IF(CSTMT(I3:I3) .EQ. CEE) THEN
               IF(JLOC14 .EQ. 0) THEN
                  JLOC14 = I3
                  GO TO 56
               ELSE
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
C
C         DETERMINE IF THE FIELD CONTAINS THE CHARACTER D
C
            IF(CSTMT(I3:I3) .EQ. CDD) THEN
               IF(JLOC15 .EQ. 0) THEN
                  JLOC15 = I3
                  GO TO 56
               ELSE
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
C
C         DETERMINE IF THE FIELD IS A PLUS SIGN
C
            IF(CSTMT(I3:I3) .EQ. CPLUS) THEN
               IF(JLOC5 .EQ. 0) THEN
                  JLOC5 = I3                ! FIRST PLUS SIGN
                  GO TO 56
               ELSE IF(JLOC5 .GT. 0 .AND. JLOC6 .EQ. 0) THEN
                  JLOC6 = I3                ! SECOND PLUS SIGN
                  GO TO 56
               ELSE IF(JLOC5 .GT. 0 .AND. JLOC6 .GT. 0) THEN
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
C
C         DETERMINE IF THE FIELD IS A MINUS SIGN
C
            IF(CSTMT(I3:I3) .EQ. CMINUS) THEN
               IF(JLOC8 .EQ. 0) THEN
                  JLOC8 = I3                ! FIRST MINUS SIGN
                  GO TO 56
               ELSE IF(JLOC8 .NE. 0) THEN
                  JLOC9 = I3                ! SECOND MINUS SIGN
                  GO TO 56
               ELSE IF(JLOC8 .GT. 0 .AND. JLOC9 .GT. 0) THEN
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
            END IF
C
C         WHEN A COMMA OCCURS, IT WILL TERMINATE THE NUMERIC
C         FIELD
C
            IF(CSTMT(I3:I3) .EQ. COMMA) GO TO 57
C
C         WHEN A SLASH OCCURS, IT WILL TERMINATE THE NUMERIC FIELD AND
C         THE DATA GROUP.
C
            IF(CSTMT(I3:I3) .EQ. CSLASH) GO TO 57
C
C         WHEN A RIGHT PARENTHESIS OCCURS. IT WILL TERMINATE A COMPLEX
C         NUMBER SPEFICICATION.
C
            IF(CSTMT(I3:I3) .EQ. CRPAR .AND. I3 .EQ. JLOC11) GO TO 57
C
C         WHEN A COMMA OR SLASH OCCURS, THIS IS THE END OF THE DATA
C         FIELD
C
            IF(CSTMT(I3:I3) .EQ. COMMA .OR. CSTMT(I3:I3) .EQ. CSLASH)
     1         GO TO 57
 56         CONTINUE
C
C         DETERMINE THE NUMBER TYPE AND CATALOG IT IN ITS SAVE ARRAY
C
 57         IF(JLOC14 .EQ. 0 .AND. JLOC15 .EQ. 0 .AND. JLOC16 .EQ. 0)
     1         THEN
C
C         THIS IS AN INTEGER NUMBER
C
               IFP = 0
               IF(.NOT.LINCL) THEN
                  CALL NUMBER (CSTMT,LTRUE,I7,II,FP,IFP)
                  CALL INSERT (II)
               END IF
            END IF
C
C         DETERMINE IF THIS IS A REAL NUMBER
C
            IF(JLOC14 .NE. 0 .OR. JLOC15 .NE. 0 .OR. JLOC16 .NE. 0) THEN
               IF(.NOT.LINCL) THEN
                  CALL NUMBER (CSTMT,LFALSE,I7,II,FP,IFP)
                  CALL FCHECK
               END IF
            END IF
C
C         DETERMINE IF A COMPLEX NUMBER SPECIFICATION IS TO PROCESS
C         THE IMAGINARY PART
C
            IF(JLOC10 .GT. 0 .AND. I7 .GT. JLOC10 .AND. I7 .LT. JLOC11)
     1         THEN
               I7 = JLOC12 + 1
               JLOC14 = 0
               JLOC15 = 0
               JLOC16 = 0
C
C         DETERMINE IF A RIGHT PARENTHESIS FOLLOWS THE LAST DIGIT OF
C         JUST PROCESSSED NUMBER.
C
               IF(CSTMT(JLOC11+1:JLOC11+1) .EQ. CRPAR) THEN
                  CONTINUE
               ELSE
                  GO TO 55
               END IF
            END IF
C
C         DETERMINE IF THE END OF A NUMERIC FIELD
C
            IF(JLOC11 .GT. 0) THEN
C
C         DETERMINE IF THE END OF THIS FIELD IS THE END OF A COMPLEX
C         NUMBER SPECIFICATION
C
               IF(CSTMT(JLOC11+1:JLOC11+1) .EQ. COMMA) THEN
                  I7 = JLOC11 + 1           ! NEXT FIELD
               ELSE IF(CSTMT(JLOC11+1:JLOC11+1) .EQ. CRPAR) THEN
                       IF(CSTMT(JLOC11+2:JLOC11+3) .EQ. '/ ') THEN
                          I7 = JLOC11 + 4
                          GO TO 59
                       END IF
                       IF(CSTMT(JLOC11+2:JLOC11+3) .EQ. '/,') THEN
                          I7 = JLOC11 + 4
                          GO TO 59
                       END IF
               ELSE IF(CSTMT(JLOC11+1:JLOC11+1) .EQ. CSLASH) THEN
                  IF(JLOC11 .EQ. KB) GO TO 59      ! EXIT
                  J9 = JLOC11 + 2           ! NEXT GROUP
                  GO TO 59
               ELSE
                  WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                  IREC0 = IREC0 + 1
                  GO TO 59                  ! EXIT
               END IF
               GO TO 53
            ELSE
C
C         THE NUMERICAL FIELD IS NOT PART OF A COMPLEX NUMBER
C
C     IF(ISN .EQ. 100)
C    1WRITE(13,948) JLOC11,CSTMT(IFP+1:IFP+1),IFP
C948  FORMAT(' TRACE 948 TYPLST  JLOC11 = ',I4,2X,'CSTMT(IFP+1:IFP+1+5)
C    1= ',A6/5X,'IFP = ',I4)
               IF(IFP .GT. 0) THEN
                  IF(CSTMT(IFP+1:IFP+1) .EQ. COMMA) THEN
                     I7 = IFP + 2           ! NEXT FIELD
                  ELSE IF(CSTMT(IFP+1:IFP+1) .EQ. CSLASH) THEN
                     IF(IFP+1 .EQ. KB) GO TO 59      ! EXIT
                     J9 = IFP + 2
                     GO TO 59               ! NEXT GROUP
                  ELSE
                     WRITE (0,117) ISN,CSTMT(I3-4:I3+4)
                     IREC0 = IREC0 + 1
                     GO TO 59               ! EXIT
                  END IF
               END IF
               GO TO 53
            END IF
         END IF
      END IF
  58  CONTINUE
C
C         CLEAR LENGTH SPECIFICATION FOR THE NEXT VARIABLE
C
 59   IF(CLEN(1:3) .EQ. '(*)' .OR. L3 .OR. L30) THEN
         CLEN(1:7) = CLENSV(1:7)
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         L17 = LFALSE
      END IF
C
C         ROUTINE EXIT
C
      L27 = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES ARITHMETIC, LOGICAL, CHARACTER
C        EXPRESSIONS, ARITHMETIC ASSIGNMENT STATMENTS, LOGICAL
C        ASSIGNMENT STATEMENTS, AND CHARACTER ASSIGNMENT STATEMENTS.
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARACTER: A
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES.
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32. THE
C                                  WORD LENGTH IS IN COLS. 38-44 IN
C                                  ARRAY CNAME.
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CDOL   - CHARACTER VARIABLE, A DOLLAR SIGN: $
C         CDOT   - CHARACTER VARIABLE, A PERIOD: .
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CEXVAR - CHARACTER STATEMENT, LIST OF ALL VARIABLE NAMES
C                  OCCURRING IN AN ARITHMETIC ASSIGNMENT STATEMENT OR IN
C                  AN EXPRESSION
C                  TOTAL LENGTH IS 60 CHARACTERS
C                  RECORD STRUCTURE:
C                  COLS  TYPE WORD CONTENT
C                   1-32 A*32   8  VARIABLE NAME
C                  33-36 I*4    9  ISN VALUE + 128
C                  37-44 A*8   11  DATA TYPE & LENGTH
C                  45-48 I*4   12  BIT SWITCHES
C                  49-52 I*4   13  LENGTH OF VARIABLE NAME ON COLS 1-32
C                  53-56 I*4   14  VARIABLE'S FIRST CHARACTER LOCATION
C                  57-60 I*4   15  VARIABLE'S LAST CHARACTER LOCATION
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS: (
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. THIS TABLE DOES NOT CONTAIN THE LIST OF
C                  VARIABLE NAMES BELONGING TO THE COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 4000
C                  PARAMETER STATEMENTS ALLOWED.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  ISN VALUE
C                  37-44  A*8   11  DATA TYPE & LENGTH
C                  45-48  I*4   12  NUMERIC VALUE OF INTEGER VARIABLES
C                                   ONLY. OTHER DATA TYPES LEAVE THIS
C                                   FIELD BLANK
C                  49-52  I*4   13  LENGTH OF THE VARIABLE NAME IN
C                                   COLS 1 - 32
C         CPERC  - CHARACTER VARIABLE, THE CHARACTER: %
C         CQUES  - CHARACTER VARIABLE, THE CHARACTER: ?
C         CRECTB - CHARACTER VARIABLE, A TABLE OF ALL VARIABLES NAMES
C                  DEFINED BY A RECORD STATEMENT. A MAXIMUM OF 1000
C                  RECORD VARIABLE NAME DEFINITIONS ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME DEFINITION REFERRED
C                                   TO BY THE RECORD STATEMENT
C                 33 - 64 A*32  16  RECORD VARIABLE NAME USING THE
C                                   TEMPLATE OF THE STRUCTURE NAME IN
C                                   COLS. 1 - 32
C                 64 - 68 I*4   17  INTEGER VALUE OF THE RECORD DERIVED
C                                   FROM THE STRUCTURE NAME IN COLS.1-32
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS: )
C         CSTMTA - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSUBTB - CHARACTER VARIABLE, TABLE OF ALL ENTRY, FUNCTION, AND
C                  SUBPROGRAMS IN THE ENTIRE CURRENT PROGRAM.
C                  RECORD STRUCTURE
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZERO)
C                  37-44  11   TYPE AND LENGTH CHARACTERISTICS
C                  45=48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS IN COLS 1-32
C                  53-56  14   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _
C         CUNION - CHARACTER VARIABLE, TABLE OF ALL VARIABLE NAMES
C                  USED WITN A UNION. A MAXIMUM OF 500 RE ALLOWED.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED WITHIN A UNION
C                     33 A*1       DATA TYPE CODE OF VARIABLE
C                  34-40 A*7    10 VARIABLE LENGTH CHARACTERISTIC
C                  41-44 I*4    11 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C         CVARST - CHARACTER VARIABLE, CONTAINS THE NAME OF ALL
C                  VARIABLES DEFINED WITHIN STRUCTURES IN THE
C                  CURRENT MODULE.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED IN THE CURRENT
C                                  STRUCTURE
C                  33-64 A*32   16 NAME OF THE STRUCTURE DEFINING THE
C                                  VARIABLE IN COLS 1-32
C                     65 A*1       DATA TYPE CODE OF THE VARIABLE IN
C                                  COLS 1-32
C                  66-72 A*7    18 LENGTH DEFINITION OF THE VARIABLE IN
C                                  COLS 1-32
C         CWK7   - CHARACTER VARIABLE, WORK AREA TO CONVERT AN INTEGER
C                  TO A TEXT FORMAT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER: Z
C         C0     - CHARACTER VARIABLE, A ZERO CHARACTER
C         C9     - CHARACTER VARIABLE, A NINE CHARACTER
C         FP     - FLOATING POINT VALUE RETURNED FROM ROUTINE NUMBER
C         FPP    - SAVE AREA FOR THE VALUE OF FP UPON ENTERING THIS
C                  SUBPROGRAM
C         FUNTBL - A TABLE OF STANDARD FORTRAN INTRINSIC FUNCTIONS
C                  COLS  1-32 THE FUNCTION NAME
C                  COLS 33-35 THE TYPE AND LENGTH OF FUNCTION'S RETURN
C                             VALUE AS NUMERIC CHARACTERS. A # IN COLUMN
C                             34 INDICATES THE LENGTH IS DEPENDENT UPON
C                             ARGUMENTS OF THE FUNCTION.
C
C                  TYPE CODES USED ARE:
C
C                  B - SINGLE PRECISION COMPLEX
C                  C - CHARACTER
C                  D - DOUBLE PRECISION REAL
C                  E - DOUBLE PRECISION COMPLEX
C                  I - INTEGER (ALL LENGTHS)
C                  L - LOGICAL (ALL LENGTHS)
C                  R - SINGLE PRECISION REAL
C         ICOMKT - COUNT OF ENTRIES IN COMTBL, A LIST OF ALL COMMON
C                  BLOCK NAMES
C         IEQ    - LOCATION OF THE EQUAL SIGN FOR AN ARITHMETIC
C                  STATEMENT. SET TO ZERO IF NO EQUAL SIGN EXISTS
C         IEXVAR - EQUIVALENCED TO CEXVAR
C         IFP    - THE LOCATION OF A THE END OF A NUMBER IN SCIENTIFIC
C                  NOTATION
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IOPENP - COUNTER USED TO DETERMINE MATCHING LEFT AND RIGHT
C                  PARENTHESES. WHEN > 0, MATCH HAS NOT BEEN FOUND
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINTIONS
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IREC11 - COUNT OF THE NUMBER OF COMMON VARIABLE NAMES ON UNIT
C                  11
C         IRET   - RETURN CODE FROM A TABLE SEARCH
C         IRET1  - RETURN CODE FROM A TABLE SEARCH
C         IRET2  - RETURN CODE FROM A TABLE SEARCH
C         IRET3  - RETURN CODE FROM A TABLE SEARCH
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISUBTB - COUNT OF THE NUMBER OF ENTRIES IN CSUBTB TABLE
C         IUNION - COUNT OF THE NUMBER OF ENTRIES IN CUNION TABLE
C         IVARKT - COUNT OF THE NUMBER OF ENTRIES IN ARRAY CEXVAR
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         I3     - WORK AREA
C         I4     - WORK AREA
C         I4WK1  - DO LOOP START VALUE
C         I5     - WORK AREA
C         I6     - WORK AREA
C         I7     - WORK AREA, SUBSCRIPT VARIABLE
C         JDIM   - COUNT OF THE NUMBER OF ENTRIES IN TABLE CDIM
C         JFINAL - SAVE LOCATION OF THE FINAL CHARACTER IN AN ASSIGNMENT
C                  STATEMENT OR AN EXPRESSION
C         JSUBTB - EQUIVALENCED TO CSUBTB
C         J1     - START LOCATION OF AN ARITHMETIC ASSIGNMENT STATEMENT
C                  OR OF AN EXPRESSION
C         J2     - END LOCATION OF AN ARITHMETIC ASSIGNMENT STATEMENT
C                  OR OF AN EXPRESSION
C         JFINAL - SAVE LOCATION OF THE FINAL CHARACTER IN THE COMPLETE
C                  FORTRAN STATEMENT OR AN EXPRESSION
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  BEING PROCESSED, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE TO PREVENT CHANGING THE
C                  LOCATION OF THE FIRST CHARACTER OF A VARIABLE NAME.
C         L2     - LOGICAL VARIABLE, SET TRUE FOR AN INTEGER NUMBER,
C                  SET FALSE FOR A FLOATING POINT NUMBER.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN EXPRESSION IS AN
C                  ARGUMENT, SET FALSE IF AN ARITHMETIC, LOGICAL, OR
C                  CHARACTER ASSIGNMENT STATEMENT.
C         NVARST - COUNT OF THE NUMBER OF ENTRIES IN TABLE CVARST
C
C     COMMENTS
C
C         UPON ENTRY TO THIS PROGRAM, ALL DECLARED VARIABLES HAVE BEEN
C         PLACED IN ARRAY CNAME. AN UNDECLARED VARIABLE MUST BE USED
C         TO THE LEFT OF THE EQUAL SIGN IN AN ARITHMETIC ASSIGNMENT
C         STATEMENT. ITS USE IS ILLEGAL TO THE RIGHT OF THE EQUAL SIGN.
C         ITS USE DECLARES THE VARIABLE NAME AND ITS TYPE AND LENGTH
C         ARE TAKEN FROM TABLE CIMP, THE DEFAULT SETTINGS FOR ALL
C         VARIABLE NAMES NOT DECLARED PRIOR TO THE FIRST EXECUTABLE
C         STATEMENT.
C
C         THERE ARE THREE TYPES OF EXPRESSIONS: ARITHMETIC, LOGICAL,
C         OR CHARACTER. AN ASSIGNMENT STATEMENT CONTAINS A VARIABLE
C         NAME FOLLOWED BY AN EQUAL SIGN, EITHER AN ARITHMETIC,
C         LOGICAL, OR CHARACTER EXPRESSION FOLLOWS. THE ARGUMENT OF AN
C         IF STATEMENT MAY CONTAIN A MIXED LOGICAL AND ARITHMETIC
C         EXPRESSION.
C
C         ALL LOGICAL OPERATORS SUCH AS: .NOT., .AND., .OR., ETC. ARE
C         REMOVED FROM ANY STATEMENT IN WHICH THEY OCCUR AND ARE
C         REPLACED WITH THE HEX NUMBER: CD. CONSEQUENTLY, ONLY VARIABLE
C         NAMES, ARITHMETIC OPERATORS, COMMAS, COLONS, DIGITS, DECIMAL
C         POINTS, PERCENT SIGNS, 'CD'X, 'CF'X (FOR LITERALS), AND BOTH
C         LEFT AND RIGHT PARENTHESES CAN EXIST WHEN THIS ROUTINE BEGINS
C         PROCESSING. ALL VARIABLE DEFINITION STATEMENTS PRECEDING
C         THE FIRST EXECUTABLE STATEMENT HAVE ALREADY BEEN PROCESSED;
C         THE ONLY UNDEFINED VARIABLE NAME THAT CAN OCCUR MUST BE TO
C         THE LEFT OF AN EQUAL SIGN.
C
C         THIS ROUTINE DOES NOT EVALUATE EXPRESSIONS FOR ANY
C         COMPUTATIONAL RESULTS. IT ONLY DETERMINES THE VARIABLE NAMES
C         AND NUMERICAL CONSTANTS EXISTING IN A MATHEMATICAL, LOGICAL,
C         OR CHARACTER EXPRESSION. ROUTINE EVALU PERFORMS EXPRESSION
C         EVALUATION, AND IT IS USED ONLY FOR THE PARAMETER STATEMENT
C         AND STATEMENTS THAT HAVE LENGTH SPECIFICTIONS, DIMENSION
C         SPECIFICATIONS, ETC. PRIOR THE FIRST EXECUTABLE STATEMENT.
C
C         DIMENSIONED CHARACTER VARIABLES MAY HAVE SUBSCRIPTS IF THEY
C         ARE DIMENSIONED AND CHARACTER RANGE SPECIFICATIONS IN ANY
C         EXPRESSION. CHARACTER ARRAY RANGE SPECIFICATIONS MUST ALWAYS
C         FOLLOW ANY SUBSCRIPT SPECIFICATIONS. ANY CHARACTER VARIABLE
C         MAY USE CHARACTER RANGE SPECIFICATIONS, BUT ONLY DIMENSIONED
C         CHARACTER VARIABLES MAY HAVE SUBSCRIPTS.
C
C         ONLY A DEFINED OR INTRINSIC FUNCTION MAY OCCUR IN ANY
C         ARITHMETIC ASSIGNMENT STATEMENT OR EXPRESSION.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         ARGLST BTEST CHKNME FCHECK INSERT ITOC NUMBER TABSRH
C
C     *****************************************************************
C
      SUBROUTINE EXPR (J1,J2,L3,CSTMTA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(1,200), NFLOC(30)
      DIMENSION CEXVAR(50), IEXVAR(15,50), JRECTB(17,1000)
      DIMENSION CMACRO(25)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*61    CF101
      CHARACTER*60    CEXVAR
      CHARACTER*59    CF100
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION, CWK44
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32, CMACRO
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP, FPP
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, LFUNC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 L1, L2, L3
C
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      COMMON /PMACRO/ CMACRO
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(49:52),
     1IVCNT), (CWORK(45:48),JBITS), (CNAME,IENAME), (CWK8(2:2),CWK7),
     2(CRECTB,JRECTB), (I4WK1,CI4WK1)
      EQUIVALENCE (CEXVAR,IEXVAR), (CSUBTB,JSUBTB)
C
C         DATA STATEMENTS
C
      DATA CF100 /'('' ISN:'',I6,'' DIMENSIONED VARIABLE LACKS SUBSCRIPT
     1S: '',A32)'/
      DATA CF101 /'('' ISN:'',I6,'' SUBSCRIPTED VARIABLE IS NOT DIMENSIO
     1NED: '',A32)'/
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' EXPRESSION INVALID')
 101  FORMAT(' ISN:',I6,' MORE THAN 50 VARIABLES IN AN EXPRESSION')
 102  FORMAT(' ISN:',I6,' ILLEGAL USE OF A RECORD VARIABLE: ',A32)
 103  FORMAT(' ISN:',I6,' NONDEFINED VARIABLE USED ILLEGALLY: ',A32)
 104  FORMAT(' ISN:',I6,' VARIABLE DEFINED WITHIN A STRUCTURE IS DIMENSI
     1ONED: ',A32)
C
C         INITIALIZATION
C
      LFUNC = LFALSE
      I3 = 0
      IEQ = 0
      IVARKT = 0
      I4WK1 = J1
      JFINAL = J2
      KFINAL = KB
      DO 10 I1 = 1,50
      CEXVAR(I1)(1:60) = CBLK52(1:50)//CBLK52(1:10)
      IEXVAR(12,I1) = 0
      IEXVAR(13,I1) = 0
      IEXVAR(14,I1) = 0
      IEXVAR(15,I1) = 0
 10   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *            VARIABLE NAME PROCESSING                            *
C     *                                                                *
C     ******************************************************************
C
C
C         THIS DO LOOP WILL IDENTIFY ALL VARIABLE NAMES OCCURRING
C         IN THE ARITHMETIC ASSIGNMENT STATEMENT OR THE EXPRESSION
C         AND CREATE AN ENTRY IN TABLE CEXVAR.
C
 11   L1 = LFALSE
      DO 13 I1 = I4WK1,J2
C
C         SAVE THE LOCATION OF AN EQUAL SIGN WHEN THIS IS AN ARITHMETIC
C         ASSIGNMENT STATEMENT. EXPRESSIONS MAY NOT CONTAIN AN EQUAL
C         SIGN EXCEPT WITHIN A LITERAL.
C
      IF(L3 .AND. CSTMT(I1:I1) .EQ. CEQ) IEQ = I1 ! EQUAL SIGN LOCATION
C
C         LOCATE THE FIRST CHARACTER OF A VARIABLE NAME
C
      IF(CSTMTA(I1:I1) .GE. CAA .AND. CSTMTA(I1:I1) .LE. CZZ .OR.
     1   CSTMTA(I1:I1) .EQ. CUNDER) THEN
C
C         LOCATION OF THE CHARACTER BEFORE THE CURRENT CHARACTER
C
         I6 = I1 - 1
C
C         LOCATION OF THE CHARACTER AFTER THE CURRENT CHARACTER
C
         I5 = I6 + 1
C
C         DETERMINE IF THE CURRENT CHARACTER IS A D OR AN E. THEY MAY
C         BE PART OF A FLOATING POINT NUMBER.
C
         IF(CSTMTA(I1:I1) .EQ. CDD .OR. CSTMTA(I1:I1) .EQ. CEE) THEN
C
C         WHEN THE D OR E IS THE FIRST CHARACTER OF THE STATEMENT, THEY
C         ARE PART OF A VARIABLE NAME.
C
            IF(I1 .EQ. I4WK1) THEN
               GO TO 111
C
C         WHEN THE D OR E IS THE LAST CHARACTER OF THE STATEMENT, THEY
C         ARE PART OF A VARIABLE NAME.
C
            ELSE IF(I1 .EQ. J2) THEN
               GO TO 111
C
C         WHEN THE PRIOR CHARACTER TO THE D OR E IS ALPHABETIC, AN
C         UNDERSCORE, A PLUS SIGN, A MINUS SIGN, AN ASTERISK, A SLASH,
C         A LEFT PARENTHESIS, A COLON, OR A LOGICAL OPERATOR: THE D OR
C         E IS PART OF A VARIABLE NAME.
C
            ELSE IF(CSTMTA(I6:I6) .GE. CAA .AND. CSTMTA(I6:I6) .LE. CZZ .OR.
     1         .OR. CSTMTA(I6:I6) .EQ. CUNDER .OR. CSTMTA(I6:I6) .EQ.
     2         CPLUS .OR. CSTMTA(I6:I6) .EQ. CMINUS .OR. CSTMTA(I6:I6)
     3         .EQ. CMINUS .OR. CSTMTA(I6:I6) .EQ. CSLASH .OR.
     4         CSTMTA(I6:I6) .EQ. CASTER .OR. CSTMTA(I6:I6) .EQ. CSLASH
     5         .OR. CSTMTA(I6:I6) .EQ. CLPAR .OR. CSTMTA(I6:I6) .EQ.
     6         COLON .OR. CSTMTA(I6:I6) .EQ. CSYMCD) THEN
               GO TO 111
C
C         WHEN THE PRIOR CHARACTER TO THE D OR E IS A DECIMAL POINT,
C         THE D OR E MUST BE PART OF A NUMERICAL VALUE. NO PERIODS
C         SHOULD EXIST AFTER IN THE STATEMENT AFTER PROCESSING BY
C         SUBROUTINE COMPRS.
C
            ELSE IF(CSTMTA(I6:I6) .EQ. CDOT) THEN
               GO TO 13
C
C         WHEN THE CHARACTER FOLLOWING THE D OR E IS ALPHABETIC, AN
C         UNDERSCORE, A DOLLAR SIGN, A RIGHT PARENTHESIS, A SLASH, AN
C         ASTERISK, A COLON, OR A LOGICAL OPERATOR: THE D OR E IS PART
C         OF A VARIABLE NAME.
C
            ELSE IF(CSTMTA(I5:I5) .GE. CAA .AND. CSTMTA(I5:I5) .LE. CZZ
     1         .OR. CSTMT(I5:I5) .EQ. CUNDER .OR. CSTMTA(I5:I5) .EQ.
     2         CDOL .OR. CSTMTA(I5:I5) .EQ. CRPAR .OR. CSTMTA(I5:I5)
     3         .EQ. CSYMCD) THEN
               GO TO 111
C
C         WHEN THE CHARACTER FOLLOWING THE D OR E IS A PLUS SIGN OR A
C         MINUS SIGN, DETERMINE IF THE D OR E IS PART OF A NUMERIC
C         VALUE.
C
            ELSE IF(CSTMTA(I5:I5) .EQ. CPLUS .OR. CSTMTA(I5:I5) .EQ.
     1         CMINUS) THEN
C
C         WHEN THE CHARACTER FOLLOWING THE PLUS OR MINUS SIGN IS A
C         NUMERICAL DIGIT, THE D OR E MAY BE PART OF A NUMERIC VALUE.
C
               IF(CSTMTA(I5+1:I5+1) .GE. C0 .AND. CSTMTA(I5+1:I5+1) .LE.
     1            C9) THEN
C
C         WHEN A NUMERICAL DIGIT FOLLOWS THE D OR E, DETERMINE IF THE
C         SPECIFICATION IS A NUMERIC VALUE.
C
C         LOCATE THE END OF THE NUMERIC FIELD FOLLOWING THE PLUS OR
C         MINUS SIGN
C
                  DO I7 = I5+1,J2
                  IF(CSTMTA(I7:I7) .GE. C0 .AND. CSTMTA(I7:I7) .LE. C9)
     1               THEN
                     CONTINUE
                  ELSE
C
C         WHEN THE NON-NUMERIC CHARACTER IS AN ARITHMETIC OR LOGICAL
C         OPERATOR, THE D OR E IS PART OF A NUMERIC VALUE.
C
                     IF(CSTMT(I7:I7) .EQ. CPLUS .OR. CSTMTA(I7:I7) .EQ.
     1                  CMINUS .OR. CSTMTA(I7:I7) .EQ. CSLASH .OR.
     2                  CSTMTA(I7:I7) .EQ. CASTER .OR. CSTMTA(I7:I7)
     3                  .EQ. CSYMCD) GO TO 13
C
C         WHEN THE NON-NUMERIC CHARACTER IS ALPHABETIC, THE D OR E IS
C         PART OF A VARIABLE NAME.
C
                     IF(CSTMT(I7:I7) .GE. CAA .AND. CSTMTA(I7:I7) .LE.
     1                  CZZ .OR. CSTMTA(I7:I7) .EQ. CUNDER .OR.
     2                  CSTMTA(I7:I7) .EQ. CDOL) GO TO 111
                  END IF
                  END DO
               END IF
            END IF
         END IF
C
C         SET LOCATION OF THE START OF A VARIABLE NAME
C
 111     IF(.NOT.L1) THEN
            IVARKT = IVARKT + 1
C
C         WHEN THE TABLE LIMIT HAS BEEN REACHED, WRITE MESSAGE AND
C         EXIT LOOP : DO 13
C
            IF(IVARKT .GT. 500) THEN
               IREC0 = IREC0 + 1
               WRITE (0,101) ISN
               GO TO 14                   ! PROCESS 50 VARIABLES ONLY
            END IF
C
C         PLACE VARIABLE ISN AND START LOCATION IN CEXVAR TABLE
C
            IEXVAR(9,IVARKT) = ISN + 128  ! ISN VALUE
            IEXVAR(14,IVARKT) = I1        ! VARIABLE START LOCATION
            I3 = I1
            L1 = LTRUE
C
C         DETERMINE THE END LOCATION OF THE VARIABLE NAME
C
            DO 12 I2 = I1,J2
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER OF THE VARIABLE
C         NAME. A VARIABLE NAME MAY CONTAIN ALPHABETIC CHARACTERS,
C         NUMERIC CHARACTERS, AN UNDERSCORE, OR A DOLLAR SIGN.
C
            IF(CSTMTA(I2:I2) .GE. CAA .AND. CSTMTA(I2:I2) .LE. CZZ .OR.
     1         CSTMTA(I2:I2) .GE. C0 .AND. CSTMTA(I2:I2) .LE. C9 .OR.
     2         CSTMTA(I2:I2) .EQ. CUNDER .OR. CSTMTA(I1:I1) .EQ. CDOL
     3         .OR. CSTMTA(I2:I2+1) .EQ. '##' .OR. CSTMTA(I2-1:I2) .EQ.
     3         '##') THEN
C
C         WHEN I2 IS THE FINAL CHARACTER OF THE ASSIGNMENT STATEMENT OR
C         EXPRESSION AND IS ALSO A CHARACTER THAT CAN BE PART OF A
C         VARIABLE NAME, SET UP CEXVAR ENTRY FOR THE VARIABLE NAME AND
C         EXIT THE DO LOOP
C
               IF(I2 .EQ. J2) THEN
                  I4 = J2
                  I5 = I4 - I3 + 1
                  IEXVAR(13,IVARKT) = I5       ! VARIABLE NAME LENGTH
                  CEXVAR(IVARKT)(1:I5) = CSTMTA(I3:I4) ! VARIABLE NAME
                  IEXVAR(15,IVARKT) = I4       ! END LOCATION
C
C         DETERMINE IF THIS VARIABLE NAME IS ALREADY CATALOGED WHEN
C         IT IS USED ON THE RIGHT SIDE OF THE EQUAL SIGN.
C
                  IF(L3 .AND. I4 .GT. IEQ) THEN
                     I6 = I - 1
C
C         DETERMINE IF THE VARIABLE NAME IS PART OF A COMPOUND VARIABLE
C
                     IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6) .EQ.
     1                  CPERC) THEN
                        GO TO 14          ! EXIT LOOP DO 12
                     END IF
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN CATALOGED
C
                     IF(BTEST(IEXVAR(12,I2),2) .OR. BTEST(IEXVAR(12,I2),
     1                  6)) THEN
                        GO TO 14          ! EXIT LOOP DO 12
                     ELSE
                        CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I2),1,
     1                     32,IRET,4000)
                        IF(IRET .LT. 0) THEN
                           IREC0 = IREC0 + 1
                           WRITE (0,103) ISN,CEXVAR(I1)(1:32)
                        END IF
                     END IF
                  END IF
                  GO TO 14                ! EXIT LOOP DO 12
               END IF
            ELSE
C
C         THE CURRENT CHARACTER AT LOCATION I2 IS NOT AN ALLOWED
C         CHARACTER IN A VARIABLE NAME. IT TERMINATES THE CURRENT
C         VARIABLE NAME.
C
               IF(I2 .LE. J2) THEN
                  I4 = I2
                  I5 = I4 - I1
                  IEXVAR(13,IVARKT) = I5       ! VARIABLE NAME LENGTH
                  I6 = I4 - 1
                  IEXVAR(15,IVARKT) = I6       ! END LOCATION
                  CEXVAR(IVARKT)(1:I5) = CSTMTA(I3:I6) ! VARIABLE NAME
                  I4WK1 = I2 + 1         ! START NEW SEARCH LOCATION
                  L1 = LFALSE
                  IF(CSTMTA(I2:I2) .EQ. CEQ) IEQ = I2
C
C         DETERMINE IF THIS VARIABLE NAME IS ALREADY CATALOGED WHEN
C         IT US USED ON THE LEFT SIDE OF THE EQUAL SIGN.
C
                  IF(L3 .AND. IEQ .LT. I6) THEN
C
C         DETERMINE IF THE VARIABLE IS A STRUCTURE OR RECORD VARIABLE.
C         THEY ARE ALREADY DEFINED.
C
                     I6 = I - 1
                     IF(I6 .GE. I1) THEN
                        IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6)
     1                     .EQ. CPERC) THEN
                           I4WK1 = I2
                           GO TO 11
                        END IF
                     END IF
                     I6 = I + 1
                     IF(I6 .LE. J2) THEN
                        IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6)
     1                     .LE. CPERC) THEN
                           I4WK1 = I2
                           GO TO 11
                        END IF
                     END IF
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN DEFINED
C
                     CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,
     1                  IRET,4000)
                     IF(IRET .GT. 0) THEN
C     IF(CSTMTA(11:20) .EQ. 'SZFMT_TEXT')
                        IREC0 = IREC0 + 1
                        WRITE (0,103) ISN,CEXVAR(I1)(1:32)
                     END IF
                  END IF
                  GO TO 11                ! NEXT VARIABLE
               END IF
            END IF
 12         CONTINUE
         END IF
      END IF
 13   CONTINUE
C
C         THE LEFT AND RIGHT BOUNDARIES ARE NOW KNOWN FOR ALL VARIABLE
C         NAMES.
C
C         SET ALL VARIABLES TYPE AND LENGTH CHARACTERISTICS IN ARRAY
C         CEXVAR FOR THE CURRENT ARITHMETIC ASSIGNMENT STATEMENT OR
C         EXPRESSION.
C
 14   DO 16 I1 = 1,IVARKT
C
C         SET SWITCH TO INCLUDE THIS VARIABLE IN THE OUTPUT LISTING
C         IF NOT PART OF AN INCLUDE INPUT FILE
C
      IF(.NOT.LINCL) IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),15)
C
C         A RECORD NAME MUST BE UNIQUE, AND IT CAN BE USED WITHIN
C         STRUCTURE AND MAP DEFINITIONS, BUT THE RECORD NAME IS DEFINED
C         OUTSIDE OF A STRUCTURE OR MAP DEFINITION. SINCE ALL
C         STRUCTURE AND RECORD DEFINTIONS MUST BE DEFINED BEFORE THE
C         FIRST EXECUTABLE STATEMENT, ALL RECORD, MAP, AND STRUCTURE
C         VARIABLES HAVE THEIR TYPE AND LENGTH CHARACTERISTICS KNOWN
C         AT THIS STAGE OF PROCESSING. A RECORD VARIABLE NAME USED IN
C         A STRUCTURE CAN HAVE AN IDENTICAL VARIABLE NAME DEFINED
C         WITHIN A STRUCTURE.
C
C         DETERMINE IF THE CURRENT VARIABLE NAME MATCHES A NAME IN
C         THE TABLE OF ALL RECORD VARIABLES. IRET > 0 WHEN A RECORD
C         NAME TABLE MATCHES.
C
      CALL TABSRH (CRECTB,IRECD,68,33,64,CEXVAR(I1),1,32,IRET,1000)
      IF(IRET .GT. 0) THEN
C
C         OBTAIN THE BIT SWITCHES FOR THIS RECORD NAME
C
         CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET3,4000)
C
C         A RECORD VARIABLE NAME USED WITHIN AN ARITHMETIC ASSIGNMENT
C         OR AN EXPRESSION, MUST BE TERMINATED BY PERIOD OR A PRECENT
C         SIGN.
C
         IF(IEXVAR(15,I1) .LT. J2) THEN
C
C         THE VARIABLE NAME MAY BE A RECORD NAME
C
            I2 = IEXVAR(15,I1) + 1
            IF(CSTMTA(I2:I2) .EQ. CDOT .OR. CSTMTA(I2:I2) .EQ. CPERC)
     1         THEN
C
C         SET BIT SWITCH TO INDICATE THIS IS A RECORD VARIABLE
C
               IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),2)  ! RECORD BIT
C
C         OBTAIN THE LENGTH CHARACTERISTIC OF THE RECORD VARIABLE NAME
C
               CI4WK1(1:4) = CRECTB(IRET)(65:68)
               CALL ITOC (I4WK1,CWK7,1,7)
               CEXVAR(11)(37:44) = CQUES(1:1)//CWK7(1:7) ! TYPE & LENGTH
C
C         DETERMINE IF THE RECORD NAME IS USED WITHIN A STRUCTURE. THE
C         LENGTH OF A RECORD VARIABLE IS DEFINED BY THE STRUCTURE TO
C         WHICH IT REFERS, NOT THE STRUCTURE THAT USES IT.
C
               CALL TABSRH (CVARST,NVARST,72,1,32,CEXVAR(I1),1,32,IRET1,
     1            1000)
C
C         SET THE BIT TO INDICATE THE VARIABLE NAME IS USED WITHIN A
C         A STRUCTURE
C
               IF(IRET1 .GT. 0) THEN
                  IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),6) ! STRUCTURE
               ELSE
                  IEXVAR(12,I1) = IBCLR(IEXVAR(12,I1),6) ! NO STRUCTURE
               END IF
C
C         ILLEGAL USE OF A RECORD VARIABLE
C
            ELSE
C
C         DO NOT WRITE THE ERROR MESSAGE IF THE RECORD NAME IS USED AS
C         AN ARGUMENT OR IS DIMENSIONED.
C
               IF(.NOT.BTEST(IENAME(9,IRET3),7) .AND.
     1            .NOT.BTEST(IENAME(9,IRET3),17)) THEN
                  IREC0 = IREC0 + 1
                   WRITE (0,102) ISN
                  GO TO 15
               END IF
            END IF
         ELSE
C
C         DO NOT WRITE THE ERROR MESSAGE IF THE RECORD NAME IS USED AS
C         ARGUMENT
C
            IF(.NOT.BTEST(IENAME(9,IRET3),7) .AND.
     1         .NOT.BTEST(IENAME(9,IRET3),17)) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102) ISN
               GO TO 15
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED WITHIN A STRUCTURE
C
 15   CALL TABSRH (CVARST,NVARST,72,1,32,CEXVAR(I1),1,32,IRET,1000)
      IF(IRET .GT. 0) THEN
         CEXVAR(I1)(37:44) = CVARST(IRET)(66:72)  ! TYPE & LENGTH
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),6)   ! STRUCTURE BIT
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED WITHIN A UNION
C
      CALL TABSRH (CUNION,IUNION,44,1,32,CEXVAR(I1),1,32,IRET,500)
      IF(IRET .GT. 0) THEN
         CEXVAR(I1)(37:44) = CUNION(IRET)(33:40)  ! TYPE & LENGTH
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),5)   ! UNION BIT
      END IF
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
      CALL TABSRH (CDIM,JDIM,104,1,32,CEXVAR(I1),1,32,IRET,1000)
      I6 = IEXVAR(15,I1) + 1
C
C         WHEN THE VARIABLE IS DIMENSIONED, IT IS ALREADY CATALOGED
C         IN ARRAY CNAME, AND ITS TYPE AND LENGTH IS KNOWN. RETRIEVE
C         THOSE CHARACTERISTICS FROM CNAME.
C
      IF(IRET .GT. 0) THEN
         CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET1,4000)
C
C         SET THE LENGTH AND TYPE CHARACTERISTICS TO THOSE IN CNAME
C
         IF(IRET1 .GT. 0) CEXVAR(I1)(37:44) = CNAME(IRET1)(37:44)
C
C         DETERMINE IF THE VARIABLE OCCURS WITHIN A STRUCTURE. A
C         DIMENSIONED VARIBLE CAN NOT BE DEFINED WITHIN A STRUCTRE.
C
         IF(BTEST(IEXVAR(12,I1),6)) THEN
            IF(I6 .GT. J2) THEN
               IREC0 = IREC0 + 1       ! DIMENSIONED STRUCTURE VARIABLE
               WRITE (0,104) ISN,CEXVAR(I1)(1:32)
            END IF
         ELSE
C
C         DETERMINE IF A SUBSCRIPT FOLLOWS THE DIMENSIONED VARIABLE
C
            IF(CSTMTA(I6:I6) .NE. CLPAR .AND. CSTMTA(I6:I6) .NE. CRPAR
     1         .AND. CSTMTA(I6:I6) .NE. COMMA) THEN
               IREC0 = IREC0 + 1         ! DIMENSIONED BUT NO SUBSCRIPT
               WRITE (0,CF100) ISN,CEXVAR(I1)(1:32)
            ELSE IF(CSTMTA(I6:I6) .EQ. CLPAR .AND. IRET .LT. 0) THEN
C
C         DETERMINE IF THE VARIABLE NAME IS AN OS2 API MACRO
C
               I2WK1 = 0
               CALL TABSRH (CMACRO,25,32,1,32,CEXVAR(I1),1,32,IRET3,25)
               IF(IRET3 .LT. 0) THEN
                  IREC0 = IREC0 + 1         ! NOT DIMENSIONED
                  WRITE (0,CF101) ISN,CEXVAR(I1)(1:32)
               END IF
            END IF
         END IF
      ELSE
         I3 = IEXVAR(15,I1) + 1
         IF(CSTMTA(I3:I3) .EQ. CLPAR) IEXVAR(12,I1) =
     1      IBSET(IEXVAR(12,I1),10)
      END IF
C
C         DETERMINE IF THE VARIABLE IS IN COMMON
C
      IRET = 1
      DO WHILE (IRET .LE. IREC11-1)
      READ (11,REC=IRET) CWK44(1:44)
      IF(CWK44(1:32) .EQ. CEXVAR(I1)(1:32)) THEN
         CEXVAR(I1)(37:44) = CWK44(37:44)       ! LENGTH & TYPE
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),1)
         GO TO 160
      END IF
      IRET = IRET + 1
      END DO
C
C         DETERMINE IF THE VARIABLE IS A DEFINED ENTRY, FUNCTION, OR
C         SUBROUTINE
C
 160  CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CEXVAR(I1),1,32,IRET2,1000)
      IF(IRET2 .GT. 0) THEN
         IF(BTEST(JSUBTB(12,I1),8)) IEXVAR(12,I1) =
     1      IBSET(IEXVAR(12,I1),8)
         IF(BTEST(JSUBTB(12,I1),9)) IEXVAR(12,I1) =
     1      IBSET(IEXVAR(12,I1),9)
         IF(BTEST(JSUBTB(12,I1),10)) IEXVAR(12,I1) =
     1      IBSET(IEXVAR(12,I1),10)
      END IF
C
C         DETERMINE IF THE VARIABLE IS AN INTRINSIC FUNCTION
C
      CALL TABSRH (FUNTBL,143,35,1,32,CEXVAR(I1),1,32,IRET2,143)
      IF(IRET2 .GT. 0 .AND. IEXVAR(15,I1) .GT. IEQ) THEN
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),10)  ! DEFINED FUNCTION
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),16)  ! INTRINSIC FUNCTION
         IF(FUNTBL(IRET2)(34:34) .EQ. CSHARP) THEN ! TYPE & LENGTH
            CEXVAR(I1)(37:39) = FUNTBL(IRET2)(33:33)//'? '
         ELSE
            CEXVAR(I1)(37:39) = FUNTBL(IRET2)(33:35)
         END IF
      END IF
C
C         DETERMINE IF THE VARIABLE IS A PARAMETER VARIABLE
C
      CALL TABSRH (CPARAM,IP,52,1,32,CEXVAR(I1),1,32,IRET,4000)
      IF(IRET .GT. 0 .OR. LPARAM) IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),
     1   14)
C
C         DETERMINE IF A TYPE AND LENGTH CODE HAS BEEN ASSIGNED
C
C
C         DETERMINE IF THE VARIABLE IS ALREADY DEFINED AND THE FIRST
C         EXECUTABLE STATEMENT HAS BEEN REACHED
C
      CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET1,4000)
      IF(IRET1 .GT. 0 .AND. LSTART) THEN
C
C         WHEN THE VARIABLE ALREADY EXISTS IN CNAME AND THE FIRST
C         EXECUTABLE STATEMENT HAS BEEN PROCESSED, SET CEXVAR TYPE
C         AND LENGTH TO THE VALUES IN CNAME.
C
         CEXVAR(I1)(37:44) = CNAME(IRET1)(37:44)
         GO TO 16
      END IF
      IF(CEXVAR(I1)(37:44) .EQ. CBLANK(1:8)) THEN
C
C         WHEN THE VARIABLE IN CEXVAR HAS NO TYPE AND LENGTH CHARACTER-
C         ISTIC, DETERMINE THE TYPE AND LENGTH FROM THE DEFAULT VALUES
C         IN CIMPL.
C
         CALL SETTL (CEXVAR(I1))          ! TYPE & LENGTH
      END IF
 16   CONTINUE
C
C         ALL VARIABLE NAMES OCCURRING IN AN ARITHMETIC ASSIGNMENT
C         STATEMENT OR AN EXPRESSION HAVE THEIR CHARACTERISTICS SET,
C         EXCEPT FOR THE POSSIBLE USE AS AN ARGUMENT IN A FUNCTION
C         CALL. SUBSCRIPT VARIABLES AND CHARACTER RANGE SPECIFICATIONS
C         ARE NOT TREATED AS ARGUMENTS.
C
      DO 19 I1 = 1,IVARKT
C
C         DETERMINE IF A VARIABLE IS A FUNCTION CALL. AN ENTRY OR
C         SUBROUTINE NAME CAN NOT OCCUR IN AN ARITHMETIC ASSIGNMENT
C         OR AN EXPRESSION.
C
      IF(BTEST(IEXVAR(12,I1),16) .OR. BTEST(IEXVAR(12,I1),10)) THEN
C     IF(CSTMTA(11:20) .EQ. 'SZFMT_TEXT')
C
C         LOCATE THE LEFT AND RIGHT ENCAPSULATING PARENTHESES, IF ANY,
C         OF THE ARGUMENT LIST.
C
         L1 = LFALSE
         I3 = IEXVAR(15,I1) + 1
         IOPENP = 0
         DO 17 I2 = I3,J2
         IF(CSTMTA(I2:I2) .EQ. COLON) GO TO 20
         IF(CSTMTA(I2:I2) .EQ. CLPAR) THEN
            IOPENP = IOPENP + 1
            IF(.NOT.L1) I4 = I2
            L1 = LTRUE
         END IF
         IF(CSTMTA(I2:I2) .EQ. CRPAR) THEN
            IOPENP = IOPENP - 1
            IF(IOPENP .EQ. 0) THEN
               I5 = I2
               L1 = LFALSE
               IF(I4+1 .EQ. I5) GO TO 20  ! ARGUMENT LIST IS ()
               GO TO 18
            END IF
         END IF
 17      CONTINUE
C        END IF
C
C         WHEN EXECUTION EXITS THE DO LOOP NORMALLY, THERE IS NO
C         ARGUMENT LIST FOR THIS FUNCTION.
C
         GO TO 20
C
C         THE LEFT AND RIGHT BOUNDARIES OF THE FUNCTION'S ARGUMENT LIST
C         ARE NOW KNOWN.
C
 18      LCALL = LTRUE
         JA = IEXVAR(14,I1)
         CALL ARGLST (CEXVAR(I1)(37:37),CSTMTA,I5)
         LCALL = LFALSE
      END IF
 19   CONTINUE
C
C         INSURE ALL VARIABLE NAMES IN CEXVAR ARE PLACED IN CNAME
C
 20   DO 21 I1 = 1,IVARKT
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CWORK(1:52) = CEXVAR(I1)(1:52)
      CALL CHKNME (CSTMTA)
 21   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *      PROCESS ALL NUMBERS: FLOATING, INTEGER, AND REAL          *
C     *                                                                *
C     ******************************************************************
C
C         ONE OF THE FOLLOWING CHARACTERS MUST PRECEDE A NUMERICAL VALUE
C         WHETHER THE NUMBER IS AN INTEGER, A REAL, OR A FLOATING POINT
C         VALUE.
C            ARITHMETIC OPERATOR (PLUS, MINUS, ASTERISK, SLASH), LOGICAL
C            OPERATOR, LEFT PARENTHESIS, COMMA, COLON
C
C         ONE OF THE FOLLOWING CHARACTERS MUST FOLLOW A NUMERICAL VALUE
C         WHETHER THE NUMBER IS AN INTEGER, A REAL, OR A FLOATING POINT
C         VALUE.
C            ARITHMETIC OPERATOR (PLUS, MINUS, ASTERISK, SLASH), LOGICAL
C            OPERATOR, RIGHT PARENTHESIS, COMMA, COLON
C
C         LOCATE THE START AND END LOCATIONS OF A NUMBER SPECIFICATION
C
      I4WK1 = J1
      J2 = JFINAL
      L2 = LTRUE
 22   DO 24 I1 = I4WK1,J2
      IF(CSTMTA(I1:I1) .GE. C0 .AND. CSTMTA(I1:I1) .LE. C9) THEN
C
C         IGNORE DIGITS THAT ARE PART OF A VARIABLE NAME
C
         DO 23 I2 = 1,IVARKT
         IF(I1 .GE. IEXVAR(14,I2) .AND. I1 .LE. IEXVAR(15,I2)) GO TO 24
C
C         DETERMINE IF A NUMERIC VALUE IS FLOATING, OR REAL
C
         IF(I2 .LT. IVARKT) THEN
C
C         BETWEEN VARIABLE NAMES
C
            IF(I1 .GT. IEXVAR(15,I2) .AND. I1 .LT. IEXVAR(14,I2+1) .AND.
     1      CSTMTA(I1:I1) .EQ. CDOT) THEN
               L2 = LFALSE
               GO TO 230
C
C         BEYOND VARIABLE NAMES
C
            ELSE IF(I1 .GE. IEXVAR(15,I2)) THEN
               IF(CSTMT(I1:I1) .EQ. CDOT) THEN
                  L2 = LFALSE
                  GO TO 230
               END IF
            END IF
         END IF
 23      CONTINUE
C
C         WHEN A DIGIT IS NOT PART OF A VARIABLE NAME, IT MUST BE A
C         NUMERICAL VALUE.
C
 230     FPP = FP
         KB = J2
         CALL NUMBER (CSTMTA,L2,I1,II,FP,IFP)
         KB = J2
         IF(L2) THEN
            CALL INSERT (II)              ! INTEGER
         ELSE
            CALL FCHECK                   ! FLOATING
         END IF
         IF(IFP .GE. J2) GO TO 25         ! EXIT
         FP = FPP
         I4WK1 = IFP + 1
         IF(IFP .GE. J2) THEN
            GO TO 25
         ELSE
            I4WK1 = IFP + 1
            IF(I4WK1 .GE. J2) GO TO 25
            GO TO 22
         END IF
      END IF
 24   CONTINUE
C
C         ROUTINE EXIT
C
 25   KB = KFINAL
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES ARITHMETIC, LOGICAL, CHARACTER
C        EXPRESSIONS, ARITHMETIC ASSIGNMENT STATEMENTS, LOGICAL
C        ASSIGNMENT STATEMENTS, AND CHARACTER ASSIGNMENT STATEMENTS
C        THAT EXIST AS AN ARGUMENT OF A CALL STATEMENT OR THAT OCCURS
C        WITHIN AN EXPRESSION PROCESSED BY ANOTHER ROUTINE.
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARACTER: A
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES.
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32. THE
C                                  WORD LENGTH IS IN COLS. 38-44 IN
C                                  ARRAY CNAME.
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CDOL   - CHARACTER VARIABLE, A DOLLAR SIGN: $
C         CDOT   - CHARACTER VARIABLE, A PERIOD: .
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CEXVAR - CHARACTER STATEMENT, LIST OF ALL VARIABLE NAMES
C                  OCCURRING IN AN ARITHMETIC ASSIGNMENT STATEMENT OR IN
C                  AN EXPRESSION
C                  TOTAL LENGTH IS 60 CHARACTERS
C                  RECORD STRUCTURE:
C                  COLS TYPE WORD CONTENT
C                   1-32 A*32   8 VARIABLE NAME
C                  33-36 I*4    9 ISN VALUE + 128
C                  37-44 A*8   11 DATA TYPE & LENGTH
C                  45-48 I*4   12 BIT SWITCHES
C                  49-52 I*4   13 LENGTH OF VARIABLE NAME ON COLS 1-32
C                  53-56 I*4   14 VARIABLE'S FIRST CHARACTER LOCATION
C                  57-60 I*4   15 VARIABLE'S LAST CHARACTER LOCATION
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS: (
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. THIS TABLE DOES NOT CONTAIN THE LIST OF
C                  VARIABLE NAMES BELONGING TO THE COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 4000
C                  PARAMETER STATEMENTS ALLOWED.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  ISN VALUE
C                  37-44  A*8   11  DATA TYPE & LENGTH
C                  45-48  I*4   12  NUMERIC VALUE OF INTEGER VARIABLES
C                                   ONLY. OTHER DATA TYPES LEAVE THIS
C                                   FIELD BLANK
C                  49-52  I*4   13  LENGTH OF THE VARIABLE NAME IN
C                                   COLS 1 - 32
C         CPERC  - CHARACTER VARIABLE, THE CHARACTER: %
C         CQUES  - CHARACTER VARIABLE, THE CHARACTER: ?
C         CRECTB - CHARACTER VARIABLE, A TABLE OF ALL VARIABLES NAMES
C                  DEFINED BY A RECORD STATEMENT. A MAXIMUM OF 1000
C                  RECORD VARIABLE NAME DEFINITIONS ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME DEFINITION REFERRED
C                                   TO BY THE RECORD STATEMENT
C                 33 - 64 A*32  16  RECORD VARIABLE NAME USING THE
C                                   TEMPLATE OF THE STRUCTURE NAME IN
C                                   COLS. 1 - 32
C                 64 - 68 I*4   17  INTEGER VALUE OF THE RECORD DERIVED
C                                   FROM THE STRUCTURE NAME IN COLS.1-32
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS: )
C         CSTMTA - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSUBTB - CHARACTER VARIABLE, TABLE OF ALL ENTRY, FUNCTION, AND
C                  SUBPROGRAMS IN THE ENTIRE CURRENT PROGRAM.
C                  RECORD STRUCTURE
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZERO)
C                  37-44  11   TYPE AND LENGTH CHARACTERISTICS
C                  45=48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS IN COLS 1-32
C                  53-56  14   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _
C         CUNION - CHARACTER VARIABLE, TABLE OF ALL VARIABLE NAMES
C                  USED WITN A UNION. A MAXIMUM OF 500 RE ALLOWED.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED WITHIN A UNION
C                     33 A*1       DATA TYPE CODE OF VARIABLE
C                  34-40 A*7    10 VARIABLE LENGTH CHARACTERISTIC
C                  41-44 I*4    11 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C         CVARST - CHARACTER VARIABLE, CONTAINS THE NAME OF ALL
C                  VARIABLES DEFINED WITHIN STRUCTURES IN THE
C                  CURRENT MODULE.
C                  RECORD STRUCTURE
C                  COLS  TYPE WORD CONTENTS
C                   1-32 A*32    8 VARIABLE NAME DEFINED IN THE CURRENT
C                                  STRUCTURE
C                  33-64 A*32   16 NAME OF THE STRUCTURE DEFINING THE
C                                  VARIABLE IN COLS 1-32
C                     65 A*1       DATA TYPE CODE OF THE VARIABLE IN
C                                  COLS 1-32
C                  66-72 A*7    18 LENGTH DEFINITION OF THE VARIABLE IN
C                                  COLS 1-32
C         CWK7   - CHARACTER VARIABLE, WORK AREA TO CONVERT AN INTEGER
C                  TO A TEXT FORMAT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER: Z
C         C0     - CHARACTER VARIABLE, A ZERO CHARACTER
C         C9     - CHARACTER VARIABLE, A NINE CHARACTER
C         FP     - FLOATING POINT VALUE RETURNED FROM ROUTINE NUMBER
C         FPP    - SAVE AREA FOR THE VALUE OF FP UPON ENTERING THIS
C                  SUBPROGRAM
C         FUNTBL - A TABLE OF STANDARD FORTRAN INTRINSIC FUNCTIONS
C                  COLS  1-32 THE FUNCTION NAME
C                  COLS 33-35 THE TYPE AND LENGTH OF FUNCTION'S RETURN
C                             VALUE AS NUMERIC CHARACTERS. A # IN COLUMN
C                             34 INDICATES THE LENGTH IS DEPENDENT UPON
C                             ARGUMENTS OF THE FUNCTION.
C
C                  TYPE CODES USED ARE:
C
C                  B - SINGLE PRECISION COMPLEX
C                  C - CHARACTER
C                  D - DOUBLE PRECISION REAL
C                  E - DOUBLE PRECISION COMPLEX
C                  I - INTEGER (ALL LENGTHS)
C                  L - LOGICAL (ALL LENGTHS)
C                  R - SINGLE PRECISION REAL
C         ICOMKT - COUNT OF ENTRIES IN COMTBL, A LIST OF ALL COMMON
C                  BLOCK NAMES
C         IEQ    - LOCATION OS THE EQUAL SIGN FOR AN ARITHMETIC
C                  STATEMENT. SET TO ZERO IF NO EQUAL SIGN EXISTS
C         IEXVAR - EQUIVALENCED TO CEXVAR
C         IFP    - THE LOCATION OF A THE END OF A NUMBER IN SCIENTIFIC
C                  NOTATION
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IOPENP - COUNTER USED TO DETERMINE MATCHING LEFT AND RIGHT
C                  PARENTHESES. WHEN > 0, MATCH HAS NOT BEEN FOUND
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINTIONS
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IREC11 - COUNT OF THE NUMBER OF COMMON VARIABLE NAMES ON UNIT
C                  11
C         IRET   - RETURN CODE FROM A TABLE SEARCH
C         IRET1  - RETURN CODE FROM A TABLE SEARCH
C         IRET2  - RETURN CODE FROM A TABLE SEARCH
C         IRET3  - RETURN CODE FROM A TABLE SEARCH
C         IRET4  - RETURN CODE FROM A TABLE SEARCH
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISUBTB - COUNT OF THE NUMBER OF ENTRIES IN CSUBTB TABLE
C         IUNION - COUNT OF THE NUMBER OF ENTRIES IN CUNION TABLE
C         IVARKT - COUNT OF THE NUMBER OF ENTRIES IN ARRAY CEXVAR
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         I3     - WORK AREA
C         I4     - WORK AREA
C         I4WK1  - DO LOOP START VALUE
C         I5     - WORK AREA
C         I6     - WORK AREA
C         I7     - WORK AREA
C         JDIM   - COUNT OF THE NUMBER OF ENTRIES IN TABLE CDIM
C         JFINAL - SAVE LOCATION OF THE FINAL CHARACTER IN AN ASSIGNMENT
C                  STATEMENT OR AN EXPRESSION
C         JSUBTB - EQUIVALENCED TO CSUBTB
C         J1     - START LOCATION OF AN ARITHMETIC ASSIGNMENT STATEMENT
C                  OR OF AN EXPRESSION
C         J2     - END LOCATION OF AN ARITHMETIC ASSIGNMENT STATEMENT
C                  OR OF AN EXPRESSION
C         JFINAL - SAVE LOCATION OF THE FINAL CHARACTER IN THE COMPLETE
C                  FORTRAN STATEMENT OR AN EXPRESSION
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE FILE IS
C                  BEING PROCESSED, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE TO PREVENT CHANGING THE
C                  LOCATION OF THE FIRST CHARACTER OF A VARIABLE NAME.
C         L2     - LOGICAL VARIABLE, SET TRUE FOR AN INTEGER NUMBER,
C                  SET FALSE FOR A FLOATING POINT NUMBER.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN EXPRESSION IS AN
C                  ARGUMENT, SET FALSE IF AN ARITHMETIC, LOGICAL, OR
C                  CHARACTER ASSIGNMENT STATEMENT.
C         NVARST - COUNT OF THE NUMBER OF ENTRIES IN TABLE CVARST
C
C     COMMENTS
C
C         THIS ROUTINE IS CALLED ONLY FROM ROUTINE XXXXXX
C
C         UPON ENTRY TO THIS PROGRAM, ALL DECLARED VARIABLES HAVE BEEN
C         PLACED IN ARRAY CNAME. AN UNDECLARED VARIABLE MUST BE USED
C         TO THE LEFT OF THE EQUAL SIGN IN AN ARITHMETIC ASSIGNMENT
C         STATEMENT. ITS USE IS ILLEGAL TO THE RIGHT OF THE EQUAL SIGN.
C         ITS USE DECLARES THE VARIABLE NAME AND ITS TYPE AND LENGTH
C         ARE TAKEN FROM TABLE CIMP, THE DEFAULT SETTINGS FOR ALL
C         VARIABLE NAMES NOT DECLARED PRIOR TO THE FIRST EXECUTABLE
C         STATEMENT.
C
C         THERE ARE THREE TYPES OF EXPRESSIONS: ARITHMETIC, LOGICAL,
C         OR CHARACTER. AN ASSIGNMENT STATEMENT CONTAINS A VARIABLE
C         NAME FOLLOWED BY AN EQUAL SIGN, EITHER AN ARITHMETIC,
C         LOGICAL, OR CHARACTER EXPRESSION FOLLOWS. THE ARGUMENT OF AN
C         IF STATEMENT MAY CONTAIN A MIXED LOGICAL AND ARITHMETIC
C         EXPRESSION.
C
C         ALL LOGICAL OPERATORS SUCH AS: .NOT., .AND., .OR., ETC. ARE
C         REMOVED FROM ANY STATEMENT IN WHICH THEY OCCUR AND ARE
C         REPLACED WITH THE HEX NUMBER: CD. CONSEQUENTLY, ONLY VARIABLE
C         NAMES, ARITHMETIC OPERATORS, COMMAS, COLONS, DIGITS, DECIMAL
C         POINTS, PERCENT SIGNS, 'CD'X, 'CF'X (FOR LITERALS), AND BOTH
C         LEFT AND RIGHT PARENTHESES CAN EXIST WHEN THIS ROUTINE BEGINS
C         PROCESSING. ALL VARIABLE DEFINITION STATEMENTS PRECEDING
C         THE FIRST EXECUTABLE STATEMENT HAVE ALREADY BEEN PROCESSED;
C         THE ONLY UNDEFINED VARIABLE NAME THAT CAN OCCUR MUST BE TO
C         THE LEFT OF AN EQUAL SIGN.
C
C         THIS ROUTINE DOES NOT EVALUATE EXPRESSIONS FOR ANY
C         COMPUTATIONAL RESULTS. IT ONLY DETERMINES THE VARIABLE NAMES
C         AND NUMERICAL CONSTANTS EXISTING IN A MATHEMATICAL, LOGICAL,
C         OR CHARACTER EXPRESSION. ROUTINE EVALU PERFORMS EXPRESSION
C         EVALUATION, AND IT IS USED ONLY FOR THE PARAMETER STATEMENT
C         AND STATEMENTS THAT HAVE LENGTH SPECIFICTIONS, DIMENSION
C         SPECIFICATIONS, ETC. PRIOR THE FIRST EXECUTABLE STATEMENT.
C
C         DIMENSIONED CHARACTER VARIABLES MAY HAVE SUBSCRIPTS IF THEY
C         ARE DIMENSIONED AND CHARACTER RANGE SPECIFICATIONS IN ANY
C         EXPRESSION. CHARACTER ARRAY RANGE SPECIFICATIONS MUST ALWAYS
C         FOLLOW ANY SUBSCRIPT SPECIFICATIONS. ANY CHARACTER VARIABLE
C         MAY USE CHARACTER RANGE SPECIFICATIONS, BUT ONLY DIMENSIONED
C         CHARACTER VARIABLES MAY HAVE SUBSCRIPTS.
C
C         ONLY A DEFINED OR INTRINSIC FUNCTION MAY OCCUR IN ANY
C         ARITHMETIC ASSIGNMENT STATEMENT OR EXPRESSION.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         ARGLST BTEST CHKNME FCHECK INSERT ITOC NUMBER TABSRH
C
C     *****************************************************************
C
      SUBROUTINE EXPRA (J1,J2,L3,CSTMTA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(1,200), NFLOC(30)
      DIMENSION CEXVAR(50), IEXVAR(15,50), JRECTB(17,1000)
      DIMENSION CMACRO(25)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CSTMTA
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*61    CF101
      CHARACTER*60    CEXVAR
      CHARACTER*59    CF100
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION, CWK44
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32, CMACRO
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP, FPP
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 L1, L2, L3
C
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      COMMON /PMACRO/ CMACRO
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(49:52),
     1IVCNT), (CWORK(45:48),JBITS), (CNAME,IENAME), (CWK8(2:2),CWK7),
     2(CRECTB,JRECTB), (I4WK1,CI4WK1)
      EQUIVALENCE (CEXVAR,IEXVAR), (CSUBTB,JSUBTB)
C
C         DATA STATEMENTS
C
      DATA CF100 /'('' ISN:'',I6,'' DIMENSIONED VARIABLE LACKS SUBSCRIPT
     1S: '',A32)'/
      DATA CF101 /'('' ISN:'',I6,'' SUBSCRIPTED VARIABLE IS NOT DIMENSIO
     1NED: '',A32)'/
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' EXPRESSION INVALID')
 101  FORMAT(' ISN:',I6,' MORE THAN 50 VARIABLES IN AN EXPRESSION')
 102  FORMAT(' ISN:',I6,' ILLEGAL USE OF A RECORD VARIABLE: ',A32)
 103  FORMAT(' ISN:',I6,' NONDEFINED VARIABLE USED ILLEGALLY: ',A32)
C
C         INITIALIZATION
C
      I3 = 0
      IEQ = 0
      IVARKT = 0
      I4WK1 = J1
      JFINAL = J2
      KFINAL = KB
      DO 10 I1 = 1,50
      CEXVAR(I1)(1:60) = CBLK52(1:50)//CBLK52(1:10)
      IEXVAR(12,I1) = 0
      IEXVAR(13,I1) = 0
      IEXVAR(14,I1) = 0
      IEXVAR(15,I1) = 0
 10   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *            VARIABLE NAME PROCESSING                            *
C     *                                                                *
C     ******************************************************************
C
C         THIS DO LOOP WILL IDENTIFY ALL VARIABLE NAMES OCCURRING
C         IN THE ARITHMETIC ASSIGNMENT STATEMENT OR THE EXPRESSION
C         AND CREATE AN ENTRY IN TABLE CEXVAR.
C
 11   L1 = LFALSE
      DO 13 I1 = I4WK1,J2
C
C         SAVE THE LOCATION OF AN EQUAL SIGN WHEN THIS IS AN ARITHMETIC
C         ASSIGNMENT STATEMENT. EXPRESSIONS MAY NOT CONTAIN AN EQUAL
C         SIGN EXCEPT WITHIN A LITERAL.
C
      IF(L3 .AND. CSTMT(I1:I1) .EQ. CEQ) IEQ = I1 ! EQUAL SIGN LOCATION
C
C         LOCATE THE FIRST CHARACTER OF A VARIABLE NAME
C
      IF(CSTMTA(I1:I1) .GE. CAA .AND. CSTMTA(I1:I1) .LE. CZZ .OR.
     1   CSTMTA(I1:I1) .EQ. CUNDER) THEN
C
C         LOCATION OF THE CHARACTER BEFORE THE CURRENT CHARACTER
C
         I6 = I1 - 1
C
C         LOCATION OF THE CHARACTER AFTER THE CURRENT CHARACTER
C
         I5 = I6 + 1
C
C         DETERMINE IF THE CURRENT CHARACTER IS A D OR AN E. THEY MAY
C         BE PART OF A FLOATING POINT NUMBER.
C
         IF(CSTMTA(I1:I1) .EQ. CDD .OR. CSTMTA(I1:I1) .EQ. CEE) THEN
C
C         WHEN THE D OR E IS THE FIRST CHARACTER OF THE STATEMENT, THEY
C         ARE PART OF A VARIABLE NAME.
C
            IF(I1 .EQ. I4WK1) THEN
               GO TO 111
C
C         WHEN THE D OR E IS THE LAST CHARACTER OF THE STATEMENT, THEY
C         ARE PART OF A VARIABLE NAME.
C
            ELSE IF(I1 .EQ. J2) THEN
               GO TO 111
C
C         WHEN THE PRIOR CHARACTER TO THE D OR E IS ALPHABETIC, AN
C         UNDERSCORE, A PLUS SIGN, A MINUS SIGN, AN ASTERISK, A SLASH,
C         A LEFT PARENTHESIS, A COLON, OR A LOGICAL OPERATOR: THE D OR
C         E IS PART OF A VARIABLE NAME.
C
            ELSE IF(CSTMTA(I6:I6) .GE. CAA .AND. CSTMTA(I6:I6) .LE. CZZ .OR.
     1         .OR. CSTMTA(I6:I6) .EQ. CUNDER .OR. CSTMTA(I6:I6) .EQ.
     2         CPLUS .OR. CSTMTA(I6:I6) .EQ. CMINUS .OR. CSTMTA(I6:I6)
     3         .EQ. CMINUS .OR. CSTMTA(I6:I6) .EQ. CSLASH .OR.
     4         CSTMTA(I6:I6) .EQ. CASTER .OR. CSTMTA(I6:I6) .EQ. CSLASH
     5         .OR. CSTMTA(I6:I6) .EQ. CLPAR .OR. CSTMTA(I6:I6) .EQ.
     6         COLON .OR. CSTMTA(I6:I6) .EQ. CSYMCD) THEN
               GO TO 111
C
C         WHEN THE PRIOR CHARACTER TO THE D OR E IS A DECIMAL POINT,
C         THE D OR E MUST BE PART OF A NUMERICAL VALUE. NO PERIODS
C         SHOULD EXIST AFTER IN THE STATEMENT AFTER PROCESSING BY
C         SUBROUTINE COMPRS.
C
            ELSE IF(CSTMTA(I6:I6) .EQ. CDOT) THEN
               GO TO 13
C
C         WHEN THE CHARACTER FOLLOWING THE D OR E IS ALPHABETIC, AN
C         UNDERSCORE, A DOLLAR SIGN, A RIGHT PARENTHESIS, A SLASH, AN
C         ASTERISK, A COLON, OR A LOGICAL OPERATOR: THE D OR E IS PART
C         OF A VARIABLE NAME.
C
            ELSE IF(CSTMTA(I5:I5) .GE. CAA .AND. CSTMTA(I5:I5) .LE. CZZ
     1         .OR. CSTMT(I5:I5) .EQ. CUNDER .OR. CSTMTA(I5:I5) .EQ.
     2         CDOL .OR. CSTMTA(I5:I5) .EQ. CRPAR .OR. CSTMTA(I5:I5)
     3         .EQ. CSYMCD) THEN
               GO TO 111
C
C         WHEN THE CHARACTER FOLLOWING THE D OR E IS A PLUS SIGN OR A
C         MINUS SIGN, DETERMINE IF THE D OR E IS PART OF A NUMERIC
C         VALUE.
C
            ELSE IF(CSTMTA(I5:I5) .EQ. CPLUS .OR. CSTMTA(I5:I5) .EQ.
     1         CMINUS) THEN
C
C         WHEN THE CHARACTER FOLLOWING THE PLUS OR MINUS SIGN IS A
C         NUMERICAL DIGIT, THE D OR E MAY BE PART OF A NUMERIC VALUE.
C
               IF(CSTMTA(I5+1:I5+1) .GE. C0 .AND. CSTMTA(I5+1:I5+1) .LE.
     1            C9) THEN
C
C         WHEN A NUMERICAL DIGIT FOLLOWS THE D OR E, DETERMINE IF THE
C         SPECIFICATION IS A NUMERIC VALUE.
C
C         LOCATE THE END OF THE NUMERIC FIELD FOLLOWING THE PLUS OR
C         MINUS SIGN
C
                  DO I7 = I5+1,J2
                  IF(CSTMTA(I7:I7) .GE. C0 .AND. CSTMTA(I7:I7) .LE. C9)
     1               THEN
                     CONTINUE
                  ELSE
C
C         WHEN THE NON-NUMERIC CHARACTER IS AN ARITHMETIC OR LOGICAL
C         OPERATOR, THE D OR E IS PART OF A NUMERIC VALUE.
C
                     IF(CSTMT(I7:I7) .EQ. CPLUS .OR. CSTMTA(I7:I7) .EQ.
     1                  CMINUS .OR. CSTMTA(I7:I7) .EQ. CSLASH .OR.
     2                  CSTMTA(I7:I7) .EQ. CASTER .OR. CSTMTA(I7:I7)
     3                  .EQ. CSYMCD) GO TO 13
C
C         WHEN THE NON-NUMERIC CHARACTER IS ALPHABETIC, THE D OR E IS
C         PART OF A VARIABLE NAME.
C
                     IF(CSTMT(I7:I7) .GE. CAA .AND. CSTMTA(I7:I7) .LE.
     1                  CZZ .OR. CSTMTA(I7:I7) .EQ. CUNDER .OR.
     2                  CSTMTA(I7:I7) .EQ. CDOL) GO TO 111
                  END IF
                  END DO
               END IF
            END IF
         END IF
C
C         SET LOCATION OF THE START OF A VARIABLE NAME
C
 111     IF(.NOT.L1) THEN
            IVARKT = IVARKT + 1
C
C         WHEN THE TABLE LIMIT HAS BEEN REACHED, WRITE MESSAGE AND
C         EXIT LOOP : DO 13
C
            IF(IVARKT .GT. 500) THEN
               IREC0 = IREC0 + 1
               WRITE (0,101) ISN
               GO TO 14                   ! PROCESS 50 VARIABLES ONLY
            END IF
C
C         PLACE VARIABLE ISN AND START LOCATION IN CEXVAR TABLE
C
            IEXVAR(9,IVARKT) = ISN + 128  ! ISN VALUE
            IEXVAR(14,IVARKT) = I1        ! VARIABLE START LOCATION
            I3 = I1
            L1 = LTRUE
C
C         DETERMINE THE END LOCATION OF THE VARIABLE NAME
C
            DO 12 I2 = I1,J2
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER OF THE VARIABLE
C         NAME. A VARIABLE NAME MAY CONTAIN ALPHABETIC CHARACTERS,
C         NUMERIC CHARACTERS, AN UNDERSCORE, OR A DOLLAR SIGN.
C
            IF(CSTMTA(I2:I2) .GE. CAA .AND. CSTMTA(I2:I2) .LE. CZZ .OR.
     1         CSTMTA(I2:I2) .GE. C0 .AND. CSTMTA(I2:I2) .LE. C9 .OR.
     2         CSTMTA(I2:I2) .EQ. CUNDER .OR. CSTMTA(I1:I1) .EQ. CDOL)
     3         THEN
C
C         WHEN I2 IS THE FINAL CHARACTER OF THE ASSIGNMENT STATEMENT OR
C         EXPRESSION AND IS ALSO A CHARACTER THAT CAN BE PART OF A
C         VARIABLE NAME, SET UP CEXVAR ENTRY FOR THE VARIABLE NAME AND
C         EXIT THE DO LOOP
C
               IF(I2 .EQ. J2) THEN
                  I4 = J2
                  IF(CSTMTA(J2:J2) .GE. CAA .AND. CSTMTA(J2:J2) .LE.
     1               CZZ .OR. CSTMTA(J2:J2) .EQ. CUNDER .OR.
     2               CSTMTA(J2:J2) .EQ. CDOL) THEN
                     I5 = I4 - I3 + 1
                   ELSE
                     I5 = I4 - I3
                  END IF
                  IEXVAR(13,IVARKT) = I5       ! VARIABLE NAME LENGTH
                  CEXVAR(IVARKT)(1:I5) = CSTMTA(I3:I4) ! VARIABLE NAME
                  IEXVAR(15,IVARKT) = I4       ! END LOCATION
C
C         DETERMINE IF THIS VARIABLE NAME IS ALREADY CATALOGED WHEN
C         IT IS USED ON THE RIGHT SIDE OF THE EQUAL SIGN.
C
                  IF(L3 .AND. I4 .GT. IEQ) THEN
                     I6 = I - 1
C
C         DETERMINE IF THE VARIABLE NAME IS PART OF A COMPOUND VARIABLE
C
                     IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6) .EQ.
     1                  CPERC) THEN
                        GO TO 14          ! EXIT LOOP DO 12
                     END IF
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN CATALOGED
C
                     IF(BTEST(IEXVAR(12,I2),2) .OR. BTEST(IEXVAR(12,I2),
     1                  6)) THEN
                        GO TO 14          ! EXIT LOOP DO 12
                     ELSE
                        CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I2),1,
     1                     32,IRET,4000)
                        IF(IRET .LT. 0 .AND. .NOT.LCALL) THEN
                           IREC0 = IREC0 + 1
                           WRITE (0,103) ISN,CEXVAR(I1)(1:32)
                        END IF
                     END IF
                  END IF
                  GO TO 14                ! EXIT LOOP DO 12
               END IF
            ELSE
C
C         THE CURRENT CHARACTER AT LOCATION I2 IS NOT AN ALLOWED
C         CHARACTER IN A VARIABLE NAME. IT TERMINATES THE CURRENT
C         VARIABLE NAME.
C
               IF(I2 .LT. J2) THEN
                  I4 = I2
                  I5 = I4 - I1
                  IEXVAR(13,IVARKT) = I5       ! VARIABLE NAME LENGTH
                  I6 = I4 - 1
                  IEXVAR(15,IVARKT) = I6       ! END LOCATION
                  CEXVAR(IVARKT)(1:I5) = CSTMTA(I3:I6) ! VARIABLE NAME
                  I4WK1 = I2 + 1         ! START NEW SEARCH LOCATION
                  L1 = LFALSE
                  IF(CSTMT(I2:I2) .EQ. CEQ) IEQ = I2
C
C         DETERMINE IF THIS VARIABLE NAME IS ALREADY CATALOGED WHEN
C         IT US USED ON THE LEFT SIDE OF THE EQUAL SIGN.
C
                  IF(L3 .AND. IEQ .LT. I6) THEN
C
C         DETERMINE IF THE VARIABLE IS A STRUCTURE OR RECORD VARIABLE.
C         THEY ARE ALREADY DEFINED.
C
                     I6 = I - 1
                     IF(I6 .GE. I1) THEN
                        IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6)
     1                     .EQ. CPERC) THEN
                           I4WK1 = I2
                           GO TO 11
                        END IF
                     END IF
                     I6 = I + 1
                     IF(I6 .LE. J2) THEN
                        IF(CSTMTA(I6:I6) .EQ. CDOT .OR. CSTMTA(I6:I6)
     1                     .LE. CPERC) THEN
                           I4WK1 = I2
                           GO TO 11
                        END IF
                     END IF
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN DEFINED
C
                     CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,
     1                  IRET,4000)
                     IF(IRET .GT. 0 .AND. .NOT.LCALL) THEN
                        IREC0 = IREC0 + 1
                        WRITE (0,103) ISN,CEXVAR(I1)(1:32)
                     END IF
                  END IF
                  GO TO 11                ! NEXT VARIABLE
               END IF
            END IF
 12         CONTINUE
         END IF
      END IF
 13   CONTINUE
C
C         THE LEFT AND RIGHT BOUNDARIES ARE NOW KNOWN FOR ALL VARIABLE
C         NAMES.
C
C         SET ALL VARIABLES TYPE AND LENGTH CHARACTERISTICS IN ARRAY
C         CEXVAR FOR THE CURRENT ARITHMETIC ASSIGNMENT STATEMENT OR
C         EXPRESSION.
C
 14   DO 16 I1 = 1,IVARKT
C
C         SET SWITCH TO INCLUDE THIS VARIABLE IN THE OUTPUT LISTING
C         IF NOT PART OF AN INCLUDE INPUT FILE
C
      IF(.NOT.LINCL) IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),15)
C
C         A RECORD NAME MUST BE UNIQUE, AND IT CAN BE USED WITHIN
C         STRUCTURE AND MAP DEFINITIONS, BUT THE RECORD NAME IS DEFINED
C         OUTSIDE OF A STRUCTURE OR MAP DEFINITION. SINCE ALL
C         STRUCTURE AND RECORD DEFINTIONS MUST BE DEFINED BEFORE THE
C         FIRST EXECUTABLE STATEMENT, ALL RECORD, MAP, AND STRUCTURE
C         VARIABLES HAVE THEIR TYPE AND LENGTH CHARACTERISTICS KNOWN
C         AT THIS STAGE OF PROCESSING. A RECORD VARIABLE NAME USED IN
C         A STRUCTURE CAN HAVE AN IDENTICAL VARIABLE NAME DEFINED
C         WITHIN A STRUCTURE.
C
C         DETERMINE IF THE CURRENT VARIABLE NAME MATCHES A NAME IN
C         THE TABLE OF ALL RECORD VARIABLES. IRET > 0 WHEN A RECORD
C         NAME TABLE MATCHES.
C
      CALL TABSRH (CRECTB,IRECD,68,33,64,CEXVAR(I1),1,32,IRET,1000)
      IF(IRET .GT. 0) THEN
C
C         A RECORD VARIABLE NAME USED WITHIN AN ARITHMETIC ASSIGNMENT
C         OR AN EXPRESSION, MUST BE TERMINATED BY PERIOD OR A PRECENT
C         SIGN.
C
         IF(IEXVAR(15,I1) .LT. J2) THEN
C
C         THE VARIABLE NAME MAY BE A RECORD NAME
C
            I2 = IEXVAR(15,I1) + 1
            IF(CSTMTA(I2:I2) .EQ. CDOT .OR. CSTMTA(I2:I2) .EQ. CPERC)
     1         THEN
C
C         SET BIT SWITCH TO INDICATE THIS IS A RECORD VARIABLE
C
               IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),2)  ! RECORD BIT
C
C         OBTAIN THE LENGTH CHARACTERISTIC OF THE RECORD VARIABLE NAME
C
               CI4WK1(1:4) = CRECTB(IRET)(65:68)
               CALL ITOC (I4WK1,CWK7,1,7)
               CEXVAR(11)(37:44) = CQUES(1:1)//CWK7(1:7) ! TYPE & LENGTH
C
C         DETERMINE IF THE RECORD NAME IS USED WITHIN A STRUCTURE. THE
C         LENGTH OF A RECORD VARIABLE IS DEFINED BY THE STRUCTURE TO
C         WHICH IT REFERS, NOT THE STRUCTURE THAT USES IT.
C
               CALL TABSRH (CVARST,NVARST,72,1,32,CEXVAR(I1),1,32,IRET1,
     1            1000)
C
C         SET THE BIT TO INDICATE THE VARIABLE NAME IS USED WITHIN A
C         A STRUCTURE
C
               IF(IRET1 .GT. 0) THEN
                  IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),6) ! STRUCTURE
               ELSE
                  IEXVAR(12,I1) = IBCLR(IEXVAR(12,I1),6) ! NO STRUCTURE
               END IF
            ELSE
C
C         ILLEGAL USE OF A RECORD VARIABLE
C
               CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET,
     1                     4000)
C
C         DO NOT WRITE ERROR MESSAGE IF THE RECORD NAME IS USED AS AN
C         ARGUMENT OR IS DIMENSIONED.
C
               IF(IRET .GT. 0 .AND. .NOT.BTEST(IENAME(9,IRET),7) .AND.
     1            .NOT.BTEST(IENAME(9,IRET),17)) THEN
                  IREC0 = IREC0 + 1
                  WRITE (0,102) ISN
                  GO TO 15
               END IF
            END IF
         ELSE
            CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET,4000)
C
C         DO NOT WRITE ERROR MESSAGE IF THE RECORD NAME IS USED AS AN
C         ARGUMENT OR IS DIMENSIONED.
C
            IF(IRET .GT. 0 .AND. .NOT.BTEST(IENAME(9,IRET),7) .AND.
     1         .NOT.BTEST(IENAME(9,IRET),17)) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102) ISN
               GO TO 15
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED WITHIN A STRUCTURE
C
 15   CALL TABSRH (CVARST,NVARST,72,1,32,CEXVAR(I1),1,32,IRET,1000)
      IF(IRET .GT. 0) THEN
         CEXVAR(I1)(37:44) = CVARST(IRET)(66:72)  ! TYPE & LENGTH
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),6)   ! STRUCTURE BIT
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED WITHIN A UNION
C
      CALL TABSRH (CUNION,IUNION,44,1,32,CEXVAR(I1),1,32,IRET,500)
      IF(IRET .GT. 0) THEN
         CEXVAR(I1)(37:44) = CUNION(IRET)(33:40)  ! TYPE & LENGTH
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),5)   ! UNION BIT
      END IF
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
      CALL TABSRH (CDIM,JDIM,104,1,32,CEXVAR(I1),1,32,IRET,1000)
      I7 = IEXVAR(15,I1) + 1
      IF(IEXVAR(15,I1) .LE. J2) THEN
         IF(CSTMTA(I7:I7) .EQ. CBLANK) THEN
         I6 = IEXVAR(15,I1)
      ELSE
         I6 = IEXVAR(15,I1) + 1
      END IF
      IF(IRET .GT. 0) THEN
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),17)  ! DIMENSION BIT
C
C         WHEN THE VARIABLE IS DIMENSIONED, IT HAS ALREADY BEEN CATALOGED
C         IN ARRAY CNAME, AND ITS TYPE AND LENGTH IS KNOWN. RETRIEVE
C         THOSE CHARACTERISTICS FROM CNAME.
C
         IF(BTEST(IEXVAR(12,I1),6)) THEN
C
C         THE VARIABLE EXISTS IN A STRUCTURE DEFINITION
C
            CALL TBLSRH (CNAME,INAME,52,1,32,CEXVAR,1,32,IRET4,4000)
            IF(IRET4 .GT. 0) CEXVAR(I1)(37:44) = CNAME(IRET)(37:44)
         ELSE
C
C         THE VARIABLE DOES NOT EXIST IN A STRUCTURE DEFINITION
C
            CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET4,4000)
            IF(IRET4 .GT. 0) CEXVAR(I1)(37:44) = CNAME(IRET4)(37:44)
         END IF
C
C         DETERMINE IF A SUBSCRIPT FOLLOWS THE DIMENSIONED VARIABLE
C
         CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET2,4000)
         IF(.NOT.BTEST(IENAME(12,IRET2),7)) THEN
            IENAME(12,IRET2) = IBSET(IENAME(12,IRET2),7)
            IF(CSTMTA(I6:I6) .NE. CLPAR .AND. CSTMTA(I6:I6) .NE. CRPAR
     1         .AND. CSTMTA(I6:I6) .NE. COMMA) THEN
               IRET0 = IRET0 + 1         ! NO SUBSCRIPT, DIMENSIONED
               WRITE (0,CF100) ISN,CEXVAR(I1)(1:32)
            ELSE IF(CSTMTA(I6:I6) .EQ. CLPAR .AND. IRET .LT. 0) THEN
               I2WK1 = 1
               CALL TABSRH (CMACRO,25,32,1,32,CEXVAR(I1),1,32,IRET3,25)
               IF(IRET3 .LT. 0) THEN
                  IRET0 = IRET0 + 1      ! SUBSCRIPT, NOT DIMENSIONED
                  WRITE (0,CF101) ISN,CEXVAR(I1)(1:32)
                  END IF
               END IF
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE VARIABLE IS IN COMMON
C
      IRET = 1
      DO WHILE (IRET .LE. IREC11-1)
      READ (11,REC=IRET) CWK44(1:44)
      IF(CWK44(1:32) .EQ. CEXVAR(I1)(1:32)) THEN
         CEXVAR(I1)(37:44) = CWK44(37:44)       ! LENGTH & TYPE
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),1)
         GO TO 160
      END IF
      IRET = IRET + 1
      END DO
C
C         DETERMINE IF THE VARIABLE IS A DEFINED ENTRY, FUNCTION, OR
C         SUBROUTINE
C
 160  CALL TABSRH (FUNTBL,143,35,1,32,CEXVAR(I1),1,32,IRET,143)
      IF(IRET .GT. 0 .AND. IEQ .EQ. 0) THEN
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),10)  ! DEFINED FUNCTION
         IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),16)  ! INTRINSIC FUNCTION
         CEXVAR(I1)(37:39) = FUNTBL(IRET)(33:35)  ! TYPE & LENGTH
      END IF
C
C         DETERMINE IF THE VARIABLE IS A PARAMETER VARIABLE
C
      CALL TABSRH (CPARAM,IP,52,1,32,CEXVAR(I1),1,32,IRET,4000)
      IF(IRET .GT. 0) IEXVAR(12,I1) = IBSET(IEXVAR(12,I1),14)
C
C         DETERMINE IF THE VARIABLE IS ALREADY IN TABLE CNAME
C
      CALL TABSRH (CNAME,INAME,52,1,32,CEXVAR(I1),1,32,IRET,4000)
      IF(IRET .GT. 0) THEN
         IF(CNAME(IRET)(37:44) .NE. CBLANK(1:8)) THEN
            CEXVAR(I1)(37:44) = CNAME(IRET)(37:44)
         ELSE
C
C         DETERMINE THE TYPE AND LENGTH CODE WHEN THE VARIABLE IS NOT
C         IN CNAME
C
            IF(CEXVAR(I1)(37:44) .EQ. CBLANK(1:8)) THEN
C
C         WHEN THE VARIABLE IN CEXVAR HAS NO TYPE AND LENGTH CHARACTER-
C         ISTIC, DETERMINE THE TYPE AND LENGTH FROM THE DEFAULT VALUES
C         IN CIMPL.
C
               CALL SETTL (CEXVAR(I1))    ! TYPE & LENGTH
            END IF
         END IF
      END IF
 16   CONTINUE
C
C         ALL VARIABLE NAMES OCCURRING IN AN ARITHMETIC ASSIGNMENT
C         STATEMENT OR AN EXPRESSION HAVE THEIR CHARACTERISTICS SET,
C         EXCEPT FOR THE POSSIBLE USE AS AN ARGUMENT IN A FUNCTION
C         CALL. SUBSCRIPT VARIABLES AND CHARACTER RANGE SPECIFICATIONS
C         ARE NOT TREATED AS ARGUMENTS.
C
      DO 19 I1 = 1,IVARKT
C
C         DETERMINE IF A VARIABLE IS A FUNCTION CALL. AN ENTRY OR
C         SUBROUTINE NAME CAN NOT OCCUR IN AN ARITHMETIC ASSIGNMENT
C         OR AN EXPRESSION.
C
      IF(BTEST(IEXVAR(12,I1),16) .OR. BTEST(IEXVAR(12,I1),10)) THEN
C
C         LOCATE THE LEFT AND RIGHT ENCAPSULATING PARENTHESES, IF ANY,
C         OF THE ARGUMENT LIST.
C
         L1 = LFALSE
         I3 = IEXVAR(15,I1) + 1
         IOPENP = 0
         DO 17 I2 = I3,J2
         IF(CSTMTA(I2:I2) .EQ. CLPAR) THEN
            IOPENP = IOPENP + 1
            IF(.NOT.L1) I4 = I2
            L1 = LTRUE
         END IF
         IF(CSTMTA(I2:I2) .EQ. CRPAR) THEN
            IOPENP = IOPENP - 1
            IF(IOPENP .EQ. 0) THEN
               I5 = I2
               L1 = LFALSE
               IF(I4+1 .EQ. I5) GO TO 20  ! ARGUMENT LIST IS ()
               GO TO 18
            END IF
         END IF
 17      CONTINUE
C        END IF
C
C         WHEN EXECUTION EXITS THE DO LOOP NORMALLY, THERE IS NO
C         ARGUMENT LIST FOR THIS FUNCTION.
C
         GO TO 20
C
C         THE LEFT AND RIGHT BOUNDARIES OF THE FUNCTION'S ARGUMENT LIST
C         ARE NOW KNOWN.
C
 18      LCALL = LTRUE
         JA = IEXVAR(14,I1)
         CALL ARGLST (CEXVAR(I1)(37:37),CSTMTA,I5)
         LCALL = LFALSE
      END IF
 19   CONTINUE
C
C         INSURE ALL VARIABLE NAMES IN CEXVAR ARE PLACED IN CNAME
C
 20   DO 21 I1 = 1,IVARKT
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CWORK(1:52) = CEXVAR(I1)(1:52)
      CALL CHKNME (CSTMTA)
 21   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *      PROCESS ALL NUMBERS: FLOATING, INTEGER, AND REAL          *
C     *                                                                *
C     ******************************************************************
C
C         ANY NUMERICAL DIGIT MUST BE PRECEDED OR FOLLOWED BY AN ARITH-
C         METIC OPERATOR: A PLUS SIGN, MINUS SIGN, ASTERISK, OR SLASH.
C         A LEFT PARENTHESIS MAY PRECEDE A DIGIT AND A RIGHT PARENTHESIS
C         MAY FOLLOW A DIGIT.
C
C         LOCATE THE START AND END LOCATIONS OF A NUMBER SPECIFICATION
C
      I4WK1 = J1
      J2 = JFINAL
 22   DO 24 I1 = I4WK1,J2
      IF(CSTMTA(I1:I1) .GE. C0 .AND. CSTMTA(I1:I1) .LE. C9) THEN
C
C         IGNORE DIGITS THAT ARE PART OF A VARIABLE NAME
C
         DO 23 I2 = 1,IVARKT
         IF(I1 .GE. IEXVAR(14,I2) .AND. I1 .LE. IEXVAR(15,I2)) GO TO 24
 23      CONTINUE
C
C         WHEN A DIGIT IS NOT PART OF A VARIABLE NAME, IT MUST BE A
C         NUMERICAL VALUE.
C
         L2 = LTRUE
         FPP = FP
         KB = J2
         CALL NUMBER (CSTMTA,L2,I1,II,FP,IFP)
         KB = J2
         IF(L2) THEN
            CALL INSERT (II)              ! INTEGER
         ELSE
            CALL FCHECK                   ! FLOATING
         END IF
         IF(IFP .GE. J2) GO TO 25         ! EXIT
         FP = FPP
         I4WK1 = IFP + 1
         IF(IFP .GE. J2) THEN
            GO TO 25
         ELSE
            I4WK1 = IFP + 1
            IF(I4WK1 .GE. J2) GO TO 25
            GO TO 22
         END IF
      END IF
 24   CONTINUE
C
C         ROUTINE EXIT
C
 25   KB = KFINAL
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES A FILE MANIPULATION CONTROL LIST.
C        IT DOES NOT PROCESS INPUT-OUTPUT LISTS FOR READ AND WRITE
C        STATEMENTS.
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDOT   - CHARACTER VARIABLE, A PERIOD: .
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IIB
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLIST  -  THE SUBSCRIPT ID CHOOSES THE ARGUMENT TO BE
C                   PROCESSED.  THE LENGTH OF EACH ARGUMENT IS STORED IN
C                   ARRAY ILIST.
C
C                   SUBSCRIPT ARGUMENT           SUBSCRIPT  ARGUMENT
C                    NUMBER  PROCESSED            NUMBER   PROCESSED
C
C                      1     ACCESS                24      MODE
C                      2     ACTION
C                      3     ASSOCIATEVARIABLE     25      NAME
C                      4     BINARY                26      NAMED
C                      5     BLANK                 27      NEXTREC
C                      6     BLOCKSIZE             28      NML
C                      7     BUFFERCOUNT           29      NOSPANBLOCKS
C                      8     CARRIAGECONTROL       30      NUMBER
C                      9     DIRECT                31      OPENED
C                     10     DISP                  32      ORGANIZATION
C                     11     DISPOSE               33      READONLY
C                     12     END                   34      REC
C                     13     ERR                   35      RECL
C                     14     EXIST                 36      RECORDSIZE
C                     15     EXTENDSIZE            37      RECORDTYPE
C                     16     FILE                  38      SEQUENTIAL
C                     17     FMT                   39      SHARE
C                     18     FORM                  40      SHARED
C                     19     FORMATTED             41      STATUS
C                     20     INITIALSIZE           42      TYPE
C                     21     IOSTAT                43      UNFORMATTED
C                     22     KEY                   44      UNIT
C                     23     KEYED                 45      USEROPEN
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM, INCLUDING ALL VARIABLE NAMES
C                  BROUGHT INTO A PROGRAM MODULE BY USING AN INCLUDE
C                  STATEMENT.
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWK32  - CHARACTER VARIABLE, USED TO SET THE VARIABLE NAME IN
C                  CWORK
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS ON UNIT 4, EQUIVALENCED TO IWR
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF A VARIABLE NAME
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN CCONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         ID     - INDEX VALUE OF THE ARGUMENT IN ARRAY CLIST TO BE
C                  PROCESSED
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - RETURN VALUE OF AN INTEGER NUMBER FROM SUBROUTINE
C                  NUMBER
C         IIB    - EQUIVALENCED TO CIB
C         IISN   - EQUIVALENCED TO CISN
C         ILIST  - THE LENGTH OF EACH ARGUMENT IN ARRAY CLIST
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET1  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET2  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         IWR    - OUTPUT BUFFER FOR UNIT 4, EQUIVALENCED TO CWR
C         I1     - LOCATION OF THE FIRST CHARACTER FOLLOWING AN EQUAL
C                  SIGN
C         I2WK1  - WORK AREA TO CONVERT AN ALPHABETIC CHARACTER TO AN
C                  INTEGER TO USE AS AN INDEX WITH ARRAY CIMPL
C         I3     - SUBSCRIPT VARIABLE
C         I4     - THE LOCATION FO THE FINAL CHARACTER IN A NUMERIC
C                  FIELD
C         I5     - COUNT OF THE NUMBER OF PARENTHESES. ONE IS ADDED
C                  FOR A LEFT PARENTHESIS; ONE IS SUBTRACTED FOR A
C                  RIGHT PARENTHESIS
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JA     - LENGTH OF THE VALUE IN THE CLIST ARRAY OF ARGUMENTS
C         JB     - END LOCATION OF A VARIABLE NAME OR NUMBER
C         JD     - LOCATION OF THE CURRENT CHARACTER
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS PROCESSED AND THE
C                  ARGUMENT IS A VARIABLE NAME; THIS PERMITS A SEARCH
C                  FOR POSSIBLE SUBSCRIPT VARIABLES OR CONSTANTS.
C                  SET FALSE OTHERWISE. THIS IS USED TO FORCE A NEW LOOP
C                  SEQUENCE IN THE CALLING ROUTINE.
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN A PARTICULAR COMMAND
C                  LIST ARGUMENT HAS BEEN PROCESSED, SET FALSE OTHERWISE
C         LC     - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE COMPOUND
C                  VARIABLE NAME EXISTS, SET FALSE OTHERWISE
C         LD     - LOGICAL WORK VARIABLE
C         LEXIST - LOGICAL VARIABLE, SET TRUE IF WORK FILES USED BY THIS
C                  PROGRAM EXIST, SET FALSE OTHERWISE
C         LF     - LOGICAL WORK VARIABLE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A LITERAL, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A VARIABLE, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHESIS
C                  OCCURS IN AN ARGUMENT, SET FALSE OTHERWISE. THIS
C                  MEANS A SUBSCRIPT EXISTS.
C         L6     - LOGICAL VARIABLE, SET TRUE ONCE FORMAT 101 IS USED,
C                  SET FALSE OTHERWISE. PREVENTS DULICATE ERROR MESSAGES
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN A RIGHT PARENTHESIS
C                  FOLLOWS A DIGIT, PREVENT MODIFICATION OF THE LOCATION
C                  IN CSTMT IN VARIABLE J, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FOLLOWING STATEMENTS CONTAIN INPUT-OUTPUT CONTROL LISTS
C
C         BACKSPACE, DECODE, ENCODE, INQUIRE, OPEN, READ, REWIND, WRITE
C
C         INDEX VALUES FOR CONTROL ARGUMENTS IN TABLE CLIST
C
C     INDEX ARGUMENT       INDEX ARGUMENT          INDEX ARGUMENT
C       1   ACCESS           2   ACTION
C       3  ASSOCIATEVARIABLE 4   BINARY              5   BLANK
C       6   BLOCKSIZE        7   BUFFERCOUNT         8   CARRIAGECONTROL
C       9   DIRECT          10   DISP               11   DISPOSE
C      12   END             13   ERR                14   EXIST
C      15   EXTENDSIZE      16   FILE               17   FMT
C      18   FORM            19   FORMATTED          20   INITIALSIZE
C      21   IOSTAT          22   KEY                23   KEYED
C      24   MODE            25   NAME               26   NAMED
C      27   NEXTREC         28   NML                29   NOSPANBLOCKS
C      30   NUMBER          31   OPENED             32   ORGANIZATION
C      33   READONLY        34   REC                35   RECL
C      36   RECORDSIZE      37   RECORDTYPE         38   SEQUENTIAL
C      39   SHARE           40   SHARED             41   STATUS
C      42   TYPE            43   UNFORMATTED        44   UNIT
C      45   USEROPEN
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C
C     SUBROUTINES CALLED
C
C         IBSET INSERT NUMBER SETTL TABSRH TBLSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE CIOLST
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CLIST(45), ILIST(45), IWR(2), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE
C
      CHARACTER*17 CLIST
      CHARACTER*8  CWR
      CHARACTER*4  CIB, CISN
      LOGICAL*1    LA, LB, LC, LD, L1, L2, L3, L4, L5, L6, L7
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/ ID,LB,L1,L2,L3,L4,LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWR,IWR), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS FOR THIS ROUTINE ONLY
C
      DATA CLIST /'ACCESS           ','ACTION           ',
     1'ASSOCIATEVARIABLE','BINARY           ','BLANK            ',
     2'BLOCKSIZE        ','BUFFERCOUNT      ','CARRIAGECONTROL  ',
     3'DIRECT           ','DISP             ','DISPOSE          ',
     4'END              ','ERR              ','EXIST            ',
     5'EXTENDSIZE       ','FILE             ','FMT              ',
     6'FORM             ','FORMATTED        ','INITIALSIZE      ',
     7'IOSTAT           ','KEY              ','KEYED            ',
     8'MODE             ','NAME             ','NAMED            ',
     9'NEXTREC          ','NML              ','NOSPANBLOCKS     ',
     A'NUMBER           ','OPENED           ','ORGANIZATION     ',
     B'READONLY         ','REC              ','RECL             ',
     C'RECORDSIZE       ','RECORDTYPE       ','SEQUENTIAL       ',
     D'SHARE            ','SHARED           ','STATUS           ',
     E'TYPE             ','UNFORMATTED      ','UNIT             ',
     F'USEROPEN         '/
      DATA ILIST /6,6,15,6,5,9,11,15,6,4,7,3,3,5,10,4,3,4,9,11,6,3,5,4,
     14,5,7,3,12,6,6,12,8,3,4,10,10,10,5,6,6,4,11,4,8/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO CLOSING COMMA OR RIGHT PARENTHESIS')
 101  FORMAT(' ISN:',I6,' A NUMERICAL FIELD CONTAINS AN ALPHABETIC CHARA
     1CTER')
 102  FORMAT(' ISN:',I6,' CONTROL LIST ARGUMENT VALUE MUST BE A CHARACTE
     1R VARIABLE')
 103  FORMAT(' ISN:',I6,' CONTROL LIST ARGUMENT VALUE MUST BE AN INTEGER
     1 VARIABLE')
 104  FORMAT(' ISN:',I6,' CONTROL LIST ARGUMENT VALUE MUST BE A LOGICAL
     1VARIABLE')
 105  FORMAT(' ISN:',I6,' CONTROL LIST ARGUMENT VALUE MUST BE A STATEMEN
     1T NUMBER')
C
C         BLANK CHARACTER WORK AREA
C
      LA = LFALSE
      L7 = LFALSE
C
C         TEST IF AN INPUT-OUTPUT COMMAND LIST ARGUMENT MATCHES
C
      JA = ILIST(ID)
      JD = J + JA - 1
      L5 = LFALSE
      L6 = LFALSE
      IF(CSTMT(J:JD) .EQ. CLIST(ID)(1:JA)) THEN
         JD = JD + 2
C
C         SET LOGICAL SWITCH TO INDICATE A CONTROL ARGUMENT HAS BEEN
C         PROCESSED. THIS PREVENTS DUPLICATE ARGUMENTS IN A STATEMENT.
C
         LB = LTRUE
C
C         DETERMINE IF THIS PARAMETER IS KEY. A KEY PARAMETER DOES
C         NOT CONFORM TO ANY OTHER PARAMETER. NONE OF ITS ARGUMENTS
C         ARE PROCESSED.
C
         I5 = 0
         IF(CSTMT(J:J+3) .EQ. 'KEY=') THEN
            DO 10 I3 = J+4,KB
            IF(CSTMT(I3:I3) .EQ. CLPAR) I5 = I5 + 1
            IF(CSTMT(I3:I3) .EQ. CRPAR) I5 = I5 - 1
            IF(CSTMT(I3:I3) .EQ. COMMA .AND. I5 .EQ. 0) THEN
               IF(I3 .EQ. KB) THEN
                  J = KB
               ELSE
                  J = I3
               END IF
               LA = LTRUE
               LB = LTRUE
               GO TO 15
            END IF
 10         CONTINUE
         END IF
C
C         DETERMINE IF ANY VALUES ARE ALLOWED FOR AN ARGUMENT
C
         IF(.NOT.L1 .AND. .NOT.L2 .AND. .NOT.L3 .AND. .NOT.L4) THEN
            J = JD
            GO TO 14
         END IF
C
C         CORRECT IF ASSOCIATEVARIABLE INSTEAD OF ASSOCIATEVARIAB IS
C         SPECIFIED
C
         IF(ID .EQ. 2 .AND. CSTMT(J:JD) .EQ. CLIST(ID)(1:JA+2)) THEN
            JD = JD + 2
         END IF
         LA = LTRUE
C
C         DETERMINE IF THE ARGUMENT IS AN ASTERISK OR A LITERAL
C
         IF(L1 .AND. (CSTMT(I1:I1) .EQ. CASTER .OR. CSTMT(I1:I1) .EQ.
     1      CSYMCF)) THEN
C
C         SET LOGICAL SWITCH TO INDICATE IF THE NUMBER IS AN INTEGER OR
C         A FLOATING POINT REAL NUMBER
C
            JB = JD + 1
            LD = LTRUE
            GO TO 14
         END IF
C
C         DETERMINE THE END LOCATION OF THE ARGUMENT LIST VALUE
C
 11      CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         I1 = JD
         DO 12 I3 = JD,KB
C
C         TEST FOR THE END OF THE FIELD
C
         IF(CSTMT(I3:I3) .EQ. COMMA .OR. CSTMT(I3:I3) .EQ. CRPAR .OR.
     1      CSTMT(I3:I3) .EQ. CLPAR .OR. CSTMT(I3:I3) .EQ. COLON) THEN
            CWK32(1:32) = CBLK52(1:32)
            JB = I3 - 1
            IC = I3 - I1
            IVCNT = IC
            IF(CSTMT(I3:I3) .EQ. CLPAR) L5 = LTRUE
            CWK32(1:IC) = CSTMT(JD:JB)
            GO TO 13
         END IF
C
C         TEST IF A REQUIRED NUMERICAL FIELD CONTAINS A CHARACTER
C
         IF(L2 .AND. L4) THEN
            IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I3:I3) .LE. CZZ .OR.
     1         CSTMT(I3:I3) .EQ. CUNDER) L4 = LFALSE
         END IF
         IF((L3 .AND. .NOT.L2) .OR. L4) THEN
            IF(.NOT.(ID .EQ. 17 .AND. CSTMT(JD:JD) .EQ. CASTER)) THEN
               LD = .NOT.(CSTMT(I3:I3) .GE. C0 .AND. CSTMT(I3:I3) .LE.
     1         C9)
               IF(.NOT.L6 .AND. LD .AND. .NOT.LINCL) THEN
                  WRITE (0,101) ISN
                  IREC0 = IREC0 + 1
                  L6 = LTRUE
               END IF
            END IF
         END IF
 12      CONTINUE
C
C         AN ERROR OCCURRED, NO CLOSING COMMA OR RIGHT PARENTHESIS
C
         IF(.NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         PROCESS THE ARGUMENT OF THE CONTROL LIST PARAMETER VARIABLE
C         NAME
C
 13      LD = LTRUE
         CWORK(1:32) = CWK32(1:32)
C
C         DETERMINE IF THE CONTROL ARGUMENT VARIABLE NAME IS OF THE
C         CORRECT TYPE. TEST FOR A CHARACTER VARIABLE TYPE.
C
         IF(ID .GE. 1 .AND. ID .LE. 5 .OR. ID .GE. 8 .AND. ID .LE. 11
     1      .OR. ID .EQ. 14 .OR. ID .GE. 16 .AND. ID .LE. 18 .OR. ID
     2      .EQ. 21 .OR. ID .GE. 23 .AND. ID .LE. 28 .OR. ID .GE. 30
     3      .AND. ID .EQ. 32 .OR. ID .EQ. 37 .AND. ID .LE. 39 .OR.
     4      ID .GE. 41 .AND. ID .LE. 45)  THEN
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               IF(CNAME(IRET)(37:37) .NE. CCC) THEN
                  WRITE (0,102) ISN
                  IREC0 = IREC0 + 1
               END IF
            END IF
         END IF
C
C         TEST FOR AN INTEGER VARIABLE TYPE
C
         IF(ID .EQ. 3 .OR. ID .EQ. 6 .OR. ID .EQ. 7 .OR.
     1      ID .EQ. 20 .OR. ID .EQ. 21 .OR. ID .EQ. 30
     2      .OR. ID .EQ. 34 .AND. ID .LE. 36 .OR.
     3      ID .EQ. 44) THEN
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               IF(CNAME(IRET)(37:37) .NE. CII) THEN
                  WRITE (0,103) ISN
                  IREC0 = IREC0 + 1
               END IF
            ELSE
               CALL SETTL (CWORK)
               CWORK(37:37) = CII
            END IF
         END IF
C
C         TEST FOR A LOGICAL VARIABLE TYPE
C
         IF(ID .EQ. 14 .OR. ID .EQ. 26 .OR. ID .EQ. 31) THEN
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0 .AND. CNAME(IRET)(37:37) .NE. CLL) THEN
               IF(CNAME(IRET)(37:37) .NE. CLL) THEN
                  WRITE (0,104) ISN
                  IREC0 = IREC0 + 1
               END IF
            ELSE
               CWORK(37:44) = CNAME(IRET)(37:44)
            END IF
         END IF
C
C         TEST FOR A STATEMENT NUMBER ARGUMENT VALUE
C
         IF(ID .EQ. 12 .OR. ID .EQ. 13) THEN
            IF(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9)
     1         THEN
               IF(.NOT.LINCL) THEN
                  L7 = LTRUE
                  CALL NUMBER (CSTMT,L7,I1,II,FP,IFP)
                  IIB = II + 128
                  IISN = ISN + 128
                  CWR(1:4) = CIB(1:4)
                  CWR(5:8) = CISN(1:4)
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR
               END IF
            ELSE
               WRITE (0,105) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
C
C         PROCESS THE ARGUMENT OF THE CONTROL LIST PARAMETER VARIABLE
C         NAME
C
         IF(L2) THEN
            IF(CSTMT(I1:I1) .GE. CAA .AND. CSTMT(I1:I1) .LE. CZZ .OR.
     1         CSTMT(I1:I1) .EQ. CUNDER) THEN
               JBITS = IBSET(JBITS,7)
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET2,4000)
               IF(IRET2 .GT. 0) THEN
                  CWORK(37:44) = CNAME(IRET2)(37:44)
                  CWORK(45:48) = CNAME(IRET2)(45:48)
                  IF(BTEST(JBITS,10)) CALL VSETUP (I1,JB,IC-1,LFALSE,
     1               LFALSE,CSTMT)
               ELSE
C
C         THE VARIABLE NAME IS NOT IN THE MASTER NAME TABLE
C
                  CALL CHKNME (CSTMT)
               END IF
               LA = LTRUE
               LD = LTRUE
C
C         IF A LEFT PARENTHESIS OCCURRED, THE VARIABLE NAME IS
C         SUBSCRIPTED, OR IT MAY HAVE CHARACTER SUBSTRING
C         SPECIFICATIONS; IF A PERIOD OR A PERCENT SIGN OCCURS, THE
C         VARIABLE IS A STRUCTURE COMPOUND VARIABLE NAME.
C
               IF(L5 .OR. LC) THEN
                  JD = JB + 2
                  I1 = JD
                  IF(CSTMT(I3:I3) .EQ. CRPAR) THEN
                     L5 = LFALSE
C
C         DETERMINE IF THE END OF THE CONTROL LIST HAS BEEN REACHED
C
                     IF(JD .GE. KB) GO TO 14
                  END IF
                  IF(CSTMT(JD:JD) .GE. C0(1:1) .AND. CSTMT(JD:JD)
     1               .LE. C9(1:1)) THEN
                     CALL NUMBER (CSTMT,LTRUE,JD,II,FP,I4)
                     IF(.NOT.LINCL) CALL INSERT (II)
                     JD = I4 + 1
                  END IF
                  IF(CSTMT(I3:I3) .EQ. CDOT .OR. CSTMT(I3:I3) .EQ. '%')
     1               LC = LFALSE
                  IF(CSTMT(I3:I3) .EQ. CLPAR) JD = I3 + 1
                  IF(CSTMT(I3:I3) .EQ. COLON) JD = I3 + 1
                  GO TO 11
               END IF
               GO TO 14
            END IF
         END IF
C
C         PROCESS A NUMERICAL FIELD
C
         IF(CSTMT(JD:JD) .GE. C0 .AND. CSTMT(JD:JD) .LE. C9) THEN
            CALL NUMBER (CSTMT,LTRUE,JD,II,FP,IFP)
            JB = IFP + 1
C
C         PLACE THE NUMERICAL CONSTANT IN THE CONSTANT SAVE TABLE
C
            IF(.NOT.LINCL) THEN
               IF(L3)CALL INSERT (II)
C
C         WRITE THE REFERENCED STATEMENT NUMBER ON UNIT 4
C
               IF(L4 .AND. ID .NE. 12 .AND. ID .NE. 13) THEN
                  IWR(1) = II + 128
                  IWR(2) = ISN + 128
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR(1:8)
               END IF
            END IF
            LD = LTRUE
            IF(CSTMT(JB:JB) .EQ. COLON .OR. CSTMT(JB:JB) .EQ. CLPAR)
     1         THEN
               JD = JB + 1
               GO TO 11
            END IF
            IF(CSTMT(IFP+1:IFP+1) .EQ. CRPAR) THEN
               IF(CSTMT(IFP+2:IFP+2) .NE. CBLANK(1:1)) LA = LFALSE
               L7 = LTRUE
               J = IFP + 1
            END IF
         END IF
C
C         SET THE NEXT ARGUMENT LOCATION
C
 14      IF(JB .GE. KB .OR. L7) GO TO 15
         J = JB + 1
         JB = J
         IF(CSTMT(J:J) .EQ. COMMA .OR. CSTMT(J:J) .EQ. COLON) J = J + 1
      END IF
C
C         ROUTINE EXIT
C
 15   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE WILL PROCESS AN INPUT-OUTPUT LIST FROM ALL
C         STATEMENTS THAT USE ONE
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO RESET VARIABLE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CI2WK1 - CHARACTER VARIABLE, WORK AREA
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C9      - CHARACTER VARIABLE, THE CHARACTER: 9
C         IA     - SUBSCRIPT VARIABLE
C         IB     - THE FINAL CHARACTER OF A FIELD
C         IC     - THE LENGTH OF THE FIELD
C         ID     - DO LOOP PARAMETER
C         IE     - LOCATION OF THE END OF A FIELD, USED TO COMPUTE IB
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         IG     - SUBSCRIPT VARIABLE
C         IH     - SAVE AREA FOR THE END LOCATION OF AN EXPRESSSION IN
C                  IOLIST
C         II     - RETURN VALUE AN INTEGER CONVERTED TO BINARY
C         IJ     - COUNT OF PARENTHESES IN AN ARITHMETIC EXPRESSSION
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET1  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISNU   - THE ISN OF THE CURRENT STATEMENT + 128, EQUIVALENCED
C                  TO CUSE1
C         ISN    - THE INTERNAL STATEMENT NUMBER
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - SUBSCRIPT VARIABLE
C         I2     - WORK AREA
C         I2WK1  - WORK AREA
C         I3     - WORK AREA
C         J      - THE LOCATION OF THE FIRST CHARACTER OF THE LIST
C         JA     - DO LOOP PARAMETER
C         KB     - THE LOCATION OF THE LAST CHARACTER OF THE LIST
C         LA     - LOGICAL VARIABLE, WORK VARIABLE
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN THE END OF A COMMOAND
C                  LIST HAS BEEN FOUND, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS FOLLOWING A DIGIT, SET FALSE OTHER-
C                  WISE. THIS ALLOWS DIFFERENTIATION BETWEEN A SUBSCRIPT
C                  THAT IS A NUMBER AND AN ARITHMETIC ESPRESSION.
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         EACH ITEM OF AN INPUT-OUTPUT LIST MAY BE ONE OF THE FOLLOWING:
C
C        1. A VARIABLE NAME
C           A. NOT DIMENSIONED
C              1. DATA TYPE NOT CHARACTER - N0 SUBSCRIPTS
C              2. CHARACTER DATA TYPE - CHARACTER RANGE SPECIFICATIONS
C           B. DIMENSIONED VARIABLES - SUBSCRIPT SPECIFICATIONS
C              1. DATA TYPE NOT CHARACTER - SUBSCRIPT SPECIFICATIONS
C              2. CHARACTER DATA TYPE - CHARACTER RANGE SPECIFICATIONS
C                                       AND SUBSCRIPT SPECIFICATIONS
C           C. ANY ITEM IN THE LIST MAY BE AN EXPRESSION, BUT A
C              CHARACTER VARIABLE EXPRESSION MAY NOT HAVE A CONCANTENAT-
C              INATION EXPRESSION UNLESS ALL VARIABLES IN THE EXPRESSION
C              HAVE DEFINED LENGTHS WHEN THE PROGRSAM IS COMPILED.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         7      - THE VARIABLE NAMES AND THE ISN WHERE THEY OCCUR
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR INSERT NUMBER SETTL TABSRH TBLSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE PIOLST
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA, LB, L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         BLANK THE CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         SET DO LOOP START VALUE
C
      JA = J
      LB = LFALSE
C
C         SCAN FROM LEFT TO RIGHT
C
 10   DO 15 I1 = JA,KB
C
C         TEST IF THE INITIAL CHARACTER IS A DELIMITER CHARACTER
C
      IF((CSTMT(I1:I1) .EQ. CLPAR(1:1) .OR. CSTMT(I1:I1) .EQ. CRPAR(1:1)
     1   .OR. CSTMT(I1:I1) .EQ. COMMA(1:1) .OR. CSTMT(I1:I1) .EQ. COLON
     2   .OR. CSTMT(I1:I1) .EQ. CEQ(1:1)) .AND. I1 .EQ. JA) GO TO 15
C
C         TEST IF THE CHARACTER IS A BLANK; IF TRUE, THIS IS THE END
C         OF THE IO LIST
C
      IF(CSTMT(I1:I1) .EQ. CBLANK(1:1)) GO TO 15
C
C         TEST IF THE CHARACTER IS A LITERAL
C
      IF(CSTMT(I1:I1) .EQ. CSYMCF) GO TO 15
C
C       IF THE INITIAL CHARACTER IS A DIGIT, THEN THIS MAY BE AN
C       ARITHMETIC EXPRESSION
C
      IF(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9 .AND.
     1   I1 .EQ. JA) THEN
C
C         LOCATE THE END OF THE EXPRESSION IN THE LIST
C
         IJ = 0
         L1 = LFALSE
         DO 11 IG = I1,KB
         IF(CSTMT(IG:IG) .EQ. CRPAR) IJ = IJ + 1
         IF(CSTMT(IG:IG) .EQ. CLPAR) IJ = IJ - 1
         IF(CSTMT(IG:IG) .EQ. CPLUS .OR. CSTMT(IG:IG) .EQ. CMINUS .OR.
     1      CSTMT(IG:IG) .EQ. CSLASH .OR. CSTMT(IG:IG) .EQ. CASTER)
     2      L1 = LTRUE
         IF(CSTMT(IG:IG) .EQ. COMMA .AND. L1) THEN
             IF(IJ .EQ. 0) THEN
               IH = KB
               KB = IG - 1
               CALL EXPR (I1,KB,LFALSE,CSTMT)
               KB = IH
               JA = IG + 1
               GO TO 10
            END IF
         END IF
 11      CONTINUE
      END IF
C
C         TEST FOR AN INITIAL ALPHABETIC CHARACTER
C
      IF(CSTMT(I1:I1) .GE. CAA .AND. CSTMT(I1:I1) .LE. CZZ .OR.
     1   CSTMT(I1:I1) .EQ. CUNDER) THEN
C
C         SET START OF DO LOOP VALUE
C
         IF(I1 .EQ. KB) THEN
            ID = I1
         ELSE
            IF(CSTMT(I1:I1) .EQ. CLPAR(1:1)) THEN
               ID = I1 + 1
            ELSE
               ID = I1
            END IF
         END IF
C
C         DETERMINE THE END OF THE VARIABLE NAME
C
          DO 13 IA = ID,KB
C
C         DETERMINE IF THE CURRENT CHARACTER IS A DELIMITER CHARACTER
C
         IF(.NOT.(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ
     1      .OR. CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9
     2      .OR. CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(IA:IA) .EQ. CDOL)
     3      .OR. IA .EQ. KB) THEN
C
C         TEST IF AN ARITHMETIC OPERATOR EXISTS
C
            IF(CSTMT(IA:IA) .EQ. CPLUS .OR. CSTMT(IA:IA) .EQ. CMINUS
     1         .OR. CSTMT(IA:IA) .EQ. CSLASH .OR. CSTMT(IA:IA) .EQ.
     2         CASTER) THEN
C
C         WHEN AN ARITHMETIC OPERATOR EXISTS, THE IOLIST ITEM IS AN
C         EXPRESSION. LOCATE THE END OF THE EXPRESSION IN THE LIST.
C
               IJ = 0
               DO 12 IG = I1,KB
               IF(CSTMT(IG:IG) .EQ. CRPAR) IJ = IJ + 1
               IF(CSTMT(IG:IG) .EQ. CLPAR) IJ = IJ - 1
               IF(CSTMT(IG:IG) .EQ. COMMA) THEN
                  IF(IJ .EQ. 0) THEN
                     IH = KB
                     KB = IG - 1
                     CALL EXPR (I1,KB,LFALSE,CSTMT)
                     KB = IH
                     JA = IG + 1
                     GO TO 10
                  END IF
               END IF
 12            CONTINUE
            END IF
C
C         DETERMINE IF THE CURRENT FIELD IS NUMERIC
C
            IF(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9) THEN
               CALL NUMBER (CSTMT,LTRUE,I1,II,FP,IFP)
               I3 = IFP + 1
               GO TO 10
            END IF
C
C         DETERMINE THE VARIABLE LENGTH
C
C           IC = IA - I1 + 1
            IF(IA .EQ. KB) THEN
               IC = IA - I1 + 1
            ELSE
               IC = IA - I1
            END IF
            IF(IA .GE. KB) THEN
C
C         DETERMINE IF THE FINAL CHARACTER IS A RIGHT PARENTHESIS OR
C         A COMMA
C
               IF(CSTMT(IA:IA) .EQ. CRPAR .OR. CSTMT(IA:IA) .EQ. COMMA)
     1            THEN
                  I2 = IA - 1
               ELSE
                  I2 = IA
               END IF
            ELSE
               I2 = IA - 1
            END IF
            CWORK(1:32) = CBLK52(1:32)
            CWORK(1:IC) = CSTMT(I1:I2)
            CWORK(37:44) = CBLANK(1:8)
            JBITS = 0
C
C         SET THE TYPE AND LENGTH CODE
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
            IF(IRET1 .GT. 0) THEN
               IF(CWORK(37:44) .NE. CNAME(IRET1)(37:44)) CWORK(37:44) =
     1            CNAME(IRET1)(37:44)
            ELSE IF(IRET .GT. 0) THEN
               IF(CWORK(37:44) .NE. CNAME(IRET)(37:44)) CWORK(37:44) =
     1            CNAME(IRET)(37:44)
               END IF
            IF(CWORK(37:37) .EQ. CBLANK(1:1)) CALL SETTL (CWORK)
            CALL VSETUP (I1,I2,IC,LFALSE,LFALSE,CSTMT)
            CWORK(37:44) = CBLANK(1:8)
            JA = IA + 1
            GO TO 10
         ELSE
C
C         THE INITIAL CHARACTER IS NOT A DELIMITER CHARACTER
C
            IE = IA
            IF(IA .EQ. KB) THEN
               IC = IA - I1 + 1
               GO TO 13
            END IF
            GO TO 13
         END IF
C
C         TEST OF THE END OF THE STATEMENT WAS REACHED
C
         IE = IA
         IF(CSTMT(IA+1:IA+1) .EQ. CBLANK(1:1)) IE = KB
C
C         TEST IF THE VARIABLE LENGTH IS TOO LONG
C
         IF(IC .GT. 32) IC = 32
         IF(IA .LT. KB) THEN
            IB = IE - 1
         ELSE
            IB = IE
         END IF
         NA = IB + 1
         IVCNT = IC
         CWORK(1:IC) = CSTMT(I1:IB)
         IWORK = ISN + 128
         CALL CHKNME (CSTMT)
         JA = IA + 1
         J = JA
C
C         TEST IF THE FINAL CHARACTER OF THE LIST HAS BEEN REACHED
C
         IF(JA .GE. KB) THEN
C
C         DETERMINE IF A COMMA FOLLOWED THE PRIOR VARIABLE IN THE LIST
C
            IF(CSTMT(IA:IA) .EQ. COMMA) THEN
C
C         PROCESS THE FINAL ARGUMENT IN THE LIST
C
               IF((I1 + IC - 1) .LT. KB) THEN
                  CWORK(1:52) = CBLK52(1:52)
                  JBITS = 0
                  GO TO 10
               END IF
               GO TO 15
            END IF
            GO TO 15
         ELSE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            IF(CSTMT(IA:IA) .EQ. CEQ(1:1)) JA = IA
            IF(IA .EQ. KB) GO TO 16
            GO TO 10
         END IF
 13      CONTINUE
      END IF
C
C         TEST FOR A NUMERICAL CONSTANT
C
      IF(CSTMT(I1:I1) .GE. C0 .AND. CSTMT(I1:I1) .LE. C9) THEN
C
C         SET START OF DO LOOP VALUE
C
         ID = I1 + 1
C
C         DETERMINE THE END OF THE CONSTANT
C
         DO 14 IA = ID,KB
C
C         DETERMINE IF THE CURRENT CHARACTER IS A SEPARATOR
C
         IF(.NOT.(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ
     1      .OR. CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9
     2      .OR. CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(IA:IA) .EQ. CDOL))
     1      THEN
C
C         THE FINAL CHARACTER OF A CONSTANT HAS BEEN LOCATED
C
            IC = IA - I1
C
C         DETERMINE IF IT IS IN THE MASTER INTEGER TABLE
C
            IB = IA - 1
C
C         SEARCH THE INTEGER TABLE FOR A MATCH
C
            LA = LTRUE
            CALL NUMBER (CSTMT,LA,I1,II,FP,IFP)
            IF(.NOT.LINCL) CALL INSERT (II)
            IF(IFP + 1 .GE. KB) GO TO 16
            JA = IA + 1
            GO TO 10
         END IF
 14      CONTINUE
      END IF
C
C         DETERMINE IF THE END OF THE STATEMENT
C
      IF(I1 .EQ. KB .OR. I1+1 .EQ. KB) GO TO 16
C
C         END OF LOOP FOR SEARCHING THE IOLIST
C
 15   CONTINUE
C
C         ROUTINE EXIT
C
 16   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE ARGUMENT LIST FOR CALL, ENTRY,
C        FUNCTION, AND SUBROUTINE STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARACTER: A
C         CAMP   - CHARACTER VARIABLE, THE CHARACTER: &
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBAR   - CHARACTER VARIABLE, THE CHARACTER: |
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CCC    - CHARACTER VARIABLE, THE CHARACTER: C
C         CDD    - CHARACTER VARIABLE, THE CHARACTER: D
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE
C                  DEFINITION RECORD OF A SUBPROGRAM; LENGTH IS
C                  1496 CHARACTERS (UNIT 3)
C         CDEF2  - CHARACTER VARIABLE, EQUIVALENCED TO IDEF2, USED TO
C                  CREATE THE ARGUMENT DATA FOR SECTION 2 OF CDEF.
C         CDEF3  - CHARACTER VARIABLE, EQUIVALENCED TO CDEF2, BUT THE
C                  VARIABLE LENGTH IS 1440 CHARACTERS, AND IT IS NOT
C                  DIMENSIONED.
C         CDIM   - CHARACTER VARIABLE, A TABLE OF DIMENSIONED VARIABLE
C                  NAMES
C         CDOL   - CHARAACTER VARIABLE, THWE CHARACTERl $
C         CDOT   - CHARACTER VARIABLE, A PERIOD
C         CEE    - CHARACTER VARIABLE, THE LETTER: E
C         CFF    - CHARACTER VARIABLE, THE LETTER: F
C         CFMTH  - CHARACTER VARIABLE, THE LISTING HEADER
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMACRO - CHARACTER VARIABLE, TABLE CONTAINING THE NAMES OF
C                  API OS/2 HELPER MACROS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COLON  - CHARACTER VARIABLE, THE CHARACTER: : (COLON)
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: /
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSS    - CHARACTER VARIABLE, THE LETTER: S
C         CSTMTA - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSUBTB - CHARACTER VARIABLE, THE TABLE OF ALL ENTRY, FUNCTION,
C                  AND SUBROUTINE NAMES.
C                  RECORD STRUCTURE
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZERO)
C                  37-44  11   TYPE AND LENGTH CHARACTERISTIC
C                  45-48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS IN COLS 1-32
C                  53-56  14   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE
C                  STATEMENT BEING PROCESSED. C - CALL STATEMENT,
C                  F - FUNCTION, E - ENTRY, S - SUBROUTINE,
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _ (UNDERSCORE)
C         CUSE   - CHARACTER VARIABLE, THE RECORD TO BE WRITTEN ON UNIT
C                  10
C         CUSE1  - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE CALL
C                  STATEMENT RECORD FOR SUBPROGRAM NAMES; LENGTH IS
C                  92 CHARACTERS
C         CUSE2  - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE CALL
C                  STATEMENT ARGUMENT LIST. EQUIVALENCED TO IUSE2.
C                  LENGTH IS 1440 CHARACTERS.
C         CUSE3  - CHARACTER VARIABLE, EQUIVALENCED TO CUSE2, BUT THE
C                  VARIABLE LENGTH IS 1440 CHARACTERS, AND IT IS NOT
C                  DIMENSIONED.
C         CWK32  - CHARACTER VARIABLE, USED TO DETERMINE THE TYPE CODE
C                  OF A VARIABLE IN AN EXPRESSION WHEN GLOBAL ERROR
C                  CHECKING IS TO BE PERFORMED IN SUBROUTINE ARGCHK.
C         CWK8   - CHARACTER VARIABLE, THE TYPE AN LENGTH CODE OF AN
C                  EXPRESSION
C         CWK80  - CHARACTER VARIABLE, WORK AREA TO PROCESS AN ARGUMENT
C                  LIST FROM CALL STATMENTS. THIS IS USED TO PROCESS
C                  AN ARGUMENT LIST THAT IS AN EXPRESSION.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CZERO  - CHARACTER VARIABLE, A HEXADECIMAL 4 BYTE ZERO
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER: Z
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C4     - CHARACTER VARIABLE, THE CHARACTER: 4
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         IARGCT - COUNT OF THE TOTAL NUMBER OF ARGUMENTS IN A STATEMENT
C         ICOLCT - COUNT OF THE TOTAL NUMBER OF CHARACTER RANGE
C                  SPECIFICATIONS
C         IDEF2  - EQUIVALENCED TO CDEF2
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - WORK AREA
C         ILOC   - LOCATION OF THE COMMA TERMINATING EACH ARGUMENT
C         ILOCC  - LOCATION OF A COLON WITHIN A SINGLE ARGUMENT
C         ILOCL  - LOCATION OF THE LEFT PARENTHESIS OF A CHARACTER RANGE
C                  SPECIFICATION OR OF A SUBSCRIPT SPECIFICATION
C         ILOCLV - THE LOW VALUE OF A RANGE SPECIFICATION WHEN THE
C                  SPECIFICATION IS AN INTEGER.
C         ILOCR  - LOCATION OF THE RIGHT PARNTHESIS OF A CHARACTER RANGE
C                  SPECIFICATION OR OF A SUBSCRIPT SPECIFICATION
C         ILOCRL - THE UPPER VALUE OF A RANGE SPECIFICATION WHEN THE
C                  SPECIFICATION IS AN INTEGER
C         IPGNME - LENGTH OF THE SUBROUTINE NAME BEING CALLED
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IREC7  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 7 (VARIABLE NAMES)
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IRET   - RETURN CODE FROM TABLE SEARCH AND INSERT. THIS VALUE
C                  IS THE LOCATION SUBSCRIPT INDEX.
C         IRET1  - RETURN CODE FROM TABLE SEARCH AND INSERT. THIS VALUE
C                  IS THE LOCATION SUBSCRIPT INDEX.
C         IRET2  - RETURN CODE FROM TABLE SEARCH AND INSERT. THIS VALUE
C                  IS THE LOCATION SUBSCRIPT INDEX.
C         IRET3  - RETURN CODE FROM TABLE SEARCH AND INSERT. THIS VALUE
C                  IS THE LOCATION SUBSCRIPT INDEX.
C         IRET4  - RETURN CODE FROM TABLE SEARCH AND INSERT. THIS VALUE
C                  IS THE LOCATION SUBSCRIPT INDEX.
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         ISNU   - ISN OF THE CURRENT STATEMENT + 128, EQUIVALENCED TO
C                  CUSE1
C         ISUBTB - COUNT OF THE NUMBER OF ENTRIES IN CSUBTB
C         IUSE   - EQUIVALENCED TO CUSE1
C         IUSE2  - EQUIVALENCED TO CUSE2
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CUSE1
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - SUBSCRIPT VARIABLE; THE ARGUMENT INDEX
C         I2     - COUNT OF THE NUMBER OF PARENTHESES AND SUBSCRIPT
C                  VARIABLE
C         I2WK1  - COUNT OF COMMAS IN THE ARGUMENT LIST. COMMAS IN SUB-
C                  CRIPTS ARE NOT COUNTED.
C         I3     - WORK AREA, START LOCATION OF AN ARGUMENT
C         I4     - LOCATION OF THE END OF AN ARGUMENT
C         I4WK1  - START OF A PARTICULAR SUBSCRIPT FIELD
C         I4WK2  - END OF A PARTICULAR SUBSCRIPT FIELD THAT IS A
C         I4WK3  - START OF A PARTICULAR SUBSCRIPT FIELD THAT IS A
C                  VARIABLE NAME WHICH IS SUSBCRIPTED
C         I4WK4  - END OF A PARTICULAR SUBSCRIPT FIELD THAT IS A
C                  VARIABLE NAME WHICH IS SUBSCRIPTED
C         I5     - SUBSCRIPT VARIABLE
C         I6     - USED TO DETERMINE THE END START AND END LOCATION OF
C                  A CHARACTER RANGE SPECIFICATION
C         I7     - LOCATION START OF A CHARACTER RANGE SPECIFICATION
C         I8     - LOCATION END OF A CHARACTER RANGE SPECIFICATION
C         I9     - WORK AREA, LOCATION OF A RIGHT PARENTHESIS WITHIN AN
C                  ARGUMENT
C         I10    - WORK AREA, USED TO DETERMINE THE LOCATION OF THE
C                  CLOSING PARENTHESIS OF A SUBSCRIPT SPECIFCATION
C         I11    - WORK AREA, LOCATION OF A COMMA WITHIN A SUBSCRIPT
C                  OR A COLON WITHIN A CHARACTER RANGE SPECIFICATION
C         I12    - WORK AREA
C         I13    - WORK AREA
C         I14    - WORK AREA, LOCATION OF THE LEFT PARENTHESIS OF A
C                  SUBSCRIPTED SUBSCRIPT VARIABLE
C         I15    - WORK AREA, LOCATION OF THE RIGHT PARENTHESIS OF A
C                  SUBSCRIPTED SUBSCRIPT VARIABLE
C         I16    - WORK AREA
C         I17    - WORK AREA
C         J      - LOCATION OF THE CURRENT CHARACTER IN THE STATEMENT
C         JA     - LOCATION OF THE START OF AN ENTRY, FUNCTION, OR
C                  SUBROUTINE IDENTIFICATION. THIS VALUE IS SET IN A
C                  DIFFERENT SUBPROGRAM.
C         JBB    - WORK AREA
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES.
C         JFINAL - LOCATION OF THE FINAL CHARACTER OF A COMPOUND
C                  VARIABLE NAME
C         JLEN   - LENGTH OF AN ENTRY, CALL, FUNCTION, OR SUBROUTINE
C                  ARGUMENT
C         JLOC   - LOCATION OF COMMAS OCCURRING WITHIN A SINGLE
C                  SUBSCRIPT SPECIFICATION
C         JLOCKT - NUMBER OF COMMAS FOUND IN A SUBSCRIPT SPECIFICATION
C         JSTART - LOCATION OF THE INITIAL CHARACTER OF A COMPOUND
C                  VARIABLE NAME
C         JSUBTB - EQUIVALENCED TO CSUBTB
C         JVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME IN COLUMNS
C                  53 - 84 IN VARIABLE CUSE1
C         JWK8   - WORK AREA TO DETERMINE THE LENGTH OF AN ARGUMENT IN
C                  A CALL STATEMENT.
C         J1     - SUBSCRIPT WORK AREA
C         J2     - SUBSCRIPT WORK AREA
C         KB     - THE LOCATION OF THE FINAL CHARACTER IN CSTMT
C         KBA    - THE LOCATION OF THE INITIAL LEFT PARENTHESIS OF THE
C                  ARGUMENT LIST
C         KBB    - THE LOCATION OF THE FINAL CHARACTER TO BE PROCESSED
C                  BY ARGLST. THE END OF THE ARGUMENT LIST TO BE
C                  PROCESSED; IT MUST BE A RIGHT PARENTHSIS.
C         KBSAVE - SAVE AREA FOR THE VALUE OF KBB UPON ENTERING ARGLST
C         KLEN   - THE LENGTH OF A CHARACTER RANGE OR A SUBSCRIPT
C                  SPECIFICATION OR A VARIABLE NAME
C         K1     - SUBSCRIPT VARIABLE
C         LA     - LOGICAL VARIABLE, WORK VARIABLE
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IS TO
C                  BE PERFORMED, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LPROG  - LOGICAL VARIABLE, SET TRUE WHEN THE PROGRAM NAME OR
C                  SUBPROGRAM NAME HAS BEEN INSERTED IN CFMTH, SET FALSE
C                  OTHERWISE.
C         LR1    - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS WITHIN THE LOW OR UPPER VALUE OF A
C                  CHARACTER RANGE SPECIFICATION, SET FALSE OTHERWISE
C         LR2    - LOGICAL VARIABLE, SET TRUE WHEN TWO SEQUENTIAL
C                  SLASHES OCCUR IN THE LOW OR UPPER VALUE CHARACTER
C                  RANGE SPECIFICATION, SET FALSE OTHERWISE
C         LR3    - LOGICAL VARIABLE, SET TRUE WHEN A DECIMAL POINT
C                  EXISTS IN THE LOW OR UPPER VALUE OF A CHARACTER RANGE
C                  SPECIFICATION, SET FALSE OTHERWISE
C         LR4    - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER VALUE
C                  RETURNED FROM SUBROUTINE NUMBER IS AN INTEGER, SET
C                  FALSE IF THE NUMBER IS REAL
C         LR5    - LOGICAL VARIABLE, SET TRUE WHEN A LITERAL OR LOGICAL
C                  OPERATOR EXIST WITHIN THE LOW OR UPPER VALUE OF A
C                  CHARACTER RANGE SPECIFICATION, SET FALSE OTHERWISE
C         LS1    - LOGICAL VARIABLE, SET TRUE WHEN A COLON OCCURS IN THE
C                  ARGUMENT INDICATING CHARACTER RANGE SPECIFICATION
C                  EXISTS, SET FALSE OTHERWISE
C         LS2    - LOGICAL VARIABLE, SET TRUE WHEN A SUBSCRIPT EXISTS,
C                  SET FALSE OTHERWISE
C         LS3    - LOGICAL VARIABLE, SET TRUE WHEN A COMMA EXISTS
C                  WITHIN A SUBSCRIPT SPECIFICATION INDICATING THAT
C                  MULTIPLE SUBSCRIPTS EXIST FOR A SINGLE VARIABLE,
C                  SET FALSE OTHERWISE
C         LS4    - LOGICAL VARIABLE, SET TRUE WHEN A SUBSCRIPT CONTAINS
C                  AN ARITHMETIC OPERATOR, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, WORK VARIABLE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME IS
C                  %LOC, %REF, %VAL, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT IN
C                  AN ENTRY, FUNCTION, OR SUBROUTINE STATEMENT IS AN
C                  ARITHMETIC EXPRESSION, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT IS
C                  A CHARACTER EXPRESSION, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT IS
C                  A NUMERICAL VALUE, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT IS
C                  STATEMENT IS A SUBPROGRAM AND THE SUBPROGRAM NAME HAS
C                  A CHARACTER RANGE SPECIFIED, SET FALSE OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT
C                  CONTAINS A LITERAL, SET FALSE OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT IS
C                  A LOGICAL EXPRESSION, SET FALSE OTHERWISE
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT
C                  CONTAINS AN ILLEGAL CHARACTER, SET FALSE OTHERWISE
C         L10    - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT
C                  CONTAINS A RETURN STATEMENT NUMBER. SET FALSE
C                  0THERWISE
C         L11    - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT
C                  CONTAINS A LOGICAL CONSTANT, SET FALSE OTHERWISE
C         L12    - LOGICAL VARIABLE, SET TRUE WHEN A DUMMY ARGUMENT
C                  CONTAINS A LEFT PARENTHESIS, SET FALSE OTHERWISE
C         L13    - LOGICAL VARIABLE, SET TRUE WHEN A COMPOUND VARIABLE
C                  NAME EXISTS, SET FALSE OTHERWISE.
C         L14    - LOGICAL VARIABLE, SAVE VARIABLE FOR THE VALUE OF
C                  LCALL UPON ENTRY TO THIS ROUTINE.
C         NARGD  - NUMBER OF ARGUMENTS IN A SUBPROGRAM CALL
C         NARGS  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C         3      - LIST OF ALL DEFINED SUBPROGRAMS THAT CAN BE CALLED.
C                  EVERY SUBROUTINE, ENTRY, AND DEFINED FUNCTION
C                  SUBPROGRAM HAVE A SINGLE RECORD ON THIS FILE. THE
C                  RECORD CONTAINS A LIST AND DEFINITION OF UP TO 30
C                  ARGUMENTS OF THE SUBPROGRAM. INTRINSIC FUNCTIONS USED
C                  ARE NOT IN THIS FILE. EACH RECORD IS 1496 CHARACTERS.
C                  THIS IS A GLOBAL RECORD AND EXTENDS BEYOND A SINGLE
C                  SUBPROGRAM. THE RECORD FOR EVERY ENTRY, FUNCTION, AND
C                  SUBROUTINE STATEMENT IS NOT WRITTEN UNTIL ALL TABLES
C                  FOR THE SUBPROGRAM DEFINITION ARE COMPLETED. THIS IS
C                  DONE TO INSURE ALL TYPE CODES AND LENGTH
C                  CHARACTERISTICS ARE CORRECTLY DEFINED.
C
C                  SECTION 1:
C
C                  DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C                  COLUMN       TYPE &
C                  NUMBER  WORD LENGTH  DESCRIPTION
C
C                  1 - 32    8  C*32  THE SUBPROGRAM NAME
C                 33 - 36    9  I*4   ISN OF THE SUBPROGRAM STATEMENT
C                 37            C*1   SUBPROGRAM NAME DATA TYPE
C                 38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C                 45 - 48   12  C*4   32 BIT SWITCHES FOR THE SUBPROGRAM
C                                     NAME ATTRIBUTES. IF BIT IS ZERO,
C                                     SWITCH IS OFF; IF BIT IS ONE,
C                                     SWITCH IS ON.
C                 49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE
C                                     SUBPROGAM NAME
C                 53 - 56   14  I*4   NUMBER OF ARGUMENTS FOR THIS
C                                     SUBPROGRAM
C
C                  SECTION 2:
C
C                  THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS
C                  REPEATED FOR EACH ARGUMENT IN A SUBPROGRAM STATEMENT
C                  UP TO A MAXIMUM OF 30 ARGUMENTS. SUBSCRIPTS MAY NOT
C                  BE USED IN A SUBPROGRAM DEFINITION STATEMENT, SINCE
C                  ALL ARGUMENTS ARE DUMMY VARIABLES.
C
C                  COLUMN       FIELD
C                  NUMBER  WORD TYPE   DESCRIPTION
C
C                  1 - 32    8  C*32  ARGUMENT VARIABLE NAME
C                 33            C*1   ARGUMENT VARIABLE DATA TYPE
C                 34 - 40   10  C*7   ARGUMENT VARIABLE DATA TYPE LENGTH
C                 41 - 44   11  I*4   32 BIT SWITCHES FOR THE ARGUMENT
C                                     VARIABLE NAME ATTRIBUTES. IF BIT
C                                     IS ZERO, SWITCH IS OFF; IF BIT IS
C                                     ONE, SWITCH IS ON.
C                 45 - 48   12  I*4   NUMBER OF CHARACTERS IN THE ARGUMENT
C                                     VARIABLE NAME
C
C                 TOTAL RECORD LENGTH IS 1496 CHARACTERS
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C         7      - THE VARIABLE NAMES AND THE ISNS WHERE THEY OCCUR,
C                  RECORD LENGTH IS 52 CHARACTERS
C        10      - LIST OF ALL DEFINED SUBPROGRAMS CALLED WITHIN THE
C                  ENTIRE PROGRAM. THIS IS A GLOBAL RECORD AND EXTENDS
C                  BEYOND A SINGLE SUBPROGRAM. RECORD LENGTH IS 1532
C                  CHARACTERS. THIS FILE CONTAINS ONLY THE CALL
C                  STATEMENTS. A RECORD IS CREATED FOR EVERY CALL
C                  STATEMENT AND WRITTEN ON UNIT 10 BY THIS ROUTINE.
C
C                  RECORD STRUCTURE OF THE INPUT SUBPROGRAM ARGUMENT
C                  LIST IN A CALL STATEMENT
C
C                  SECTION 1:
C
C                  DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C                  COLUMN  WORD TYPE &
C                  NUMBER       LENGTH  DESCRIPTION
C
C                   1 - 32    8  C*32  CALLED SUBPROGRAM NAME
C                  33 - 36    9  I*4   ISN OF THE CALL STATEMENT
C                  37            C*1   SUBPROGRAM NAME DATA TYPE; COL 32
C                  38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C                  45 - 48   12  I*4   32 BIT SWITCHES FOR THE
C                                      SUBPROGRAM NAME ATTRIBUTES. IF
C                                      BIT IS ZERO, SWITCH IS OFF;
C                                      IF BIT IS ONE, SWITCH IS ON.
C                  49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE
C                                      CALLED SUBPROGRAM NAME IN COLS
C                                       1- 32
C                  53 - 84   21  C*32  ROUTINE NAME WHERE THE CALL
C                                      STATEMENT OCCURS
C                  85 - 88   22  I*4   NUMBER OF CHARACTERS IN THE
C                                      VARIABLE NAME IN COLUMNS 53 - 84.
C                  89 - 92   23  I*4   NUMBER OF ARGUMENTS FOR THIS CALL
C                                      STATEMENT
C
C                  SECTION 2:
C
C                  THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS
C                  REPEATED FOR EACH ARGUMENT IN A CALL STATEMENT UP TO
C                  A MAXIMUM OF 30 ARGUMENTS. SUBSCRIPTS OF ARGUMENTS
C                  ARE NOT COUNTED AND ARE NOT PROCESSED.
C
C                  COLUMN WORD  FIELD  DESCRIPTION
C                  NUMBER       TYPE
C
C                   1 - 32   8   A*32  ARGUMENT VARIABLE NAME
C                  33            A*1   ARGUMENT VARIABLE DATA TYPE
C                  34 - 40  10   A*7   ARGUMENT VARIABLE DATA LENGTH
C                  41 - 44  11   I*4   BIT SWITCHES FOR THE ARGUMENT
C                                      VARIABLE NAME ATTRIBUTES. IF BIT
C                                      IS ZERO, SWITCH IS OFF; IF BIT IS
C                                      ONE, SWITCH IS ON.
C                  45 - 48  12   I*4   NUMBER OF CHARACTERS IN THE
C                                      ARGUMENT VARIABLE NAME
C
C                  THE TOTAL RECORD LENGTH IS 1532 CHARACTERS
C
C     COMMENTS
C
C         A MAXIMUM OF 200 DIFFERENT CALLED SUBPROGRAM NAMES PER ROUTINE
C         BEING ANALYZED ARE ALLOWED.
C
C         A MAXIMUM OF 30 ARGUMENTS FOR ONE SUBPROGRAM CALL ARE ALLOWED.
C         A MAXIMUM OF 30 CHARACTER RANGE SPECIFICATIONS FOROR A SINGLE
C         ARGUMENT ARE ALLOWED.
C
C         AN ARGUMENT LIST MAY CONTAIN ONLY DUMMY VARIABLE NAMES WHEN AN
C         ENTRY, FUNCTION, OR SUBROUTINE STATEMENT IS PROCESSED. NO
C         SUBSCRIPTED VARIABLES, CONSTANT VALUES OF ANY TYPE, NOR ANY
C         EXPRESSIONS MAY OCCUR.
C
C         A CALL STATEMENT OF AN ENTRY, FUNCTION, OR SUBROUTINE NAME MAY
C         HAVE ARGUMENTS THAT ARE: 1. VARIABLE NAMES (WITH AND WITHOUT
C         6UBSCRIPTS), 2. CONSTANTS OF ANY TYPE, 3. EXPRESSIONS OF ANY
C         ALLOWED ARITHMETIC, LOGICAL, OR CHARACTER TYPE, 4. A FUNCTION
C         OR SUBROUTINE NAME (NO ARGUMENTS MAY BE PROVIDED), 5. A RETURN
C         STATEMENT NUMBER (*nn OR &nn)
C
C         SUBROUTINE VSETUP IS NOT CALLED FOR THE ENTRY, FUNCTION, OR
C         SUBROUTINE STATEMENT'S NAME SINCE THEY CAN NOT BE A COMPOUND
C         VARIABLE NAME.
C
C         THE DUMMY ARGUMENTS (IF ANY) IN A ENTRY, FUNCTION, OR
C         SUBROUTINE STATEMENT CONTAINS ONLY DUMMY VARIABLE NAMES;
C         CONSEQUENTLY, NO NUMERIC CONSTANT, ANY EXPRESSION, LITERAL,
C         OR A SUBPROGRAM NAME CAN BE A DUMMY ARGUMENT.
C
C         HOWEVER, THE ARGUMENTS OF A CALL STATEMENT MAY CONTAIN
C         VARIABLE NAMES OF ANY TYPE, COMPLEX NUMBERS, INTEGER NUMBERS,
C         REAL NUMBERS, LOGICAL VARIABLES AND EXPRESSIONS, AND
C         ARITHMETIC EXPRESSIONS.
C
C         WHEN AN EXPRESSION OCCURS, THE SYNTHETIC VARIABLE C##EX IS
C         GENERATED AS THE VARIABLE NAME TO BE PLACED ON UNIT 10 WHEN
C         GLOBAL DIAGNOSTICS ARE TO BE PERFORMED. THE TYPE OF THE FIRST
C         VARIABLE IN THE EXPRESSION IS USED TO SET THE TYPE AND LENGTH
C         DEFINITIONS OF THE SYNTHETIC VARIABLE. THE VARIABLE LENGTH
C         NAME SIZE IS SET TO 5. C##EX IS NOT PLACED IN CNAME FOR GLOBAL
C         ANALYSIS.
C
C         IF THE CALL STATEMENT ARGUMENT IS A CHARACTER CONSTANT, I.E.,
C         LITERAL, THE SYNTHETIC VARIABLE C##NNN, WHERE NNN IS A NUMBER,
C         WILL BE PLACED IN CNAME FOR GLOBAL ANALYSIS. THE LENGTH OF THE
C         CHARACTERISTIC FOR C##NNN IS SET TO THE ACTUAL LENGTH OF THE
C         LITERAL.
C
C         IF THE ARGUMENT IS A CONSTANT, THE SYNTHETIC ARGUMENT C##NUM
C         IS PLACED ON UNIT 10. C##NUM IS NOT PLACED IN CNAME FOR GLOBAL
C         ANALYSIS. THE LENGTH DEFINITION IS THE SAME AS THE NUMERIC
C         VALUE.
C
C         IF A DUMMY ARGUMENT IN AN ENTRY, FUNCTION, OR SUBROUTINE
C         DEFINITION STATEMNENT HAS AN INHERITED LENGTH CHARACTERISTIC,
C         THE LENGTH IS SHOWN AS (*) IN THE LISTING. NO LENGTH
C         VERIFICATION IS POSSIBLE FOR THIS CASE IN THE GLOBAL
C         ANALYSIS, BECAUSE THE ACTUAL LENGTH IS KNOWN ONLY DURING
C         PROGRAM EXECUTION.
C
C         AN ARGUMENT FIELD CONTAINING A HOLLERITH FIELD IS NOT
C         PROCESSED BY THIS ROUTINE, BECAUSE ROUTINE COMPRS WILL REPLACE
C         THE HOLLERITH ARGUMENT WITH ITS EQUIVALENT LITERAL.
C
C     SUBROUTINES CALLED
C
C         BTEST CHKNME CSETUP EXPR FCHECK IBCLR IBSET INSERT NUMBER
C         SETTL TABSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE ARGLST (CTYPED,CSTMTA,KBB)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION CUSE2(30), IUSE1(23), IUSE2(12,30), CDEF2(30), IDEF(374)
     1,IDEF2(12,30)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION ILOC(30), ILOCC(30)
      DIMENSION NDIM(26,1000), JLOC(7), IWK8(2)
      DIMENSION JSUBTB(14,1000), JRECTB(17,1000)
      DIMENSION CMACRO(25)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT, CSTMTA
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*1440  CDEF3, CUSE3
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK, CUSE1
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE, CWK80
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*48    CUSE2, CDEF2, CWK48
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32, CMACRO
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*4 CIB, CZERO
      LOGICAL*1   LA, L1, L2, L3, L4, L5, L6, L7, L8, L9, L10, L11, L12,
     1            L13, L14
      LOGICAL*1   LR1, LR2, LR3, LR4, LR5, LS1, LS2, LS3, LS4
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      COMMON /PMACRO/ CMACRO
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK48(41:44),KBITS), (CWK48(45:48),KVCNT), (CWK8(2:2),CWK7)
      EQUIVALENCE (CUSE1(33:36),ISNU), (CUSE1(85:88),JVCNT),
     1(CUSE1(89:92),IARGCT), (CUSE1,IUSE1)
      EQUIVALENCE (CUSE2,IUSE2,CUSE3)
      EQUIVALENCE (IDEF,CDEF)
      EQUIVALENCE (CDEF(53:56),NARGD), (CDEF(33:36),JSNU),
     1(CDEF(49:52),MVCNT)
      EQUIVALENCE (CDEF(57:57),CDEF2,IDEF2,CDEF3)
      EQUIVALENCE (CIB,IIB), (I4WK1,CI4WK1)
      EQUIVALENCE (CDIM,NDIM), (CWK8,IWK8)
      EQUIVALENCE (CSUBTB,JSUBTB), (CRECTB,JRECTB)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CZERO /'00000000'X/
C     DATA LZ/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' STATEMENT ENDS ILLEGALY')
 101  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 SUBSCRIPTED OR RANGE SPECIFICATION ARGUMENTS')
 102  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 SUBSCRIPTED ARGUMENTS')
 103  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 NUMERICAL ARGUMENTS')
 104  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 MATHEMATICAL EXPRESSION ARGUMENTS')
 105  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 LITERAL ARGUMENTS')
 106  FORMAT(' ISN:',I6,' STATEMENT HAS MORE THAN 30 ARGUMENTS')
 107  FORMAT(' ISN:',I6,' FUNCTION STATEMENT IS NOT THE FIRST STATEMENT'
     1)
 108  FORMAT(' ISN:',I6,' SUBROUTINE STATEMENT IS NOT THE FIRST STATEMEN
     1T')
 109  FORMAT(' ISN:',I6,' ILLEGAL RETURN DESIGNATION FOR ARGUMENT ',I3)
 110  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 CONCANTENATED EXPRESSION ARGUMENTS')
 111  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 LOGICAL CONSTANTS')
 112  FORMAT(' ISN:',I6,' CALL ARGUMENT VARIABLE IS NOT DEFINED: ',A32)
 113  FORMAT(' ISN:',I6,' ARGUMENT LENGTH EXCEEDS 80 CHARACTERS')
 114  FORMAT(' ISN:',I6,' CALL ARGUMENT SUBSCRIPT DOES NOT MATCH ITS DIM
     1ENSION: ',A32)
 115  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; ONLY CALL STATEMENTS MAY HAVE
     1 LOGICAL EXPRESSION ARGUMENTS')
 116  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; CALL STATEMENT ARGUMENT HAS I
     1LEGAL CHARACTERS')
 117  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; CHARACTER RANGE VALUE MUST BE
     1 ARITHMETIC')
 118  FORMAT(' ISN:',I6,' ARGUMENT ',I3,'; CHARACTER RANGE VALUE MUST BE
     1 AN INTEGER')
 119  FORMAT(' ISN:',I6,' VARIABLE IS NOT DIMENSIONED: ',A32)
 120  FORMAT(' ISN:',I6,' ARGUMENT ',I3,': A SUBSCRIPT MUST BE AN INTEGE
     1R')
 121  FORMAT(' ISN:',I6,' DUMMY VARIABLE NAME EXCEEDS 32 CHARACTERS: ',A
     132)
 122  FORMAT(' ISN:',I6,' DUMMY VARIABLE NAME IS A SUBPROGRAM NAME: ',A
     132)
C
C         SAVE THE ORIGINAL VALUE OF KBB
C
      KBSAVE = KBB
C
C         SAVE ORIGINAL VALUE OF LCALL UPON ENTRY
C
      L14 = LCALL
C
C         INITIALIZE THE NUMBER OF DEFINED ARGUMENTS FOR A DEFINED
C         SUBPROGRAM.
C
      IF(.NOT.LCALL) NARGD = 0
C
C         DETERMINE IF GLOBAL ANALYSIS IS REQUESTED
C
      L3 = LFALSE
      IARGCT = 0
      IF(LGLOBL) THEN
C
C         INITIALIZE THE CORRECT RECORD BUFFER FOR UNIT 3 OR UNIT 10
C
         IF(LCALL) THEN
C
C         A CALL STATEMENT IS TO BE PROCESSED; INITIALIZE THE RECORD
C         BUFFER FOR UNIT 10, CUSE1 AND CUSE2.
C
            DO 10 I1 = 1,11
            CUSE1(I1:I1+7) = CBLANK(1:8)
 10         CONTINUE
            IUSE1(23) = 0
            DO 11 I1 = 1,30
            CUSE2(I1)(1:48) = CBLK52(1:48)
 11         CONTINUE
C
C         SET THE ISN OF THE CALL STATEMENT FOR UNIT 10
C
C           ISNU = ISN + 128
         ELSE
C
C         AN ENTRY, FUNCTION, OR SUBROUTINE STATEMENT IS BEING PROCESSED;
C         INITIALIZE THE RECORD FOR UNIT 3, CDEF2.
C
            DO 12 I1 = 1,30
            CDEF2(I1)(1:48) = CBLK52(1:48)
 12         CONTINUE
         END IF
      END IF
C
C         SCAN TO LOCATE AN INITIAL LEFT PARENTHESIS OF THE ARGUMENT
C         LIST
C
      KBA = 0
      K1 = 0
      DO 13 I1 = JA,KBB
C
C         LOCATE THE LEFT PARENTHESIS STARTING THE ARGUMENT LIST, IF ANY
C
      IF(CSTMTA(I1:I1) .EQ. CLPAR(1:1)) THEN
         KBA = I1
C
C         DETERMINE IF ANY ARGUMENT LIST EXISTS FOR THIS STATEMENT. THE
C         FINAL CHARACTER OF THE STATEMENT MUST BE A RIGHT PARENTHESIS
C         FOR AN ARGUMENT LIST TO EXIST. WHEN A RIGHT PARENTHESIS IS NOT
C         THE FINAL CHARACTER, NO ARGUMENT LIST IS PROCESSED; EVEN IF A
C         LEFT PARENTHESIS EXISTS.
C
         IF(CSTMTA(KBB:KBB) .NE. CRPAR(1:1) .AND. ISN .GT. 0) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            IARGCT = 0
            KBB = KBA - 1
            GO TO 17
         END IF
C
C         WHEN NO COMMAS ARE FOUND, ONLY A SINGLE ARGUMENT MAY EXIST
C
         I2WK1 = 0
         GO TO 14
      END IF
C
C         LOCATE AN ASTERISK FOLLOWING A VARIABLE NAME, IF ANY.
C         IF AN ASTERISK OCCURS PRIOR TO THE INITIAL LEFT PARENTHESIS,
C         SAVE ITS LOCATION. THIS WILL BE THE END OF THE VARIABLE NAME
C         RATHER THAN A LEFT PRENTHESIS. THIS CONDITION SHOULD EXIST
C         ONLY FOR A FUNCTION STATEMENT NAME.
C
      IF(CSTMTA(I1:I1) .EQ. CASTER) K1 = I1
 13   CONTINUE
C
C         WHEN NO COMMAS ARE FOUND, ONLY A SINGLE ARGUMENT MAY EXIST
C
      I2WK1 = 0
C
C         THE BOUNDARIES OF THE ARGUMENT LIST ARE NOW KNOWN; THE LEFT
C         STARTING LOCATION IS IN KBA; THE RIGHT ENDING LOCATION IN IN
C         KBB.
C
 14   I2 = 0
C
C         WHEN KBA IS ZERO, NO ARGUMENT LIST EXISTS
C
      IF(KBA .EQ. 0) THEN
         IF(CSTMTA(KBB:KBB) .NE. CRPAR(1:1)) THEN
            IARGCT = 0
            GO TO 17
         END IF
      END IF
C
C         WHEN AN ARGUMENT LIST EXISTS, AN ASTERISK OCCURS BEFORE A
C         A LEFT PARENTHESIS, THE END OF A FUNCTION NAME IS DETERMINED
C         BY THE ASTERISK.
C
      IF(K1 .GT. 0) THEN
         IF(K1 .LT. KBA .AND. KBA .GT. 0) KBA = K1 - 1
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *     THE FOLLOWING CODE CREATES A TABLE OF THE STARTING AND     *
C     *     ENDING LOCATIONS OF EACH ARGUMENT IN THE ARGUMENT LIST.    *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE THE LOCATION OF EACH COMMA DELIMITING AN ARGUMENT
C         IN THE ARGUMENT LIST. NOTE THAT THE INITIAL LEFT PARENTHESIS
C         LOCATED AT KBA AND THE FINAL RIGHT PARENTHESIS LOCATED AT KBB
C         ARE NOT PROCESSED BY THIS DO LOOP.
C
      DO 16 I1 = KBA+1,KBB-1
      IF(CSTMTA(I1:I1) .EQ. CLPAR(1:1)) I2 = I2 + 1
      IF(CSTMTA(I1:I1) .EQ. CRPAR(1:1)) THEN
         I2 = I2 - 1
         IF(I2 + 1 .LE. 0 .AND. I1 .LT. KBB) THEN
C
C         WHEN A CHARACTER EXISTS FOLLOWING THE CLOSING RIGHT
C         PARENTHESIS, A SYNTAX ERROR EXISTS
C
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         A COMMA NOT OCCURRING WITHIN ENCAPSULATED LEFT AND RIGHT
C         PARENTHESES TERMINATES AN ARGUMENT SPECIFICATION. COMMAS THAT
C         A PART OF A SUBSCRIPT SPECIFICATION ARE NOT COUNTED.
C
      IF(CSTMTA(I1:I1) .EQ. COMMA(1:1) .OR. I1 .EQ. KBB - 1) THEN
C
C         DETERMINE IF THE MAXIMUM ARGUMENT COUNT EXCEEDS 30
C
         IF(I2 .EQ. 0) THEN
            I2WK1 = I2WK1 + 1
            IF(I2WK1 .GT. 30) THEN
               IREC0 = IREC0 + 1
               WRITE (0,106) ISN
C
C         SET PARAMETERS TO TERMINATE THE STATEMENT AFTER 30 ARGUMENTS,
C         AND BLANK THE REMAINDER OF THE STATEMENT
C
               IARGCT = 30
               I2WK1 = 30
               JBB = ILOC(I2WK1-1)
               IF(CSTMTA(JBB:JBB) .EQ. COMMA) THEN
                  CSTMTA(JBB:JBB) = CRPAR(1:1)
               ELSE
                  CSTMTA(JBB-1:JBB-1) = CRPAR(1:1)
               END IF
               DO 15 J1 = JBB+1,KB
               CSTMTA(J1:J1) = CBLANK(1:1)
 15            CONTINUE
               KBB = JBB
               GO TO 17
            END IF
            IF(CSTMTA(I1:I1) .EQ. COMMA) THEN
               ILOC(I2WK1) = I1
               IF(I1+1 .EQ. KBB) THEN
                  I2WK1 = I2WK1 + 1
                  ILOC(I2WK1) = KBB
               END IF
            ELSE
               IF(I1 .LT. KBB-1) THEN
                  ILOC(I2WK1) = I1
               ELSE
                  ILOC(I2WK1) = I1 + 1
               END IF
            END IF
         END IF
      END IF
 16   CONTINUE
C
C         SET THE TOTAL NUMBER OF ARGUMENTS IN THE LIST
C
      IARGCT = I2WK1
      NARGD = I2WK1
C
C     ******************************************************************
C     *                                                                *
C     *  THIS SECTION PROCESSES THE SUBPROGRAM NAME                    *
C     *                                                                *
C     ******************************************************************
C
C         FILL THE CWORK BUFFER WITH BLANKS, SET BIT SWITCHES TO OFF,
C         AND SET THE ISN VALUE
C
 17   CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      IWORK = ISN + 128
C
C         DETERMINE THE STATEMENT BEING PROCESSED. THE VALUE OF J WILL
C         BE SET TO THE START LOCATION OF THE SUBPROGRAM NAME. JA WILL
C         BE THE LOCATION OF THE STATEMENT'S FIRST CHARACTER - CALL,
C         ENTRY, FUNCTION, OR SUBROUTINE. A CALL STATEMENT SUBPROGRAM
C         NAME IS ASSUMED TO BE A SUBROUTINE; ALTH0UGH IT MAY BE AN
C         ENTRY STATEMENT.
C
      IF(CTYPED(1:1) .EQ. CCC(1:1)) THEN
         J = JA + 4
         JBITS = IBSET(JBITS,9)
         JBITS = IBCLR(JBITS,8)
         JBITS = IBCLR(JBITS,10)
      ELSE IF(CTYPED(1:1) .EQ. CEE(1:1)) THEN
         J = JA + 5
         JBITS = IBSET(JBITS,8)
         JBITS = IBCLR(JBITS,9)
         JBITS = IBCLR(JBITS,10)
      ELSE IF(CTYPED(1:1) .EQ. CFF(1:1)) THEN
         J = JA + 8
         JBITS = IBSET(JBITS,10)
         JBITS = IBCLR(JBITS,8)
         JBITS = IBCLR(JBITS,9)
C
C         DETERMINE IF THE FUNCTION IS THE FIRST NON-COMMENT STATEMENT
C
         IF(ISN .GT. 1) THEN
            IREC0 = IREC0 + 1
            WRITE (0,107) ISN
         END IF
      ELSE IF(CTYPED(1:1) .EQ. CSS(1:1)) THEN
         J = JA + 10
         JBITS = IBSET(JBITS,9)
C
C         DETERMINE IF THE SUBROUTINE IS THE FIRST NON-COMMENT STATEMENT
C
         IF(ISN .GT. 1) THEN
            IREC0 = IREC0 + 1
            WRITE (0,108) ISN
         END IF
      END IF
C
C         INDICATE WHETHER THE SUBPROGRAM NAME IS TO APPEAR IN THE
C         OUTPUT LISTINGS
C
      IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C        WHEN NO ARGUMENT LIST EXISTS, KBB IS THE FINAL CHARACTER OF THE
C        SUBPROGRAM NAME. I3 IS SET TO THE SUBPROGRAM NAME'S LENGTH.
C
      IF(IARGCT .EQ. 0) THEN
C
C         CREATE CWORK FOR FOR THE SUBPROGRAM NAME WITHOUT ARGUMENTS
C
         IF(KBA .EQ. 0) THEN
C
C         NO LENGTH SPECIFICATION EXISTS
C
            I3 = KBB - JA + 1
            CWORK(1:I3) = CSTMTA(JA:KBB)
         ELSE
C
C         A LENGTH SPECIFICATION EXISTS
C
            I3 = KBA -JA + 1
            CWORK(1:I3) = CSTMTA(JA:KBA-1)
         END IF
      ELSE
C
C         CREATE CWORK FOR FOR THE SUBPROGRAM NAME WITH ARGUMENTS
C
         I3 = KBA - JA
         CWORK(1:I3) = CSTMTA(JA:KBA-1)
      END IF
C
C         SET THE SUBPROGRAM NAME CHARACTER LENGTH
C
      IVCNT = I3
C
C         DETERMINE STATEMENT TYPE
C
      IF(CTYPED(1:1) .EQ. CEE(1:1) .OR. CTYPED(1:1) .EQ. CSS(1:1) .OR.
     1   CTYPED(1:1) .EQ. CCC(1:1)) THEN
C
C         SET THE CHARACTER IN COL. 37 TO PREVENT PRINTING TYPE AND
C         LENGTH INFORMATION FOR ENTRY AND SUBROUTINE SUBPROGRAMS
C
         CWORK(37:44) = CBAR(1:1)//CBLANK(1:7)
      ELSE IF(CTYPED(1:1) .EQ. CFF(1:1)) THEN
C
C         SET THE TYPE AND LENGTH CODE FOR A FUNCTION STATEMENT
C
         CWORK(37:44) = CWK8(1:8)
      END IF
C
C         DETERMINE IF THE FUNCTION NAME IS A DEFINED FUNCTION OF THIS
C         PROGRAM
C
      CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,1000)
      IF(IRET .GT. 0) THEN
         IF(BTEST(JSUBTB(12,IRET),8)) THEN
            JBITS = IBSET(JBITS,8)
         ELSE IF(BTEST(JSUBTB(12,IRET),9)) THEN
            JBITS = IBSET(JBITS,9)
         ELSE IF(BTEST(JSUBTB(12,IRET),10)) THEN
            JBITS = IBSET(JBITS,10)
         END IF
         CWORK(37:44) = CSUBTB(IRET)(37:44)
      END IF
C
C         DETERMINE IF THE FUNCTION NAME IS AN INTRINSIC FUNCTION
C
      CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRET,143)
      IF(IRET .GT. 0) THEN
         JBITS = IBSET(JBITS,10)
         JBITS = IBSET(JBITS,16)
         IF(FUNTBL(IRET)(34:34) .EQ. CSHARP) THEN
            CWORK(37:39) = FUNTBL(IRET)(33:33)//'? '
         ELSE
            CWORK(37:39) = FUNTBL(IRET)(33:35)
         END IF
      END IF
C
C         ENTER THE SUBPROGRAM NAME IN THE MASTER NAME TABLE. DO NOT USE
C         VSETUP HERE, BECAUSE A SUBPROGRAM NAME CAN NOT BE A COMPOUND
C         VARIABLE NAME.
C
      CALL CHKNME (CSTMTA)
C
C         SET THE NUMBER OF ARGUMENTS COUNT IN CSUBTB FOR THIS ENTRY,
C         FUNCTION, OR SUBPROGRAM DEFINITION.
C
      IF(ISUBTB .GT. 0) THEN
         CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,1000)
         IF(IRET .GT. 0) THEN
            JRECTB(17,IRET) = IARGCT
         ELSE
            JRECTB(17,IRET) = 0
         END IF
      END IF
C
C         PLACE THE SUBPROGRAM NAME IN FCMTH OF THE HEADER FOR THE
C         OUTPUT LISTING WHEN THE STATEMENT IS A SUBROUTINE OR FUNCTION
C         DEFINITION.  ENTRY STATEMENTS ARE NOT SUBPROGRAM NAMES.
C
      IF(CTYPED(1:1) .EQ. CSS(1:1) .OR. CTYPED(1:1) .EQ. CFF(1:1)) THEN
C
C         DO NOT CHANGE CFMTH IF THE STATEMENT IS FROM AN INCLUDE FILE
C
         IF(.NOT.LINCL) THEN
            I4WK1 = 64 + IVCNT - 1
            CFMTH(64:I4WK1) = CWORK(1:IVCNT)
            CPGNME(1:32) = CBLK52(1:32)
            CPGNME(1:IVCNT) = CWORK(1:IVCNT)
            IPGNME = IVCNT
            II = 32 - IVCNT
            IF(II .GT. 0) CFMTH(I4WK1+1:94) = CBLK52(1:II)
            LPROG = LTRUE
         END IF
      END IF
C
C         DETERMINE IF GLOBAL DIAGNOSTICS ARE BEING PERFORMED
C
      IF(LGLOBL) THEN
         IF(LCALL) THEN
C
C         WHEN THE STATEMENT IS A CALL STATEMENT, SET UP PART 1 OF THE
C         USAGE RECORD FOR UNIT 10
C
            CUSE1(1:52) = CWORK(1:52)
            CUSE1(53:IPGNME+52) = CPGNME(1:IPGNME)
            JVCNT = IPGNME
            ISNU = ISN + 128
            NARGD = IARGCT
C
C         WHEN NO ARGUMENT LIST EXISTS, WRITE THE UNIT 10 SUBPROGRAM
C         USAGE RECORD
C
            IF(IARGCT .EQ. 0) THEN
               IREC10 = IREC10 + 1
               WRITE (10,REC=IREC10) CUSE1(1:92)//CUSE3(1:1440)
               GO TO 45                     ! EXIT ARGLST
            END IF
         ELSE
C
C         IF THE STATEMENT IS NOT A CALL STATEMENT, SET UP PART 1 OF THE
C         SUBPROGRAM DEFINITION RECORD FOR UNIT 3
C
            CDEF(1:52) = CWORK(1:52)
            NARGS = IARGCT
            NARGD = IARGCT
            IF(IARGCT .EQ. 0) GO TO 45      ! EXIT ARGLST
         END IF
      ELSE
C
C         DETERMINE IF ANY ARGUMENT LIST EXISTS WHEN GLOBAL DIAGNOSTICS
C         ARE NOT REQUESTED
C
         IF(IARGCT .EQ. 0) GO TO 45         ! EXIT ARGLST
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *  THIS SECTION PROCESSES THE ARGUMENT LIST, IF ANY              *
C     *                                                                *
C     ******************************************************************
C
C
C         DETERMINE IF A CALL STATEMENT ARGUMENT LIST IS TO BE PROCESSED
C
      CWORK(37:44) = CBLANK(1:8)
      IF(LCALL) GO TO 20
C
C         ARGUMENTS OF ENTRY, FUNCTION, OR SUBROUTINE STATEMENTS ARE
C         PROCESSED HERE. THIS SECTION WILL CREATE A RECORD FOR UNIT 3
C         ONLY.
C
      DO 19 I1 = 1,IARGCT
C
C         INITIALIZE THE WORK BUFFER FOR EACH ARGUMENT'S PROCESSING
C
      CWK80(1:80) = CBLK52(1:50)//CBLK52(1:30)
C
C         SET THE INDIVIUAL ARGUMENT START AND END LOCATIONS FOR
C         PROCESSING
C
      IF(I1 .EQ. 1) THEN
         I3 = KBA + 1
      ELSE
         I3 = ILOC(I1-1) + 1
      END IF
      IF(I1 .EQ. IARGCT) THEN
         I4 = ILOC(I1)
         IF(CSTMTA(I4:I4) .GE. CAA .AND. CSTMTA(I4:I4) .LE. CZZ .OR.
     1      CSTMTA(I4:I4) .GE. C0 .AND. CSTMTA(I4:I4) .LE. C9 .OR.
     2      CSTMTA(I4:I4) .EQ. CUNDER .OR. CSTMTA(I4:I4) .EQ. CDOL)
     3      THEN
            CONTINUE
         ELSE
            I4 = ILOC(I1) - 1
         END IF
      ELSE
         I4 = ILOC(I1) - 1
      END IF
C
C         MOVE THE ARGUMENT FROM CSTMTA TO CWK80 FOR PROCESSING, I3 IS
C         THE START LOCATION AND I4 IS THE END LOCATION OF THE ARGUMENT.
C
      JLEN = I4 - I3 + 1
C
C         WRITE MESSAGE WHEN JLEN IS GREATER THAN 80 CHARACTERS
C
      IF(JLEN .GT. 80) THEN
         IREC0 = IREC0 + 1
         WRITE (0,113) ISN
      END IF
C
C         MOVE ARGUMENT TO WORK AREA. THE ARGUMENT WILL NOT CONTAIN
C         DELIMITER CHARACTERS AT THE START AND END OF THE FIELD.
C
      CWK80(1:JLEN) = CSTMTA(I3:I4)
C
C         DETERMINE IF ANY ARGUMENT IS AN ILLEGAL ARGUMENT FOR AN ENTRY,
C         FUNCTION, OR SUBROUTINE STATEMENT. THESE STATEMENTS MAY HAVE
C         DUMMY VARIABLES ONLY.
C
      DO 18 I2 = 1,JLEN
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      L6 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      L9 = LFALSE
      L10 = LFALSE
      L11 = LFALSE
      L12 = LFALSE
C
C        DETERMINE IF A MATHEMATICAL OR CHARACTER EXPRESSION ERROR
C
      IF((.NOT.L3 .OR. .NOT.L4) .AND. CWK80(1:1) .NE. CASTER) THEN
         IF(CWK80(I2:I2) .EQ. CPLUS .OR. CWK80(I2:I2) .EQ. CMINUS .OR.
     1      CWK80(I2:I2) .EQ. CASTER .OR. CWK80(I2:I2) .EQ. CSLASH) THEN
C
C         DETERMINE IF THE EXPRESSION IS A CHARACTER EXPRESSION
C
            IF(.NOT.L4 .AND. CWK80(I1:I1) .EQ. CSLASH) THEN
               IF(CWK80(I2+1:I2+1) .EQ. CSLASH) THEN
                  L4 = LTRUE
                  IREC0 = IREC0 + 1
                  WRITE (0,110) ISN,I1
                  GO TO 19                  ! NEXT ARGUMENT
               END IF
            END IF
C
C         DETERMINE IF THE EXPRESSION IS AN ARITHMETIC EXPRESSION
C
            IF(.NOT.L3) THEN
               L3 = LTRUE
               IREC0 = IREC0 + 1
               WRITE (0,104) ISN,I1
               GO TO 19                     ! NEXT ARGUMENT
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A NUMERIC VALUE ERROR
C
      IF(.NOT.L5) THEN
         IF(CWK80(I2:I2) .GE. C0 .AND. CWK80(I2:I2) .LE. C9 .OR.
     1      CWK80(I2:I2) .EQ. CDOT) THEN
            IF(CWK80(1:1) .GE. CAA .AND. CWK80(1:1) .LE. CZZ .OR.
     1         CWK80(1:1) .EQ. CUNDER .AND. CWK80(I2:I2) .NE. CDOT) THEN
               CONTINUE
            ELSE
               L5 = LTRUE
               IREC0 = IREC0 + 1
               WRITE (0,103) ISN,I1
               GO TO 19                     ! NEXT ARGUMENT
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A CHARACTER RANGE ERROR
C
      IF(.NOT.L6) THEN
         IF(CWK80(I2:I2) .EQ. COLON) THEN
            L6 = LTRUE
            IREC0 = IREC0 + 1
            WRITE (0,101) ISN,I1
            GO TO 19                        ! NEXT ARGUMENT
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A LITERAL ERROR
C
      IF(.NOT.L7) THEN
         IF(CWK80(I2:I2) .EQ. CSYMCF) THEN
            L7 = LTRUE
            IREC0 = IREC0 + 1
            WRITE (0,105) ISN,I1
            GO TO 19                        ! NEXT ARGUMENT
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A LOGICAL EXPRESSION ERROR
C
      IF(.NOT.L8) THEN
         IF(CWK80(I2:I2) .EQ. CSYMCD) THEN
            L8 = LTRUE
            IREC0 = IREC0 + 1
            WRITE (0,115) ISN,I1
            GO TO 19                        ! NEXT ARGUMENT
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A RETURN STATEMENT NUMBER
C
      IF(.NOT.L10) THEN
         IF((CWK80(1:1) .EQ. CAMP .OR. CWK80(1:1) .EQ. CASTER) .AND.
     1      JLEN .GT. 1) THEN
            IF(CWK80(2:2) .NE. COMMA .AND. CWK80(2:2) .NE. CRPAR) THEN
               L10 = LTRUE
               IREC0 = IREC0 + 1
               WRITE (0,109) ISN,I1
               GO TO 19                     ! NEXT ARGUMENT
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT HAS ILLEGAL CHARACTERS ERROR
C
      IF(.NOT.L9) THEN
         IF(.NOT.(CWK80(I2:I2) .GE. CAA .AND. CWK80(I2:I2) .LE. CZZ .OR.
     1      CWK80(I2:I2) .GE. C0 .AND. CWK80(I2:I2) .LE. C9 .OR.
     2      CWK80(I2:I2) .EQ. CUNDER .OR. CWK80(I2:I2) .EQ. CDOL .OR.
     3      CWK80(I2:I2) .EQ. CPLUS .OR. CWK80(I2:I2) .EQ. CMINUS .OR.
     4      CWK80(I2:I2) .EQ. CASTER .OR. CWK80(I2:I2) .EQ. CSLASH .OR.
     5      CWK80(I2:I2) .EQ. CAMP)) THEN
            L9 = LTRUE
            IREC0 = IREC0 + 1
            WRITE (0,116) ISN,I1
            GO TO 19                        ! NEXT ARGUMENT
         END IF
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A LOGICAL CONSTANT
C
      IF(.NOT.L11) THEN
         IF(CWK80(I2:I2) .EQ. CDOT .AND. (CWK80(I2:I2+5) .EQ. '.TRUE.'
     1      .OR. CWK80(I2:I2+6) .EQ. '.FALSE.')) THEN
            L11 = LTRUE
            IREC0 = IREC0 + 1
            WRITE (0,111) ISN,I1
            GO TO 19                        ! NEXT ARGUMENT
         END IF
      END IF
C
C         WHEN AN ALPHABETIC CHARACTER IS FOUND, IT IS EXPECTED TO BE A
C         VARIABLE NAME. DETERMINE IF THE END OF THE VARIABLE NAME IS A
C         LEFT PARENTHESIS INDICATING A CHARACTER RANGE OR SUBSCRIPT IS
C         SPECIFIED.
C
      IF(.NOT.L12) THEN
         IF(CWK80(I2:I2) .GE. CAA .AND. CWK80(I2:I2) .LE. CZZ .OR.
     1      CWK80(I2:I2) .EQ. CUNDER) THEN
C
C        DETERMINE THE END OF THE VARIABLE NAME. WHEN THE TERMINUS OF
C        THE VARIABLE NAME IS A LEFT PARENTHESIS, EITHER A SUBSCRIPT OR
C        RANGE SPECIFICATION EXISTS, ASSUME A SUBSCRIPT EXISTS, SINCE
C        THE RANGE SPECIFICATION IS TESTED FOR SEPARATLY.
C
            DO 180 I5 = I2,JLEN
            IF(.NOT.(CWK80(I5:I5) .GE. CAA .AND. CWK80(I5:I5) .LE. CZZ
     1         .OR. CWK80(I5:I5) .GE. C0 .AND. CWK80(I5:5) .LE. C9 .OR.
     2         CWK80(I5:I5) .EQ. CUNDER .OR. CWK80(I5:I5) .EQ. CDOL))
     3         THEN
               IF(CWK80(I5:I5) .EQ. CLPAR) THEN
                  L12 = LTRUE
                  IREC0 = IREC0 + 1
                  WRITE (0,102) ISN,I1
               END IF
            END IF
 180        CONTINUE
         END IF
      END IF
 18   CONTINUE
C
C         WHEN AN ENTRY, FUNCTION, OR SUBROUTINE SUBPROGRAM STATEMENT
C         IS BEING PROCESSED, NO LIST ARGUMENT MAY BE SUBSCRIPTED,
C         HAVE A CHARACTER RANGE SPECIFIED, BE AN EXPRESSION, OR BE A
C         NUMERICAL VALUE. AN ARGUMENT MAY ONLY BE A VARIABLE NAME, A
C         PROGRAM DEFINED FUNCTION NAME, AN ALTERNATIVE RETURN
C         SPECIFICATION, AN INTRINSIC FUNCTION NAME, OR AN EXTERNAL
C         PROCEDURE NAME. AN ARGUMENT NAME MAY NOT BE A COMPOUND NAME,
C         OR A LITERAL.
C
C         DETERMINE IF THE ARGUMENT IS A RETURN STATEMENT DESIGNATION.
C         THE INITIAL CHARACTER OF THE ARGUMENT FIELD MUST BE AN
C         ASTERISK OR AN AMPERSAND.
C
      IF(CWK80(1:1) .EQ. CAMP .OR. CSTMTA(1:1) .EQ. CASTER) THEN
C
C         SET UP THE ARGUMENT DATA FOR GLOBAL PROCESSING
C
         IF(.NOT.LINCL) THEN
            IF(LGLOBL) THEN
               I4WK1 = 6
C
C         CREATE ARGUMENT DATA FOR UNIT 3
C
               CDEF2(I1)(1:6) =  'C##STM'
               CDEF2(I1)(33:40) = CBLANK(1:8)
               CDEF2(I1)(41:44) = CZERO(1:4)
               CDEF2(I1)(45:48) = CI4WK1(1:4)
            END IF
         END IF
         GO TO 19     ! NEXT ARGUMENT
      END IF
C
C         DETERMINE IF THE ARGUMENT IS A VARIABLE NAME
C
      IF(CWK80(1:1) .GE. CAA .AND. CWK80(1:1) .LE. CZZ .OR. CWK80(1:1)
     1   .EQ. CUNDER) THEN
C
C         DETERMINE IF THE ARGUMENT VARIABLE NAME EXCEEDS 32 CHARCTERS
C
         IF(JLEN .GT. 32) THEN
            IREC0 = IREC0 + 1
            WRITE (0,121) ISN,CWK80(1:32)
            JLEN = 32
         END IF
C
C        CREATE THE WORK AREA TO INSERT THE VARIABLE NAME INTO THE
C        MASTER NAME TABLE. USE CHKNME INSTEAD OF VSETUP, SINCE THE
C        VARIABLE NAME IN AN ENTRY, FUNCTION, OR SUBROUTINE STATEMENT
C        ARGUMENT CAN NOT BE A COMPOUND NAME.
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         CWORK(1:JLEN) = CWK80(1:JLEN)
C
C         DETERMINE IF THE ARGUMENT VARIABLE IS IN THE MASTER NAME
C         TABLE. FOR THE ARGUMENT LIST OF A FUNCTION OR SUBROUTINE
C         SUBPROGRAM, IT CAN NOT BE IN THE TABLE, BUT WHEN AN ENTRY
C         STATEMENT IS BEING PROCESSED, IT MAY IN THE TABLE.
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
            CWORK(37:44) = CNAME(IRET)(37:44)
         ELSE
            CALL SETTL (CWORK)
         END IF
         IWORK = ISN + 128
         JBITS = IBSET(JBITS,7)
         JBITS = IBSET(JBITS,15)
         JBITS = IBSET(JBITS,20)
         IVCNT = JLEN
         CALL CHKNME (CSTMTA)
C
C         SET UP THE ARGUMENT DATA FOR GLOBAL PROCESSING
C
         IF(.NOT.LINCL) THEN
            IF(LGLOBL) THEN
C
C         CREATE ARGUMENT DATA FOR UNIT 3
C
               CDEF2(I1)(1:JLEN) = CWORK(1:JLEN)
               CDEF2(I1)(33:40) = CWORK(37:44)
               CDEF2(I1)(41:44) = CWORK(45:48)
               IDEF2(12,I1) = JLEN
            END IF
         END IF
      END IF
 19   CONTINUE
C
C         ALL ARGUMENTS OF THE ARGUMENT LIST FOR ENTRY, FUNCTION, AND
C         SUBROUTINE STATEMENTS ARE PROCESSED.
C
      GO TO 45                              ! EXIT ARGLST
C
C     ******************************************************************
C     *                                                                *
C     *   ARGUMENTS OF CALL STATEMENTS ARE PROCESSED HERE              *
C     *                                                                *
C     ******************************************************************
C
C         PROCESS EACH ARGUMENT ONE AT A TIME
C
C
C         DETERMINE IF ANY ARGUMENTS EXISTS IN A CALL STATMENT
C
 20   IF(IARGCT .EQ. 0) GO TO 44
      DO 43 I1 = 1,IARGCT
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         SET LCALL TO FALSE, SINCE NO VARIABLE NAME USED IN A CHARACTER
C         RANGE SPECIFICATION IS AN ARGUMENT OF THE CALL STATEMENT, NO
C         RECORD WILL BE WRITTEN ON UNIT 10 FOR RANGE SPECIFICATIONS.
C
      L2 = LFALSE
      LCALL = LFALSE
C
C         DETERMINE THE INDIVIUAL ARGUMENT START AND END LOCATIONS FOR
C         PROCESSING
C
      IF(I1 .EQ. 1) THEN
         I3 = KBA + 1
      ELSE
         I3 = ILOC(I1-1) + 1
      END IF
      IF(I1 .EQ. IARGCT) THEN
         I4 = ILOC(I1)
         IF(CSTMTA(I4:I4) .GE. CAA .AND. CSTMTA(I4:I4) .LE. CZZ .OR.
     1      CSTMTA(I4:I4) .GE. C0 .AND. CSTMTA(I4:I4) .LE. C9 .OR.
     2      CSTMTA(I4:I4) .EQ. CUNDER .OR. CSTMTA(I4:I4) .EQ. CDOL)
     3      THEN
C
C         DETERMINE IF THE CHARACTER FOLLOWING THE FINAL CHARACTER OF
C         THE VARIABLE NAME IS A LEFT PARENTHESIS INDICATING A SUBSCRIPT
C         EXISTS FOR THE VARIABLE.
C
            IF(CSTMTA(I4+1:I4+1) .EQ. CLPAR) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102) ISN,I1
            END IF
            CONTINUE
         ELSE
            I4 = ILOC(I1) - 1
         END IF
      ELSE
         I4 = ILOC(I1) - 1
      END IF
C
C         MOVE THE ARGUMENT FROM CSTMTA TO CWK80 FOR PROCESSING, I3 IS
C         THE START LOCATION AND I4 IS THE END LOCATION OF THE ARGUMENT.
C
      JLEN = I4 - I3 + 1
C
C         WRITE MESSAGE WHEN JLEN IS GREATER THAN 80 CHARACTERS
C
      IF(JLEN .GT. 80) THEN
         IREC0 = IREC0 + 1
         WRITE (0,113) ISN
      END IF
C
C         MOVE ARGUMENT TO WORK AREA
C
      CWK80(1:80) = CBLK52(1:50)//CBLK52(1:30)
      CWK80(1:JLEN) = CSTMTA(I3:I4)
C
C     ******************************************************************
C     *                                                                *
C     *   PROCESS ANY CHARACTER RANGE SPECIFICATIONS                   *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF ANY CHARACTER RANGE SPECIFICATIONS EXIST WITHIN
C         THE ARGUMENT. THIS LOOP WILL PROCESS ALL CHARACTER RANGE
C         SPECIFICATIONS WITHIN THE CALL STATEMENT ARGUMENT. A
C         CHARACTER RANGE SPECIFICATION MAY BE AN ARITHMETIC EXPRESSION,
C         A SINGLE VARIABLE NAME, OR AN INTEGER NUMERIC VALUE. WHEN
C         GLOBAL ANALYSIS IS TO BE PERFORMED, NO VARIABLE NAME USED IN
C         A CHARACTER RANGE SPECIFICATION WILL HAVE A RECORD WRITTEN
C         ON UNIT 10.
C
      ILOCLV = 0
      ILOCRV = 0
      ICOLCT = 0
      LS1 = LFALSE
C
C         DETERMINE IF A COLON EXISTS
C
      DO 200 I2 = 1,JLEN
      IF(CWK80(I2:I2) .EQ. COLON) THEN
         LS1 = LTRUE
         ICOLCT = ICOLCT + 1
         ILOCC(ICOLCT) = I2
      END IF
 200  CONTINUE
C
C         WHEN NO CHARACTER RANGE SPECIFCATION EXISTS, PROCESS ANY
C         SUBSCRIPT SPECIFICATIONS
C
      IF(.NOT. LS1) GO TO 26
C
C         PROCESS A CHARACTER RANGE SPECIFICATION
C
      DO 25 I2 = 1,ICOLCT
C
C         DETERMINE IF A COLON OCCURS
C
      I11 = ILOCC(I2)
      IF(CWK80(I11:I11) .EQ. COLON) THEN
C
C         DETERMINE IF NO LOW VALUE EXISTS FOR THE CHARACTER RANGE
C         SPECIFICATION
C
         IF(CWK80(I11-1:I11-1) .EQ. CLPAR) THEN
            ILOCL = I11 - 1
            GO TO 22
         END IF
C
C         DETERMINE THE LOCATION OF THE LEFT BOUNDARY OF THE LOW VALUE
C         OF THE CHARACTER RANGE SPECIFICATION
C
         I6 = 0
         LR1 = LFALSE
         LR2 = LFALSE
         LR3 = LFALSE
         LR4 = LFALSE
         LR5 = LFALSE
C
C         SCAN BACKWARDS FROM THE COLON UNTIL AN UNBALANCED LEFT
C         PARENTHESIS IS LOCATED. THAT LOCATION IS THE LEFT BOUNDARY
C         OF THE LOW CHARACTER RANGE SPECIFICATION.
C
         DO 21 I5 = I11-1,1,-1
C
C         COUNT RIGHT PARENTHESES
C
         IF(CWK80(I5:I5) .EQ. CRPAR) I6 = I6 - 1
C
C         COUNT LEFT PARENTHESES
C
         IF(CWK80(I5:I5) .EQ. CLPAR) I6 = I6 + 1
C
C         DETERMINE IF AN ARITHMETIC OPERATOR EXISTS WITHIN THE LOW
C         VALUE OF THE CHARACTER RANGE SPECIFICATION
C
         IF(CWK80(I5:I5) .EQ. CPLUS .OR. CWK80(I5:I5) .EQ. CMINUS .OR.
     1      CWK80(I5:I5) .EQ. CASTER .OR. CWK80(I5:I5) .EQ. CSLASH)
     2      LR1 = LTRUE
         IF(CWK80(I5:I5) .EQ. CSLASH .AND. CWK80(I5+1:I5+1) .EQ.
     1      CSLASH) THEN
            LR2 = LTRUE
            LR1 = LFALSE
         END IF
C
C         DETERMINE IF A LOGICAL EXPRESSION OR A LITERAL EXISTS
C
         IF(CWK80(I5:I5) .EQ. CSYMCD .OR. CWK80(I5:I5) .EQ. CSYMCF .AND.
     1      .NOT.LR5) THEN
            IREC0 = IREC0 + 1
            WRITE (0,118) ISN,I1
            LR5 = LTRUE
         END IF
C
C         A PERIOD MAY BE PART OF A COMPOUND NAME OR PART OF A NUMBER
C
C        IF(CWK80(I5:I5) .EQ. CDOT) LR3 = LTRUE
         IF(CWK80(I5:I5) .EQ. CDOT) THEN
            IF(CWK80(I5-1:I5-1) .GE. C0 .AND. CWK80(I5-1:I5-1) .LE. C9
     1         .OR. CWK80(I5+1:I5+1) .GE. C0 .AND. CWK80(I5+1:I5) .LE.
     2         C9 .OR. CWK80(I5+1:I5+1) .EQ. CEE .OR. CWK80(I5+1:I5+1)
     3         .EQ. CDD .OR. CWK80(I5+1:I5+1) .EQ. CRPAR .OR.
     4          CWK80(I5+2:I5+1) .EQ. COMMA) THEN
               LR3 = LFALSE
            ELSE
               LR3 = LTRUE
            END IF
         END IF
C
C         WHEN I6 HAS A VALUE OF ONE, THE LEFT BOUNDARY OF THE LOW
C         CHARACTER RANGE SPECIFICATION HAS BEEN FOUND.
C
         IF(I6 .EQ. 1) THEN
C
C         SAVE THE LOCATION OF THE LEFT BOUNDARY OF THE RANGE
C         SPECIFICATION
C
            ILOCL = I5
C
C         WHEN A LITERAL OR A LOGICAL OPERATOR EXISTS IN THE LOW
C         CHARACTER RANGE SPECIFICATION, DO NOT PROCESS THE LOW VALUE
C
            IF(LR5) GO TO 22
C
C         SET THE LEFT AND RIGHT BOUNDARIES OF THE LOW VALUE OF THE
C         CHARACTER RANGE SPECIFICATION
C
            I7 = ILOCL + 1                  ! START LOCATION
            I8 = I11 - 1                    ! END LOCATION
C
C         DETERMINE IF THE LOW CHARACTER RANGE VALUE IS AN EXPRESSION.
C         A CHARACTER RANGE LOWER VALUE IS NOT AN ARGUMENT OF THE CALL
C         STATEMENT, SINCE IT IS A MODIFIER OF THE ACTUAL CALL STATEMENT
C         ARGUMENT.
C
            IF(LR1) THEN
               CALL EXPRA (I7,I8,LFALSE,CWK80)
               GO TO 22                     ! PROCESS UPPER RANGE VALUE
            END IF
C
C         DETERMINE IF THE RANGE VALUE IS A CHARACTER EXPRESSION. THIS
C         IS AN ILLEGAL SPECIFICATION, SINCE A CHARACTER RANGE MUST
C         EVALUATE TO AN INTEGER VALUE.
C
            IF(LR2) THEN
               IREC0 = IREC0 + 1
               WRITE (0,117) ISN,I1
               GO TO 22                     ! PROCESS UPPER RANGE VALUE
            END IF
C
C         THE LOWER VALUE OF A CHARACTER RANGE SPECIFICATION IS EITHER
C         A NUMERICAL VALUE OR A SINGLE VARIABLE NAME RATHER THAN AN
C         ARITHMETIC EXPRESSION.
C
            IF(.NOT.LR1 .AND. .NOT.LR2) THEN
C
C         DETERMINE IF A SINGLE VARIABLE NAME (CAN BE A COMPOUND NAME).
C         ANY VARIABLE NAME USED IN AN ARGUMENT WILL BE DEFINED BY NOW.
C
C
               IF(CWK80(I7:I7) .GE. CAA .AND. CWK80(I7:I7) .LE. CZZ .OR.
     1            CWK80(I7:I7) .EQ. CUNDER) THEN
                  I16 = 0
                  IF(CWK80(I8:I8) .EQ. CRPAR) THEN
                     DO 201 I18 = I7,I8
                     IF(CWK80(I18:I18) .EQ. CLPAR .OR. CWK80(I18:I18)
     1                  .EQ. CRPAR .AND. I16 .EQ. 0) THEN
                        I16 = I18 - 1
                     END IF
 201                 CONTINUE
                     I16 = I8 - 1
                  ELSE
                     I16 = I8
                  END IF
                  KLEN = I16 - I7 + 1
                  CWORK(1:32) = CWK80(I7:I16)//CBLK52(1:32-KLEN)
                  CALL SETTL (CWORK)
                  JBITS = 0
                  JBITS = IBCLR(JBITS,8)
                  JBITS = IBCLR(JBITS,9)
                  JBITS = IBCLR(JBITS,10)
                  JBITS = IBSET(JBITS,15)
                  CALL VSETUP (I7,I16,KLEN,LFALSE,LFALSE,CWK80)
                  GO TO 22                  ! PROCESS UPPER RANGE VALUE
               END IF
C
C         DETERMINE IF A NUMERICAL FIELD
C
               IF(CWK80(I7:I7) .GE. C0 .AND. CWK80(I7:I7) .LE. C9)
     1            THEN
                  LR4 = LTRUE
                  CALL NUMBER (CWK80,LR4,I7,II,FP,IFP)
                  ILOCLV = II
                  IF(.NOT.LR4) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,118) ISN,I1
                  END IF
                  GO TO 22                  ! PROCESS UPPER RANGE VALUE
               END IF
            END IF
         END IF
 21      CONTINUE
C
C         PROCESS UPPER RANGE SPECIFICATION
C
 22      LR1 = LFALSE
         LR2 = LFALSE
         LR3 = LFALSE
         LR4 = LFALSE
         LR5 = LFALSE
         I6 = 0
         I7 = I11 + 1                       ! START LOCATION
         I8 = JLEN                          ! END LOCATION
         J1 = 0
         J2 = 0
C
C         DETERMINE IF NO UPPER VALUE EXISTS FOR THE CHARACTER RANGE
C         SPECIFICATION. I11 IS THE LOCATION OF THE COLON.
C
         IF(CWK80(I7:I7) .EQ. CRPAR) THEN
            I12 = I11
            ILOCR = I7
            GO TO 24
         END IF
C
C         DETERMINE THE RIGHT BOUNDARY OF THE UPPER RANGE SPECIFICATION
C
         DO 23 I5 = I7,I8
C
C         COUNT LEFT PARENTHESES. A LEFT PARENTHESIS OCCURING BEFORE
C         A RIGHT PARENTHESIS MEANS THE UPPER RANGE SPECIFICATION
C         VARIABLE IS SUBSCRIPTED OR A FUNCTION WITH AN ARGUMENT LIST.
C
         IF(CWK80(I5:I5) .EQ. CLPAR) THEN
            I6 = I6 + 1
            IF(J1 .EQ. 0) J1 = I5
         END IF
C
C         COUNT RIGHT PARENTHESES
C
         IF(CWK80(I5:I5) .EQ. CRPAR) THEN
            I6 = I6 - 1
            IF(J2 .EQ. 0) J2 = I5
         END IF
C
C         DETERMINE IF AN ARITHMETIC OPERATOR EXISTS WITHIN THE UPPER
C         VALUE OF THE CHARACTER RANGE SPECIFICATION
C
         IF(CWK80(I5:I5) .EQ. CPLUS .OR. CWK80(I5:I5) .EQ. CMINUS .OR.
     1      CWK80(I5:I5) .EQ. CASTER .OR. CWK80(I5:I5) .EQ. CSLASH)
     2      LR1 = LTRUE
         IF(CWK80(I5:I5) .EQ. CSLASH .AND. CWK80(I5+1:I5+1) .EQ.
     1      CSLASH) THEN
            LR2 = LTRUE
            LR1 = LFALSE
         END IF
C
C         A PERIOD MAY BE PART OF A COMPOUND NAME OR PART OF A NUMBER
C
         IF(CWK80(I5:I5) .EQ. CDOT) LR3 = LTRUE
C
C         DETERMINE IF A LOGICAL EXPRESSION OR A LITERAL EXISTS
C
         IF(CWK80(I5:I5) .EQ. CSYMCD .OR. CWK80(I5:I5) .EQ. CSYMCF .AND.
     1      I6 .LE. 0 .AND. .NOT.LR5) THEN
            IREC0 = IREC0 + 1
            WRITE (0,118) ISN,I1
            LR5 = LTRUE
            GO TO 24
         END IF
C
C         WHEN I6 HAS A VALUE OF MINUS ONE, THE RIGHT BOUNDAY OF THE
C         UPPER CHARACTER RANGE SPECIFICATION HAS BEEN FOUND.
C
         IF(I6 .EQ. -1) THEN
C
C         SAVE THE LOCATION OF THE RIGHT BOUNDARY OF THE UPPER RANGE
C         SPECIFICATION
C
            ILOCR = I5
C
C         DETERMINE IF THE UPPER RANGE SPECIFICATION IS AN EXPRESSION.
C         A CHARACTER RANGE UPPER VALUE IS NOT AN ARGUMENT OF A CALL
C         STATEMENT, SINCE IT IS A MODIFIER OF THE ACTUAL CALL
C         STATEMENT ARGUMENT.
C
            IF(LR1) THEN
               CALL EXPRA (I7,I8,LFALSE,CWK80)
               GO TO 24                     ! BLANK THE RANGE VALUES
            END IF
C
C         DETERMINE IF THE RANGE IS A CHARACTER EXPRESSION. THIS IS
C         AN ILLEGAL SPECIFICATION, SINCE A CHARACTER RANGE MUST
C         EVALUATE TO AN INTEGER VALUE.
C
            IF(LR2) THEN
               IREC0 = IREC0 + 1
               WRITE (0,117) ISN,I1
               GO TO 24                     ! BLANK THE RANGE VALUES
            END IF
C
C         THE UPPER VALUE OF A CHARACTER RANGE SPECIFICATION IS EITHER
C         A NUMERICAL VALUE OR A SINGLE VARIABLE NAME RATHER THAN AN
C         ARITHMETIC EXPRESSION.
C
            IF(.NOT.LR1 .AND. .NOT.LR2) THEN
C
C         DETERMINE IF A SINGLE VARIABLE NAME (CAN BE A COMPOUND NAME)
C
               IF(CWK80(I7:I7) .GE. CAA .AND. CWK80(I7:I7) .LE. CZZ .OR.
     1            CWK80(I7:I7) .EQ. CUNDER) THEN
                  I16 = 0
                  IF(CWK80(ILOCR:ILOCR) .EQ. CRPAR) THEN
                     DO 202 I18 = I7,ILOCR
                     IF(CWK80(I18:I18) .EQ. CLPAR .OR. CWK80(I18:I18)
     1                  .EQ. CRPAR .AND. I16 .EQ. 0) THEN
                        I16 = I18 - 1
                     END IF
 202                 CONTINUE
                     IF(I16 .EQ. 0) I16 = ILOCR - 1
                  ELSE
                     I16 = ILOCR - 1
                  END IF
                  KLEN = I16 - I7 + 1
                  CWORK(1:32) = CWK80(I7:I16)//CBLK52(1:32-KLEN)
                  CALL SETTL (CWORK)
                  JBITS = 0
                  JBITS = IBCLR(JBITS,8)
                  JBITS = IBCLR(JBITS,9)
                  JBITS = IBCLR(JBITS,10)
                  JBITS = IBSET(JBITS,15)
                  CALL VSETUP (I7,I16,KLEN,LFALSE,LFALSE,CWK80)
                  GO TO 24                  ! BLANK THE RANGE VALUES
C
C         DETERMINE IF A NUMERICAL FIELD
C
               ELSE IF(CWK80(I7:I7) .GE. C0 .AND. CWK80(I7:I7) .LE. C9)
     1            THEN
                  LR4 = LTRUE
                  CALL NUMBER (CWK80,LR4,I7,II,FP,IFP)
                  ILOCRV = II
                  IF(.NOT.LR4) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,118) ISN,I1
                  END IF
                  GO TO 24                  ! BLANK THE RANGE VALUES
               END IF
            END IF
         END IF
 23      CONTINUE
      END IF
C
C         DETERMINE IF A COLON WAS FOUND WITHIN THE ARGUMENT
C
 24   IF(.NOT.LS1) THEN
         I12 = 1
         GO TO 29
      END IF
C
C       DETERMINE LENGTH OF THE CHARACTER RANGE SPECIFICATION
C
      KLEN = ILOCR - ILOCL + 1
C
C         DELETE THE RANGE SPECIFICATION JUST PROCESSED FROM THE CALL
C         STATEMENT ARGUMENT
C
      IF(KLEN .GT. 50) THEN
         CWK80(ILOCL:ILOCR) = CBLK52(1:50)//CBLK52(1:KLEN-50)
      ELSE
         CWK80(ILOCL:ILOCR) = CBLK52(1:KLEN)
      END IF
 25   CONTINUE
C
C         REMOVE ALL BLANKS FROM THE ARGUMENT AFTER ALL CHARACTER RANGE
C         SPECIFICATIONS HAVE BEEN PROCESSED
C
 26   IF(LS1) THEN
C
C         AFTER ALL CHARACTER RANGE SPECIFICATIONS HAVE BEEN PROCESSED,
C         REMOVE ALL BLANKS FROM THE MODIFIED ARGUMENT EXPRESSION.
C         CALL STATEMENT ARGUMENTS WILL NOW HAVE ALL CHARACTER RANGE
C         SPECIFICATIONS REMOVED.
C
         DO 28 I12 = 1,JLEN
C
C         DETERMINE THE LEFT MOST BLANK OF THE CALL STATEMENT ARGUMENT
C
         IF(CWK80(I12:I12) .EQ. CBLK52(1:1)) THEN
            I13 = I12 + 1
C
C         WHEN I13 EXCEEDS THE VALUE OF JLEN, NO FIELD NEEDS TO BE
C         FILLED WITH BLANKS. SET THE CORRECT VALUE OF JLEN OF THE
C         REMAINING NON-BLANK FIELD IN CWK80.
C
            IF(I13 .GT. JLEN) THEN
               JLEN = ILOCL - 1
            END IF
C
C         LOOP TO LOCATE THE FIRST NONBLANK CHARACTER FOLLOWING THE
C         BLANK
C
            DO 27 I2WK1 = I13,JLEN
            IF(CWK80(I2WK1:I2WK1) .NE. CBLANK) THEN
               KLEN = I2WK1 - I12           ! SIZE OF BLANK FIELD
               I5 = JLEN - KLEN             ! NUMBER OF CHARACTERS MOVED
C
C         MOVE ALL CHARACTERS RIGHT OF LOCATION I2WK1 LEFT KLEN
C         CHARACTERS
C
               CWK80(I12:JLEN-KLEN+1) = CWK80(I2WK1:JLEN)
               JLEN = JLEN - KLEN           ! SET ARGUMENT'S NEW LENGTH
C
C         BLANK THE REMAINING CHARACTERS ON CWK80.
C
               IF(80-JLEN .LE. 50) THEN
                  CWK80(JLEN+1:80) = CBLK52(1:80-JLEN)
               ELSE
                  CWK80(JLEN+1:80) = CBLK52(1:50)//CBLK52(1:80-JLEN)
               END IF
C
C         REMOVE THE NEXT CHARACTER RANGE SPECIFICATION, IF ANY
C
               GO TO 26
            END IF
 27         CONTINUE
         END IF
 28      CONTINUE
      END IF
      LS2 = LFALSE
C
C         WHEN THIS STAGE OF PROCESSING IS REACHED, ALL CHARACTER RANGE
C         SPECIFICATIONS HAVE BEEN PROCESSED AND REMOVED FROM THE CALL
C         ARGUMENT. THE VALUE OF JLEN CONTAINS THE NEW LENGTH OF THE
C         CALL ARGUMENT.
C
C     ******************************************************************
C     *                                                                *
C     *   PROCESS ANY SUBSCRIPT SPECIFICATIONS                         *
C     *                                                                *
C     ******************************************************************
C
C         SEARCH FOR ANY SUBSCRIPT SPECIFICATIONS FOR THE VARIABLES
C         WITHIN THE CALL ARGUMENT. ANY PARENTHESES REMAINING IN THE
C         ARGUMENT MAY BE FOR AN ARITHMETIC EXPRESSION OR SUBSCRIPTS.
C         NO SUBSCRIPT VARIABLE IS CODED AS AN ARGUMENT OF A CALL
C         STATEMENT.
C
      I12 = 1
 29   DO 36 I2 = I12,JLEN
C
C         DETERMINE THE START OF A VARIABLE ARGUMENT NAME
C
      IF(CWK80(I2:I2) .GE. CAA .AND. CWK80(I2:I2) .LE. CZZ .OR.
     1   CWK80(I2:I2) .EQ. CUNDER .OR. CWK80(I2:I2) .EQ. CPERC) THEN
C
C         DETERMINE IF A SUBSCRIPT EXISTS FOR THE CURRENT ARGUMENT
C         VARIABLE
C
          IF(CWK80(JLEN:JLEN) .NE. CRPAR) GO TO 40
C
C         DETERMINE THE END LOCATION OF THE VARIABLE NAME
C
         DO 35 I5 = I2,JLEN
         IF(CWK80(I5:I5) .EQ. CPLUS .OR. CWK80(I5:I5) .EQ. CMINUS .OR.
     1      CWK80(I5:I5) .EQ. CASTER .OR. CWK80(I5:I5) .EQ. CSLASH .OR.
     2      CWK80(I5:I5) .EQ. CLPAR .OR. CWK80(I5:I5) .EQ. CRPAR) THEN
C
C         THE LEFT AND RIGHT BOUNDARIES OF THE VARIABLE NAME ARE NOW
C         KNOWN; CATALOG THE VARIABLE NAME.
C
            IF(LCALL) THEN
               L1 = LTRUE
            ELSE
               L1 = LFALSE
            END IF
            I12 = I5 - 1
            I13 = I5 - I2
C           CWORK(1:I5-I2+1) = CWK80(I2:I5)
C           IWORK = ISN + 128
C           IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
            CALL VSETUP (1,I12,I13,L1,L14,CWORK)
C
C         ONLY A LEFT PARENTHESIS TERMINATING THE VARIABLE NAME MAY
C         BE THE LEFT BOUNDARY OF A SUBSCRIPT SPECIFICATION. NO OTHER
C         CHARACTER CAN START A SUBSCRIPT SPECIFICATION. THIS LEFT
C         PARENTHESIS IS NOT PART OF AN ARITHMETIC EXPRESSION.
C
            I10 = 0
            IF(CWK80(I5:I5) .EQ. CLPAR) THEN
               LS2 = LTRUE
               ILOCL = I5
C
C         LOCATE THE RIGHT BOUNDARY OF THE SUBSCRIPT SPECIFICATION
C
               LA = LFALSE
               LS3 = LFALSE
               DO 30 I9 = I5+1,JLEN
               IF(CWK80(I9:I9) .EQ. CLPAR) I10 = I10 + 1
               IF(CWK80(I9:I9) .EQ. CRPAR) I10 = I10 - 1
               IF(CWK80(I9:I9) .EQ. COMMA) LS3 = LTRUE
               IF(.NOT.LA .AND. CWK80(I9:I9) .EQ. CSYMCD .OR.
     1            CWK80(I9:I9) .EQ. CSYMCF) LA = LTRUE
               IF(I10 .EQ. -1) THEN
                  ILOCR = I9
                  IF(LA .AND. CWK80(1:1) .NE. CPERC) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,120) ISN,I1
                     KLEN = ILOCR - ILOCL + 1
                     IF(KLEN .GT. 50) THEN
                        CWK80(ILOCL:ILOCR) = CBLK52(1:50)//
     1                                       CBLK52(1:KLEN-50)
                     ELSE
                        CWK80(ILOCL:ILOCR) = CBLK52(1:KLEN)
                     END IF
                     I12 =  ILOCR + 1
                     GO TO 29
                  END IF
                  GO TO 31
               END IF
 30            CONTINUE
C
C         THE LEFT AND RIGHT BOUNDARIES OF THE SUBSCRIPT ARE DETERMINED.
C         OBTAIN THE DIMENSION DATA FROM THE CDIM TABLE.
C
 31            CWK32(1:32) = CBLK52(1:32)
               CWK32(1:I5-I2) = CWK80(I2:I5-1)
               CALL TABSRH (CDIM,JDIM,104,1,32,CWK32,1,32,IRET,1000)
               IF(IRET .LT. 0) THEN
C
C         WHEN THE VARIABLE NAME THAT HAS A SUBSCRIPT, DETERMINE IF THE
C         NAME IS ONE OF THE FUNCTIONS: %LOC, %REF, OR &VAL
C
                  IF(CWK32(1:1) .NE. CPERC) THEN
C
C         DETERMINE IF THE VARIABLE NAME IS A DEFINED FUNCTION OR AN
C         INTRINSIC FUNCTION
C
                     CALL TABSRH (CNAME,INAME,52,1,32,CWK32,1,32,IRET1,
     1                            4000)
                     CALL TABSRH (FUNTBL,143,35,1,32,CWK32,1,32,IRET2,
     1                            143)
                     IF(IRET2 .LT. 0 .AND. .NOT.BTEST(IENAME(12,IRET1),
     1               10)) THEN
C
C         DETERMINE IF THE VARIABLE NAME IS AN OS2 API MACRO
C
                        I2WK1 = 0
                        CALL TABSRH (CMACRO,25,32,1,32,CWK32,1,32,IRET3,
     1                               25)
C
C         DETERMINE IF THE VARIABLE IS A DIMENSIONED VARIABLE
C
                        CALL TABSRH (CDIM,JDIM,104,1,32,CWK32,1,32,
     1                     IRET4,1000)
                        IF(IRET3 .LT. 0 .AND. IRET4 .LT.0) THEN
C
C         DO NOT WRITE MESSAGE WHEN THE VARIABLE NAME IS AN OS/2 API
C         MACRO
C
C
C         THE VARIABLE IS NOT DIMENSIONED, WRITE ERROR MESSAGE
C
                           IREC0 = IREC0 + 1
                           WRITE (0,119) ISN,CWK32(1:32)
                        END IF
                     END IF
                  END IF
               END IF
C
C         PROCESS THE SUBSCRIPT. WHEN THE VARIABLE IS NOT DIMENSIONED,
C         PROCESS ANY ILLEGAL SUBSCRIPT SPECIFICATION NORMALLY.
C
C         LOOP TO PROCESS ALL SUBSCRIPT VALUES WITHIN THE SUBSCRIPT'S
C         TERMINATION. JLOCKT IS THE COUNT OF ACTUAL SUBSCRIPTS THAT
C         OCCUR IN THE CALL STATEMENT ARGUMENT FOR A PARTICULAR
C         VARIABLE.
C
               JLOCKT = 0
               I6 = 0
               L1 = LFALSE
C              DO 32 I11 = I5,JLEN
               DO 32 I11 = I5,I9
               IF(CWK80(I11:I11) .EQ. CLPAR) I6 = I6 + 1
               IF(CWK80(I11:I11) .EQ. CRPAR) I6 = I6 - 1
               IF(CWK80(I11:I11) .EQ. COMMA) THEN
C
C         WHEN MORE THAN ONE LEFT PARENTHESIS OCCURS BEFORE A COMMA,
C         THIS INDICATES A SUBSCRIPTED VARIABLE HAS A VARIABLE NAME AS
C         A SUBSCRIPT THAT CONTAINS SUBSCRIPTS.
C
                  IF(I6 .GT. 1) L1 = LTRUE
                  JLOCKT = JLOCKT + 1
                  JLOC(JLOCKT) = I11
               END IF
 32            CONTINUE
C
C         DETERMINE IF THE NUMBER OF SUBSCRIPTS USED MATCHES THE NUMBER
C         OF SUBSCRIPTS DEFINED FOR THE ARGUMENT VARIABLE.
C
               IF(JLOCKT + 1 .NE. NDIM(10,IRET) .AND. .NOT.L1) THEN
C
C         DETERMINE IF THE VARIABLE NAME IS A DEFINED FUNCTION OR AN
C         INTRINSIC FUNCTION
C
                  CALL TABSRH (CNAME,INAME,52,1,32,CWK32,1,32,IRET1,
     1                         4000)
                  CALL TABSRH (FUNTBL,143,35,1,32,CWK32,1,32,IRET2,143)
C
C         WRITE SUBSCRIPT DOES NOT MATCH DIMENSION MESSAGE SIZE ONLY
C         WHEN THE VARIABLE NAME IS NOT %LOC, %REF, %VAL AND IT IS NOT
C         A DEFINED OR INTRINSIC FUNCTION.
C
                  IF(CWK32(1:1) .NE. CPERC .AND. IRET2 .LE. 0) THEN
                     IF(IRET1 .GT. 0 .AND. BTEST(IENAME(12,IRET1),10))
     1                  THEN
                        CONTINUE
                     ELSE
C
C         DETERMINE IF THE VARIABLE NAME IS AN OS2 API MACRO
C
                        I2WK1 = 0
                        CALL TABSRH (CMACRO,25,32,1,32,CWK32,1,32,IRET3,
     1                               25)
                        JRET3 = IABS(IRET3)
C
C         DO NOT WRITE MESSAGE WHEN THE VARIABLE NAME IS AN OS/2 API
C         MACRO
C
                        IF(IRET3 .LT. 0) THEN
                           IREC0 = IREC0 + 1
                           WRITE (0,114) ISN,CWK32(1:32)
                        END IF
                     END IF
                  END IF
               ELSE
                  JLOCKT = NDIM(10,IRET)
                  JLOC(JLOCKT) = JLEN
               END IF
               IF(JLOCKT .EQ. 0) THEN
                  JLOCKT = 1
               ELSE
                  JLOCKT = NDIM(10,IRET)
               END IF
C
C         THE LOCATION OF THE START AND END OF EACH SUBSCRIPT SPECIFIED
C         WITHIN A SUBSCRIPT SPECIFICATION IS DETERMINED. PROCESS EACH
C         SUBSCRIPT SPECIFIED.
C
               DO 34 I10 = 1,JLOCKT
               IF(I10 .EQ. 1) THEN
                  I4WK1 = ILOCL + 1
                  IF(I4WK2 .LT. I4WK1) THEN
                     I4WK2 = JLOC(I10)
                  ELSE
                     I4WK2 = ILOCR -1
                  END IF
               ELSE
                  I4WK1 = JLOC(I10-1) + 1
                  I4WK2 = ILOCR - 1
               END IF
C
C         CASE 1: THE SUBSCRIPT IS AN EXPRESSION
C
               DO 33 I11 = I4WK1,I4WK2
C
C         DETERMINE IF THE SUBSCRIPT IS AN EXPRESSION
C
               IF(CWK80(I11:I11) .EQ. CPLUS .OR. CWK80(I11:I11) .EQ.
     1            CMINUS .OR. CWK80(I11:I11) .EQ. CASTER .OR.
     2            CWK80(I11:I11) .EQ. CSLASH) THEN
                  IF(CWK80(I11:I11+1) .EQ. '//') THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,120) ISN,I1
                  END IF
C
C         THE SUBSCRIPT IS AN EXPRESSION. VARIABLES OCCURRING IN A
C         SUBSCRIPT ARE NOT ARGUMENTS OF THE CALL STATEMENT
C
                  LA = LFALSE
                  LCALL = LFALSE
                  CALL EXPRA (I2,ILOCR-1,LA,CWK80)
                  GO TO 34               ! NEXT SUBSCRIPT
               END IF
 33            CONTINUE
C
C         CASE 2: THE SUBSCRIPT IS A NUMERICAL VALUE
C
C         DETERMINE IF THE SUBSCRIPT IS A NUMBER. THIS NUMBER CAN NOT
C         BE PART OF AN ARITHMETIC EXPRESSION SINCE EXPRESSIONS HAVE
C         ALREADY BEEN PROCESSED.
C
               IF(CWK80(I4WK1:I4WK1) .GE. C0 .AND. CWK80(I4WK1:I4WK1)
     1            .LE. C9) THEN
                  LA = LTRUE
                  L1 = LFALSE
                  DO 330 I11 = I4WK1,I4WK2
                  IF(CWK80(I11:I11) .EQ. COMMA) L1 = LTRUE
                  IF(.NOT.L1) THEN
                     IF(CWK80(I11:I11) .EQ. CDOT .OR. CWK80(I11:I11)
     1               .EQ. CEE .OR. CWK80(I11:I11) .EQ. CDD) LA = LFALSE
                  END IF
 330              CONTINUE
                  IF(L1) THEN
                     KB = I11
                  ELSE
                     KB = JLEN
                  END IF
                  CALL NUMBER (CWK80,LA,I4WK1,II,FP,IFP)
                  KB = KBSAVE
                  IF(.NOT.LA) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,118) ISN,I1
                  ELSE
                     CALL INSERT (II)
                  END IF
C
C         WHEN A COMMA TERMINATES A SUBSCRIPT
C
                  GO TO 34                  ! NEXT SUBSCRIPT
               END IF
C
C         CASE 3: THE SUBSCRIPT IS A SINGLE VARIABLE NAME
C
C         THE SUBSCRIPT MUST BE A SINGLE VARIABLE NAME SINCE EXPRESSIONS
C         AND NUMERICAL ARGUMENTS HAVE ALREADY BEEN PROCESSED. THE
C         VARIABLE NAME MUST BE TERMINATED BY A RIGHT PARENTHESIS OR A
C         COMMA.
C
               IF(CWK80(I4WK1:I4WK1) .GE. CAA .AND. CWK80(I4WK1:I4WK1)
     1            .LE. CZZ .OR. CWK80(I4WK1:I4WK1) .EQ. CUNDER) THEN
C
C         DETERMINE THE END OF THE VARIABLE NAME
C
                  I14 = 0
                  I15 = I4WK1
                  DO 331 I13 = I4WK1,I4WK2+1
                  IF(CWK80(I13:I13) .EQ. CLPAR .OR. CWK80(I13:I13) .EQ.
     1               COMMA) THEN
                     I14 = I13
                     KLEN = I13 - I15
                     I4WK1 = I15
                     CWORK(1:32) = CWK80(I15+1:I13-1)//
     1                             CBLK52(1:32-KLEN)
C
C         SET THE CORRECT TYPE AND LENGTH CHARACTERISTICS WHEN THE
C         VARIABLE NAME IS A DEFINED FUNCTION.
C
                     CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,
     1                           1000)
                     IF(IRET .GT. 0 .AND. BTEST(JSUBTB(12,IRET),10))
     1                  CWORK(37:44) = CSUBTB(IRET)(37:44)
C
C         SET THE CORRECT TYPE AND LENGTH CHARACTERISTICS WHEN THE
C         VARIABLE NAME IS AN INTRINSIC FUNCTION.
C
C                    IRET = 0
                     CALL TABSRH (FUNTBL,143,35,1,32,CWORK,1,32,IRET4,
     1                           1000)
                     IF(IRET4 .GT. 0) THEN
                        IF(FUNTBL(IRET4)(34:34) .EQ. CSHARP) THEN
                           CWORK(37:39) = FUNTBL(IRET4)(33:33)//'? '
                        ELSE
                           CWORK(37:39) = FUNTBL(IRET4)(33:35)
                        END IF
                     END IF
C
C         WHEN THE VARIABLE IS ALREADY IN CNAME, OBTAIN THE CORRECT
C         TYPE AND LENGTH DEFINITIONS
C
                     IRET = 0
                     CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,
     1                           4000)
                     IF(IRET .GT. 0) THEN
                        IF(IRET4 .GT. 0) THEN
                           CNAME(IRET)(37:44) = CWORK(37:44)
                        ELSE
                           CWORK(37:44) = CNAME(IRET)(37:44)
                        END IF
                     END IF
                     IVCNT = KLEN
                     CALL VSETUP (I4WK1,I13-1,KLEN,LFALSE,LFALSE,
     1                            CWK80)
C
C         DETERMINE IF ANOTHER SUBSCRIPT FOLLOWS THE CURRENT ONE
C
                     IF(CWK80(I13:I13) .EQ. COMMA) GO TO 34
                  END IF
                  IF(CWK80(I13:I13) .EQ. CLPAR) THEN
                     I15 = I13
                  END IF
                  IF(CWK80(I13:I13) .EQ. CRPAR) THEN
                     KLEN = I13 - I15
                     CWORK(1:32) = CWK80(I15:I13-1)//
     1                             CBLK52(1:32-KLEN)
C
C         DETERMINE IF THE SUBSCRIPT IS VARIABLE NAME
C
                     IF(CWORK(1:1) .GE. CAA .AND. CWORK(1:1) .LE. CZZ
     1                  .OR. CWORK(1:1) .EQ. CUNDER) THEN
                        IVCNT = KLEN
                        CALL VSETUP (I15,I13-1,KLEN,LFALSE,LFALSE,CWK80)
                        CWK80(I15:I13) = CBLK52(1:KLEN+2)
                     END IF
C
C         DETERMINE IF THE SUBSCRIPT IS A NUMERICAL VALUE
C
                     IF(CWK80(I14+1:I13-1) .GE. C0 .AND.
     1                  CWK80(I14+1:I13-1) .LE. C9) THEN
                        LR4 = LTRUE
                        CALL NUMBER (CWK80,LR4,I14+1,II,FP,IFP)
                        CALL INSERT (II)
                     END IF
                  END IF
 331              CONTINUE
                  IF(I4WK2 + 1 .LT. I11) THEN
                     CALL SETTL (CWORK)
                     JBITS = 0
                     JBITS = IBCLR(JBITS,8)
                     JBITS = IBCLR(JBITS,9)
                     JBITS = IBCLR(JBITS,10)
                     JBITS = IBSET(JBITS,15)
C
C         DETERMINE IF THE SUBSCRIPT VARIABLE IS ITSELF SUBSCRIPTED
C
                     CALL VSETUP (I4WK1,I4WK2,KLEN,LFALSE,LFALSE,CWK80)
                  END IF
                  I6 = 0
                  DO 332 I13 = I4WK2,JLEN
                  IF(CWK80(I13:I13) .EQ. CPLUS .OR. CWK80(I13:I13)
     1               .EQ. CMINUS .OR. CWK80(I13:I13) .EQ. CASTER .OR.
     2               CWK80(I13:I13) .EQ. CSLASH) LS4 = LTRUE
                  IF(CWK80(I13:I13) .EQ. CLPAR .AND. .NOT.LS4) THEN
                     IF(I6 .EQ. 0) THEN
                        I6 = I6 + 1
                        JLOCL = I13
                     END IF
                  END IF
                  IF(CWK80(I13:I13) .EQ. CRPAR) THEN
                     IF(I6 .GT. 0) THEN
                        I6 = I6 - 1
                        JLOCR = I13
                     END IF
                  END IF
 332              CONTINUE
C
C         TREAT THE SECONDARY SUBSCRIPT AS AN EXPRESSION
C
                  IF(JLOCL .NE. 0 .AND. JLOCR .NE. 0) THEN
                     LA = LFALSE
                     LCALL = LFALSE
                     CALL EXPRA (JLOCL,JLOCR,LA,CWK80)
                  END IF
               ELSE
                  KLEN = I4WK2 - I4WK1 + 1
                  IVCNT = KLEN
               END IF
 34            CONTINUE
            END IF
C
C         WHEN NO SUBSCRIPT HAS BEEN FOUND, CONTINUE PROCESSING
C
            IF(.NOT.LS2) GO TO 36
C
C         THE ENTIRE SUBSCRIPT SPECIFICATION IS NOW PROCESSED. DELETE
C         THE SUBSCRIPT BY FILLING IT WITH BLANKS
C
            KLEN = ILOCR - ILOCL + 1
            IF(KLEN .GT. 50) THEN
               CWK80(ILOCL:ILOCR) = CBLK52(1:50)//CBLK52(1:KLEN-50)
            ELSE
               CWK80(ILOCL:ILOCR) = CBLK52(1:KLEN)
            END IF
            JLEN = JLEN - KLEN
            I12 = I2
            GO TO 36
         END IF
 35      CONTINUE
C
C         SET UP TO CONTINUE SEARCH FOR MORE SUBSCRIPT SPECIFICATIONS
C
         IF(I12 .LT. JLEN) THEN
            GO TO 29
         ELSE
            GO TO 360
         END IF
      END IF
 36   CONTINUE
C
C         REMOVE ALL BLANKS FROM ARGUMENT AFTER SUBSCRIPTS ARE
C         PROCESSED
C
 360  IF(LS2) THEN
C
C         AFTER ALL SUBSCRIPTS HAVE BEEN PROCESSED, REMOVE ALL BLANKS
C         FROM THE MODIFIED ARGUMENT EXPRESSION.
C
 37      DO 39 I12 = 1,JLEN
C
C         DETERMINE THE LEFT MOST BLANK OF THE CALL STATEMENT ARGUMENT
C
         IF(CWK80(I12:I12) .EQ. CBLK52(1:1)) THEN
            I13 = I12 + 1
C
C         LOOP TO LOCATE THE FIRST NONBLANK CHARACTER FOLLOWING THE
C         BLANK
C
            DO 38 I8 = I13,JLEN
            IF(CWK80(I8:I8) .NE. CBLANK) THEN
               KLEN = I8 - I12              ! SIZE OF BLANK FIELD
               I5 = JLEN - KLEN             ! NUMBER OF CHARACTERS MOVED
C
C         MOVE ALL CHARACTERS RIGHT OF LOCATION I8 LEFT KLEN CHARACTERS
C
               CWK80(I8:I5) = CWK80(I8+KLEN+1:JLEN)
C
C         BLANK THE FINAL KLEN CHARACTERS ON CWK80.
C
               IF(KLEN .LE. 50) THEN
                  CWK80(I5+1:JLEN) = CBLK52(1:KLEN)
               ELSE
                  CWK80(I5+1:JLEN) = CBLK52(1:50)//CBLK52(1:KLEN-50)
               END IF
               JLEN = I5                    ! SET ARGUMENT'S NEW LENGTH
C
C         REMOVE THE NEXT SUBSCRIPT, IF ANY
C
               GO TO 37
            END IF
 38         CONTINUE
         END IF
 39      CONTINUE
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   PROCESS THE ACTUAL CALL OR FUNCTION STATEMENT ARGUMENTS      *
C     *                                                                *
C     ******************************************************************
C
C         CALL STATEMENT ARGUMENTS WILL NOW HAVE ALL SUBSCRIPT AND
C         CHARACTER RANGE SPECIFICATIONS REMOVED. JLEN IS THE LENGTH OF
C         OF THE MODIFIED ARGUMENT.
C
C         AT THIS STAGE OF PROCESSING, THE ARGUMENT CONTAINS ONLY A
C         NUMERIC FIELD, A SINGLE VARIABLE, AN EXPRESSION, A RETURN
C         PARAMETER, A LITERAL, OR A LOGICAL CONSTANT.
C
 40   LCALL = LTRUE
C
C         WHEN THE FIRST CHARACTER OF CWK80 IS A PRECENTAGE SIGN, IT
C         IS A RETURN STATEMENT NUMBER, NOT A VARIABLE NAME.
C
      IF(CWK80(1:1) .EQ. CPERC) L2 = LTRUE
C
C         CASE 1: THE ARGUMENT IS AN EXPRESSION
C
      IF(CWK80(1:1) .NE. CASTER .AND. CWK80(1:1) .NE. CPERC) THEN
         DO 41 I5 = 1,JLEN
C
C         DETERMINE IF THE ARGUMENT IS A NUMERICAL VALUE WHEN I5 = 1
C         AND THE INITIAL CHARACTER IS A PLUS OR MINUS SIGN
C
         IF(I5 .EQ. 1 .AND. (CWK80(1:1) .EQ. CPLUS .OR. CWK80(1:1) .EQ.
     1      CMINUS) .AND. CWK80(2:2) .GE. C0 .AND. CWK80(2:2) .LE. C9)
     2      GO TO 410
C
C         DETERMINE IF THE ARGUMENT IS AN EXPRESSION
C
         IF(CWK80(I5:I5) .EQ. CPLUS .OR. CWK80(I5:I5) .EQ. CMINUS .OR.
     1      CWK80(I5:I5) .EQ. CASTER .OR. CWK80(I5:I5) .EQ. CSLASH .OR.
     2      CWK80(I5:I5) .EQ. CSYMCD) THEN
C
C         WHEN AN ARITHMETIC, CHARACTER , LOGICAL OPERATOR OCCURS, OR
C         // OCCUR, THIS IS IS AN EXPRESSION
C
            I17 = 1
            CALL EXPRA (I17,JLEN,LTRUE,CWK80)
            IF(LGLOBL) THEN
               CUSE2(I1)(1:5) = 'C##EX'
               IF(CWK80(I5:I5) .EQ. CSYMCD) THEN
                  CUSE2(I1)(33:40) = 'L4      '
               ELSE IF(CWK80(I5:I5+1) .EQ. '//') THEN
                  CUSE2(I1)(33:40) = 'C4      '
               ELSE
                  CUSE2(I1)(33:40) = 'I4      '
               END IF
               CUSE2(I1)(41:44) = CZERO(1:4)
               IUSE2(12,I1) = 5
            END IF
            GO TO 43                        ! NEXT ARGUMENT
         END IF
 41      CONTINUE
      END IF
C
C         CASE 2: THE ARGUMENT IS A NUMERICAL VALUE
C
C         DETERMINE IF THE ARGUMENT IS A NUMBER. THIS NUMBER CAN NOT
C         BE PART OF AN ARITHMETIC EXPRESSION SINCE EXPRESSIONS HAVE
C         ALREADY BEEN PROCESSED.
C
 410  IF(CWK80(1:1) .GE. C0 .AND. CWK80(1:1) .LE. C9 .OR. CWK80(1:1)
     1   .EQ. CPLUS .OR. CWK80(1:1) .EQ. CMINUS) THEN
         LA = LTRUE
C
C         DETERMINE IF THE NUMBER IS REAL
C
         DO 42 I6 = 1,JLEN
         IF(CWK80(I6:I6) .EQ. CDOT .OR. CWK80(I6:I6) .EQ. CDD .OR.
     1      CWK80(I6:I6) .EQ. CEE) LA = LFALSE
 42      CONTINUE
         CALL NUMBER (CWK80,LA,1,II,FP,IFP)
         IF(LA) THEN
            CALL INSERT (II)
         ELSE
            CALL FCHECK
         END IF
         IF(LGLOBL) THEN
            CUSE2(I1)(1:6) = 'C##NUM'
            IF(LA) THEN
               CUSE2(I1)(33:44) = CII(1:1)//C4(1:1)//CBLANK(1:6)//
     1                            CZERO(1:4)
            ELSE
               CUSE2(I1)(33:44) = CRR(1:1)//C4(1:1)//CBLANK(1:6)//
     1                            CZERO(1:4)
            END IF
            IUSE2(12,I1) = 6
         END IF
         GO TO 43                           ! NEXT ARGUMENT
      END IF
C
C         CASE 3: THE ARGUMENT IS A SINGLE VARIABLE
C
      IF(CWK80(1:1) .EQ. CPERC) THEN
C
C         THE VARIABLE NAME IS %LOC, %REF, OR %VAL FUNCTION
C
         CWORK(37:44) = 'I4      '
         JBITS = IBSET(JBITS,10)
         I5 = 2
      ELSE
         I5 = 1
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS A COMPOUND VARIABLE NAME
C
      DO 420 I12 = 2,80
C
C         LOCATE THE END OF THE VARIABLE NAME
C
      IF(CWK80(I12:I12) .EQ. CLPAR  .OR. CWK80(I12:I12) .EQ. CRPAR .OR.
     1   CWK80(I12:I12) .EQ. COLON  .OR. CWK80(I12:I12) .EQ. COMMA .OR.
     2   CWK80(I12:I12) .EQ. CEQ    .OR. CWK80(I12:I12) .EQ. CPLUS .OR.
     3   CWK80(I12:I12) .EQ. CMINUS .OR. CWK80(I12:I12) .EQ. CASTER .OR.
     4   CWK80(I12:I12) .EQ. CSLASH .OR. CWK80(I12:I12) .EQ. CBLANK(1:1)
     5   .OR. CWK80(I12:I12) .EQ. CDOT) THEN
C
C         DETERMINE IF THIS IS A COMPOUND VARIABLE NAME. THE OCCURRENCE
C         OF A PERIOD OR PERCENTAGE SIGN CAN ONLY INDICATE A COMPOUND
C         VARIABLE SINCE ALL LOGICAL OPERATORS HAVE BEEN REMOVED FROM
C         THE STATEMENT IN ROUTINE COMPRS.
C
         I13 = I12 - 1
         L13 = LFALSE
         DO 421 I16 = 2,I13
         IF(CWK80(I16:I16) .EQ. CDOT .OR. CWK80(I16:I16) .EQ. CPERC)
     1      THEN
C
C         WHEN THE NAME IS A COMPOUND VARIABLE NAME, PROCESS THE NAME
C
            L13 = LTRUE
            CALL CSETUP (CWK80,1,I13)
            GO TO 43
         END IF
 421     CONTINUE
      END IF
 420  CONTINUE
      IF(CWK80(I5:I5) .GE. CAA .AND. CWK80(I5:I5) .LE. CZZ .OR.
     1   CWK80(I5:I5) .EQ. CUNDER) THEN
         CWK32(1:32) = CBLK52(1:32)
         CWK32(1:JLEN-I5+1) = CWK80(I5:JLEN)
         IF(I5 .GT. 1) JLEN = JLEN - 1
         IF(I5 .GE. 1) THEN
            CALL TABSRH (CNAME,INAME,52,1,32,CWK32,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
C
C         SET BITS TO FORCE LISTING AND IDICATE THE VARIABLE IS USED AS
C         AN ARGUMENT IN AN ARGUMENT LIST
C
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),7)
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),15)
               IF(.NOT.LINCL) IENAME(9,IRET) = ISN
            END IF
         END IF
C
C         DETERMINE IF THE VARIABLE NAME IS A COMPOUND NAME
C
         L13 = LFALSE
         DO 422 I17 = 1,32
         IF(CWK32(I17:I17) .EQ. CDOT .OR. CWK32(I17:I17) .EQ.
     1      CPERC) L13 = LTRUE
422      CONTINUE
         IF(IRET .LT. 0 .AND. .NOT.L13) THEN
C
C         THE VARIABLE DOES NOT EXIST IN THE MASTER NAME TABLE.
C
C         IT CAN NOT BE A DEFINED SUBPROGRAM NAME SINCE THEY HAVE BEEN
C         PLACED IN CNAME BY SUBROUTINE SUBTBL. HOWEVER, IT MAY BE AN
C         INTRINSIC FUNCTION.
C
            CALL TABSRH (FUNTBL,143,35,1,32,CWK32,1,32,IRET1,143)
            IF(IRET1 .GT. 0) THEN
               IF(FUNTBL(IRET1)(34:34) .EQ. CSHARP) THEN
                  CWORK(37:39) = FUNTBL(IRET1)(33:33)//'? '
               ELSE
                  CWORK(37:39) = FUNTBL(IRET1)(33:35)
               END IF
               JBITS = IBSET(JBITS,7)
               JBITS = IBSET(JBITS,10)
               JBITS = IBSET(JBITS,16)
            END IF
C
C         THE VARIABLE NAME DOES NOT EXIST IN THE MASTER NAME TABLE;
C         DETERMINE IF IT IS AN EXTERNAL DEFINITION.
C
            IF(IEXTNL .GT. 0) THEN
               CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CWK32,1,32,IRET1,1000)
C
C         WHEN THE VARIABLE IS NOT IN THE EXTERNAL TABLE, WRITE A
C         MESSAGE THAT THE ARGUMENT VARIABLE IS NOT DEFINED AT THIS
C         STAGE OF PROCESSING
C
               IF(IRET1 .LT. 0 .AND. .NOT.BTEST(JBITS,10)) THEN
                  IF(.NOT.L13) THEN
                     IREC0 = IREC0 +1
                     WRITE (0,112) ISN,CWK32(1:32)
                  END IF
               END IF
            END IF
            CWORK(1:32) = CWK32(1:32)
            IWORK = ISN + 128
            JBITS = IBSET(JBITS,7)
            JBITS = IBSET(JBITS,15)
            IVCNT = JLEN
C
C         WHEN I5 = 1, THE VARIABLE IS A SIMPLE NAME, OBTAIN ITS TYPE
C         AND LENGTH CHARACTERISTICS
C
            IF(I5 .EQ. 1) THEN
               IF(IRET .GT. 0) CWORK(37:44) = CNAME(IRET)(37:44)
            ELSE
               IF(.NOT.BTEST(JBITS,16)) CALL SETTL (CWORK)
            END IF
            IF(LCALL) THEN
               CALL VSETUP (1,JLEN,JLEN,LTRUE,LFALSE,CWK32)
            ELSE
               CALL CHKNME (CSTMTA)
            END IF
            IF(.NOT.LINCL) THEN
               WRITE (7,REC=IREC7) CWORK(1:52)
               IREC7 = IREC7 + 1
            END IF
         ELSE
            CWORK(1:52) = CNAME(IRET)(1:52)
            IWORK = ISN + 128
            IENAME(12,IRET) = IBSET(IENAME(12,IRET),7)
            JBITS = IBSET(JBITS,7)
            IF(.NOT.LCALL) JBITS = IBSET(JBITS,20)
            IF(.NOT.LINCL) THEN
               IF(CWORK(1:3) .NE. 'C##') THEN
                  WRITE (7,REC=IREC7) CWORK(1:52)
                  IREC7 = IREC7 + 1
               END IF
            END IF
         END IF
         IF(LGLOBL) THEN
C
C         CREATE THE RECORD FOR UNIT 10 FOR THIS ARGUMENT
C
            IF(IRET .GT. 0) THEN
               CUSE2(I1)(1:32) = CNAME(IRET)(1:32)
               CUSE2(I1)(33:40) = CNAME(IRET)(37:44)
C
C         WHEN A CHARCTER RANGE SPECIFICATION EXISTS, THIS MUST BE A
C         CHARACTER VARIABLE. THE VARIABLE'S DEFINED LENGTH WILL BE
C         SET TO THE LENGTH DEFINED BY THE RANGE SPECIFICATION RATHER
C         THAN THE ITS TRUE LENGTH FOR THE RECORD IN UNIT 10. THIS
C         ALLOWS CORRECT CHECKING OF ARGUMENT LENGTH IN ARGUMENTS IN
C         CALL STATEMENTS, SO THAT THE LENGTH WILL MATCH THE ENTRY,
C         FUNCTION, OR SUBROUTINE DUMMY ARGUMENTS. THIS MODIFICATION
C         IS PERFORMED ONLY FOR CALL STATEMENTS.
C
               IF(LCALL) THEN
                  IF(ILOCLV .GT. 0 .AND. ILOCRV .GT. 0) THEN
                     JWK8 = ILOCRV - ILOCLV + 1
                     CWK8(1:8) = CBLANK(1:8)
                     CUSE2(I1)(34:40) = CBLANK(1:7)
                     WRITE (CWK8,'(I8)') JWK8
                     I17 = 0
                     DO I16 = 1,8
                     IF(CWK8(I16:I16) .NE. CBLANK) THEN
                        I17 = I17 + 1
                        CUSE2(I1)(I17+33:I17+33) = CWK8(I16:I16)
                     END IF
                     END DO
                  END IF
               END IF
               CUSE2(I1)(41:44) = CNAME(IRET)(45:48)
               CUSE2(I1)(45:48) = CNAME(IRET)(49:53)
            END IF
         END IF
         GO TO 43                           ! NEXT ARGUMENT
      END IF
C
C         CASE 4: THE ARGUMENT IS A RETURN PARAMETER
C
      IF(CWK80(1:1) .EQ. CAMP .OR. CWK80(1:1) .EQ. CASTER) THEN
C
C         DETERMINE IF THE RETURN PARAMETER IS NUMERIC
C
C        IF(CWK80(1:1) .EQ. CASTER .OR. CWK80(1:1) .EQ. CAMP) THEN
         L1 = LFALSE
         IF(.NOT.(CWK80(2:2) .GE. C0 .AND. CWK80(2:2) .LE. C9) .OR.
     1      .NOT.(CWK80(JLEN:JLEN) .GE. C0 .AND. CWK80(JLEN:JLEN)
     2      .LE. C9)) THEN
            IF(CWK80(JLEN:JLEN) .NE. CBLANK(1:1)) THEN
               IREC0 = IREC0 + 1
               WRITE (0,109) ISN,I1
               L1 = LTRUE
             END IF
         END IF
         IF(LGLOBL) THEN
            CUSE2(I1)(1:6) = 'C##STM'
            CUSE2(I1)(33:40) = CBLANK(1:8)
            CUSE2(I1)(41:44) = CZERO(1:4)
            IUSE2(12,I1) = 6
         END IF
C
C         CREATE THE RECORD FOR UNIT 4 (STATEMENT NUMBER TABLE)
C
         IF(.NOT.L1) THEN
         LA = LTRUE
         CALL NUMBER (CWK80,LA,2,II,FP,IFP)
         IWK8(1) = II + 128
         IWK8(2) = ISN + 128
         IREC4 = IREC4 + 1
         WRITE (4,REC=IREC4) CWK8
         END IF
         GO TO 43                           ! NEXT ARGUMENT
      END IF
C
C         CASE 5: THE ARGUMENT IS A LITERAL
C
      IF(CWK80(1:1) .EQ. CSYMCF) THEN
         IF(LGLOBL) THEN
            CUSE2(I1)(1:6) = 'C##LIT'
            CUSE2(I1)(33:40) = 'C4      '
            CUSE2(I1)(41:44) = CNAME(IRET)(45:48)
            IUSE2(12,I1) = 6
         END IF
      END IF
C
C         DETERMINE IF THE FINAL ARGUMENT OF THE STATEMENT HAS BEEN
C         PROCESSED
C
      IF(I1 .EQ. IARGCT) GO TO 45
 43   CONTINUE
C
C         WRITE THE CALL STATEMENT RECORD ON UNIT 10 WHEN ALL ARGUMENTS
C         ARE PROCESSED
C
 44   IF(LGLOBL .AND. LCALL) THEN
         IREC10 = IREC10 + 1
         WRITE (10,REC=IREC10) CUSE1(1:92)//CUSE3(1:1440)
      END IF
C
C         ROUTINE EXIT
C
 45   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE CONTROL LIST AND THE INPUT-OUTPUT
C        LIST OF READ AND WRITE STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1; USED TO
C                  COMPUTE THE LENGTH OF A PARAMETER NAME FOR MESSAGE
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         CWK8   - CHARACTER VARIABLE, BUFFER TO CREATE THE OPUTPUT
C                  RECORD FOR UNIT 4
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         IIB    - EQUIVALENCED TO CIB
C         IISN   - EQUIVALENCED TO CISN
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN CODE FROM TABLE SEARCH ROUTINE
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISNUM  - TABLE OF DEFINED STATEMENT NUMBERS FOUND IN THE
C                  PROGRAM; WORD 1 CONTAINS THE STATEMENT
C                  NUMBER VALUE, WORD 2 CONTAINS THE ISN DEFINING
C                  THE STATMENT NUMBER (128 IS NOT ADDED TO THIS VALUE)
C         IWK8   - EQUIVALENCED TO CWK8
C         I1     - SUBSCRIPT VARIABLE
C         I2     - PARENTHESIS COUNT, ADD ONE FOR LEFT PARENTHESIS,
C                  SUBTRACT ONE FOR RIGHT PARENTHESIS
C         I3     - WORK AREA
C         I4     - START LOCATION OF THE FORMAT SPECIFICATION
C         I5     - START LOCATION OF LEFT PARENTHESIS STARTING A CONTROL
C                  ARGUMENT SPECIFICATION
C         I6     - START LOCATION OF RIGHT PARENTHESIS ENDING A CONTROL
C                  ARGUMENT SPECIFICATION
C         I7     - SUBSCRIPT VARIABLE
C         I8     - WORK AREA
C         I9     - WORK AREA
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         J1     - SUBSCRIPT VARIABLE
C         J2     - WORK AREA
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KBSAV  - SAVE AREA FOR THE INITIAL VALUE OF KB UPON ENTERING
C                  THIS ROUTINE
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE; SKIPS FURTHER PROCESSING IN THE
C                  CURRENT ARGUMENT, AND FORCES PROCESSING OF THE NEXT
C                  ARGUMENT
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT IS FOUND
C                  AND PROCESSED, SET FALSE OTHERWISE; PREVENTS FURTHER
C                  PROCESSING OF AN ALREADY DETERMINED ARGUMENT TYPE.
C                  7 SUBSCRIPT VALUES ARE ALLOWED FOR A READ OR WRITE
C                  STATEMENT. THEY ARE:
C                  1 - END, 2 - ERR, 3 - FMT, 5 - IOSTAT, 6 - KEY,
C                  6 - NML, 7 - REC
C         LBB    - LOGICAL ARGUMENT, VALUE OF ARRAY LB TO BE PASSED TO
C                  SUBROUTINE CIOLST
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN IS
C                  FOUND IN THE FIRST ARGUMENT OF THE CONTROL LIST
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A STANDARD DEFAULT
C                  UNIT IS USED AND NO UNIT= EXISTS, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A COMMA FOLLOWS A
C                  UNIT DESIGNATION, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE FORMAT
C                  SPECIFICATION IS NUMERIC AND A SCAN IS TO BE MADE FOR
C                  THE COMMAND LIST END, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHESIS
C                  TERMINATES A FORMAT VARIABLE NAME WHICH IS AN ARRAY,
C                  SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A COLON FOLLOWS THE
C                  FINAL CHARACTER OF A NUMBER, SET FALSE OTHERWISE.
C                  THIS INDICATES A SUBSCRIPT RANGE VALUE IS NEXT.
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR IS PART OF FORMAT SPECIFICATION WITHIN THE
C                  STATEMENT, SET FALSE OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN A FORMAT
C                  SPECIFICATION IS A NUMBER, SET FALSE OTHERWISE
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN A FORMAT
C                  SPECIFICATION IS A NUMBER AND IT HAS BEEN WRITTEN ON
C                  UNIT 4, SET FALSE OTHERWISE. PREVENTS UNNECESSARY
C                  WRITING THE FORMAT STATEMENT NUMBER.
C         L10    - LOGICAL VARIABLE, SET TRUE WHEN AN INVALID PARAMETER
C                  MESSAGE HAS JUST BEEN WRITTEN, SET FALSE OTHERWISE.
C                  THIS INSURES THE REMAINING COMMAND LIST PARAMETERS
C                  ARE PROCESSED.
C         L11    - LOGICAL VARIABLE, SET TRUE WHEN A WRITE STATEMENT
C                  IS TO BE PROCESSED, SET FALSE WHEN A READ STATEMENT
C                  IS TO BE PROCESSED
C         L12    - LOGICAL VARIABLE, SET TRUE WHEN 'FMT=' SPECIFIES A
C                  NUMERICAL STATEMENT NUMBER, SET FALSE OTHERISE
C
C     COMMENTS
C
C         IF DUPLICATE CONTROL LIST ARGUMENTS OCCUR, THE FIRST ONE
C         ENCOUNTERED WILL BE USED; DUPLICATES ARE IGNORED.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C
C     SUBROUTINES CALLED
C
C         CIOLST CUNIT INSERT NUMBER PIOLST TABSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE PRDWR (L11)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION LB(7), IWK8(2), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*62    CF101
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
      LOGICAL*1 L1, L2, L3, L4, L5, L6, L7, L8, L9, L10, L11, L12, LA,
     1          LB, LBB
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/ ID,LBB,L1,L2,L3,L4,LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7), (CWK8,IWK8)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CF101/'('' ISN:'',I6,'' A PARAMETER IN A CONTROL LIST IS INVA
     1LID: '',AXX)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO CLOSING COMMA OR RIGHT OR LEFT PARENTHESIS
     1')
 101  FORMAT(' ISN:',I6,' END PARAMETER ILLEGAL IN A WRITE STATEMENT')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      L1 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      L6 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      L9 = LFALSE
      L10 = LFALSE
      I2 = 0
      I4 = 0
      I5 = 0
      I6 = 0
C
C         INITIALIZE THE LOGIC WORK ARRAY
C
      DO 10 I1 = 1,7
 10   LB(I1) = LFALSE
      L2 = LFALSE
C
C         PROCESS THE IO CONTROL LIST
C         VERIFY A LEFT PARENTHESIS FOLLOWS THE STATEMENT
C
      IF(CSTMT(J:J) .EQ. CLPAR) THEN
C
C         DETERMINE THE ENDING RIGHT PARENTHESIS OF THE CONTROL
C         ARGUMENTS SPECIFICATIONS
C
        I1 = 0
        DO 11 I = J,KB
        IF(CSTMT(I:I) .EQ. CLPAR) THEN
           I1 = I1 + 1
           IF(I .EQ. J) I5 = I
        END IF
        IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
        IF(I1 .EQ. 0) THEN
           I6 = I
           GO TO 12
        END IF
 11     CONTINUE
C
C         WHEN I1 IS NOT ZERO AFTER FINISHING THE DO LOOP, THE CLOSING
C         RIGHT PARENTHESIS IS MISSING. WRITE ERROR MESSAGE.
C
        IF(I1 .GT. 0) THEN
           WRITE (0,100) ISN
           IREC0 = IREC0 + 1
           GO TO 35
        END IF
C
C         IF A LEFT PARENTHESIS FOLLOWS THE READ OR WRITE COMMAND, A
C         CONTROL LIST MUST EXIST
C
         GO TO 12
      ELSE
C
C         A LEFT PARENTHESIS WAS NOT FOUND; TEST FOR AN ASTERISK.
C         NO FORMAT OCCURS IN THIS CASE. SKIP A LITERAL OCCURRENCE.
C
C        IF(CSTMT(J:J) .EQ. CASTER) THEN
         IF(CSTMT(J:J) .EQ. CASTER .OR. CSTMT(J:J) .EQ. CSYMCF) THEN
            J = J + 2
            GO TO 32
         END IF
C
C         NO PARENTHESIS FOLLOWS THE I/O COMMAND, ONLY AN ASTERISK OR
C         A FORMAT DESIGNATION WITHOUT AN FMT= ARGUMENT MAY FOLLOW
C
C         TEST FOR A FORMAT DESIGNATION, NO UNIT OCCURS IN THIS CASE
C
         L2 = LTRUE
C
C         DETERMINE IF THE FORMAT IS A VARIABLE NAME
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) GO TO 21
C
C         DETERMINE IF THE FORMAT IS A STATEMENT NUMBER
C
         IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) GO TO 20
C
C         WRITE DIAGNOSTIC FOR MISSING LEFT PARENTHESIS
C
         IF(.NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 35
         END IF
      END IF
C
C         ADJUST SUBSCRIPT VALUES AND PARENTHESES COUNT
C
 12   J = J + 1
      I2 = I2 + 1
C
C         DETERMINE IF A UNIT IS SPECIFIED AS THE INITIAL ARGUMENT.
C         TEST IF THE UNIT IS AN ASTERISK.
C
      IF(CSTMT(J:J) .EQ. CASTER) THEN
C
C         DETERMINE IF A COMMA FOLLOWS THE ASTERISK
C
         IF(CSTMT(J+1:J+1) .EQ. COMMA .OR. CSTMT(J+1:J+1) .EQ. CRPAR)
     1      THEN
            CALL CUNIT
         ELSE
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
         J = J + 1
         GO TO 14
      END IF
C
C         WHEN NO ASTERISK IS USED AS A UNIT DESIGNATION, DETERMINE
C         IF THE UNIT= ARGUMENT IS USED. THE UNIT= ARGUMENT MAY BE IN
C         ANY SEQUENCE WITHIN THE COMMAND ARGUMENTS.
C
      IF(CSTMT(J:J+4) .EQ. 'UNIT=') GO TO 25
C
C         TEST IF THE FMT= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'FMT=') GO TO 25
C
C         TEST IF THE NML= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'NML=') GO TO 25
C
C         TEST IF THE REC= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'REC=') GO TO 25
C
C         TEST IF THE END= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'END=') THEN
         IF(L11) THEN
            WRITE (0,101)
            IREC0 = IREC0 + 1
         END IF
         GO TO 25
      END IF
C
C         TEST IF THE ERR= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'ERR=') GO TO 25
C
C         TEST IF THE IOSTAT= ARGUMENT IS USED
C
      IF(CSTMT(J:J+6) .EQ. 'IOSTAT=') GO TO 25
C
C         TEST IF THE KEY= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'KEY=') GO TO 25
C
C         DETERMINE IF THE UNIT IS A NUMBER OR A LETTER WHEN THE UNIT=
C         SPECIFICATION IS NOT MADE. UPON RETURN FROM CUNIT, J IS THE
C         LOCATION OF THE CHARACTER AFTER THE COMMA OR RIGHT PARENTHESIS
C         DELINEATING THE END OF THE UNIT SPECIFICATION.
C
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9 .OR.
     1   CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     2   CSTMT(J:J) .EQ. CUNDER) THEN
         KBSAV = KB
         CALL CUNIT
         KB = KBSAV
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
C
C         DETERMINE THE LOCATION IF A COMMA TERMINATES THE UNIT
C
         IF(CSTMT(J+1:J+2) .EQ. '),') J = J + 2
         I4 = J
C
C         IF THE CHARACTER AT LOCATION J IN CSTMT IS A COMMA, THIS
C         IS THE END OF THE UNIT SPECIFICATION, BUT IT CAN NOT BE
C         THE END OF THE COMMAND LIST.
C
         IF(CSTMT(J:J) .EQ. COMMA) THEN
            J = J + 1
         END IF
C
C         IF THE CHARACTER AT LOCATION J IN CSTMT IS A RIGHT
C         PARENTHESIS, THIS IS THE END OF THE CONTROL LIST. THE
C         CONTROL LIST CONTAINS ONLY THE UNIT WITHOUT A FORMAT
C         DESIGNATION.
C
         IF(CSTMT(J:J) .EQ. CRPAR) THEN
            J = J + 1
            GO TO 34
         END IF
C
C         WHEN THE CHARACTER LOCATED AT THE LOCATION DEFINED BY J IS A
C         NUMBER, IT MUST BE A FORMAT SPECIFICATION
C
C        IF(CSTMT(J:J) .EQ. COMMA) J = J + 1
         IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
            L8 = LTRUE
            GO TO 20
         END IF
C
C         WHEN THE CHARACTER LOCATED AT THE LOCATION DEFINED BY J IS A
C         RIGHT PARENTHESIS, THIS IS THE END OF THE CONTROL LIST
C
         IF(CSTMT(J:J) .EQ. CRPAR .AND. CSTMT(J+1:J+1) .NE. CRPAR)
     1      GO TO 16
      END IF
C
C         DETERMINE THE END OF THE FIRST ARGUMENT FOLLOWING THE UNIT
C
      DO 13 I1 = J,I6
C
C         WHEN AN EQUAL SIGN OCCURS, THERE IS A SECOND ARGUMENT THAT
C         IS ONE OF THE ALLOWED COMMANDS
C
      IF(CSTMT(I1:I1) .EQ. CEQ) GO TO 14
C
C         WHEN A LEFT PARENTHESIS OCCURS, IT IS THE END OF THE FIRST
C         ARGUMENT AND INDICATES THE VARIABLE MUST BE SUBSCRIPTED
C
      IF(CSTMT(I1:I1) .EQ. CLPAR) THEN
C
C         THE FORMAT SPECIFICATION MUST BE VARIABLE NAME WHEN A LEFT
C         PARENTHESIS TERMINATES THE NAME.
C
         J2 = I1 - I4 - 1
C
C         SET UP CWORK WHEN THE VARIABLE NAME ALREADY EXISTS IN CNAME
C
         CWORK(1:J2) = CSTMT(I4+1:I4+J2)
         CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
            IWORK = ISN + 128
            CWORK(37:44) = CNAME(IRET)(37:44)
            CWORK(45:48) = CNAME(IRET)(45:48)
            IVCNT = JB
         END IF
         CALL VSETUP (I4+1,I4+J2,J2,LFALSE,LFALSE,CSTMT)
         I2 = I2 + 1
         J = I1 + 1
         L5 = LTRUE
         GO TO 14
      END IF
C
C         WHEN A RIGHT PARENTHESIS OCCURS, IT IS THE END OF THE CONTROL
C         LIST ONLY WHEN THE PARENTHESES LEVEL COUNT IS ZERO; OTHERWISE
C         IT IS THE END OF A FIELD.
C
      IF(CSTMT(I1:I1) .EQ. CRPAR) THEN
         I2 = I2 - 1
C
C         DETERMINE IF THE FORMAT SPECIFICATION IS A VARIABLE NAME
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
            I4 = J
            I6 = I1 - 1
            I3 = I1 - J
            CWORK(1:I3) = CSTMT(J:I6)
C
C         DETERMINE IF THE FORMAT VARIABLE NAME IS CATALOGED IN CNAME
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               IWORK = ISN + 128
               CWORK(37:44) = CNAME(IRET)(37:44)
               CWORK(45:48) = CNAME(IRET)(45:48)
               IVCNT = I3
            END IF
C     IF(ISN .EQ. 1985)
C    1WRITE(13,9030) CWORK(1:6),CWORK(37:40),J,I6,I3
C9030 FORMAT(' TRACE 9030 PRDWR  CWORK(1:6) = ',A6,2X,'CWORK(37:40) = ',
C    1A4/5X,'J = ',I4,2X,'I6 = ',I4,2X,'I3 = ',I4)
            CALL VSETUP (J,I6,I3,LFALSE,LFALSE,CSTMT)
         END IF
         J = I1 + 1
         IF(I2 .EQ. 0) GO TO 34
         L8 = LTRUE
         GO TO 14
      END IF
C
C         WHEN A COMMA OCCURS, IT IS THE END OF THE CONTROL LIST ONLY
C         WHEN THE PARENTHESES LEVEL COUNT IS ZERO
C
      IF(CSTMT(I1:I1) .EQ. COMMA) THEN
         J = I1 + 1
         L3 = LTRUE
         GO TO 14
      END IF
 13   CONTINUE
C
C         NO CLOSING COMMA OR RIGHT PARENTHESIS EXISTS
C
      IF(.NOT.LINCL) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
         GO TO 32
      END IF
C
C         DETERMINE IF THE SECOND ARGUMENT IS THE FORMAT SPECIFICATION
C
C         DETERMINE IF THE SECOND FIELD IS A NUMBER
C
 14   IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
         I4 = J
         GO TO 20
      END IF
C
C         TEST FOR AN ASTERISK FORMAT SPECIFICATION OR LITERAL FORMAT
C         SPECIFICATION
C
      IF(CSTMT(J:J) .EQ. CASTER .OR. CSTMT(J:J) .EQ. CSYMCF) THEN
C
C         TEST FOR THE END OF THE CONTROL LIST
C
         J = J + 1
         IF(J .GE. KB) THEN
            GO TO 35
         ELSE
C
C         THE SECOND ARGUMENT MAY BE A FORMAT SPECIFIED AS A VARIABLE
C         NAME
C
            IF(CSTMT(J:J) .EQ. CRPAR) THEN
               J = J + 1
               GO TO 34
            ELSE
C
C         DETERMINE IF THE END OF THE CONTROL LIST
C
               DO 15 I1 = J,KB
               IF(CSTMT(I1:I1) .EQ. CEQ) GO TO 25
               IF(CSTMT(I1:I1) .EQ. CLPAR) I2 = I2 + 1
               IF(CSTMT(I1:I1) .EQ. CRPAR) THEN
                  I2 = I2 - 1
                  J = I1 + 1
                  IF(I2 .EQ. 0) GO TO 34
               END IF
               IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CPLUS
     1            .OR. CSTMT(I1:I1) .EQ. CMINUS .OR. CSTMT(I1:I1) .EQ.
     2            CSLASH .OR. CSTMT(I1:I1) .EQ. CASTER .OR. CSTMT(I1:I1)
     3            .EQ. COLON) THEN
                  J = I1 + 1
                  GO TO 25
               END IF
 15            CONTINUE
               GO TO 25
            END IF
         END IF
      END IF
C
C         TEST IF THE FMT= ARGUMENT IS USED
C
 16   IF(CSTMT(J:J+3) .EQ. 'FMT=') THEN
C     IF(ISN .EQ. 250)
C    1WRITE(13,904) CWORK(1:6),CWORK(37:40),J,I6,I3,CSTMT(J:J)
C904  FORMAT(' TRACE 904 PRDWR  CWORK(1:6) = ',A6,2X,'CWORK(37:40) = ',
C    1A4/5X,'J = ',I4,2X,'I6 = ',I4,2X,'I3 = ',I4,2X,'CSTMT(J:J) = ',A1)
C
C         DETERMINE IF THE FORMAT SPECIFICATION IS A LITERAL
C
         IF(CSTMT(J+4:J+4) .EQ. CSYMCF) THEN
            J = J + 2
            GO TO 32
         END IF
C
C         DETERMINE IF THE FORMAT IS A NUMBER
C
         IF(CSTMT(J+4:J+4) .GE. C0 .AND. CSTMT(J+4:J+4) .LE. C9) THEN
            L12 = LTRUE
C     IF(ISN .EQ. 250)
C    1WRITE(13,9040) CWORK(1:6),CWORK(37:40),J,CSTMT(J+4:J+4)
C9040 FORMAT(' TRACE 9040 PRDWR  CWORK(1:6) = ',A6,2X,'CWORK(37:40) = ',
C    1A4/5X,'J = ',I4,2X,'CSTMT(J+4:J+4) = ',A1)
            CALL NUMBER (CSTMT,L12,J+4,II,FP,IFP)
         END IF
         GO TO 25
C
C         WHEN NO FMT= DESIGNATION EXISTS, ASSUME THIS MAY BE A
C         VARIABLE FORMAT DESIGNATION
C
      ELSE
         IF(CSTMT(J-1:J-1) .EQ. CLPAR) THEN
            IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1         CSTMT(J:J) .EQ. CUNDER) THEN
               GO TO 21
            ELSE
               GO TO 20
            END IF
         END IF
      END IF
C
C         TEST IF THE NML= ARGUMENT IS USED
C
      IF(CSTMT(J:J+3) .EQ. 'NML=') THEN
         GO TO 25
C
C         TEST IF THE REC= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+3) .EQ. 'REC=') THEN
         GO TO 25
C
C         TEST IF THE END= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+3) .EQ. 'END=') THEN
         IF(L11) THEN
            WRITE (0,101)
            IREC0 = IREC0 + 1
         END IF
         GO TO 25
C
C         TEST IF THE ERR= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+3) .EQ. 'ERR=') THEN
         GO TO 25
C
C         TEST IF THE IOSTAT= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+6) .EQ. 'IOSTAT=') THEN
         GO TO 25
C
C         TEST IF THE UNIT= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
         GO TO 25
C
C         TEST IF THE KEY= ARGUMENT IS USED
C
      ELSE IF(CSTMT(J:J+3) .EQ. 'KEY=') THEN
         GO TO 25
C
C         WRITE ERROR MESSAGE
C
      ELSE
C
C         DETERMINE THE END LOCATION OF THE INVALID PARAMETER
C
         I8 = J
         DO 18 J1 = J,KB
         IF(CSTMT(J1:J1) .EQ. CEQ) THEN
            I9 = J1
            DO 17 I7 = J1,KB
            IF(CSTMT(I7:I7) .EQ. COMMA) THEN
               IF(I7 .EQ. KB) THEN
                  J = I7
               ELSE
                  J = I7 + 1
               END IF
               GO TO 19
            END IF
 17         CONTINUE
         END IF
 18      CONTINUE
 19      I7 = I9 - I8 + 1
         IF(I9 .GT. 0) THEN
            WRITE (CI2WK1,'(I2)') I7
            IF(CI2WK1(1:1) .EQ. CBLANK) THEN
               CF101(60:61) = CI2WK1(2:2)//CBLANK(1:1)
            ELSE
               CF101(60:61) = CI2WK1(1:2)
            END IF
            WRITE (0,CF101) ISN,CSTMT(I8:J1)
            IREC0 = IREC0 + 1
            L10 = LTRUE
            IF(J .GE. I6) THEN
               GO TO 32
            ELSE
               GO TO 16
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE FORMAT SPECIFICATION IS NUMERIC WHEN FMT=
C         SPECIFICATION IS NOT USED

 20   IF(CSTMT(J:J) .EQ. CLPAR) J = J + 1
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9 .OR.
     1   I4 .NE. 0 .AND. CSTMT(I4:I4) .GE. C0 .AND. CSTMT(I4:I4)
     2   .LE. C9) THEN
C
C         CONVERT STATEMENT NUMBER TO AN INTEGER FORM
C
         CALL NUMBER (CSTMT,LTRUE,J,IIB,FP,IFP)
         II = IIB
C
C         THE FORMAT SPECIFICATION MAY BE A NUMBER OR A SUBSCRIPT OF
C         A VARIABLE NAME THAT IS A FORMAT
C
         IF(L5) THEN
            CALL INSERT (II)
         ELSE
            IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
               IF(.NOT.LINCL) THEN
                  IIB = IIB + 128
                  IISN = ISN + 128
                  CWR(1:4) = CIB(1:4)
                  CWR(5:8) = CISN(1:4)
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR
                  L9 = LTRUE
               END IF
            END IF
         END IF
C
C         DETERMINE IF A NUMERIC VALUE IS A SUBSCRIPT OF AN ARRAY
C         VARIABLE NAME INDICATING THIS NUMBER IS NOT A FORMAT STATEMENT
C         NUMBER. FOR THIS CASE, UNIT 4 WILL NOT HAVE AN ENTRY MADE IN
C         THE LIST OF STATEMENT NUMBERS.
C
         IF(L7 .OR. L8 .AND. .NOT.LINCL) THEN
            J = IFP + 1
            L7 = LFALSE
            IF(CSTMT(J:J) .EQ. COLON) L6 = LTRUE
            IF(.NOT.L8) GO TO 21
         END IF
         IF(.NOT.L5 .AND. .NOT.L9 .AND. .NOT.LINCL) THEN
            IIB = II + 128
            IISN = ISN + 128
            CWR(1:4) = CIB(1:4)
            CWR(5:8) = CISN(1:4)
            IREC4 = IREC4 + 1
            WRITE (4,REC=IREC4) CWR
         END IF
C
C         DETERMINE IF THE END OF THE COMMAND LIST HAS BEEN REACHED
C
         IF(CSTMT(IFP+1:IFP+1) .EQ. CRPAR) J = IFP + 1
         IF(CSTMT(IFP+1:IFP+1) .EQ. COMMA) J = IFP + 1
C
C         DETERMINE IF AN IO LIST FOLLOWS WITH OR WITHOUT AN IMPLIED DO
C         LOOP
C
         JD = IFP + 2
         IF(JD .LE. I6) THEN
            IF(CSTMT(JD:JD) .EQ. CLPAR .OR. CSTMT(JD:JD) .GE. CAA
     1         .AND. CSTMT .LE. CZZ .OR. CSTMT(JD:JD) .EQ. CUNDER) THEN
               J = J + 1
               GO TO 25
            ELSE
               J = IFP + 1
C
C         DETERMINE IF THE CHARACTER FOLLOWING THE NUMBER IS A COLON;
C         IF TRUE, THE NEXT FIELD IS A SUBSCRIPT RANGE SPECIFICATION.
C
               IF(CSTMT(J:J) .EQ. COLON) L6 = LTRUE
            END IF
         END IF
C
C         DETERMINE IF THE NEXT CHARACTER IS A RIGHT PARENTHESIS THAT
C         TERMINATES THE FORMAT DESIGNATION
C
         IF(CSTMT(IFP+1:IFP+1) .EQ. CRPAR) THEN
            J = IFP + 2
            I2 = I2 -1
            IF(I2 .EQ. 0) GO TO 34
         END IF
         IF(L2) GO TO 21
         IF(.NOT.L5) L4 = LTRUE
         GO TO 21
      END IF
C
C         TEST IF THE FORMAT ARGUMENT IS A VARIABLE NAME WHEN FMT=
C         SPECIFICATION IS NOT MADE
C
 21   IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1   CSTMT(J:J) .EQ. CUNDER .OR. L4) THEN
         IF(L4) THEN
            L4 = LFALSE
            GO TO 23
         END IF
         DO 22 I1 = J,KB
         IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CLPAR .OR.
     1      CSTMT(I1:I1) .EQ. CRPAR .OR. CSTMT(I1:I1) .EQ. COLON .OR.
     2      CSTMT(I1:I1) .EQ. CPLUS .OR. CSTMT(I1:I1) .EQ. CMINUS
     3      .OR. CSTMT(I1:I1) .EQ. CASTER .OR. CSTMT(I1:I1) .EQ.
     4      CSLASH) THEN
            IF(CSTMT(I1:I1) .EQ. CLPAR) THEN
               I2 = I2 + 1
               L5 = LTRUE
            END IF
            IF(CSTMT(I1+1:I1+1) .GE. C0 .AND. CSTMT(I1+1:I1+1) .LE.
     1         C9) L7 = LTRUE
            IF(CSTMT(I1:I1) .EQ. CRPAR) I2 = I2 - 1
C     IF(ISN .EQ. 1985)
C     WRITE(13,911) CWORK(1:6),CWORK(37:40),J,I1,I3
C911  FORMAT(' TRACE 911 PRDWR  CWORK(1:6) = ',A6,2X,'CWORK(37:40) = ',
C    1A4/5X,'J = ',I4,2X,'I6 = ',I4,2X,'I3 = ',I4)
            CALL VSETUP (J,I1-1,I3,LFALSE,LFALSE,CSTMT)
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            IF(L2) GO TO 32
            J = I1 + 1
            IF(I2 .EQ. 0) GO TO 34
            IF(L10) THEN
               L10 = LFALSE
               GO TO 16
            END IF
            IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CRPAR)
     1         GO TO 21
C
C         IF THE VARIABLE NAME IS TERMINATED BY AN ARITHMETIC OPERATOR,
C         PROCESS THE REMAINDER OF THE EXPRESSION
C
            IF(CSTMT(I1:I1) .EQ. CPLUS .OR. CSTMT(I1:I1) .EQ. CMINUS
     1         .OR. CSTMT(I1:I1) .EQ. CASTER .OR. CSTMT(I1:I1) .EQ.
     2         CSLASH) J = I1 + 1
            GO TO 20
         END IF
 22      CONTINUE
C
C         DETERMINE IF THE END OF THE CONTROL LIST
C
 23      DO 24 I1 = J,KB
         IF(CSTMT(I1:I1) .EQ. CEQ) GO TO 25
         IF(CSTMT(I1:I1) .EQ. CLPAR) I2 = I2 + 1
         IF(CSTMT(I1:I1) .EQ. CRPAR) THEN
            I2 = I2 - 1
            J = I1 + 1
            IF(I2 .EQ. 0) GO TO 34
         END IF
         IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CPLUS .OR.
     1      CSTMT(I1:I1) .EQ. CMINUS .OR. CSTMT(I1:I1) .EQ. CSLASH
     2      .OR. CSTMT(I1:I1) .EQ. CASTER .OR. CSTMT(I1:I1) .EQ. COLON)
     3      THEN
            J = I1
            GO TO 25
         END IF
 24      CONTINUE
      END IF
C
C         LOOP FOR THE VARIOUS ARGUMENTS OF THE CONTROL LIST
C
 25   J1 = J
      DO 31 I1 = J1,KB
C
C         DETERMINE IF A SUBSCRIPT RANGE EXISTS
C
      IF(L6) THEN
         IF(CSTMT(I1:I1) .EQ. COLON) THEN
            J = J + 1
            L6 = LFALSE
            GO TO 20
         END IF
      END IF
C
C         COUNT THE LEFT OR RIGHT PARENTHESIS WHEN IT OCCURS
C
      IF(CSTMT(I1:I1) .EQ. CLPAR) I2 = I2 + 1
      IF(CSTMT(I1:I1) .EQ. CRPAR) I2 = I2 - 1
C
C         DETERMINE IF THE COMMAND LIST CLOSING RIGHT PARENTHESIS
C         HAS BEEN FOUND
C
      IF(I2 .EQ. 0) THEN
         IF(CSTMT(I1:I1) .EQ. CRPAR) J = I1 +1
         GO TO 34
      END IF
C
C         DETERMINE IF A COMMA OR LEFT PARENTHESIS FOLLOWS THE CHARACTER
C         AT LOCATION DESIGNATED BY THE VALUE IN VARIABLE I1
C
C         PROCESS THE END= ARGUMENT
C
      IF(.NOT.LB(1) .AND. CSTMT(J:J+3) .EQ. 'END=') THEN
         ID = 12
         LBB = LB(1)
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LTRUE
         LA = LFALSE
         CALL CIOLST
         J = JB + 1
         IF(LA) GO TO 29
C
C         PROCESS THE ERR= ARGUMENT
C
      ELSE IF(.NOT.LB(2) .AND. CSTMT(J:J+3) .EQ. 'ERR=') THEN
         ID = 13
         LBB = LB(2)
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LTRUE
         LA = LFALSE
         CALL CIOLST
         J = JB + 1
         IF(LA) GO TO 29
C
C         PROCESS THE FMT= ARGUMENT
C
      ELSE IF(.NOT.LB(3) .AND. CSTMT(J:J+3) .EQ. 'FMT=') THEN
C
C         DO NOT PROCESS A LITERAL FORMAT SPECIFICATION
C
         IF(CSTMT(J+4:J+4) .EQ. CSYMCF) THEN
            J = J + 5
            GO TO 29
         END IF
         ID = 17
         LBB = LB(3)
         L1 = LFALSE
         L2 = LTRUE
         L3 = LFALSE
         L4 = LTRUE
         LA = LFALSE
         CALL CIOLST
         IF(LA) GO TO 29
C
C         PROCESS THE IOSTAT= ARGUMENT
C
      ELSE IF(.NOT.LB(4) .AND. CSTMT(J:J+6) .EQ. 'IOSTAT=') THEN
         ID = 21
         LBB = LB(4)
         L1 = LFALSE
         L2 = LTRUE
         L3 = LFALSE
         L4 = LFALSE
         LA = LFALSE
         CALL CIOLST
         J = JB + 1
         IF(LA) GO TO 29
C
C         PROCESS THE KEY= ARGUMENT
C
      ELSE IF(.NOT.LB(5) .AND. CSTMT(J:J+3) .EQ. 'KEY=') THEN
         ID = 22
         LBB = LB(5)
         L1 = LFALSE
         L2 = LTRUE
         L3 = LTRUE
         L4 = LFALSE
         LA = LFALSE
         CALL CIOLST
         IF(LA) GO TO 29
C
C         PROCESS THE NML= ARGUMENT
C
      ELSE IF(.NOT.LB(6) .AND. CSTMT(J:J+4) .EQ. 'NML=') THEN
         ID = 28
         LBB = LB(5)
         L1 = LFALSE
         L2 = LTRUE
         L3 = LTRUE
         L4 = LFALSE
         LA = LFALSE
         CALL CIOLST
         J = JB + 1
         IF(LA) GO TO 29
C
C         PROCESS THE REC= ARGUMENT
C
      ELSE IF(.NOT.LB(7) .AND. CSTMT(J:J+3) .EQ. 'REC=') THEN
         ID = 34
         LBB = LB(6)
         L1 = LFALSE
         L2 = LTRUE
         L3 = LTRUE
         L4 = LFALSE
         LA = LFALSE
         CALL CIOLST
         J = JB + 1
         IF(LA) GO TO 29
C
C         IF THE ARGUMENT IS NOT UNIT=, THEN AN ERRONEOUS ARGUMENT
C         EXISTS
C
      ELSE IF(CSTMT(J:J+4) .NE. 'UNIT=') THEN
C
C         DETERMINE THE END LOCATION OF THE INVALID PARAMETER
C
         I8 = J
         DO 27 J1 = J,KB
         IF(CSTMT(I1:I1) .EQ. CEQ) THEN
            I9 = J1
            DO 26 I7 = J1,KB
            IF(CSTMT(I7:I7) .EQ. COMMA) THEN
               IF(I7 .EQ. KB) THEN
                  J = I7
               ELSE
                  J = I7 + 1
               END IF
               GO TO 28
            END IF
 26         CONTINUE
         END IF
 27      CONTINUE
 28      I7 = I9 - I8 + 1
         WRITE (CI2WK1,'(I2)') I7
         IF(CI2WK1(1:1) .EQ. CBLANK) THEN
            CF101(59:60) = CBLANK(1:1)//CI2WK1(2:2)
         ELSE
            CF101(59:60) = CI2WK1(1:2)
         END IF
C
C         WRITE ERROR MESSAGE
C
         WRITE (0,CF101) ISN,CSTMT(I8:J1)
         IREC0 = IREC0 + 1
      END IF
C
C         PROCESS THE UNIT= ARGUMENT
C
      IF(CSTMT(J:J+4) .EQ. 'UNIT=') CALL CUNIT
         IF(CSTMT(I1:I1) .NE. CRPAR) THEN
            IF(CSTMT(J:J) .EQ. CRPAR) THEN
               I2 = I2 - 1
               J = J + 1
               IF(I2 .EQ. 0) GO TO 34
            END IF
            IF(CSTMT(J:J) .EQ. COMMA) THEN
               J = J + 1
            ELSE
               J = J + 2
            END IF
         ELSE
            I2 = I2 - 1
            IF(I2 .EQ. 0) THEN
               J = I1
               GO TO 34
            END IF
         END IF
         LA = LFALSE
C
C         DETERMINE IF THE RETURNED INDEX VALUE OF J IS LARGER THAN
C         THE LIMIT OF I6 FOR THE INPUT-OUTPUT COMMAND LIST
C
 29      IF(J .GE. I6) THEN
            J = I6 + 1
            GO TO 34
         END IF
C
C         SEARCH FOR THE NEXT ARGUMENT
C
         IF(J .GE. KB .OR. CSTMT(I1:I1) .EQ. CRPAR .OR. CSTMT(J:J)
     1       .EQ. CLPAR .OR. CSTMT(J:J) .EQ. CRPAR) THEN
            IF(CSTMT(J:J) .EQ. CLPAR) THEN
               I2 = I2 + 1
               J = J + 1
               GO TO 34
            END IF
            IF(CSTMT(I1:I1) .EQ. CRPAR) THEN
               I2 = I2 - 1
               J = I1 + 1
            ELSE
               J = J + 1
            END IF
            GO TO 34
         ELSE
            DO 30 I7 = J,KB
            IF(CSTMT(I7:I7) .EQ. CEQ) GO TO 14
            IF(CSTMT(I7:I7) .EQ. COMMA .OR. CSTMT(I7:I7) .EQ. CRPAR)
     1         THEN
               IF(CSTMT(I7:I7+1) .EQ. '),') THEN
                  J = I7 + 2
               ELSE
                  J = I7 + 1
               END IF
               J1 = J
               L9 = LTRUE
               GO TO 16
            END IF
            IF(CSTMT(I7:I7) .EQ. CLPAR) J = I7 + 1
 30         CONTINUE
C
C         THE ARGUMENT FOLLOWING UNIT= MAY NOT CONTAIN AN EQUAL SIGN
C         WHICH INDICATES THE FORMAT ARGUMENT IS EITHER A NUMERICAL
C         CONSTANT OR A VARIABLE NAME
C
            GO TO 14
         END IF
C
C         TEST IF THE END OF THE COMMAND LIST
C
         IF(CSTMT(I1:I1) .EQ. CRPAR) THEN
            J = I1 + 1
            GO TO 34
         END IF
 31   CONTINUE
C
C         FIND THE LOCATION OF A TERMINATING COMMA FOR THE DEFAULT
C         INPUT UNIT CASE
C
 32   DO 33 I1 = J,KB
      IF(CSTMT(I1:I1) .EQ. COMMA) THEN
         J = I1 + 1
         GO TO 34
      END IF
 33   CONTINUE
C
C         PROCESS THE IOLIST, IF ANY
C
 34   IF(J .GT. KB) GO TO 35
      IF(CSTMT(J:J) .EQ. COMMA) J = J + 1
      IF(CSTMT(J:J) .EQ. CLPAR .OR. (CSTMT(J:J) .GE. CAA .AND.
     1   CSTMT(J:J) .LE. CZZ) .OR. CSTMT(J:J) .EQ. CUNDER  .OR.
     2   (CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) .OR.
     3   CSTMT(J:J) .EQ. CSYMCF) CALL PIOLST
C
C         ROUTINE EXIT
C
 35     RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE SCANS THE TABLE OF INTEGER CONSTANTS AND INSERTS
C         THE INTEGER INTO THE TABLE ICONIT IF NOT FOUND. STATEMENT
C         NUMBERS ARE NOT PROCESSED BY THIS ROUTINE.
C
C
C     MEANING OF THE VARIABLES
C
C         ICONI  - COUNT OF THE NUMBER IF INTEGER CONSTANTS IN ICONIT
C         ICONIT - ARRAY OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM, WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         II     - THE INTEGER NUMBER BEING PROCESSED
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         I1     - WORK AREA USED TO CONTAIN THE VALUE OF ISN + 128
C         I2     - SUBSCRIPT VARIABLE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT, JSTRUC, RETURNS TO ZERO.
C
C     ******************************************************************
C
      SUBROUTINE INSERT (II)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
C     CHARACTER*132   CSREC
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB
      CHARACTER*56    CSUBTB
      CHARACTER*52    CNAME, CPARAM
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      REAL*8          FCONFT, FP
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      INTEGER*2       ISRECL, I2WK1
C
C         COMMON STATEMENTS
C
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWK8(2:2),CWK7), (CNAME(1),IENAME(1,1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' MORE THAN 2000 INTEGERS OCCUR IN THE PROGRAM'
     1)
C
C         DO NOT ENTER ANY INTEGER VALUES IN TABLE ICONIT WHEN THEY
C         OCCUR WITHIN A FILE FROM AN INCLUDE STATEMENT
C
      IF(LINCL) GO TO 12
C
C         SET THE ISN VALUE FOR INSERTION INTO THE ARRAY OF INTEGERS
C
      I1 = ISN + 128
C
C         TEST IF THIS IS THE INITIAL TABLE ENTRY
C
      IF(ICONI .EQ. 0) GO TO 11
C
C         DETERMINE IF THE ISN IS A DUPLICATE FOR THIS NUMBER
C
      DO 10 I2 = 1,ICONI
      IF(ICONIT(1,I2) .EQ. II) THEN
         IF(ICONIT(2,I2) .EQ. I1) GO TO 12
C     IF(ICONIT(1,ICONI) .EQ. II) THEN
C        IF(ICONIT(2,ICONI) .EQ. I1) GO TO 12
      END IF
 10   CONTINUE
C
C         NO MATCH WAS FOUND, INSERT THIS INTEGER NUMBER INTO ITS
C         SAVE ARRAY
C
 11   ICONI = ICONI + 1
C
C         DETERMINE IF THE INTEGER TABLE LIMIT HAS BEEN REACHED
C
      IF(ICONI .LE. 2000) THEN
         ICONIT(1,ICONI) = II
         ICONIT(2,ICONI) = I1
      ELSE
         IF(ICONI .EQ. 2001) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE SCANS THE TABLE OF FLOATING CONSTANTS AND INSERTS
C         A FLOATING NUMBER INTO THE TABLE FCONFT IF NOT FOUND
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         FCONFT - DOUBLE PRECISION ARRAY OF ALL REAL CONSTANTS OCCURING
C                  IN THE PROGRAM WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         FP     - DOUBLY PRECISION FLOATING POINT WORK AREA
C         ICONF  - COUNT OF THE NUMBER IF REAL CONSTANTS IN FCONFT
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         JCONFT - ARRAY OF ISN VALUES FOR REAL CONSTANTS OCCURING IN
C                  THE PROGRAM
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE TABLE OF
C                  FLOATING POINT NUMBERS EXCEED 4000, SET FALSE
C                  OTHERWISE
C
C     COMMENTS
C
C         ARRAYS FCONFT AND JCONFT ARE EQUIVALENCED TO ALLOW THE
C         FLOATING NUMBER TO BE STORED IN FLOATING FORMAT IN WORD 1,
C         AND THE ALLOW THE ISN TO BE STORED IN AN INTEGER FORMAT IN
C         WORD 2
C
C     ******************************************************************
C
      SUBROUTINE FCHECK
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB
      CHARACTER*56    CSUBTB
      CHARACTER*52    CNAME, CPARAM
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV
      CHARACTER*7     CWK7
      CHARACTER*8     CBLANK, CIMPL, CWK8
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWK8(2:2),CWK7), (CNAME(1),IENAME(1,1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA L1/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' MORE THAN 4000 FLOATING NUMBERS OCCUR IN THE P
     1ROGRAM')
C
C         DO NOT ENTER ANY FLOATING POINT VALUES IN TABLE FCONFT WHEN
C         THEY OCCUR WITHIN A FILE FROM AN INCLUDE STATEMENT
C
      IF(LINCL) GO TO 12
C
C         DETERMINE IF THE FLOTAING POINT NUMBER TABLE IS FULL
C
      IF(ICONF .EQ. 0) THEN
         L1 = LFALSE
      ELSE
         IF(L1) GO TO 12
      END IF
C
C         TEST IF THIS IS THE INITIAL TABLE ENTRY
C
      IF(ICONF .EQ. 0) GO TO 11
C
C         CHECK FOR A DUPLICATE ISN OF THE SAME NUMBER
C
      DO 10 I = 1,ICONF
      IF(FCONFT(I) .EQ. FP) THEN
         IF(JCONFT(I) .EQ. ISN) GO TO 12
      END IF
 10   CONTINUE
C
C         NO MATCH WAS FOUND, INSERT THIS FLOATING NUMBER INTO ITS
C         SAVE ARRAY
C
 11   ICONF = ICONF + 1
C
C         DETERMINE IF THE FLOATING NUMBER TABLE LIMIT HAS BEEN REACHED
C
      IF(ICONF .LE. 4000) THEN
         FCONFT(ICONF) = FP
         JCONFT(ICONF) = ISN
      ELSE
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
         L1 = LTRUE
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C
C         THIS ROUTINE SEARCHES A HOLLERITH FIELD FOR AN APOSTROPHE
C         WITHIN THE FIELD AND CONVERTS IT TO TWO SEQUENTIAL
C         APOSTROPHES. THE REMAINDER OF THE HOLLERITH FIELD IS NOT
C         MODIFIED.
C
C     MEANING OF THE VARIABLES
C
C
C         CAPOS  - CHARACTER VARIABLE, AN APOSTROPHE
C         CI4WK1 - EQUIVALENCED TO I4WK1
C         CSTMT  - CHARACTER VARIABLE, THE HOLLERITH FIELD TO BE
C                  SEARCHED FOR IN THE STATEMENT
C         I      - SUBSCRIPT VARIABLE
C         IREC0  - COUNNT OF MESSAGES WRITTEN ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER OF THE STATEMEMT BEING
C                  PROCESSED
C         I1     - LOCATION OF THE INITIAL DIGIT OF THE HOLLERITH FIELD
C                  LENGTH SPECIFICATION
C         I2     - LOCATION OF THE H INDICATING THIS IS A HOLLERITH
C                  FIELD
C         I3     - LOCATION OF THE FINAL CHARACTER OF THE HOLLERITH
C                  FIELD PRIOR TO MODIFICATION
C         I4     - NUMBER OF CHARACTERS IN THE HOLLERITH FIELD LENGTH
C                  SPECIFICATION
C         I4WK1  - USED TO CREATE THE CORRECT HOLLERITH FIELD LENGTH
C                  AFTER CORRECTION
C         I5     - LOCATION OF AN APOSTROPHE WITHIN THE HOLLERITH FIELD
C                  APOSTROPHE
C         I7     - LENGTH OF THE HOLLERITH FIELD EXCLUDING THE H AND
C                  THE NUMBER OF CHARACTERS IN THE FIELD LENGTH
C         I8     - LOCATION OF THE FINAL CHARACTER OF THE STATEMENT
C                  AFTER THE HOLLERITH FIELD IS MODIFIED
C         I9     - LOCATION OF THE START OF THE HOLLERITH FIELD DATA.
C                  IF MORE THAN ONE APOSTROPHE OCCURS IN THE DATA FIELD
C                  UPON ENTRY TO THIS ROUTINE, THE VALUE IS SET TO THE
C                  IMMEDIATE CHARACTER AFTER THE SECOND APOSROPHE'S
C                  INSERTION LOCATION. THIS PREVENTS DUPLICATE
C                  PROCESSING
C         I10    - VALUE OF THE HOLLERITH FIELD LENGTH BEFORE EXPANSION
C         I11    - WORK AREA TO ADJUST KB WHEN NECESSARY AND SUBSCRIPT
C                  VARIABLE
C         I12    - WORK AREA
C         I13    - WORK AREA
C         I14    - WORK AREA
C         I15    - WORK AREA
C         I16    - WORK AREA
C         I17    - WORK AREA
C         I18    - WORK AREA
C         KB     - LOCATION OF THE FINAL CHARACTER OF THE STATEMENT
C         LFOR   - LOGICAL VARIABLE, SET TRUE WHEN A FORMAT STATEMENT
C                  IS BEING PROCESSED, SET FALSE OTHERWISE
C
C     ******************************************************************
C
      SUBROUTINE SAPOSH (CSTMT,I1,I2,I3,KB,ISN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*4     CI4WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I4WK1,CI4WK1)
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' HOLLERITH FIELD HAS MORE THAN 999 CHARACTERS')
C
C       SAVE STATEMENT
C
      SAVE
C
C         SET THE TOTAL LENGTH OF THE HOLLERITH FIELD INCLUDING H AND
C         FIELD LENGTH
C
      IF(I1 .EQ. 0) GO TO 17
      I4 = I2 - I1      ! NUMBER OF FIELD LENGTH DIGITS
      I7 = I3 - I2      ! LENGTH OF DATA FIELD
      I9 = I2 + 1       ! START LOCATION OF DATA FIELD
      I10 = I4
      I11 = 0
      I12 = 0
      CI4WK1(1:4) = '    '
      CI4WK1(1:I4) = CSTMT(I1:I2-1)
      READ (CI4WK1(1:4),'(I4)') I10
C
C         LOCATE ANY APOSTROPHE WITHIN THE HOLLERITH FIELD
C
 10   DO 11 I = I9,I3+I4
      IF(CSTMT(I:I) .EQ. CAPOS) THEN
         I5 = I
         GO TO 12
      END IF
 11   CONTINUE
C
C         NO APOSTROPHE WAS FOUND
C
      GO TO 16
C
C         AN APOSTROPHE HAS BEEN FOUND; MAKE THE APOSTROPHE A DOUBLE
C         SET OF APOSTROPHES BY MOVING ALL CHARACTERS FROM THE
C         APOSTROPHE TO THE END OF THE STATEMENT RIGHT ONE CHARACTER.
C
 12   I8 = KB + 1       ! NEW END OF STATEMENT LOCATION
      I13 = I5 + 1
      DO 13 I = I8,I13,-1
      CSTMT(I:I) = CSTMT(I-1:I-1)
 13   CONTINUE
      KB = I8
C
C         CORRECT THE HOLLERITH FIELD LENGTH VALUE WHEN REQUIRED
C
      I7 = I7 + 1
C
C         CREATE THE HOLLERITH LENGTH TEXT DIGITS FOR THE STATEMENT
C
      CI4WK1(1:4) = '    '
      WRITE (CI4WK1,'(I4)') I7
C
C         DETERMINE IF THE HOLLERITH FIELD LENGTH NEEDS TO BE INCREASED
C
      IF(I10 .LT. 10) THEN
         IF(I7 .GE. 10) THEN
            I2 = I2 + 1
            I4 = I4 + 1
            I8 = I8 + 1
            DO 14 I = I8,I2,-1
            I13 = I - 1
            CSTMT(I:I) = CSTMT(I13:I13)
 14         CONTINUE
            CSTMT(I1:I1+1) = CI4WK1(3:4)
            I9 = I5 + 2
         ELSE
            CSTMT(I1:I1) = CI4WK1(4:4)
         END IF
      ELSE IF(I10 .LT. 100 .AND. I10 .GE. 10) THEN
         IF(I7 .GE. 100) THEN
            I2 = I2 + 1
            I4 = I4 + 1
            I8 = I8 + 1
            DO 15 I = I8,I2,-1
            I13 = I  - 1
            CSTMT(I:I) = CSTMT(I13:I13)
 15         CONTINUE
            CSTMT(I1:I1+2) = CI4WK1(2:4)
            I9 = I9 + 1
         ELSE
            CSTMT(I1:I1+1) = CI4WK1(3:4)
         END IF
      ELSE IF(I10 .LT. 1000 .AND. I10 .GE. 100) THEN
         IF(I7 .GE. 1000) THEN
            IREC0 = IREC0 + 1
            WRITE (0,100) ISN
         ELSE
            CSTMT(I1:I1+2) = CI4WK1(2:4)
         END IF
      END IF
C
C         SEARCH FOR ADDITIONAL APOSTROPHES WITHIN THE SAME HOLLERITH
C         DATA FIELD
C
      I9 = I5 + 2
      GO TO 10
C
C         SET THE END OF THE MODIFIED STATEMENT IF REQUIRED
C
  16  IF(I8 .GT. KB) KB = I8
C
C         PLACE THE START AND END APOSTROPHES TO CREATE THE LITERAL IN
C         STANDARD SYNTAX
C
      I12 = I3                           ! HOLLERITH FIELD END LOCATION
      I11 = I3 + 1
      IF(CSTMT(I12:I12) .NE. ' ') THEN
         IF(LFOR .AND. CSTMT(I11:I11) .EQ. COMMA .OR. (CSTMT(I11:I11)
     1      .EQ. CRPAR .OR. CSTMT(I11:I11) .EQ. CSLASH)) THEN
            CONTINUE
         ELSE
            I13 = I11 + 1
            IF(CSTMT(I11:I11) .EQ. CDOL .OR. CSTMT(I11:I11) .EQ. '\'
     1         .OR. CSTMT(I11:I11) .EQ. COLON .OR. CSTMT(I11:I11) .EQ.
     2         CAA .OR. CSTMT(I11:I13) .EQ. 'BN' .OR. CSTMT(I11:I13)
     3         .EQ. 'BZ' .OR. CSTMT(I11:I11) .EQ. CDD .OR.
     4         CSTMT(I11:I11) .EQ. CEE .OR. CSTMT(I11:I11) .EQ. CFF .OR.
     5         CSTMT(I11:I11) .EQ. CGG .OR. CSTMT(I11:I11) .EQ. CII .OR.
     6         CSTMT(I11:I11) .EQ. CLL .OR. CSTMT(I11:I11) .EQ. COO .OR.
     7         CSTMT(I11:I11) .EQ. CQQ .OR. CSTMT(I11:I11) .EQ. CSS .OR.
     8         CSTMT(I11:I11) .EQ. CTT .OR. CSTMT(I11:I11) .EQ. CXX .OR.
     9         CSTMT(I11:I11) .EQ. CZZ) I11 = I11 - 1
         END IF
         IF(I11 .EQ. I12) THEN
            I13 = I11 + 1
         ELSE
            I13 = I11 - 1
         END IF
         I14 = I2 + 1
         I15 = I2 + I7
         IF(I11 .GE. KB) THEN
            CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS
         ELSE
            IF(CSTMT(I11:I11) .EQ. COMMA) THEN
               IF(I7 .LT. 10) THEN
                  CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS
               ELSE IF(I7 .GE. 10 .AND. I7 .LE. 99) THEN
                  CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS
               ELSE IF(I7 .GT. 99) THEN
                  CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS//
     1            '  '
               END IF
            ELSE
C
C         DETERMINE IF THE END CHARACTER IS A SLASH
C
               IF(CSTMT(I11:I11) .EQ. CRPAR) THEN
                  IF(CSTMT(I15:I15) .EQ. CRPAR) THEN
                     I18 = I14 - I1 - 1
                     IF(I18 .EQ. 1) THEN
                        CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS//
     1                                  ' '
                     ELSE IF(I18 .EQ. 2) THEN
                        CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS//
     1                                  CSTMT(I11:I11)//' '
                     ELSE IF(I18 .EQ. 3) THEN
                        CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS//
     1                                  CSTMT(I11:I11)//' '
                     END IF
                  ELSE
                     CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS
                  END IF
               ELSE
C
C         DETERMINE IF THE CHARACTER IS IN A FORMAT STATEMENT
C
                  IF(LFOR) THEN
                     IF(CSTMT(I11+1:I11+1) .EQ. COMMA .OR.
     1                  CSTMT(I11:I11) .EQ. CRPAR .OR. CSTMT(I11:I11)
     2                  .EQ. CSLASH) THEN
                        IF(CSTMT(I11:I11) .EQ. CSLASH) THEN
                           I3 = I11 + 1
                           IF(CSTMT(I11+1:I13) .GE. C0 .AND.
     1                        CSTMT(I11+1:I13) .LE. C9) THEN
                              I13 = I11 - 1
                              CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)
     1                                          //CAPOS
                           ELSE
                              IF(CSTMT(I11:I11) .EQ. COMMA .OR.
     1                           CSTMT(I11:I11) .EQ. CSLASH) THEN
                                 CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     1                                           CAPOS//CSTMT(I11:I11)
                              ELSE
                                 CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     1                                           CAPOS//' '
                              END IF
                           END IF
                        END IF
                        I13 = I11 + 1
                        IF(CSTMT(I13:I13) .EQ. COMMA)
     1                     CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     2                                     CAPOS//' '
                        IF(CSTMT(I13:I13) .EQ. CRPAR .AND.
     1                     CSTMT(I13-1:I13-1) .NE. CSLASH) THEN
                           IF(I13 .LT. KB) THEN
                              IF(CSTMT(I13-1:I13-1) .NE. ' ')
     1                           CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     2                                           CAPOS//' '
                           ELSE
                              IF(CSTMT(I13-1:I13-1) .NE. ' ')
     1                           CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     2                                           CAPOS//' '
                           END IF
                        END IF
                     ELSE
                        I13 = I11 + 1
                        IF(CSTMT(I13:I13) .EQ. COMMA .OR.
     1                     CSTMT(I11:I11) .EQ. CRPAR .OR. CSTMT(I11:I11)
     2                     .EQ. CSLASH) THEN
                           I11 = I11 - 1
                        ELSE
                           CONTINUE
                        END IF
                        I16 = I11 - I1
                        I17 = I15 - I14
                        IF(I16 .GT. I17) THEN
                           I18 = I15 + I16 - I17
                           IF(I18 .EQ. KB) THEN
                              CSTMT(I1:I11+3) = CAPOS//CSTMT(I14:I15)
     1                                          //CAPOS//CSTMT(I18:I18)
     2                                          //' '
                           ELSE IF(I18 .GT. KB) THEN
                              CSTMT(I1:KB) = CAPOS//CSTMT(I14:I15)
     1                                          //CAPOS//CSTMT(KB:KB)
                           ELSE
                              CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     1                                        CAPOS
                           END IF
                        END IF
                     END IF
                  ELSE
                     IF(CSTMT(I1-1:I1-1) .EQ. CSLASH) THEN
                        CSTMT(I1:I11-1) = CAPOS//CSTMT(I14:I15)//
     1                  CAPOS
                     ELSE IF(CSTMT(I13:I13) .EQ. COMMA .OR.
     1                  CSTMT(I1-1:I1-1) .EQ. CRPAR) THEN
                        CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//
     1                  CAPOS
                     ELSE
                        IF(I15+1 .EQ. I11) THEN
                           CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS
     1                                     //CSTMT(I11:I11)
                        ELSE
                           CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS
     1                                     //' '
                        END IF
                     END IF
                  END IF
               END IF
            END IF
         END IF
         IF(KB .LT. I11) KB = I11
      ELSE
         I13 = I1 + I7 + 2
         I14 = I2 + 1
         I15 = I2 + I7
         IF(I2+I7+1 .EQ. KB) THEN
            IF(I7 .LE. 9) THEN
               CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS//
     1                         CSTMT(KB:KB)
            ELSE
               CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS//' '
            END IF
         ELSE
            IF(I7 .LE. 9) THEN
               I11 = I1 + I7 + 1
               CSTMT(I1:I11) = CAPOS//CSTMT(I14:I15)//CAPOS
               IF(KB .LT. I11) KB = I11
            ELSE
               CSTMT(I1:I13) = CAPOS//CSTMT(I14:I15)//CAPOS//' '
            END IF
         END IF
      END IF
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C
 17   DO 18 I = KB,1,-1
      IF(CSTMT(I:I) .NE. ' ') THEN
         KB = I
         GO TO 19
      END IF
 18   CONTINUE
C
C         ROUTINE EXIT
C
 19   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE EVALUATES THE EXPRESSION DEFINING A PARAMETER
C         VALUE FOR A PARAMETER STATEMENT. ANOTHER PARAMETER VARIABLE
C         MUST HAVE BEEN DEFINED PRIOR TO ITS USE IN A PARAMETER
C         EXPRESSION. ANY PARAMETER SPECIFICATION EXPRESSION VALUE MAY
C         BE USED IN DIMENSION AND TYPE STATEMENT DEFINITIONS TO
C         DETERMINE THEIR SIZE AND LENGTH
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHRACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CDIGIT - CHARACTER VARIABLE, LIST OF DIGITS FROM 0 - 9
C         CEXPR  - CHARACTER VARIABLE, WORK AREA FOR EVALUATING A
C                  PARAMETER EXPRESSION. THE MAXIMUM LENGTH OF AN
C                  EXPRESSION IS 104 CHARACTERS.
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 4000
C                  PARAMETER STATEMENTS IN A ROUTINE ARE ALLOWED
C                  RECORD STRUCTURE:
C                  COLS TYPE WORD DESCRIPTION
C                  1-32 C*32   8  VARIABLE NAME
C                 33-36 I*4    9  ISN VALUE
C                 37-44 C*8   11  DATA TYPE & LENGTH
C                 45-48 I*4   12  NUMERIC VALUE OF INTEGER VARIABLES
C                                 ONLY; OTHER DATA TYPES LEAVE THIS
C                                 FIELD BLANK
C                 49-52 I*4   13  LENGTH OF THE VARIABLE NAME IN COLS
C                                 1 - 32
C
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE FORTRAN STATEMENT BEING
C                  PROCESSED
C         CWTXT  - CHARACTER VARIABLE, THE CHARACTERS: IWnn, WHERE nn IS
C                  AN ASCII DIGIT FROM 1 TO 10
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C                  VARIABLE EXPRESSION
C         IARG3  - RESULTANT VALUE OF THE COMPUTATION FROM ROUTINE EVALU
C         II     - THE VALUE OF THE A NUMBER IN A PARAMETER STATEMENT
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - VALUE OF AN INTEGER CONVERTED FROM ASCII
C         IP     - THE NUMBER OF PARAMETER TABLE ENTRIES
C         IPLEV  - TABLE OF PARENTHESIS LEVELS, A MAXIMUM OF 10 MATCHING
C                  PARENTHESES LEVELS MAY BE SPECIFIED IN A SINGLE
C                  EXPRESSION
C         IPLOC  - TABLE OF LOCATIONS OF PARENTHESES IN THE EXPRESSIONS
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IW     - SAVE ARRAY FOR VALUES OF THE RESULT OF EACH OPERATION
C         I1     - THE INITIAL STARTING LOCATION OF THE EXPRESSION. THIS
C                  IS THE CHARACTER FOLLOWING THE EQUAL SIGN
C         I2     - THE CHARACTER ENDING THE EXPRESSION. THIS IS THE
C                  CHARACTER PRECEDING THE RIGHT PARENTHESIS CLOSING THE
C                  PARAMETER STATEMENT OR A COMMA CLOSING THE PARAMETER
C                  SPECIFICATION.
C         I3     - PARENTHESES LEVEL COUNT
C         I4     - NUMBER OF PARENTHESES, INCLUDES BOTH LEFT AND RIGHT
C         I5     - LOCATION OF THE CHARACTER FOLLOWING THE MATCHING LEFT
C                  PARENTHESIS. IF NO PARENTHESES EXIST, THEN I5 IS THE
C                  START LOCATION OF THE NUMBER OR PARAMETER VARIABLE TO
C                  THE LEFT OF THE ARITHMETIC OPERATOR.
C         I6     - SUBSCRIPT LOCATION OF THE CHARACTER PRECEDING THE
C                  HIGHEST RANKING RIGHT PARENTHESIS.  IF NO PARENTHESES
C                  EXIST, THEN I5 IS THE START LOCATION OF THE NUMBER OR
C                  PARAMETER VARIABLE TO THE RIGHT OF THE ARITHMETIC
C                  OPERATOR.
C         I7     - NUMBER OF CHARACTERS BETWEEN MATCHING PARENTHESES OF
C                  HIGHEST RANK
C         I8     - START LOCATION OF ONE OF THE ARITHMETIC OPERATOR
C                  CHARACTERS PRECEDING OR FOLLOWING THE OPERATOR
C         I9     - WORK AREA FOR SUBSCRIPT COMPUTATION
C         I10      INDEX USED TO COMPRESS THE EXPRESSION AND SUBSCRIPT
C                  VARIABLE
C         I11    - LOCATION OF AN ADD OR SUBTRACT ARITHMETIC OPERATOR
C         I12    - LOCATION OF A MULTIPLY OR DIVIDE ARITHMETIC OPERATOR
C         I13    - START LOCATION FOR LOCATING THE END OF THE VARIABLE
C                  OR NUMBER TO THE RIGHT OF THE ARITHMETIC OPERATOR
C         I14    - COUNT OF THE TOTAL NUMBER OF ARITHMETIC OPERATORS
C         I15    - SAVE AREA FOR THE VALUE OF KB, THE LAST CHARACTER OF
C                  THE STATEMENT
C         I16    - SAVE AREA FOR THE NUMBER OF CHARACTERS IN THE
C                  PARAMETER EXPRESSION IN CEXPR
C         JFINAL - THE END LOCATION OF THE EXPRESSION FOR A SINGLE
C                  PARAMETER SPECIFICATION IN CSTMT
C         JSTART - THE START LOCATION OF THE EXPRESSION FOR A SINGLE
C                  PARAMETER SPECIFICATION IN CSTMT
C         KI     - COUNT OF THE INDEX OF WORK AREA IW
C         K1     - LOCATION OF THE START LOCATION OF THE PORTION OF THE
C                  EXPRESSION TO BE FILLED WITH BLANKS
C         K2     - LOCATION OF THE END LOCATION OF THE PORTION OF THE
C                  EXPRESSION TO BE FILLED WITH BLANKS
C         LARG1  - LOGICAL VARIABLE, SET TRUE IF THE FIRST ARGUMENT IS
C                  NEGATIVE, SET FALSE IF POSITIVE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LPAREN - LOGICAL VARIABLE, SET TRUE WHEN A PARAMETER STATEMENT
C                  HAS A BALANCED NUMBER OF LEFT AND RIGHT PARENTHESES,
C                  SET FALSE OTHERWISE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE IF AN ADD OR SUBTRACT
C                  OPERATOR EXISTS IN THE EXPRESSION, SET FALSE IF NOT
C         L2     - LOGICAL VARIABLE, SET TRUE IF A MULTIPLY OR DIVIDE
C                  OPERATOR EXISTS IN THE EXPRESSION, SET FALSE IF NOT
C         M      - SUBSCRIPT VARIABLE
C
C       COMMENTS
C
C         A MAXIMUM OF 10 $Wn TEMPORARY WORK AREAS ARE ALLOWED IN
C         EVALUATING AN EXPRESSION
C
C     SUBROUTINES CALLED
C
C         EVALU NUMBER
C
C     ******************************************************************
C
      SUBROUTINE PARAEV (JSTART,JFINAL,IARG3)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION IPLEV(20), IPLOC(20), IW(10), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM, CEXPR
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*10    CDIGIT
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CWTXT
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LARG1, L1, L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CNAME(1),IENAME(1,1)), (CWK8(2:2),
     1            CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CWTXT/'$W  '/, CDIGIT/'123414671460'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' UNBALANCED PARENTHESES IN PARAMETER STATEMENT'
     1)
 101  FORMAT(' ISN:',I6,' INVALID EXPRESSION IN PARAMETER STATEMENT')
 102  FORMAT(' ISN:',I6,' ILLEGAL EXPRESSION SYNTAX IN PARAMETER STATEME
     1NT')
 103  FORMAT(' ISN:',I6,' MORE THAN 10 PARENTHESES IN A PARAMETER STATEM
     1ENT EXPRESSION')
C
C         INITIALIZATION FOR SCANNING THE PARAMETER EXPRESSION
C
      I1 = JSTART
      I2 = JFINAL
      I16 = JFINAL - I1 + 1
      I14 = 0
      KI = 0
      LARG1 = LFALSE
C
C         MOVE THE EXPRESSION TO THE WORK AREA FOR PROCESSING.
C         THE EXPRESSION WILL CONTAIN ALL CHARACTERS BETWEEN THE FIRST
C         CHARACTER FOLLOWING THE EQUAL SIGN ON THE LEFT TO THE
C         PRECEDING CHARACTER TO THE COMMA OR LEFT PARENTHESIS ON THE
C         RIGHT THAT INCLUDES A SINGLE PARAMETER SPECIFICATION.
C
      CEXPR(1:52) = CBLK52(1:52)
      CEXPR(52:104) = CBLK52(1:52)
      CEXPR(1:I2) = CSTMT(I1:JFINAL)
C
C         DETERMINE IF THE NUMBER OF CHARACTERS IN THE POSSIBLE
C         EXPRESSION IS A SINGLE CHARACTER
C
      IF(I2 .EQ. 1) THEN
C
C         DETERMINE IF THE SINGLE CHARACTER IS A LITERAL
C
         IF(CEXPR(1:1) .EQ. CSYMCF) GO TO 28
      END IF
C
C         SET EXPRESSION LIMIT FOR THE WORK AREA
C
 10   I1 = 1
      I3 = 0
      I4 = 0
      L1 = LFALSE
      L2 = LFALSE
C
C         SCAN THE EXPRESSION TO LOCATE ANY POSSIBLE PARENTHESES
C
      DO 11 M = I1,I2
C
C         COUNT AND RANK LEFT PARENTHESES
C
      IF(CEXPR(M:M) .EQ. CLPAR(1:1)) THEN
         I3 = I3 + 1
         I4 = I4 + 1
         IPLEV(I4) = I3
         IPLOC(I4) = M
         GO TO 11
      END IF
C
C         COUNT AND RANK RIGHT PARENTHESES
C
      IF(CEXPR(M:M) .EQ. CRPAR(1:1)) THEN
         I3 = I3 - 1
         I4 = I4 + 1
         IPLEV(I4) = I3
         IPLOC(I4) = M
         GO TO 11
      END IF
C
C         DETERMINE IF ANY ARITHMETIC OPERATORS EXIST IN THE EXPRESSION
C
      IF(CEXPR(M:M) .EQ. CPLUS(1:1) .OR. CEXPR(M:M) .EQ. CMINUS(1:1))
     1   THEN
         IF(.NOT.L1) I11 = M
         I14 = I14 + 1
         IF(M .EQ. I1) THEN
            IF(CEXPR(M:M) .EQ. CPLUS .OR. CEXPR(M:M) .EQ. CMINUS) THEN
               L1 = LFALSE
            ELSE
               L1 = LTRUE
            END IF
         ELSE
            L1 = LTRUE
         END IF
      END IF
      IF(CEXPR(M:M) .EQ. CASTER(1:1) .OR. CEXPR(M:M) .EQ. CSLASH(1:1))
     1   THEN
         IF(.NOT.L2) I12 = M
         IF(CEXPR(M-1:M) .EQ. '**') GO TO 11
         I14 = I14 + 1
         L2 = LTRUE
      END IF
 11   CONTINUE
C
C     ******************************************************************
C     *       PROCESSING EXPRESSION THAT CONTAINS NO PARENTHESES       *
C     ******************************************************************
C
C         DETERMINE IF ANY PARENTHESES EXIST
C
      IF(I3 .EQ. 0 .AND. I4 .EQ. 0) THEN
C
C       TEST IF A MULTIPLY OR DIVIDE ARITHMETIC OPERATOR EXISTS IN THE
C       EXPRESSION WHEN NO PARENTHESES EXIST
C
         IF(L2) THEN
C
C         SET THE DO LOOP START LOCATION TO SEARCH FOR THE VARIABLE
C         TO THE RIGHT OF THE ARITHMETIC OPERATOR
C
            I13 = I12
C
C         ADJUST THE VALUE OF I13 WHEN THE ARITHMETIC OPERATOR IS **
C         FOR EPONENTIATION
C
            IF(CEXPR(I13:I13+1) .EQ. '**') I13 = I13 + 1
            GO TO 12
         END IF
C
C       TEST IF AN ADD OR SUBTRACT ARITHMETIC OPERATOR EXISTS IN THE
C       EXPRESSION WHEN NO PARENTHESES EXIST
C
         IF(L1) THEN
C
C         SET THE DO LOOP START LOCATION TO SEARCH FOR THE END OF THE
C         VARIABLE TO THE RIGHT OF THE ARITHMETIC OPERATOR
C
            I13 = I1 + I11 - 1
         END IF
C
C         LOCATE THE END OF THE VARIABLE FOLLOWING THE ARITHMETIC
C         OPERATOR WHEN NO PARENTHESES EXIST.
C
 12      IF(L1 .OR. L2) THEN
C
C         DETERMINE THE END LOCATION OF THE PARAMETER VARIABLE NAME OR
C         THE NUMERICAL CONSTANT TO THE RIGHT OF THE ARITHMETIC OPERATOR
C
            DO 13 I10 = I13+1,I2
            IF(CEXPR(I10:I10) .EQ. CPLUS .OR. CEXPR(I10:I10) .EQ. CMINUS
     1         .OR. CEXPR(I10:I10) .EQ. CASTER .OR. CEXPR(I10:I10) .EQ.
     2         CSLASH .OR. I10 .EQ. I2) THEN
               IF(I10 .EQ. I2) THEN
                  I6 = I10
               ELSE
                  I6 = I10 - 1
               END IF
               GO TO 14
            END IF
 13         CONTINUE
C
C         ADJUST THE VALUE OF I13 WHEN THE ARITHMETIC OPERATOR IS **
C         FOR EPONENTIATION
C
            IF(CEXPR(I13-1:I13) .EQ. '**') I13 = I13 - 1
C
C         ADJUST THE VALUE OF I13 WHEN THE FIRST CHARACTER IS A PLUS OR
C         MINUS SIGN
C
            IF(CEXPR(I13:I13) .NE. CPLUS .AND. CEXPR(I13:I13) .NE.
     1         CMINUS) I13 = I13 - 1
C
C         DETERMINE THE START LOCATION OF THE PARAMETER VARIABLE NAME OR
C         THE NUMERICAL CONSTANT TO THE LEFT OF A MUILITPLY OR DIVIDE
C         ARITHMETIC OPERTATORS. MULTIPLY AND DIVIDE OPERATIONS ARE
C         PROCESSED BEFORE ADD AND SUBTRACT OPERATORS

 14         DO 15 I10 = I13,I1,-1
            IF(CEXPR(I10:I10) .EQ. CASTER .OR. CEXPR(I10:I10) .EQ.
     1         CSLASH .OR. I10 .EQ. I1) THEN
               IF(I10 .EQ. I1) THEN
                  I5 = I10
               ELSE
                  I5 = 1
               END IF
               I8 = 1
               GO TO 18
            END IF
 15         CONTINUE
C
C         DETERMINE THE START LOCATION OF THE PARAMETER VARIABLE NAME OR
C         THE NUMERICAL CONSTANT TO THE LEFT OF AN ADD OR SUBTRACT
C         ARITHMETIC OPERTATORS
C
            DO 16 I10 = I13-1,I1,-1
            IF(CEXPR(I10:I10) .EQ. CPLUS .OR. CEXPR(I10:I10) .EQ.
     1         CMINUS .OR. I10 .EQ. I1) THEN
               IF(I10 .EQ. I1) THEN
                  I5 = I10
               ELSE
                  I5 = I10 - 1
               END IF
               I8 = 1
               GO TO 18
            END IF
 16         CONTINUE
         ELSE
C
C         WHEN NO ARITHMETIC OPERATORS EXIST BUT PARENTHESES DO EXIST,
C         THE PARAMETER VALUE CAN BE EITHER A VARIABLE NAME OF ANOTHER
C         PARAMETER OR A NUMBER SPECIFICATION. IF THE INTIAL CHARACTER
C         IS $, IT IS A WORK AREA. ALSO, THE INITIAL CHARACTER CAN NOT
C         BE A MINUS SIGN.
C
            I9 = I1
            IF(CEXPR(I9:I9) .GE. C0(1:1) .AND. CEXPR(I9:I9) .LE.
     1         C9.OR. CEXPR(I9:I9) .EQ. CUNDER .OR. CEXPR(I9:I9) .GE.
     2         CAA .AND. CEXPR(I9:I9) .LE. CZZ .OR. CEXPR(I9:I9) .EQ.
     3         CDOL) THEN
               I5 = 1
               I6 = I2
               I8 = 1
               GO TO 18
            END IF
         END IF
      END IF
C
C     ******************************************************************
C     *           PROCESS EXPRESSION WITH PARENTHESES                  *
C     ******************************************************************
C
C         PARENTHESES EXIST, DETERMINE IF ALL PARENTHESES ARE BALANCED
C
      IF(I3 .NE. 0) THEN
C
C         WRITE DIAGNOSTIC
C
         IF(.NOT.LPAREN .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
         RETURN
      END IF
C
C         DETERMINE THE INNER MOST LEFT PARENTHESIS
C
      I3 = IPLEV(1)
      I5 = 1
      I6 = 1
C
C         DETERMINE IF ONLY A SINGLE SET OF MATCHING PARENTHESES OCCURS
C         AND SET THE BOUNDARY OF THE INNER RANGE WITHIN THE MATCHING
C         PARENTHESES FOR EVALUATION
C
      IF(I4 .EQ. 2) THEN
         I5 = IPLOC(1) + 1
         I6 = IPLOC(2) - 1
         IF(I14 .EQ. 0) THEN
            I8 = 1
         ELSE
            I8 = -1
         END IF
         GO TO 18
      END IF
C
C         MULTIPLE SETS OF MATCHING PARENTHESES OCCUR. FIND THE HIGHEST
C         RANKING PARENTHESES.
C
      IF(I4 .GT. 2) THEN
         DO 17 M = 1,I4
         IF(IPLEV(M) .GT. I3) THEN
            I3 = IPLEV(M)
            I5 = IPLOC(M) + 1
            I6 = IPLOC(M+1) - 1
            I8 = -1
            GO TO 17
         END IF
 17      CONTINUE
      END IF
C
C         IF PARENTHESES EXIST, I7 IS THE LENGTH OF THE NUMBER OF
C         CHARACTERS BETWEEN THE PARENTHESES WITH THE HIGHEST RANK, OR
C         WHEN THERE ARE NO PARENTHESES, I7 IS THE TOTAL LENGTH OF ALL
C         CHARACTERS OCCURRING TO THE RIGHT OF THE EQUAL SIGN FOR THIS
C         EXPRESSION
C
 18   I7 = I6 - I5 + I8
C
C         TEST FOR AN INVALID EXPRESSION
C
      IF(I4 .NE. 0 .AND. I7 .LT. 1) THEN
         IF(.NOT.LINCL) THEN
            WRITE (0,101) ISN
            IREC0 = IREC0 + 1
         END IF
         RETURN
      END IF
C
C         DETERMINE IF A PLUS OR MINUS SIGN IS THE FIRST CHARACTER
C         OF THE EXPRESSION FOLLOWING THE HIGHEST RANKING PARENTHESES,
C         OR THE FIRST CHARACTER OF THE EXPRESSION WHEN NO PARENTHESES
C         EXIST. THIS CAN ONLY BE AN ARITHMETIC SIGN AND IS NOT AN
C         OPERATOR, AND ONLY A PLUS OR MINUS SIGN MAY OCCUR.
C
      IF(CEXPR(I5:I5) .EQ. CPLUS(1:1) .OR. CEXPR(I5:I5) .EQ. CMINUS(1:1)
     1   ) THEN
         IF(CEXPR(I5:I5) .EQ. CPLUS(1:1)) LARG1 = LFALSE
         IF(CEXPR(I5:I5) .EQ. CMINUS(1:1)) LARG1 = LTRUE
         IF(.NOT.L1 .AND. .NOT.L2) THEN
            IF(I5 .GT. JSTART) I5 = I5 + 1
         END IF
      END IF
C
C         IF A MULTIPLY, DIVIDE, OR EXPONENTIAL OPERATOR OCCUR AS THE
C         INITIAL CHARACTER OF THE EXPRESSION, A DIAGNOSTIC MESSAGE IS
C         WRITTEN, SINCE THIS IS ILLEGAL SYNTAX.
C
      IF(CEXPR(I5:I5) .EQ. CASTER(1:1) .OR. CEXPR(I5:I5) .EQ.
     1   CSLASH(1:1)) THEN
         IF(.NOT.LINCL) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
         END IF
         RETURN
      END IF
C
C         DETERMINE IF THE EXPRESSION CONTAINS A SINGLE ARGUMENT THAT
C         IS AN INTEGER WITHOUT ANY ARITHMETIC OPERATORS
C
      IF(.NOT.L1 .AND. .NOT. L2) THEN
         IF(CEXPR(I5:I5) .GE. C0(1:1) .AND. CEXPR(I5:I5) .LE.
     1      C9(1:1) .OR. CEXPR(I5:I5) .EQ. CPLUS .OR. CEXPR(I5:I5)
     2      .EQ. CMINUS) THEN
            I15 = KB
C
C         DETERMINE WHEN A ONLY A NUMBER EXISTS
C
            IF(I4 .NE. 0) KB = I6
            CALL NUMBER (CEXPR,LTRUE,I5,II,FP,IFP)
            KB = I15
            IARG3 = II
            GO TO 28
         END IF
C
C         DETERMINE IF THE EXPRESSION CONTAINS A SINGLE ARGUMENT THAT
C         IS A VARIABLE NAME WITHOUT ANY ARITHMETIC OPERATORS
C
         IF(CEXPR(I5:I5) .GE. CAA .AND. CEXPR(I5:I5) .GE. C9(1:1)
     1      .OR. CEXPR(I5:I5) .EQ. CUNDER) THEN
            CALL EVALU (CEXPR,IW,0,I6,I5,I6,IRET,IARG3,LFALSE,LFALSE,
     1                  LFALSE)
            GO TO 28
         END IF
      END IF
C
C         SEARCH FOR ARITHMETIC OPERATORS IN ORDER OF PRECEDENCE
C
      DO 19 M = I5,I6
C
C         SEARCH FOR AN EXPONENTIAL OPERATOR
C
      IF(CEXPR(M:M) .EQ. CASTER(1:1) .AND. CEXPR(M+1:M+1) .EQ.
     1   CASTER(1:1)) THEN
         CALL EVALU (CEXPR,IW,5,M,I5,I6,IRET,IARG3,LARG1,L1,L2)
         GO TO 24
      END IF
 19   CONTINUE
C
C         TEST FOR A DIVIDE OPERATOR
C
      DO 20 M = I5,I6
      IF(CEXPR(M:M) .EQ. CSLASH(1:1)) THEN
C
C         DETERMINE IF THE SLASH OCCURS IN SUCCESSION INIDICATING THIS
C         IS A CONCANTINATION OPERATOR. NO FURTHER PROCESSING IS
C         REQUIRED FOR A CHARACTER TYPE VARIABLE.
C
         IF(CEXPR(M:M+1) .EQ. '//') GO TO 28
         CALL EVALU (CEXPR,IW,4,M,I5,I6,IRET,IARG3,LARG1,L1,L2)
         GO TO 24
      END IF
 20   CONTINUE
C
C         TEST FOR A MULTIPLY OPERATOR
C
      DO 21 M = I5,I6
      IF(CEXPR(M:M) .EQ. CASTER(1:1)) THEN
         CALL EVALU (CEXPR,IW,3,M,I5,I6,IRET,IARG3,LARG1,L1,L2)
         GO TO 24
      END IF
 21   CONTINUE
C
C         TEST FOR A SUBTRACT OPERATOR
C
      DO 22 M = I5,I6
      IF(CEXPR(M:M) .EQ. CMINUS(1:1)) THEN
         CALL EVALU (CEXPR,IW,2,M,I5,I6,IRET,IARG3,LARG1,L1,L2)
         GO TO 24
      END IF
 22   CONTINUE
C
C         TEST FOR AN ADD OPERATOR
C
      DO 23 M = I5,I6
      IF(CEXPR(M:M) .EQ. CPLUS(1:1)) THEN
         CALL EVALU (CEXPR,IW,1,M,I5,I6,IRET,IARG3,LARG1,L1,L2)
         GO TO 24
      END IF
 23   CONTINUE
C
C         SAVE COMPUTATIONAL RESULT AND CHANGE THE EXPRESSION FOR
C         FURTHER PROCESSING
C
C         DELETE THE PORTION OF THE EXPRESSION EVALUATED
C
 24   KI = KI + 1
C
C         REDUCE COUNT OF ARITHMETIC OPERATORS REMAINING TO BE PROCESSED
C
      I14 = I14 - 1
C
C         DETERMINE IF THE EXPRESSION EVALUATION IS COMPLETE
C
      IF(I14 .EQ. 0) GO TO 28
C
C         VERIFY IF SUFFICIENT WORK AREAS
C
      IF(KI .GT. 10) THEN
         IF(.NOT.LINCL) THEN
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
         END IF
         KI = 10
      END IF
      IW(KI) = IARG3
      IF(I4 .NE. 0) THEN
         IF(CEXPR(I5-1:I5-1) .EQ. CPLUS .OR. CEXPR(I5-1:I5-1) .EQ.
     1      CMINUS .OR. CEXPR(I5-1:I5-1) .EQ. CASTER .OR.
     2      CEXPR(I5-1:I5-1) .EQ. CSLASH) THEN
            K1 = I5
         ELSE
            K1 = I5 - 1
         END IF
C
C         SET END VALUE FOR BLANKING THE EXPRESSION
C
         IF(CEXPR(I6+1:I6+1) .EQ. CRPAR) THEN
            IF(CEXPR(I6+2:I6+2) .EQ. CPLUS .OR. CEXPR(I6+2:I6+2) .EQ.
     1         CMINUS .OR. CEXPR(I6+2:I6+2) .EQ. CASTER .OR.
     2         CEXPR(I6+2:I6+2) .EQ. CSLASH) THEN
               K2 = I6 + 1
            ELSE
               IF(CEXPR(I5-1:I5-1) .EQ. CLPAR) THEN
                  K2 = I6 + 1
               ELSE
                  K2 = I6
               END IF
            END IF
         ELSE
C
C         THE CHARACTER AT THE END OF THE PORTION OF THE EXPRESSION
C         EVALUATED IS NOT A RIGHT PARENTHESIS; DETERMINE IF THE
C         CHRACTER IS AN ARITHMETIC OPERATOR.
C
            IF(CEXPR(I6+1:I6+1) .EQ. CPLUS .OR. CEXPR(I6+1:I6+1) .EQ.
     1         CMINUS .OR. CEXPR(I6+1:I6+1) .EQ. CASTER .OR.
     2         CEXPR(I6+1:I6+1) .EQ. CSLASH) THEN
               K1 = K1 + 1
               K2 = I6
            END IF
         END IF
      ELSE
         K1 = I5
         K2 = I6
      END IF
      DO 25 I = K1,K2
      CEXPR(I:I) = CBLK52(1:1)
 25    CONTINUE
C
C         DETERMINE IF THE ENTIRE EXPRESSION HAS BEEN EVALUATED
C
      IF(CEXPR(1:1) .EQ. CBLANK(1:1) .AND. CEXPR(I16:I16) .EQ.
     1   CBLANK(1:1)) GO TO 28
C
C         ADD THE $Wnn SYMBOL TO THE EXPRESSION DESIGNATING A WORK AREA
C         WHERE THE RESULT OF AN INTERMEDIATE COMPUTATION HAS BEEN
C         STORED
C
      IF(KI .LT. 10) THEN
         CWTXT(3:3) = CDIGIT(KI:KI)
         CEXPR(I5:I5+2) = CWTXT(1:3)
      ELSE
         CWTXT(3:3) = CDIGIT(1:1)
         CWTXT(4:4) = CDIGIT(KI:KI)
         CEXPR(I5:I5+3) = CWTXT(1:4)
      END IF
C
C         COMPRESS THE MODIFIED EXPRESSISON
C
      I10 = 1
      DO 26 M = 1,I2
C
C         WHEN A BLANK IS FOUND, CONTINUE WITH OUT CHANGE; THIS WILL
C         INCREMENT M BUT NOT I10.
C
      IF(CEXPR(M:M) .EQ. CBLANK(1:1)) GO TO 26
C
C         DO NOT MOVE A CHARACTER WHEN M = I10
C
      IF(M .EQ. I10) THEN
         I10 = I10 + 1
         GO TO 26
      END IF
C
C         MOVE A CHARACTER ONLY WHEN M > I10
C
      IF(M .GT. I10) THEN
         CEXPR(I10:I10) = CEXPR(M:M)
         IF(CEXPR(M:M) .NE. CBLANK(1:1)) THEN
            IF(M .EQ. I2) THEN
               CEXPR(M:M) = CBLANK(1:1)
               GO TO 26
            ELSE
               I10 = I10 + 1
            END IF
         END IF
C
C         REPLACE THE MOVED CHARACTER WITH A BLANK ONLY WHEN M > J
C
         CEXPR(M:M) = CBLANK(1:1)
      END IF
 26   CONTINUE
C
C         RESET THE PARENTHESES RANKING AND COUNT
C
      DO 27 I = 1,I4
      IPLEV(I) = 0
      IPLOC(I) = 0
 27   CONTINUE
C
C         RESET THE LENGTH OF THE EXPRESSION AND THE COUNTERS FOR
C         PARENTHESES
C
      I2 = I10
      I3 = 0
      I4 = 0
C     KI = 0
C
C         WHEN THE EXPRESSION CONTAINS ONLY THE WORK AREA AFTER THE
C         THE REMOVAL OF BLANKS, THE EXPRESSION HAS BEEN EVALUATED
C
      IF(CEXPR(1:1) .EQ. '$' .AND. CEXPR(3:3) .NE. CBLANK(1:1)) THEN
         IF(CEXPR(4:4) .EQ. CBLANK(1:1)) THEN
            GO TO 28
         ELSE IF(CEXPR(5:5) .EQ. CBLANK(1:1)) THEN
            GO TO 28
         END IF
      END IF
C
C         DETERMINE IF THE ENTIRE EXPRESSION HAS BEEN EVALUATED
C
      IF(CEXPR(1:1) .EQ. CBLANK(1:1) .AND. I2 .EQ. 0) GO TO 28
      GO TO 10
 28   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE EVALUATES THE TWO ARGUMENTS OF AN ARITHMETIC
C         OPERATION WITHIN A PARAMETER SPECIFICATION AND COMPUTES THE
C         VALUE OF THE RESULTS OF THE OPERATION.
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK
C         CARG   - CHARACTER VARIABLE, ARG1 AND ARG2 VARIABLE NAMES
C         CBITS  - CHARACTER VARIABLE, WORK AREA TO HOLD BIT SWITCHES,
C                  EQUIVALENCED TO JBITS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEXPR  - CHARACTER VARIABLE, WORK AREA FOR EVALUATING A
C                  PARAMETER EXPRESSION
C         CIARG1 - CHARACTER VARIABLE, EQUIVALENCED TO IARG1
C         CIARG2 - CHARACTER VARIABLE, EQUIVALENCED TO IARG2
C         CJ2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO J2WK1
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C         CPARAM - TABLE OF INTEGER TYPE PARAMETER VARIABLE NAMES AND
C                  THEIR VALUES
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CVAR   - CHARACTER VARIABLE, A PARAMETER VARIABLE NAME WITHIN
C                  AN EXPRESSION BEING EVALUATED
C         CWBITS - CHARACTER VARIABLE, USED TO MANIPULATE BIT SWITCHES
C         CWORKP - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT WORK AREA
C         IARG1  - VALUE OF ARGUMENT 1 FOR COMPUTATION
C         IARG2  - VALUE OF ARGUMENT 2 FOR COMPUTATION
C         IARG3  - RESULTANT VALUE OF ARGUMENT 1 AND ARGUMENT 2 AFTER
C                  ARITHMETIC OPERATION IS PERFORMED
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER OR THE FINAL DIGIT OF AN INTEGER
C                  NUMBER
C         II     - INTEGER NUMBER CONVERTED FROM ASCII
C         IP     - THE NUMBER OF PARAMETER TABLE ENTRIES IN CPARAM
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IOPER  - CODE TO INDICATE THE TYPE OF ARITHMETIC OPERATION TO
C                  BE PERFORMED
C                  1 - ADD, 2 - SUBTRACT, 3 - MULTIPLY, 4 - DIVIDE,
C                  5 - EXPONENTIAL
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN THE TABLE OF
C                  INTEGER PARAMETER DEFINITIONS
C         IREC7  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 7 (VARIABLE NAMES)
C         IREC0  - COUNT OF THE NUMBER ERROR MESSAGES ON UNIT 0
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET1  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET2  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET3  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISN    - ISN OF THE PARAMETER STATEMENT
C         IW     - TEMPORARY WORK AREA TO SAVE INTERMEDIATE COMPUTATIONS
C         J      - THE LOCATION OF THE ARITHMETIC OPERATOR
C         JISN   - ISN OF A VARIABLE NAME, WORK AREA
C         JLEN   - THE LENGTH OF A PARAMETER VARIABLE NAME
C         J1     - THE START LOCATION OF THE ARGUMENT PRECEDING THE
C                  ARITHMETIC OPERATOR
C         J2     - THE END LOCATION OF THE ARGUMENT FOLLOWING THE
C                  ARITHMETIC OPERATOR
C         J2WK1  - WORK AREA USED TO DETERMINE THE WORK AREA USED FOR
C                  COMPUTING VALUES OF AN EXPRESSION
C         J3     - START LOCATION OF THE FIRST ARGUMENT OF THE
C                  PARAMETER EXPRESSION
C         J4     - END LOCATION OF THE FIRST ARGUMENT OF THE PARAMETER
C                  EXPRESSION
C         J5     - START LOCATION OF THE SECOND ARGUMENT OF THE
C                  PARAMETER EXPRESSION
C         J6     - END LOCATION OF THE SECOND ARGUMENT OF THE PARAMETER
C                  EXPRESSION
C         J7     - WORK AREA, LOCATION OF THE FIRST CHARACTER TO THE
C                  LEFT OR RIGHT OF THE ARITHMETIC OPERATOR
C         J8     - WORK AREA, USED TO SAVE AND RESTORE THE VALUE OF KB,
C                  THE LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         LARG1  - LOGICAL VARIABLE, SET TRUE WHEN THE IARG3 VALUE IS
C                  NEGATIVE, SET FALASE OTHERWISE
C         LARITH - LOGICAL VARIABLE, SET TRUE IF ANY ARITHMETIC
C                  OPERATORS EXIST IN THE EXPRESSION, SET FALSE IF NOT
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE IF AN ADD OR SUBTRACT
C                  OPERATOR EXISTS IN THE EXPRESSION, SET FALSE IF NOT
C         L2     - LOGICAL VARIABLE, SET TRUE IF A MULTIPLY OR DIVIDE
C                  OPERATOR EXISTS IN THE EXPRESSION, SET FALSE IF NOT
C         L3     - LOGICAL VARIABLE, USED AS A WORK AREA TO DETERMINE
C                  USAGE AND DEFINITION OF VARIABLES
C         L4     - LOGICAL VARIABLE, USED AS A WORK AREA TO DETERMINE
C                  USAGE AND DEFINITION OF VARIABLES
C         M      - SUBSCRIPT VARIABLE
C
C     SUBROUTINES CALLED
C
C         BTEST IBSET INSERT NUMBER SETTL TABINS TABSRH
C
C     ******************************************************************
C
      SUBROUTINE EVALU (CEXPR,IW,IOPER,J,J1,J2,IRET,IARG3,LARG1,L1,L2)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CARG(2), IPARAM(13,4000), IW(10), IWORKP(13),
     1ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM, CEXPR
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK, CWORKP
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32, CARG
      CHARACTER*32    CVAR
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CIARG1, CIARG2, CBITS
      CHARACTER*2     CI2WK1, CJ2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LARG1, L1, L2, L3, L4
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, JJ,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (IARG1,CIARG1), (IARG2,CIARG2),
     1(J2WK1,CJ2WK1), (CBITS(1:4),JBITS), (CWORKP(33:36),JISN),
     2(CWORKP,IWORKP), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7),
     3(CPARAM(1),IPARAM(1,1))
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' PARAMETER EVALUATION ARGUMENT NOT FOUND: ',
     1A32)
 101  FORMAT(' ISN:',I6,' VARIABLE DIMENSION SUBSCRIPT VALUE IS ZER0: '
     1,A32)
 102  FORMAT(' ISN:',I6,' CAN NOT DIVIDE DIMENSION SUBSCRIPT BY ZERO: '
     1,A32)
C
C         INITIALIZATION
C
      J3 = 0
      J4 = 0
      J5 = 0
      J6 = 0
      IRET = 0
C
C         DETERMINE IF ANY MATHEMATICAL OPERATORS EXIST
C
      IF(IOPER .EQ. 0 .AND. .NOT.L1 .AND. .NOT.L2) THEN
C
C         A SINGLE VARIABLE EXISTS AS THE VALUE TO BE DETERMINED
C
         CALL TABSRH (CPARAM,IP,52,1,32,CEXPR,1,32,IRET1,4000)
         IF(IRET1 .GT. 0) THEN
            IARG3 = IPARAM(12,IRET1)
            GO TO 16
         ELSE
C
C         DETERMINE IF THE SINGLE VARIABLE ARGUMENT IS CATALOGED
C
            CALL TABSRH (CNAME,INAME,52,1,32,CEXPR,1,32,IRET2,4000)
            IF(IRET2 .GT. 0) THEN
               IF(BTEST(IENAME(12,IRET2),20)) THEN
                  CONTINUE
               ELSE
                  IF(.NOT.LINCL) THEN
                     WRITE (0,100) ISN,CEXPR(1:32)
                     IREC0 = IREC0 + 1
                  END IF
               END IF
            END IF
         END IF
      END IF
C
C         SET SCAN START INDEX VALUE
C
      IF(IOPER .EQ. 0) THEN
         J7 = J2
      ELSE
         J7 = J - 1
      END IF
C
C         LOCATE THE BOUNDARY OF THE FIRST ARGUMENT WHEN IT IS A SINGLE
C         CHARACTER
C
      IF(J7 .EQ. J1) THEN
         J3 = J7
         J4 = J7
         GO TO 11
      END IF
C
C         LOCATE THE BOUNDARY OF THE FIRST ARGUMENT USING A BACKWARD
C         SCAN WHEN IT IS MORE THAN ONE CHARACTER
C
      DO 10 M = J7,J1,-1
      IF(CEXPR(M:M) .EQ. CPLUS(1:1) .OR. CEXPR(M:M) .EQ. CMINUS(1:1)
     1   .OR. CEXPR(M:M) .EQ. CSLASH(1:1) .OR. CEXPR(M:M) .EQ.
     2    CASTER(1:1) .OR. M .EQ. J1) THEN
          IF(M .EQ. J1) THEN
             J3 = M
          ELSE
             J3 = M + 1
          END IF
          J4 = J7
          GO TO 11
      END IF
 10   CONTINUE
C
C         WHEN NO ARITHMETIC OPERATOR OCCURS ON THE LEFT OF THE FIRST
C         ARGUMENT, IT STARTS WITH THE LEFT BOUNDARY OF THE FIELD IN
C         J1, AND TERMINATES AT THE CHARACTER BEFORE THE ARITHMETIC
C         OPERATOR
C
      J3 = J1
      IF(IOPER .NE. 0) THEN
         J4 = J - 1
      ELSE
         J4 = J2
      END IF
C
C         LOCATE THE BOUNDARY OF THE SECOND ARGUMENT WHEN THE ARITHMETIC
C         OPERATOR IS EXPONENTIATION
C
 11   IF(IOPER .EQ. 5) THEN
         J7 = J + 2
      ELSE
         IF(IOPER .NE. 0) J7 = J + 1
      END IF
C
C         LOCATE THE BOUNDARY OF THE SECOND ARGUMENT WHEN IT IS A SINGLE
C         CHARACTER
C
      IF(J7 .EQ. J1) THEN
         J5 = J7
         J6 = J7
         GO TO 13
      END IF
C
C         LOCATE THE BOUNDARY OF THE SECOND ARGUMENT USING A FORWARD
C         SCAN WHEN IT IS MORE THAN ONE CHARACTER
C
      DO 12 M = J7,J2
      IF(CEXPR(M:M) .EQ. CPLUS(1:1) .OR. CEXPR(M:M) .EQ. CMINUS(1:1)
     1   .OR. CEXPR(M:M) .EQ. CSLASH(1:1) .OR. CEXPR(M:M) .EQ.
     2    CASTER(1:1) .OR. M .EQ. J2) THEN
          J5 = J7
          IF(M .EQ. J2) THEN
             J6 = M
          ELSE
             J6 = M - 1
          END IF
          GO TO 13
      END IF
 12   CONTINUE
C
C         WHEN NO ARITHMETIC OPERATOR OCCURS TO THE RIGHT OF THE SECOND
C         ARGUMENT, IT STARTS WITH THE RIGHT BOUNDARY FIELD IN J2
C
      IF(L1 .OR. L2) THEN
         J5 = J + 1
      ELSE
         J5 = J7 + 1
      END IF
      J6 = J2
C
C     ******************************************************************
C     *                                                                *
C     *                PROCESSING FOR ARGUMENT 1                       *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF THE FIRST ARGUMENT IS A VARIABLE NAME
C
 13   IF(CEXPR(J3:J3) .GE. CAA .AND. CEXPR(J3:J3) .LE. CZZ .OR.
     1   CEXPR(J3:J3) .EQ. CUNDER) THEN
C
C         PLACE THE VARIABLE NAME IN THE WORK AREA
C
C        JLEN = J - J3 + 1
         JLEN = J - J3
         CVAR(1:32) = CBLK52(1:32)
         CARG(1)(1:32) = CBLK52(1:32)
         CARG(2)(1:32) = CBLK52(1:32)
         CVAR(1:JLEN) = CEXPR(J3:J4)
         CARG(1)(1:32) = CVAR(1:32)
C
C         DETERMINE IF THE VARIABLE NAME IS AN ARGUMENT OF A SUBPROGRAM.
C         A SUBPROGRAM ARGUMENT CAN NOT BE A COMPOUND VARIABLE.
C
         CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         DETERMINE IF THE ARGUMENT IS A PARAMETER VARIABLE
C
            IF(.NOT.(BTEST(IENAME(12,IRET),14))) THEN
C
C         WHEN A VARIABLE NAME IS IN COMMON OR IS A SUBPROGRAM ARGUMENT,
C         INSURE ITS USE IS RECORDED ON UNIT 7; HOWEVER, NO EVALUATION
C         WILL OCCUR.
C
               L3 = BTEST(IENAME(12,IRET),1)
               L4 = BTEST(IENAME(12,IRET),7)
               IF(BTEST(IENAME(12,IRET),1) .OR.
     1            BTEST(IENAME(12,IRET),7)) THEN
                  CWORKP(1:52) = CNAME(IRET)(1:52)
                  JISN = ISN + 128
                  IF(.NOT.LINCL) THEN
                     IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                        IENAME(12,IRET) = IBSET(IENAME(12,IRET),15)
                        CWORKP(45:48) = CNAME(IRET)(45:48)
                        IWORKP(13) = JLEN
                        IF(.NOT.LINCL) THEN
                           WRITE (7,REC=IREC7) CWORKP
                           IREC7 = IREC7 + 1
                        END IF
                     END IF
                  END IF
                  GO TO 14
               END IF
            END IF
         ELSE
C
C         PARAMETER VARIABLE NOT DEFINED, WRITE DIAGNOSTIC
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN,CVAR(1:32)
               IREC0 = IREC0 + 1
            END IF
C
C         WHEN THE VARIABLE HAS NOT YET BEEN CATALOGED IN THE MASTER
C         NAME TABLE, PLACE THE NAME INTO THE TABLE AND WRITE IT ON
C         UNIT 7
C
            CWORKP(1:32) = CVAR(1:32)
            JISN = ISN + 128
            IWORKP(12) = 0
            IWORKP(13) = JLEN
            IF(.NOT.LINCL) THEN
               IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                  CALL SETTL (CWORKP)
                  IWORKP(12) = IBSET(IWORKP(12),15)
                  CALL TABINS (CNAME,INAME,52,1,32,CWORKP,1,32,IRET4,
     1                         4000)
                  IF(.NOT.LINCL) THEN
                     WRITE (7,REC=IREC7) CWORKP
                     IREC7 = IREC7 + 1
                  END IF
                  GO TO 14
               END IF
            END IF
         END IF
C
C         OBTAIN THE VALUE FROM THE TABLE OF PARAMETER VARIABLE
C         DEFINITIONS
C
         CALL TABSRH (CPARAM,IP,52,1,32,CVAR,1,32,IRET,4000)
C
C         DETERMINE IF A MATCH WAS FOUND
C
         IF(IRET .GT. 0) THEN
C
C         MOVE THE VARIABLE VALUE TO ARGUMENT 1
C
            CIARG1(1:4) = CPARAM(IRET)(45:48)
C
C         SAVE THE NAME ENTRY FOR THE LISTING
C
            CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET,4000)
            CWORKP(1:52) = CNAME(IRET)(1:52)
            JISN = ISN + 128
            IF(.NOT.LINCL) THEN
               IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                  IENAME(12,IRET) = IBSET(IENAME(12,IRET),14)
                  CWORKP(45:48) = CNAME(IRET)(45:48)
                  IF(.NOT.LINCL) THEN
                     WRITE (7,REC=IREC7) CWORKP
                     IREC7 = IREC7 + 1
                  END IF
               END IF
            END IF
         ELSE
C
C         PARAMETER VARIABLE NOT DEFINED, WRITE DIAGNOSTIC
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN,CVAR(1:32)
               IREC0 = IREC0 + 1
            END IF
C
C         THE PARAMETER VARIABLE IS NOT IN THE TABLE OF PARAMETER
C         VARIABLES WITH DEFINED INTEGER VALUES. DETERMINE IF THE
C         VARIABLE NAME EXISTS IN THE MASTER NAME TABLE.
C
            CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               IARG1 = 0
               GO TO 14
            END IF
         END IF
         GO TO 14
      END IF
C
C         CHECK FOR A WORK AREA VALUE FOR THE FIRST ARGUMENT VALUE
C
      IF(CEXPR(J3:J3) .EQ. '$') THEN
         IF(CEXPR(J3+3:J3+3) .EQ. C0(1:1)) THEN
            IARG1 = IW(10)
         ELSE
            J2WK1 = 0
            CJ2WK1(IDXE:IDXE) = CEXPR(J3+2:J3+2)
            J2WK1 = J2WK1 - 48
            IARG1 = IW(J2WK1)
         END IF
         GO TO 14
      END IF
C
C         DETERMINE IF ARGUMENT 1 IS A NUMBER
C
      IF(CEXPR(J3:J3) .GE. C0(1:1) .AND. CEXPR(J3:J3) .LE.
     1   C9(1:1)) THEN
C
C         CONVERT ASCII NUMBER TO INTEGER
C
         J8 = KB
         KB = J4
         CALL NUMBER (CEXPR,LTRUE,J3,II,FP,IFP)
         KB = J8
         IF(.NOT.LINCL) CALL INSERT (II)
         IARG1 = II
         IF(IOPER .EQ. 0) THEN
            IARG3 = II
            GO TO 16
         END IF
      END IF
C
C         DETERMINE IF THE VALUE OF ARG1 IS NEGATIVE
C
 14   IF(LARG1) IARG1 = -IARG1
C
C         DETERMINE IF ONLY ARGUMENT 1 EXISTS IN THE EXPRESSION
C
      IF(.NOT.L1 .AND. .NOT.L2) THEN
         IARG3 = IARG1
         GO TO 16
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *                PROCESSING FOR ARGUMENT 2                       *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF THE SECOND ARGUMENT IS A VARIABLE NAME
C
      IF(CEXPR(J5:J5) .GE. CAA .AND. CEXPR(J5:J5) .LE. CZZ .OR.
     1   CEXPR(J5:J5) .EQ. CUNDER) THEN
C
C         ADJUST THE END LOCATION VALUE IF NECESSARY
C
         IF(CEXPR(J6:J6) .EQ. CRPAR) J6 = J6 - 1
C
C         PLACE THE VARIABLE NAME IN THE WORK AREA
C
C        JLEN = J6 - J5
         JLEN = J6 - J5 + 1
         CVAR(1:32) = CBLK52(1:32)
         CVAR(1:JLEN) = CEXPR(J5:J6)
         CARG(2)(1:32) = CVAR(1:32)
C
C         DETERMINE IF THE VARIABLE NAME IS AN ARGUMENT OF A SUBPROGRAM
C
         CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         DETERMINE IF THE ARGUMENT IS A PARAMETER VARIABLE
C
            IF(.NOT.(BTEST(IENAME(12,IRET),14))) THEN
C
C         WHEN A VARIABLE NAME IS IN COMMON OR IS A SUBPROGRAM ARGUMENT,
C         INSURE ITS USE IS RECORDED ON UNIT 7; HOWEVER, NO EVALUATION
C         MAY OCCUR.
C
               IF(BTEST(IENAME(12,IRET),1) .OR.
     1            BTEST(IENAME(12,IRET),7)) THEN
                  CWORKP(1:52) = CNAME(IRET)(1:52)
                  JISN = ISN + 128
                  IF(.NOT.LINCL) THEN
                     IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                        IENAME(12,IRET) = IBSET(IENAME(12,IRET),15)
                        CWORKP(45:48) = CNAME(IRET)(45:48)
                        IWORKP(13) = JLEN
C     IF(CWORKP(1:6) .EQ. 'JRECTB')
C     IF(ISN .EQ. 31)
C    1WRITE(13,922) ISN,CWORKP(1:9),CWORKP(37:40),CWORKP(45:45),
C    2CWORKP(46:46),CWORKP(47:47),CWORKP(48:48),IREC7
C922  FORMAT(' TRACE 922 EVALU  ISN = ',I4,2X,'CWORKP(1:9) = ',A9,2X,
C    1'CWORKP(37:40) = ',A6/5X,'CWORKP(45:48) = ',4(Z2,1X),2X,'IREC7 = '
C    2,I4)
                        IF(.NOT.LINCL) THEN
                           WRITE (7,REC=IREC7) CWORKP
                           IREC7 = IREC7 + 1
                        END IF
                     END IF
                  END IF
                  GO TO 16
               END IF
            END IF
         END IF
C
C         OBTAIN THE VALUE FROM THE TABLE OF PARAMETER VARIABLE
C         DEFINITIONS
C
         CALL TABSRH (CPARAM,IP,52,1,32,CVAR,1,32,IRET1,1000)
C
C         DETERMINE IF A MATCH WAS FOUND
C
         IF(IRET1.GT. 0) THEN
C
C         MOVE THE VARIABLE VALUE TO ARGUMENT 2
C
            CIARG2(1:4) = CPARAM(IRET1)(45:48)
C
C         SAVE THE NAME ENTRY FOR THE LISTING
C
            CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET2,4000)
            CWORKP(1:52) = CNAME(IRET2)(1:52)
            JISN = ISN + 128
            IF(.NOT.LINCL) THEN
               IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                  IENAME(12,IRET2) = IBSET(IENAME(12,IRET2),14)
                  CWORKP(45:48) = CNAME(IRET2)(45:48)
                  IWORKP(13) = JLEN
C     IF(CWORKP(1:6) .EQ. 'JRECTB')
C     IF(ISN .EQ. 31)
C    1WRITE(13,923) ISN,CWORKP(1:9),CWORKP(37:40),CWORKP(45:45),
C    2CWORKP(46:46),CWORKP(47:47),CWORKP(48:48),IREC7
C923  FORMAT(' TRACE 923 EVALU  ISN = ',I4,2X,'CWORKP(1:9) = ',A9,2X,
C    1'CWORKP(37:40) = ',A6/5X,'CWORKP(45:48) = ',4(Z2,1X),2X,'IREC7 = '
C    2,I4)
                  WRITE (7,REC=IREC7) CWORKP
                  IREC7 = IREC7 + 1
               END IF
            END IF
         ELSE
C
C         PARAMETER VARIABLE NOT DEFINED, WRITE DIAGNOSTIC
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN,CVAR(1:32)
               IREC0 = IREC0 + 1
            END IF
C
C         WHEN THE VARIABLE HAS NOT BEEN CATALOGED IN THE MASTER NAME
C         TABLE, PLACE THE NAME INTO THE TABLE AND WRITE IT ON UNIT 7
C
            CWORKP(1:32) = CVAR(1:32)
            JISN = ISN + 128
            IWORKP(12) = 0
            IWORKP(13) = JLEN
            IF(.NOT.LINCL) THEN
               IF(CWORKP(1:8) .NE. CBLANK(1:8)) THEN
                  CALL SETTL (CWORKP)
                  IWORKP(12) = IBSET(IWORKP(12),15)
                  CALL TABINS (CNAME,INAME,52,1,32,CWORKP,1,32,IRET4,
     1                         4000)
C     IF(CWORKP(1:6) .EQ. 'JRECTB')
                  WRITE (7,REC=IREC7) CWORKP
                  IREC7 = IREC7 + 1
                  GO TO 15
               END IF
            END IF
C
C         THE PARAMETER VARIABLE IS NOT IN THE TABLE OF PARAMETER
C         VARIABLES WITH DEFINED INTEGER VALUES. DETERMINE IF THE
C         VARIABLE NAME EXISTS IN THE MASTER NAME TABLE.
C
            CALL TABSRH (CNAME,INAME,52,1,32,CVAR,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               IARG2 = 0
               GO TO 15
            END IF
         END IF
         GO TO 15
      END IF
C
C         ARG2 IS NOT A VARIABLE NAME. CHECK FOR A WORK AREA VALUE FOR
C         THE SECOND ARGUMENT
C
      IF(CEXPR(J5:J5) .EQ. '$') THEN
         IF(CEXPR(J5+3:J5+3) .EQ. C0(1:1)) THEN
            IARG2 = IW(10)
         ELSE
            J2WK1 = 0
            CJ2WK1(IDXE:IDXE) = CEXPR(J5+2:J5+2)
            J2WK1 = J2WK1 - 48
            IARG2 = IW(J2WK1)
         END IF
         GO TO 15
      END IF
C
C         DETERMINE IF ARGUMENT 2 IS A NUMBER
C
      IF(CEXPR(J5:J5) .GE. C0(1:1) .AND. CEXPR(J5:J5) .LE.
     1   C9(1:1)) THEN
C
C         CONVERT ASCII NUMBER TO INTEGER
C
         J8 = KB
         KB = J6
         CALL NUMBER (CEXPR,LTRUE,J5,II,FP,IFP)
         KB = J8
         IF(.NOT.LINCL) CALL INSERT (II)
         IARG2 = II
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *        EVALUATE THE RESULTS OF THE ARITHMETIC OPERATION        *
C     *                                                                *
C     ******************************************************************
C
 15   IF(IOPER .EQ. 5) THEN
C
C         EVALUATE EXPONENTIATION
C
         IF(IARG1 .EQ. 0) THEN
            IF(IARG2 .EQ. 0) THEN
               IARG3 = 0
               IF(.NOT.LINCL) THEN
                  WRITE (0,101) ISN,CARG(2)(1:32)
                  IREC0 = IREC0 + 2
               END IF
            ELSE
               IARG3 = 1
            END IF
         ELSE
            IF(IARG2 .EQ. 0) THEN
               IARG3 = 1
            ELSE
               IARG3 = IARG1**IARG2
            END IF
         END IF
      END IF
      IF(IOPER .EQ. 4) THEN
C
C         EVALUATE DIVISION
C
         IF(IARG1 .EQ. 0) THEN
            IF(IARG2 .EQ. 0) THEN
               IARG3 = 0
               IF(.NOT.LINCL) THEN
                  WRITE (0,102) ISN,CARG(2)(1:32)
                  IREC0 = IREC0 + 1
               END IF
            ELSE
               IARG3 = 0
            END IF
         ELSE
            IF(IARG2 .EQ. 0) THEN
               IF(.NOT.LINCL) THEN
                  WRITE (0,102) ISN,CARG(2)(1:32)
                  IREC0 = IREC0 + 1
               END IF
               IARG3 = 0
            ELSE
               IARG3 = IARG1/IARG2
            END IF
         END IF
      END IF
      IF(IOPER .EQ. 3) IARG3 = IARG1*IARG2
      IF(IOPER .EQ. 2) IARG3 = IARG1-IARG2
      IF(IOPER .EQ. 1) IARG3 = IARG1+IARG2
C
C         DELETE THE PORTION OF THE EXPRESSION EVALUATED
C
C     CEXPR(J3:J6) = CBLK52(1:J3-J6+1)
      J1 = J3
      J2 = J6
C
C         EXIT, ARGUMENT 3 CONTAINS THE COMPUTATIONAL RESULT
C
 16   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE WILL CONVERT AN INTEGER VALUE TO ITS CHARACTER
C         FORM AND PLACE IT IN A CHARACTER FIELD OF NO MORE THAN SEVEN
C         CHARACTERS
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CI2WK1 - CHARACTER VARIABLE, WORK AREA USED TO CONVERT DIGITS
C                  EQUIVALENCED TO I2WK1
C         CWORK  - THE CHARACTER FIELD TO RECIEVE THE NUMBER
C         I      - NUMBER OF DIGITS IN THE CHARACTER FIELD TO CONTAIN
C                  THE DIGITS
C         IDTN   - THE VALUE TO CONVERT FROM NUMERIC INTEGER DIGITS TO
C                  CHARACTER DIGITS
C         IJ     - SUBSCRIPT VARIABLE DETERMINING THE LOCATION IN CWORK
C                  WHERE A CHARACTER DIGIT IS TO BE PLACED
C         IPREV  - THE PREVIOUS DIGIT LEFT OF THE CURRENT
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         ISTART - THE START LOCATION TO PLACE THE NUMERIC CHARACTERS
C         ITERM  - THE END LOCATION TO PLACE THE NUMERIC CHARACTERS
C         IWK    - WORK AREA TO ISOLATE A DIGIT OF THE THE VALUE IN
C                  VARIABLE NUM
C         I4WK1  - WORK AREA USED TO CONVERT DIGITS
C         I4WK2  - WORK AREA USED TO HOLD THE REMAINDER OF THE VALUE IN
C                  VARIABLE NUM AS EACH LEFT MOST DIGIT IS CONVERTED
C         I2WK1  - WORK AREA USED TO CONVERT DIGITS
C         JJ     - SUBSCRIPT VARIABLE
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST LEFTMOST
C                  NON-ZERO DIGIT IS FOUND, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         NUM    - THE INTEGER VALUE OF THE NUMBER TO BE CONVERTED TO
C                  CHARACTER FORM
C
C     *****************************************************************
C
      SUBROUTINE ITOC (NUM,CWORK,ISTART,ITERM)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CWORK
      CHARACTER*92  CLITWK
      CHARACTER*8   CBLANK, CWK8
      CHARACTER*7   CWK7
      CHARACTER*2   CI2WK1
      INTEGER*2     ISRECL, I2WK1
      INTEGER*2     ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1              IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      REAL*8        FP
C
C         COMMON STATEMENTS
C
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWK8(2:2),CWK7)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NUMBER GREATER THAN 7 DIGITS')
C
C         BLANK THE CHARACTER FIELD
C
      L = LFALSE
      I = ITERM - ISTART
      IK = 0
      IF(I .GT. 7) I = 7
      CWORK(ISTART:ITERM) = CBLANK(1:I)
C
C         DETERMINE IF THE INTEGER NUMBER EXCEEDS 7 CHARACTER DIGITS.
C
      IF(NUM .GT. 9999999) THEN
         IF(ISN .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
         NUM = 9999999
      END IF
C
C         DETERMINE IF THE VALUE TO BE CONVERTED IS LESS THAN 10
C
      IF(NUM .LT. 10) THEN
C
C         ONLY A SINGLE DIGIT IS TO BE CONVERTED
C
         I2WK1 = NUM + IDTN
         CWORK(ISTART:ISTART) = CI2WK1(1:1)
         GO TO 11
      END IF
C
C         LOOP TO PERFORM THE INTEGER TO CHARACTER CONVERSION
C
      I4WK2 = NUM
      DO 10 JJ = I,1,-1
C
C         DETERMINE THE LEFT MOST DIGIT OF THE NUMBER
C
      IWK = I4WK2/(10**JJ)
      I4WK1 = I4WK2 - IWK*(10**JJ)
C
C         TEST IF THE DIGIT IS A ZERO, AND SKIP OVER LEADING ZEROS
C
      IF(.NOT.L) THEN
         IF(IWK .EQ. 0) THEN
            GO TO 10
         ELSE
            L = LTRUE
         END IF
      END IF
C
C         COMPUTE THE TEXT FORM OF THE DIGIT
C
      I2WK1 = IWK + IDTN
C
C         DETERMINE THE LOCATION WHERE THE DIGIT IS TO BE PLACED IN THE
C         OUTPUT FIELD, AND MOVE IT INTO THAT FIELD, LEFT ADJUSTED.
C
      IJ = ISTART + IK
      CWORK(IJ:IJ) = CI2WK1(1:1)
      IK = IK + 1
C
C         IF THIS IS THE FINAL DIGIT, PLACE IT IN THE OUTPUT FIELD
C
      IF(JJ .EQ. 1) THEN
         I2WK1 = I4WK1 + IDTN
         IJ = ISTART + IK
         CWORK(IJ:IJ) = CI2WK1(1:1)
      END IF
C
C         REMOVE THE LEFT MOST DIGIT OF THE NUMBER BEING CONVERTED
C
        I4WK2 = I4WK1
 10   CONTINUE
 11   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE PERFORMS A BINARY SEARCH OF A SINGLY
C         DIMENSIONED CHARACTER VARIABLE ARRAY. ONLY THE VARIABLE
C         NAME IS USED.
C
C     MEANING OF THE VARIABLES
C
C         CTABLE - CHARACTER VARIABLE, THE ARRAY TO BE SEARCHED; THE
C                  ENTRIES MUST BE IN ASCENDING COLLATING SEQUENCE AND
C                  MAY NOT CONTAIN DUPLICATE ENTRIES.
C         CTEST  - CHARACTER VARIABLE, THE RECORD CONTAINING THE DATA
C                  TO BE SEARCHED FOR IN CTABLE
C         IBOT   - THE LOW STARTING INDEX OF THE RANGE TO BE SEARCHED
C         IBINPT - THE BINARY LOCATION INDEX FOR THE SEARCH; THIS VALUE
C                  IS MIDWAY BETWEEN IBOT AND ITOP.
C         IDLEN  - THE DIMENSION SIZE OF CTABLE IN WORDS. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE CTABLE ARRAY. THE TOTAL
C                  MEMORY IN THE TABLE IS IDLEN X IFLEN
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         IEND2  - LOCATION INDEX WHERE THE FIELD TO BE TESTED ENDS IN
C                  VARIABLE CTEST (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY CTABLE (WORD SIZE, BYTES)
C         INDEX  - INDEX VALUE TO LOCATE COMPARE FIELDS (BYTES)
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE VALUE IN CTEST WAS
C                  FOUND IN CTABLE. WHEN IRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY WAS FOUND.
C                  WHEN IRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE CTEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN IRET .EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC IS WRITTEN ON UNIT 10.
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE CTEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN CTABLE
C         ITOP   - THE HIGH INDEX OF THE RANGE TO BE SEARCHED
C
C     COMMENTS
C
C         A CTABLE ENTRY AND THE CTEST RECORD ARE NOT REQUIRED TO BE OF
C         IDENTICAL LENGTH, BUT THE COMPARE FIELD IN A CTABLE ENTRY AND
C         CTEST RECORD MUST BE OF IDENTICAL LENGTH.
C
C         CTABLE MUST NOT HAVE DUPLICATE ENTRIES AND MUST BE IN
C         ASCENDING COLLATING SEQUENCE.
C
C     ******************************************************************
C
      SUBROUTINE TABSRH (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CTABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CTABLE, CTEST
      INTEGER*2     ISRECL
C     CHARACTER*8   CBLANK, CWK8
C     CHARACTER*92  CLITWK
C     REAL*8        FP
C
C         COMMON STATEMENTS
C
C     COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
C    1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
C    2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' IN TABSRH, LENGTH OF COMPARE FIELDS UNEQUAL')
 101  FORMAT(' IN TABSRH, COMPARE FIELD LENGTH GREATER THAN RECORD LENGT
     1H')
C
C         VERIFY RECORD LENGTH IS GREATER THAN THE COMPARE FIELD LENGTH
C
      IF(IFLEN .LT. IEND1 - ISTRT1) THEN
         IREC0 = IREC0 + 1
         WRITE (0,101)
         GO TO 13
      END IF
C
C         VERIFY THE COMPARE FIELDS ARE OF IDENTICAL LENGTH; WHEN THE
C         LENGTHS ARE UNEQUAL, WRITE A DIAGNOSTIC MESSAGE.
C
      IF((IEND1 - ISTRT1) .NE. (IEND2 - ISTRT2)) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 13
      END IF
C
C         WHEN NO ENTRIES EXIST IN THE TABLE, SET THE INSERTION CODE
C         INDEX VALUE
C
      IF(ITBLKT .GT. 2) THEN
         GO TO 10
      ELSE IF(ITBLKT .EQ. 0) THEN
         IRET = -1
         GO TO 13
C
C         WHEN ONLY A SINGLE ENTRY IS IN THE TABLE, SET THE INSERTION
C         INDEX VALUE
C
      ELSE IF(ITBLKT .EQ. 1) THEN
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(1)(ISTRT1:IEND1)) IRET = 1
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(1)(ISTRT1:IEND1)) IRET = -2
         IF(CTEST(ISTRT2:IEND2) .LT. CTABLE(1)(ISTRT1:IEND1)) IRET = -1
         GO TO 13
C
C         WHEN TWO ENTRIES ARE IN THE TABLE, SET THE INSERTION INDEX
C         VALUE
C
      ELSE IF(ITBLKT .EQ. 2) THEN
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(1)(ISTRT1:IEND1)) IRET = 1
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(2)(ISTRT1:IEND1)) IRET = 2
         IF(CTEST(ISTRT2:IEND2) .LT. CTABLE(1)(ISTRT1:IEND1)) IRET = -1
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(1)(ISTRT1:IEND1) .AND.
     1      CTEST(ISTRT2:IEND2) .LT. CTABLE(2)(ISTRT1:IEND1)) IRET = -2
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(2)(ISTRT1:IEND1)) IRET = -3
         GO TO 13
      END IF
C
C         INITIALIZATION WHEN ITBLKT .GT. 2
C
 10   IBOT = 0
      ITOP = ITBLKT + 1
C
C         DETERMINE THE BINARY SEARCH MIDPOINT LOCATION
C
 11   IBINPT = (IBOT + ITOP)/2
C
C         DETERMINE IF THE BINARY SEARCH LOCATION MATCHES THE LOW START
C         INDEX VALUE.
C
      IF(IBINPT .EQ. IBOT) THEN
         IF(CTABLE(IBOT)(ISTRT1:IEND1) .EQ. CTEST(ISTRT2:IEND2)) THEN
            GO TO 13
         END IF
         IRET = IBINPT + 1
         IF(CTABLE(IRET)(ISTRT1:IEND1) .EQ. CTEST(ISTRT2:IEND2)) THEN
            GO TO 13
         ELSE
            GO TO 12
         END IF
      END IF
C
C         COMPARE THE TEST FIELD AGAINST THE TABLE ENTRY; WHEN THE
C         FIELDS ARE EQUAL, A TABLE MATCH OCCURS
C
      IF(CTABLE(IBINPT)(ISTRT1:IEND1) .EQ. CTEST(ISTRT2:IEND2)) THEN
         IRET = IBINPT
         GO TO 13
      ELSE IF(CTABLE(IBINPT)(ISTRT1:IEND1) .GT. CTEST(ISTRT2:IEND2))
     1   THEN
         ITOP = IBINPT
         GO TO 11
      ELSE IF(CTABLE(IBINPT)(ISTRT1:IEND1) .LT. CTEST(ISTRT2:IEND2))
     1   THEN
         IBOT = IBINPT
         GO TO 11
      END IF
C
C         THE CTEST FIELD IS NOT IN THE TABLE, SET IRET NEGATIVE
C
 12   IRET = -(IBINPT + 1)
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE INSERTS A CTEST RECORD INTO INTO ARRAY CTABLE
C         WHEN NO ENTRY EXISTS IN CTABLE FOR THE COMPARE FIELD. NO
C         INSERTION IS MADE INTO CTABLE IF THE CONDITION FIELD IN CTEST
C         ALREADY EXISTS. THIS ROUTINE DOES NOT USE THE TYPE CODE AND
C         LENGTH CHARACTERISTICS IN THE COMPARE FOR INSERTION INTO THE
C         TABLE.
C
C     MEANING OF THE VARIABLES
C
C         CTABLE - CHARACTER VARIABLE, THE ARRAY TO BE SEARCHED; THE
C                  ENTRIES MUST BE IN ASCENDING COLLATING SEQUENCE AND
C                  MAY NOT CONTAIN DUPLICATE ENTRIES.
C         CTEST  - CHARACTER VARIABLE, THE RECORD CONTAINING THE DATA
C                  TO BE SEARCHED FOR IN CTABLE
C         I      - SUBSCRIPT VARIABLE
C         IDLEN  - THE DIMENSION SIZE OF CTABLE IN WORDS. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE CTABLE ARRAY. EACH WORD HAS
C                  A LENGTH OF IFLEN.
C         IEND   - BEGINNING LOCATION FOR A SHIFTED ENTRY IN CTABLE
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY CTABLE (BYTES)
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE FIELD IN CTEST ALREADY
C                  EXISTS IN CTABLE WHEN IRET .EQ. 0; WHEN IRET .GT. 0,
C                  THE VALUE IS THE INDEX WHERE THE CTEST RECORD WAS
C                  INSERTED INTO CTABLE.
C         ISTART - BEGINNING MOVE LOCATION IN CTABLE FOR TABLE ENTRY
C                  SHIFT
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE CTEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN CTABLE
C         J      - THE VALUE OF I + 1
C         JRET   - RETURN CODE TO INDICATE IF THE VALUE IN CTEST WAS
C                  FOUND IN CTABLE. WHEN JRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY WAS FOUND.
C                  WHEN JRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE CTEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN JRET.EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC WAS WRITTEN ON UNIT 0.
C
C     COMMENTS
C
C         THE FIELD IN CTEST DEFINED BY THE VALUES OF CSTRT2 - CEND2 IS
C         USED TO SEARCH CTABLE FOR A MATCH. WHEN A MATCH IS FOUND, IRET
C         IS SET TO 0 AND RETURNS TO THE CALLING ROUTINE. WHEN NO MATCH
C         IS FOUND, THE CTEST FIELD IS INSERTED IN THE CORRECT COLLATING
C         SEQUENCE BY EITHER MOVING THE PART AFTER THE TABLE LOCATION OF
C         INSERTION, OR BY INSERTING THE FIELD AT THE TABLE'S END.
C
C         THE RECORD LENGTH OF CTEST MUST EQUAL THE ENTRY LENGTH OF
C         CTABLE.
C
C     ******************************************************************
C
      SUBROUTINE TABINS (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CTABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CTABLE, CTEST
      INTEGER*2     ISRECL
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' TABLE FULL: TABINS')
C
C         INITIALIZATION
C
      JRET = 0
C
C         DETERMINE LOCATION IN CTABLE WHERE CTEST IS TO BE INSERTED
C
      CALL TABSRH (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,IEND2,
     1            JRET,IDLEN)
C
C         DETERMINE IF THE CTEST RECORD ALREADY EXISTS IN CTABLE. NO
C         ENTRY IS MADE INTO CTABLE IN THIS CASE.
C
      IF(JRET .GT. 0) THEN
         IRET = JRET
         GO TO 12
      END IF
C
C         JRET IS NEGATIVE; DETERMINE IF THE CTEST RECORD IS TO BE
C         PLACED AT THE END OF THE TABLE.
C
      JRET = -JRET
      IF(JRET .EQ. ITBLKT + 1) THEN
         CTABLE(JRET)(1:IFLEN) = CTEST(1:IFLEN)
         GO TO 11
      END IF
C
C         DETERMINE IF PART OF THE CTABLE ENTRIES ARE TO BE SHIFTED TO
C         MAKE SPACE FOR THE NEW TABLE ENTRY
C
      IF(ITBLKT .EQ. 0) THEN
         CTABLE(1)(1:IFLEN) = CTEST(1:IFLEN)
         GO TO 11
      END IF
C
C         LOOP TO MOVE ALL TABLE ENTRIES AFTER JRET ARE TO MAKE SPACE
C         FOR A NEW TABLE ENTRY. THE ENTRIES ARE SHIFTED TOWARDS THE
C         BOTTOM OF CTABLE.
C
      DO 10 I = ITBLKT,JRET,-1
      J = I + 1
C
C         DETERMINE IF THE TABLE IS FULL AND WRITE ERROR MESSAGE
C
      IF(J .GT. IDLEN) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 12
      END IF
C
C         SHIFT THE CTABLE ENTRIES AFTER THE INSERTION LOCATION TO MAKE
C         SPACE FOR THE NEW INSERTION IN CTABLE. THE SHIFT IS DONE IN
C         REVERSE ORDER.
C
      CTABLE(J)(1:IFLEN) = CTABLE(I)(1:IFLEN)
10    CONTINUE
C
C         INSERT THE NEW ENTRY FROM CTEST INTO CTABLE
C
      CTABLE(JRET)(1:IFLEN) = CTEST(1:IFLEN)
C
C         AUGMENT THE TOTAL ENTRY COUNT IN CTABLE BY ONE AND SET IRET
C
 11   ITBLKT = ITBLKT + 1
      IRET = JRET
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE PERFORMS A BINARY SEARCH OF A SINGLY
C         DIMENSIONED CHARACTER VARIABLE ARRAY USING THE VARIABLE
C         NAME IN ARRAY CNAME AND ITS DEFINED LENGTH CHARACTERISTIC.
C         THE FIELDS ARE IN COLS 1 - 32 FOR THE VARIABLE NAME AND IN
C         COLS 38 - 44 FOR THE LENGTH DEFINITION.
C
C     MEANING OF THE VARIABLES
C
C         CTABLE - CHARACTER VARIABLE, THE ARRAY TO BE SEARCHED; THE
C                  ENTRIES MUST BE IN ASCENDING COLLATING SEQUENCE AND
C                  MAY NOT CONTAIN DUPLICATE ENTRIES.
C         CTEST  - CHARACTER VARIABLE, THE RECORD CONTAINING THE DATA
C                  TO BE SEARCHED FOR IN CTABLE
C         IBOT   - THE LOW STARTING INDEX OF THE RANGE TO BE SEARCHED
C         IBINPT - THE BINARY LOCATION INDEX FOR THE SEARCH; THIS VALUE
C                  IS MIDWAY BETWEEN IBOT AND ITOP.
C         IDLEN  - THE DIMENSION SIZE OF CTABLE IN WORDS. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE CTABLE ARRAY.
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY CTABLE (BYTES)
C         INDEX  - INDEX VALUE TO LOCATE COMPARE FIELDS (BYTES)
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE VALUE IN CTEST WAS
C                  FOUND IN CTABLE. WHEN IRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY EXISTS.
C                  WHEN IRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE CTEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN IRET.EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC IS WRITTEN ON UNIT 10.
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE CTEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN CTABLE
C         ITOP   - THE HIGH INDEX OF THE RANGE TO BE SEARCHED
C
C     COMMENTS
C
C         A CTABLE ENTRY AND THE CTEST RECORD ARE NOT REQUIRED TO BE OF
C         IDENTICAL LENGTH, BUT THE COMPARE FIELD IN A CTABLE ENTRY AND
C         CTEST RECORD MUST BE OF IDENTICAL LENGTH.
C
C     SUBPROGRAMS
C
C
C
C     ******************************************************************
C
      SUBROUTINE TBLSRH (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CTABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CTABLE, CTEST
      INTEGER*2     ISRECL
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' IN TBLSRH, LENGTH OF COMPARE FIELDS UNEQUAL')
 101  FORMAT(' IN TBLSRH, COMPARE FIELD LENGTH GREATER THAN RECORD LENGT
     1H')
C
C         VERIFY RECORD LENGTH IS GREATER THAN THE COMPARE FIELD LENGTH
C
      IF(IFLEN .LT. IEND1 - ISTRT1) THEN
         IREC0 = IREC0 + 1
         WRITE (0,101)
         GO TO 13
      END IF
C
C         VERIFY THE COMPARE FIELDS ARE OF IDENTICAL LENGTH; WHEN THE
C         LENGTHS ARE UNEQUAL, WRITE A DIAGNOSTIC MESSAGE.
C
      IF((IEND1 - ISTRT1) .NE. (IEND2 - ISTRT2)) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 13
      END IF
C
C         WHEN NO ENTRIES EXIST IN THE TABLE, SET THE INSERTION CODE
C         INDEX VALUE
C
      IF(ITBLKT .GT. 2) THEN
         GO TO 10
      ELSE IF(ITBLKT .EQ. 0) THEN
         IRET = -1
         GO TO 13
C
C         WHEN ONLY A SINGLE ENTRY IS IN THE TABLE, SET THE INSERTION
C         INDEX VALUE
C
      ELSE IF(ITBLKT .EQ. 1) THEN
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(1)(ISTRT1:IEND1)) THEN
            IF(CTABLE(1)(37:44) .EQ. CTEST(37:44)) THEN
               IRET = 1
            ELSE IF(CTABLE(1)(37:44) .LT. CTEST(37:44)) THEN
               IRET = -1
            ELSE IF(CTABLE(1)(37:44) .GT. CTEST(37:44)) THEN
               IRET = -2
            END IF
         END IF
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(1)(ISTRT1:IEND1)) IRET = -2
         IF(CTEST(ISTRT2:IEND2) .LT. CTABLE(1)(ISTRT1:IEND1)) IRET = -1
         GO TO 13
C
C         WHEN TWO ENTRIES ARE IN THE TABLE, SET THE INSERTION INDEX
C         VALUE
C
      ELSE IF(ITBLKT .EQ. 2) THEN
C
C         WHEN THE TEST VARIABLE NAME #1 AND THE TABLE VARIABLE NAME ARE
C         EQUAL, DETERMINE IF THE LENGTH CHARACTERISTICS MATCH
C
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(1)(ISTRT1:IEND1)) THEN
            IF(CTABLE(1)(37:44) .EQ. CTEST(37:44)) THEN
               IRET = 1
            ELSE IF(CTABLE(1)(37:44) .LT. CTEST(37:44)) THEN
               IRET = -1
            ELSE IF(CTABLE(1)(37:44) .GT. CTEST(37:44)) THEN
               IRET = -2
            END IF
         END IF
C
C         WHEN THE TEST VARIABLE NAME #2 AND THE TABLE VARIABLE NAME ARE
C         EQUAL, DETERMINE IF THE LENGTH CHARACTERISTICS MATCH
C
         IF(CTEST(ISTRT2:IEND2) .EQ. CTABLE(2)(ISTRT1:IEND1)) THEN
            IF(CTABLE(2)(37:44) .EQ. CTEST(37:44)) THEN
               IRET = 2
            ELSE IF(CTABLE(2)(37:44) .LT. CTEST(37:44)) THEN
               IRET = -2
            ELSE IF(CTABLE(2)(37:44) .GT. CTEST(37:44)) THEN
               IRET = -3
            END IF
         END IF
C
C         WHEN THE TEST VARIABLE NAME IS LESS THAN THE TABLE VARIABLE #1
C         NAME SET THE RETURN CODE
C
         IF(CTEST(ISTRT2:IEND2) .LT. CTABLE(1)(ISTRT1:IEND1)) IRET = -1
C
C         WHEN THE TEST VARIABLE NAME IS GREATER THAN THE TABLE VARIABLE
C         NAME #1 AND LESS THAN THE TABLE VARIABLE NAME #2, SET THE
C         RETURN CODE
C
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(1)(ISTRT1:IEND1) .AND.
     1      CTEST(ISTRT2:IEND2) .LT. CTABLE(2)(ISTRT1:IEND1)) IRET = -2
C
C         WHEN THE TEST VARIABLE NAME IS GREATER THAN THE TABLE VARIABLE
C         #2 NAME, SET THE RETURN CODE
C
         IF(CTEST(ISTRT2:IEND2) .GT. CTABLE(2)(ISTRT1:IEND1)) IRET = -3
         GO TO 13
      END IF
C
C         INITIALIZATION WHEN ITBLKT .GT. 2
C
 10   IBOT = 0
      ITOP = ITBLKT + 1
C
C         DETERMINE THE BINARY SEARCH MIDPOINT LOCATION
C
 11   IBINPT = (IBOT + ITOP)/2
C
C         DETERMINE IF THE BINARY SEARCH LOCATION MATCHES THE LOW START
C         INDEX VALUE.
C
      IF(IBINPT .EQ. IBOT) THEN
         IRET = IBINPT + 1
C
C         DETERMINE IF TEST AND TABLE VARIABLE NAMES ARE EQUAL
C
         IF(CTABLE(IRET)(ISTRT1:IEND1) .EQ. CTEST(ISTRT2:IEND2)) THEN
C
C         DETERMINE IF TEST AND TABLE TYPE AND LENGTHS ARE EQUAL
C
            IF(CTABLE(IRET)(37:44) .EQ. CTEST(37:44)) THEN
               GO TO 13
            ELSE
               IF(CTABLE(IRET+1)(37:44) .EQ. CTEST(37:44) .AND.
     1            CTABLE(IRET+1)(1:32) .EQ. CTEST(1:31)) THEN
                  IRET = IRET + 1
                  GO TO 13
               ELSE
                  IRET = -IRET
                  GO TO 12
               END IF
            END IF
         ELSE
            GO TO 12
         END IF
      END IF
C
C         COMPARE THE TEST FIELD AGAINST THE TABLE ENTRY; WHEN THE
C         FIELDS ARE EQUAL, A TABLE MATCH OCCURS
C
      IF(CTABLE(IBINPT)(ISTRT1:IEND1) .EQ. CTEST(ISTRT2:IEND2)) THEN
         IF(CTABLE(IBINPT)(37:44) .EQ. CTEST(37:44)) THEN
            IRET = IBINPT
            GO TO 13
         ELSE IF(CTABLE(IBINPT)(37:44) .GT. CTEST(37:44)) THEN
            ITOP = IBINPT
            GO TO 11
         ELSE IF(CTABLE(IBINPT)(37:44) .LT. CTEST(37:44)) THEN
            IBOT = IBINPT
            GO TO 11
         END IF
      ELSE IF(CTABLE(IBINPT)(ISTRT1:IEND1) .GT. CTEST(ISTRT2:IEND2))
     1   THEN
         ITOP = IBINPT
         GO TO 11
      ELSE IF(CTABLE(IBINPT)(ISTRT1:IEND1) .LT. CTEST(ISTRT2:IEND2))
     1   THEN
         IBOT = IBINPT
         GO TO 11
      END IF
C
C         THE CTEST FIELD IS NOT IN THE TABLE, SET IRET NEGATIVE
C
 12   IRET = -(IBINPT + 1)
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE INSERTS A CTEST RECORD INTO INTO ARRAY CTABLE
C         WHEN NO ENTRY EXISTS IN CTABLE FOR THE COMPARE FIELDS. NO
C         INSERTION IS MADE INTO CTABLE IF THE CONDITION FIELDS IN CTEST
C         EXIST. THIS ROUTINE DIFFERS FROM TABINS IN THAT THE VARIABLE
C         TO BE INSERTED MUST HAVE THE SAME TYPE AND LENGTH CODE BEFORE
C         TABLE INSERTION. THIS IS NECESSARY FOR STRUCTURE VARIABLES,
C         WHICH CAN HAVE IDENTICAL VARIABLE NAMES WITH NON-STRUCTURE
C         NAMES, BUT HAVE DIFFERENT LENGTH AND TYPE DEFINITIONS.
C
C     MEANING OF THE VARIABLES
C
C         CTABLE - CHARACTER VARIABLE, THE ARRAY TO BE SEARCHED; THE
C                  ENTRIES MUST BE IN ASCENDING COLLATING SEQUENCE AND
C                  MAY NOT CONTAIN DUPLICATE ENTRIES.
C         CTEST  - CHARACTER VARIABLE, THE RECORD CONTAINING THE DATA
C                  TO BE SEARCHED FOR IN CTABLE
C         I      - SUBSCRIPT VARIABLE
C         IDLEN  - THE DIMENSION SIZE OF CTABLE IN BYTES. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE CTABLE ARRAY.
C         IEND   - BEGINNING LOCATION FOR A SHIFTED ENTRY IN CTABLE
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY CTABLE (BYTES)
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE FIELD IN CTEST ALREADY
C                  EXISTS IN CTABLE WHEN IRET .EQ. 0; WHEN IRET .GT. 0,
C                  THE VALUE IS THE INDEX WHERE THE CTEST RECORD WAS
C                  INSERTED INTO CTABLE.
C         ISTART - BEGINNING MOVE LOCATION IN CTABLE FOR TABLE ENTRY
C                  SHIFT
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE CTABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE CTEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN CTABLE
C         J      - THE VALUE OF I + 1
C         JRET   - RETURN CODE TO INDICATE IF THE VALUE IN CTEST WAS
C                  FOUND IN CTABLE. WHEN JRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY WAS FOUND.
C                  WHEN JRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE CTEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN JRET.EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC WAS WRITTEN ON UNIT 10.
C
C     COMMENTS
C
C         THE FIELDS IN CTEST DEFINED BY THE VALUES OF CSTRT2 - CEND2
C         AND IN COLS 38:44 ARE USED TO SEARCH CTABLE FOR A MATCH. WHEN
C         A MATCH IS FOUND, IRET IS SET TO 0 AND RETURNS TO THE CALLING
C         ROUTINE. WHEN NO MATCH IS FOUND, THE CTEST FIELD IS INSERTED
C         IN THE CORRECT COLLATING SEQUENCE BY EITHER MOVING THE TABLE'S
C         PART AFTER THE TABLE INSERTION LOCATION, OR BY INSERTING
C         THE FIELD AT THE TABLE'S END.
C
C         THE RECORD LENGTH OF CTEST MUST EQUAL THE ENTRY LENGTH OF
C         CTABLE.
C
C     ******************************************************************
C
      SUBROUTINE TBLINS (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CTABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CTABLE, CTEST
      INTEGER*2     ISRECL
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' TABLE FULL: TBLINS')
C
C         INITIALIZATION
C
      JRET = 0
C
C         DETERMINE LOCATION IN CTABLE WHERE CTEST IS TO BE INSERTED
C
      CALL TBLSRH (CTABLE,ITBLKT,IFLEN,ISTRT1,IEND1,CTEST,ISTRT2,IEND2,
     1            JRET,IDLEN)
C
C         DETERMINE IF THE CTEST RECORD ALREADY EXISTS IN CTABLE. NO
C         ENTRY IS MADE INTO CTABLE IN THIS CASE.
C
      IF(JRET .GT. 0) THEN
         IRET = JRET
         GO TO 12
      END IF
C
C         JRET IS NEGATIVE; DETERMINE IF THE CTEST RECORD IS TO BE
C         PLACED AT THE END OF THE TABLE.
C
      JRET = -JRET
      IF(JRET .EQ. ITBLKT + 1) THEN
         CTABLE(JRET)(1:IFLEN) = CTEST(1:IFLEN)
         GO TO 11
      END IF
C
C         DETERMINE IF PART OF THE CTABLE ENTRIES ARE TO BE SHIFTED TO
C         MAKE SPACE FOR THE NEW TABLE ENTRY
C
      IF(ITBLKT .EQ. 0) THEN
         CTABLE(1)(1:IFLEN) = CTEST(1:IFLEN)
         GO TO 11
      END IF
C
C         LOOP TO MOVE ALL TABLE ENTRIES AFTER JRET ARE TO MAKE SPACE
C         FOR A NEW TABLE ENTRY. THE ENTRIES ARE SHIFTED TOWARDS THE
C         BOTTOM OF CTABLE.
C
      DO 10 I = ITBLKT,JRET,-1
      J = I + 1
C
C         DETERMINE IF THE TABLE IS FULL AND WRITE ERROR MESSAGE
C
      IF(J .GT. IDLEN) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 12
      END IF
C
C         SHIFT THE CTABLE ENTRIES AFTER THE INSERTION LOCATION TO MAKE
C         SPACE FOR THE NEW INSERTION IN CTABLE. THE SHIFT IS DONE IN
C         REVERSE ORDER.
C
      CTABLE(J)(1:IFLEN) = CTABLE(I)(1:IFLEN)
10    CONTINUE
C
C         INSERT THE NEW ENTRY FROM CTEST INTO CTABLE
C
      CTABLE(JRET)(1:IFLEN) = CTEST(1:IFLEN)
C
C         AUGMENT THE TOTAL ENTRY COUNT IN CTABLE BY ONE AND SET IRET
C
 11   ITBLKT = ITBLKT + 1
      IRET = JRET
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE PERFORMS A BINARY SEARCH OF A SINGLY
C         DIMENSIONED INTEGER VARIABLE ARRAY
C
C     MEANING OF THE VARIABLES
C
C         ITABLE - CHARACTER VARIABLE, THE ARRAY TO BE SEARCHED; THE
C                  ENTRIES MUST BE IN ASCENDING INTEGER ORDER AND
C                  MAY NOT CONTAIN DUPLICATE ENTRIES.
C         ITEST  - CHARACTER VARIABLE, THE RECORD CONTAINING THE DATA
C                  TO BE SEARCHED FOR IN ITABLE
C         IBOT   - THE LOW STARTING INDEX OF THE RANGE TO BE SEARCHED
C         IBINPT - THE BINARY LOCATION INDEX FOR THE SEARCH; THIS VALUE
C                  IS MIDWAY BETWEEN IBOT AND ITOP.
C         IDLEN  - THE DIMENSION SIZE OF ITABLE IN WORDS. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE ITABLE ARRAY. THE TOTAL
C                  MEMORY IN THE TABLE IS IDLEN X IFLEN
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE ITABLE (BYTES)
C         IEND2  - LOCATION INDEX WHERE THE FIELD TO BE TESTED ENDS IN
C                  VARIABLE ITEST (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY ITABLE (BYTES)
C         INDEX  - INDEX VALUE TO LOCATE COMPARE FIELDS (BYTES)
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE VALUE IN ITEST WAS
C                  FOUND IN ITABLE. WHEN IRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY WAS FOUND.
C                  WHEN IRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE ITEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN IRET .EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC IS WRITTEN ON UNIT 10.
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE ITABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE ITEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN ITABLE
C         ITOP   - THE HIGH INDEX OF THE RANGE TO BE SEARCHED
C
C     COMMENTS
C
C         ITABLE MUST NOT HAVE DUPLICATE ENTRIES AND MUST BE IN
C         ASCENDING NUMERICAL ORDER.
C
C     ******************************************************************
C
      SUBROUTINE ITABSR (ITABLE,ITBLKT,IFLEN,ISTRT1,IEND1,ITEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ITABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      INTEGER*2 ISRECL
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' IN ITABSR, LENGTH OF COMPARE FIELDS UNEQUAL')
 101  FORMAT(' IN ITABSR, COMPARE FIELD LENGTH GREATER THAN RECORD LENGT
     1H')
C
C         VERIFY RECORD LENGTH IS GREATER THAN THE COMPARE FIELD LENGTH
C
      IF(IFLEN .LT. IEND1 - ISTRT1) THEN
         IREC0 = IREC0 + 1
         WRITE (0,101)
         GO TO 13
      END IF
C
C         VERIFY THE COMPARE FIELDS ARE OF IDENTICAL LENGTH; WHEN THE
C         LENGTHS ARE UNEQUAL, WRITE A DIAGNOSTIC MESSAGE.
C
      IF((IEND1 - ISTRT1) .NE. (IEND2 - ISTRT2)) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 13
      END IF
C
C         WHEN NO ENTRIES EXIST IN THE TABLE, SET THE INSERTION CODE
C         INDEX VALUE
C
      IF(ITBLKT .GT. 2) THEN
         GO TO 10
      ELSE IF(ITBLKT .EQ. 0) THEN
         IRET = -1
         GO TO 13
C
C         WHEN ONLY A SINGLE ENTRY IS IN THE TABLE, SET THE INSERTION
C         INDEX VALUE
C
      ELSE IF(ITBLKT .EQ. 1) THEN
         IF(ITEST .EQ. ITABLE(1)) IRET = 1
         IF(ITEST .GT. ITABLE(1)) IRET = -2
         IF(ITEST .LT. ITABLE(1)) IRET = -1
         GO TO 13
C
C         WHEN TWO ENTRIES ARE IN THE TABLE, SET THE INSERTION INDEX
C         VALUE
C
      ELSE IF(ITBLKT .EQ. 2) THEN
         IF(ITEST .EQ. ITABLE(1)) IRET = 1
         IF(ITEST .EQ. ITABLE(2)) IRET = 2
         IF(ITEST .LT. ITABLE(1)) IRET = -1
         IF(ITEST .GT. ITABLE(1) .AND. ITEST .LT. ITABLE(2)) IRET = -2
         IF(ITEST .GT. ITABLE(2)) IRET = -3
         GO TO 13
      END IF
C
C         INITIALIZATION WHEN ITBLKT .GT. 2
C
 10   IBOT = 0
      ITOP = ITBLKT + 1
C
C         DETERMINE THE BINARY SEARCH MIDPOINT LOCATION
C
 11   IBINPT = (IBOT + ITOP)/2
C
C         DETERMINE IF THE BINARY SEARCH LOCATION MATCHES THE LOW START
C         INDEX VALUE.
C
      IF(IBINPT .EQ. IBOT) THEN
         IF(ITABLE(IBOT) .EQ. ITEST) THEN
            GO TO 13
         END IF
         IRET = IBINPT + 1
         IF(ITABLE(IRET) .EQ. ITEST) THEN
            GO TO 13
         ELSE
            GO TO 12
         END IF
      END IF
C
C         COMPARE THE TEST FIELD AGAINST THE TABLE ENTRY; WHEN THE
C         FIELDS ARE EQUAL, A TABLE MATCH OCCURS
C
      IF(ITABLE(IBINPT) .EQ. ITEST) THEN
         IRET = IBINPT
         GO TO 13
      ELSE IF(ITABLE(IBINPT) .GT. ITEST)
     1   THEN
         ITOP = IBINPT
         GO TO 11
      ELSE IF(ITABLE(IBINPT) .LT. ITEST) THEN
         IBOT = IBINPT
         GO TO 11
      END IF
C
C         THE ITEST FIELD IS NOT IN THE TABLE, SET IRET NEGATIVE
C
 12   IRET = -(IBINPT + 1)
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE INSERTS AN ITEST RECORD INTO INTO ARRAY ITABLE
C         WHEN NO ENTRY EXISTS IN ITABLE FOR THE COMPARE FIELD. NO
C         INSERTION IS MADE INTO ITABLE IF THE CONDITION FIELD IN ITEST
C         ALREADY EXISTS.
C
C     MEANING OF THE VARIABLES
C
C         ITABLE - THE ARRAY TO BE SEARCHED; THE ENTRIES MUST BE IN
C                  ASCENDING NUMERICAL ORDER AND MAY NOT CONTAIN
C                  DUPLICATE ENTRIES.
C         ITEST  - THE RECORD CONTAINING THE DATA TO BE SEARCHED FOR IN
C                  ITABLE
C         IDLEN  - THE DIMENSION SIZE OF ITABLE IN WORDS. THIS IS THE
C                  MAXIMUM WORD SIZE OF THE ITABLE ARRAY. EACH WORD HAS
C                  A LENGTH OF IFLEN.
C         IEND   - BEGINNING LOCATION FOR A SHIFTED ENTRY IN ITABLE
C         IEND1  - LOCATION INDEX WHERE THE FIELD TO BE COMPARED ENDS
C                  IN AN ENTRY IN VARIABLE ITABLE (BYTES)
C         IFLEN  - LENGTH OF AN ENTRY IN ARRAY ITABLE (BYTES)
C         INDEXS - SUBSCRIPT VARIABLE
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - RETURN CODE TO INDICATE IF THE FIELD IN ITEST ALREADY
C                  EXISTS IN ITABLE WHEN IRET .EQ. 0; WHEN IRET .GT. 0,
C                  THE VALUE IS THE INDEX WHERE THE ITEST RECORD WAS
C                  INSERTED INTO ITABLE.
C         ISTART - BEGINNING MOVE LOCATION IN ITABLE FOR TABLE ENTRY
C                  SHIFT
C         ISTRT1 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN AN ENTRY IN VARIABLE ITABLE (BYTES)
C         ISTRT2 - LOCATION INDEX WHERE THE FIELD TO BE COMPARED BEGINS
C                  IN THE ITEST RECORD (BYTES)
C         ITBLKT - COUNT OF THE NUMBER OF ENTRIES CURRENTLY IN ITABLE
C         J      - THE VALUE OF I + 1
C         JRET   - RETURN CODE TO INDICATE IF THE VALUE IN ITEST WAS
C                  FOUND IN ITABLE. WHEN JRET .GT. 0, A MATCH WAS FOUND,
C                  AND THE VALUE IS THE INDEX WHERE THE MATCHING TABLE
C                  ENTRY WAS FOUND.
C                  WHEN JRET .LT. 0, NO MATCH WAS FOUND, AND THE VALUE
C                  IS THE NEGATIVE VALUE OF THE INDEX WHERE THE ITEST
C                  RECORD MAY BE INSERTED INTO THE TABLE.
C                  WHEN JRET.EQ. 0, AN ERROR HAS OCCURRED, AND A
C                  DIAGNOSTIC WAS WRITTEN ON UNIT 10.
C
C     COMMENTS
C
C         THE FIELD IN ITEST DEFINED BY THE VALUES OF ISTRT2 - IEND2 IS
C         USED TO SEARCH ITABLE FOR A MATCH. WHEN A MATCH IS FOUND, IRET
C         IS SET TO 0 AND RETURNS TO THE CALLING ROUTINE. WHEN NO MATCH
C         IS FOUND, THE ITEST FIELD IS INSERTED IN THE CORRECT NUMERICAL
C         ORDER BY EITHER MOVING THE PART AFTER THE TABLE LOCATION OF
C         INSERTION, OR BY INSERTING THE FIELD AT THE TABLE'S END.
C
C         THE RECORD LENGTH OF ITEST MUST EQUAL THE ENTRY LENGTH OF
C         ITABLE.
C
C     ******************************************************************
C
      SUBROUTINE ITABIN (ITABLE,ITBLKT,IFLEN,ISTRT1,IEND1,ITEST,ISTRT2,
     1IEND2,IRET,IDLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ITABLE(IDLEN)
      DIMENSION ISRECL(20)
C
C         TYPE STATEMENTS
C
      INTEGER*2 ISRECL
C
C         COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' TABLE FULL: ITABIN')
C
C         INITIALIZATION
C
      JRET = 0
C
C         DETERMINE LOCATION IN ITABLE WHERE ITEST IS TO BE INSERTED
C
      CALL ITABSR (ITABLE,ITBLKT,IFLEN,ISTRT1,IEND1,ITEST,ISTRT2,IEND2,
     1            JRET,IDLEN)
C
C         DETERMINE IF THE ITEST RECORD ALREADY EXISTS IN ITABLE. NO
C         ENTRY IS MADE INTO ITABLE IN THIS CASE.
C
      IF(JRET .GT. 0) THEN
         IRET = JRET
         GO TO 12
      END IF
C
C         JRET IS NEGATIVE; DETERMINE IF THE ITEST RECORD IS TO BE
C         PLACED AT THE END OF THE TABLE.
C
      JRET = -JRET
      IF(JRET .EQ. ITBLKT + 1) THEN
         ITABLE(JRET) = ITEST
         GO TO 11
      END IF
C
C         DETERMINE IF PART OF THE ITABLE ENTRIES ARE TO BE SHIFTED TO
C         MAKE SPACE FOR THE NEW TABLE ENTRY
C
      IF(ITBLKT .EQ. 0) THEN
         ITABLE(1) = ITEST
         GO TO 11
      END IF
C
C         LOOP TO MOVE ALL TABLE ENTRIES AFTER JRET ARE TO MAKE SPACE
C         FOR A NEW TABLE ENTRY. THE ENTRIES ARE SHIFTED TOWARDS THE
C         BOTTOM OF ITABLE.
C
      DO 10 INDEXS = ITBLKT,JRET,-1
      J = INDEXS+ 1
C
C         DETERMINE IF THE TABLE IS FULL AND WRITE ERROR MESSAGE
C
      IF(J .GT. IDLEN) THEN
         WRITE (0,100)
         IREC0 = IREC0 + 1
         IRET = 0
         GO TO 12
      END IF
C
C         SHIFT THE ITABLE ENTRIES AFTER THE INSERTION LOCATION TO MAKE
C         SPACE FOR THE NEW INSERTION IN ITABLE. THE SHIFT IS DONE IN
C         REVERSE ORDER.
C
      ITABLE(J) = ITABLE(INDEXS)
10    CONTINUE
C
C         INSERT THE NEW ENTRY FROM ITEST INTO ITABLE
C
      ITABLE(JRET) = ITEST

C         AUGMENT THE TOTAL ENTRY COUNT IN ITABLE BY ONE AND SET IRET
C
 11   ITBLKT = ITBLKT + 1
      IRET = JRET
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM WILL ANALYZE THE ACCEPT STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDOT   - CHARACTER VARIABLE, A PERIOD OR DECIMAL POINT
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CI2WK1 - WORK AREA, EQUIVALENCED TO I2WK1
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM. EACH NAME MAY BE 32 CHARAC-
C                  TERS; PLUS: 1. 4 CHARACTERS FOR THE ISN VALUE, 2.
C                  8 CHARACTERS FOR TYPE AND LENGTH CODE,
C                  3. 1 CHARACTER TO INDICATE THE VARIABLE IS A COMMON
C                  VARIABLE, 4. 1 CHARACTER TO INDICATE THE VARIABLE IS
C                  A SUBPROGRAM ARGUMENT, 5. 1 CHARACTER TO INDICATE
C                  THE VARIABLE IS USED IN A EQUIVALENCE STATEMENT.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                  COLS.        DESCRIPTION
C                  1  - 32 C*32 VARIABLE NAME
C                  33 - 36 I*4  ISN VALUE
C                  37 - 44 C*8  DATA TYPE & LENGTH
C                  45 - 48 I*4  BIT SWITCHES
C                  49 - 52 I*4  LENGTH OF THE VARIBALE NAME IN COLS 1-32
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUSCRIPT VARIABLE
C         ID     - COUNT OF LEFT AND RIGHT PARENTHESES IN THE STATEMENT.
C                  IF AN EQUAL SIGN OCCURS AND IS NOT ENCAPSULATED IN
C                  MATCHED LEFT AND RIGHT PARENTHESES, THE STATEMENT
C                  IS NOT AN ACCEPT STATEMENT.
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I2WK1  - WORK AREA
C         I4WK1  - WORK AREA
C         J      - THE CURRENT CHARACTER LOCATION IN THE FORTRAN STATE-
C                  MENT
C         JA     - WORK AREA
C         JB     - WORK AREA
C         JC     - WORK AREA
C         JD     - WORK AREA
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         KB     - THE LOCATION OF THE LAST CHARACTER IN THE FORTRAN
C                  STATEMENT BEING ANALYZED
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C         MNUM   - COUNTER CONTAINS THE SUBSCRIPT VALUE OF THE NEXT
C                  ENTRY INTO TABLES ISNUM AND ISNUMD, THE STATMENT
C                  NUMBER AND ITS DEFINITION ISN
C
C     COMMENT
C
C         ACCEPT OCCURS IN THREE FORMS:
C
C         ACCEPT fmt,iolist
C         ACCEPT *,iolist
C         ACCEPT namelist
C
C        THE FORMAT ARGUMENT (fmt) AND THE IOLIST ARGUMENTS (iolist) MAY
C        BE COMPOUND VARIABLES.  namelist CAN NOT BE A COMPOUND VARIABLE.
C        THE ACCEPT STATEMENT DOES NOT HAVE CONTROL LIST PARAMETERS AS
C        DO READ AND WRITE STATEMENTS.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF INTERNAL STATEMENT NUMBERS REFERENCED
C                  BY OTHER STATEMENTS IN THE PROGRAM
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR INSERT NUMBER PIOLST
C
C     *****************************************************************
C
      SUBROUTINE STMT01
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         SAVE STATEMENT
C
      SAVE
C
C         EQUIVALENCE STATEMENT
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7)
C
C         TEST IF THIS IS THE ACCEPT STATEMENT
C
      J = KF + 5
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'ACCEPT') THEN
         J = J + 1
      ELSE
         GO TO 16
      END IF
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT
C
      ID = 0
      LEXEC = LTRUE
      DO 10 I = J,KB
      IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
      IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         IF(ID .EQ. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 16
         END IF
      END IF
 10   CONTINUE
C
C         DETERMINE IF THE FORMAT SPECIFICATION IS AN ASTERISK
C
      IF(CSTMT(J:J) .EQ. CASTER) THEN
         J = J + 2
         GO TO 13
      END IF
C
C         DETERMINE IF A NAMELIST OR FORMAT VARIABLE NAME
C
C         OCCURRENCE OF A PERIOD IMPLIES A STRUCTURE COMPOUND VARIABLE
C         NAME AND CAN NOT INDICATE A LOGICAL OPERATOR OR CONSTANT
C
      IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1   CSTMT(J:J) .EQ. CUNDER) THEN
         JB = J + 1
         JD = JB
         DO 11 I = JB,KB
         IF(.NOT.(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ) .AND.
     1      .NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9)
     2      .AND. .NOT.CSTMT(I:I) .EQ. CUNDER .AND. .NOT.CSTMT(I:I) .EQ.
     3      CDOL)THEN
            JA = I - J
            JC = I - 1
            NA = JC + 1
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            IVCNT = JA
            CWORK(1:JA) = CSTMT(JD:JC)
            IWORK = ISN + 128
            CALL CHKNME (CSTMT)
            J = I
            IF(CSTMT(I:I) .EQ. CDOT) THEN
               JD = I + 1
               GO TO 11
            END IF
            GO TO 13
         END IF
 11      CONTINUE
      END IF
C
C         DETERMINE IF A FORMAT STATEMENT NUMBER
C
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
C
C         SEARCH FOR A STATEMENT NUMBER
C
         JB = J + 5
         DO 12 I = J,JB
C
C         TEST FOR A SEPARATOR
C
         IF(.NOT.(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ) .AND.
     1      .NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9)
     2      .AND. .NOT.CSTMT(I:I) .EQ. CUNDER .AND. .NOT.CSTMT(I:I) .EQ.
     3      CDOL)THEN
            JA = I - 1
            I4WK1 = 0
            I2WK1 = 0
C
C         CONVERT THE STATEMENT NUMBER TO FIXED POINT
C
            CALL NUMBER (CSTMT,LTRUE,J,I4WK1,FP,IFP)
C           IIB = I4WK1
C           IISN = ISN
            IIB = I4WK1 + 128
            IISN = ISN + 128
            CWR(1:4) = CIB(1:4)
            CWR(5:8) = CISN(1:4)
            IF(.NOT.LINCL) THEN
               CALL INSERT (I4WK1)
               IREC4 = IREC4 + 1
               WRITE (4,REC=IREC4) CWR
            END IF
            J = I + 1
            GO TO 13
         END IF
 12      CONTINUE
      END IF
C
C         PROCESS THE IOLIST FOR THE * AND FORMAT STATEMENT REFERENCES
C         TEST IF AN IOLIST
C
 13   IF(CSTMT(J:J) .EQ. CBLANK(1:1)) GO TO 16
C
C         DETERMINE THE FINAL CHARACTER OF THE STATEMENT
C
      DO 14 I = 1,KB
      JA = KB - I + 1
      IF(CSTMT(I:I) .NE. CBLANK(1:1)) THEN
         GO TO 15
      END IF
 14   CONTINUE
C
C         PROCESS THE INPUT-OUTPUT LIST
C
 15   CALL PIOLST
C
C         END OF ROUTINE
C
 16   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM ANALYZES THE ASSIGN STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO FILL VARIABLE
C                  CWORK
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM, INCLUDING ALL VARIABLE NAMES
C                  BROUGHT INTO A PROGRAM MODULE BY USING AN INCLUDE
C                  STATEMENT.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 C*32   8  CALLED SUBPROGRAM NAME
C                 33 - 34 I*4    9  ISN OF THE CALL STATEMENT
C                 37      C*1       SUBPROGRAM NAME DATA TYPE
C                 38 - 44 C*7   11  SUBPROGRAM NAME DATA LENGTH
C                 45 - 48 C*4   12  32 BIT SWITCHES FOR THE SUBPROGRAM
C                                   NAME ATTRIBUTES. IF BIT IS ZERO,
C                                   SWITCH IS OFF; IF BIT IS ONE,
C                                   SWITCH IS ON.
C                 49 - 52 I*4   13  NUMBER OF CHARACTERS IN THE CALLED
C                                   SUBPROGRAM NAME IN COLUMNS 1 - 32
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         I4WK1  - FOUR BYTE WORK AREA, CONTAINS THE STATEMENT NUMBER
C                  IN INTEGER FORM
C         I2WK1  - TWO BYTE WORK AREA, USED TO CONVERT TO BINARY FROM
C                  ASCII
C         J      - LOCATION OF THE CURRENT CHARACTER FOR SCANNING
C         JA     - SUBSCRIPT VARIABLE
C         JB     - SUBSCRIPT VARIABLE
C         JC     - SUBSCRIPT VARIABLE
C         JD     - DO LOOP PARAMETER
C         KB     - THE LOCATION OF THE LAST CHARACTER IN THE FORTRAN
C                  STATEMENT BEING ANALYZED
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE IF A STRUCTURE COMPOUND
C                  VARIABLE NAME EXISTS, SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         THE ASSGIN STATEMENT HAS THE FOLLOWING FORM:
C
C         ASSIGN label TO name
C
C         THE label AND name ARGUMENTS MAY BE A COMPOUND VARIABLES
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C
C     FORTRAN SUBROUTINES CALLED BY THIS ROUTINE
C
C         CHKNME EXPR INSERT NUMBER
C
C     *****************************************************************
C
      SUBROUTINE STMT02
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
      LOGICAL*1   LA
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK THE CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         TEST IF THIS IS THE ASSIGN STATEMENT
C
      J = KF + 5
      LA = LFALSE
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'ASSIGN') THEN
         J = J + 1
      ELSE
        GO TO 16
      END IF
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS AN ARITHMETIC
C         STATEMENT
C
      DO 10 I = J,KB
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         GO TO 16
      END IF
 10   CONTINUE
C
C         DETERMINE THE STATEMENT NUMBER
C         SCAN FROM LEFT TO RIGHT
C
      LEXEC = LTRUE
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
C
C         A DIGIT HAS BEEN FOUND, LOCATE ITS END
C
         DO 11 JA = J,KB
         IF(CSTMT(JA:JA) .EQ. CTT) THEN
            JB = JA + 2
            GO TO 12
         END IF
 11      CONTINUE
C
C         THE END OF THE NUMERICAL FIELD HAS BEEN FOUND
C         SEARCH THE TABLE OF STATEMENT NUMBER FOR A MATCH
C
 12      I4WK1 = 0
         I2WK1 = 0
C
C         CONVERT THE STATEMENT NUMBER TO FIXED POINT INTEGER
C
         CALL NUMBER (CSTMT,LTRUE,J,I4WK1,FP,IFP)
         IIB = I4WK1 + 128
         IISN = ISN + 128
         CWR(1:4) = CIB(1:4)
         CWR(5:8) = CISN(1:4)
         IF(.NOT.LINCL) THEN
            CALL INSERT (IIB)
            IREC4 = IREC4 + 1
            WRITE (4,REC=IREC4) CWR
         END IF
         J = JA + 2
      END IF
C
C         DETERMINE IF THE VARIABLE NAME IS A STRUCTURE COMPOUND NAME
C
 13   DO 14 I = JB,KB
      IF(CSTMT(I:I) .EQ. CDOT) THEN
         LA = LTRUE
         JD = I + 1
         GO TO 15
      END IF
 14   CONTINUE
C
C         SET THE START OF THE VARIABLE NAME SUBSCRIPT VALUE
C
 15   IF(LA) THEN
         JC = JD - JC + 1
         NA = JD + 1
         IVCNT = JC
      ELSE
         JD = KB
         JC = JB
         NA = KB + 1
         IVCNT = NA - JB
      END IF
C
C         PLACE THE VARIABLE NAME
C
      CWORK(1:JC) = CSTMT(JB:JD)
      IWORK = ISN + 128
C
C         SEARCH THE TABLE OF VARIABLE NAMES FOR A MATCH
C
      CALL CHKNME (CSTMT)
C
C         TEST IF A STRUCTURE COMPOUND VARIABLE NAME EXISTS
C
      IF(LA) THEN
         JB = I + 1
         LA = LFALSE
         GO TO 13
      END IF
C
C         ROUTINE EXIT
C
 16   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM PROCESSES THE BACKSPACE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, THE CHARACTER: (
C         C9  - CHARACTER VARIABLE, THE CHARACTER: 9
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, THE CHARACTER: )
C         CSTMT  - CHARACTER VARIABLE, THE FORTRAN STATEMENT BEING
C                  PROCESSED
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         C0  - CHARACTER VARIABLE, THE CHARACTER: 0
C         I      - SUBSCRIPT VARIABLE
C         ID     - COUNT OF LEFT AND RIGHT PARENTHESES IN THE STATEMENT.
C                  IF AN EQUAL SIGN OCCURS AND IS NOT ENCAPSULATED IN
C                  MATCHED LEFT AND RIGHT PARENTHESES, THE STATEMENT
C                  IS NOT A BACKSPACE STATEMENT.
C         IE     - SUBSCRIPT VARIABLE
C         II     - BINARY VALUE OF AN INTEGER CONVERTED FROM ASCII
C         IREC0  - COUNT OF THE MUMBER OF RECORDS ON UNIT 0
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IREC8  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 8 (INPUT-OUTPUT VARIABLE
C                  NAMES
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I2WK1  - WORK AREA, USED TO CONVERT ASCII DIGITS TO INTEGER
C         I4WK1  - VALUE OF CONVERTED INTEGER FROM ASCII
C         J      - LOCATION OF THE CURRENT CHARACTER IN CSTMT
C         JA     - THE START LOCATION OF A FIELD
C         JB     - THE END LOCATION OF A FIELD
C         JC     - SUBSCRIPT VARIABLE
C         JD     - LOCATION OF THE START OF A NUMERICAL SUBSCRIPT VALUE
C         KB     - THE LOCATION OF THE FINAL CHARACTER IN CSTMT
C         KF     - THE LOCATION OF THE INITIAL CHARACTER OF THE STATE-
C                  MENT IN CSTMT OMITTING ANY STATEMENT NUMBER
C         L      - LOGICAL VARIABLE, SET TRUE IF PARENTHESES EXIST
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER CONVER-
C                  SION IS TO INTEGER, SET FALSE IF FLOATING POINT
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LEQ    - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN EXISTS
C                  IN THE STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL STATEMENT, SET TRUE IF A LEFT PARENTHESIS
C                  OCCURS IN AN IOSTAT PARAMETER VARIABLE, SET FALSE
C                  OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHESIS
C                  EXISTS IN THE STATEMENT
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A RIGHT PARENTHESIS
C                  EXISTS IN THE STATEMENT
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C         8      - VARIABLE INPUT-OUTPUT UNIT NAMES, RECORD LENGTH IS 36
C                  CHARACTERS
C
C     COMMENTS
C
C         WHEN A LEFT OR RIGHT PARENTHESIS IS MISSING, THE STATEMENT IS
C         TREATED AS AN ARITHMETIC STATEMENT WHEN AN EQUAL SIGN EXISTS.
C
C         THE FOLLOWING CONTROL LIST PARAMETERS ARE ALLOWED:
C         ERR, IOLIST
C
C     SUBROUTINES CALLED
C
C         CHKNME CUNIT EXPR INSERT NUMBER
C
C     ******************************************************************
C
      SUBROUTINE STMT04
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
      LOGICAL*1   LA, LEQ, L1, L2, L3
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' BACKSPACE CONTROL ARGUMENT ERR IS A VARIABLE N
     1AME')
 101  FORMAT(' ISN:',I6,' BACKSPACE CONTROL ARGUMENTS LACK A RIGHT PAREN
     1THESIS')
 102  FORMAT(' ISN:',I6,' BACKSPACE CONTROL ARGUMENTS LACK A LEFT PARENT
     1HESIS')
C
C         INITIALIZATION
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      I4WK1 = 0
      I2WK1 = 0
      JA = 0
      JB = 0
      L = LFALSE
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      LEXEC = LFALSE
      LEQ =  LFALSE
      J = KF + 8
C
C         VERIFY THE BACKSPACE STATEMENT
C
      IF(CSTMT(KF:J) .EQ. 'BACKSPACE') THEN
         J = J + 1
         LEXEC =  LTRUE
         IE = 0
C
C         DETERMINE IF THE FINAL STATEMENT CHARACTER IS A RIGHT
C         PARENTHESIS
C
         IF(CSTMT(KB:KB) .EQ. CRPAR) L3 = LTRUE
C
C         DETERMINE IF THERE IS A MATCHING LEFT PARENTHESIS IMMEDIATELY
C         FOLLOWING BACKSPACE
C
         IF(CSTMT(J:J) .EQ. CLPAR) L2 = LTRUE
C
C         LOCATE THE FIRST EQUAL SIGN, IF ANY
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LEQ = LTRUE
            IE = I
            GO TO 11
         END IF
 10      CONTINUE
C
C         DETERMINE IF AN ARITHMETIC STATEMENT
C
 11      IF(LEQ) THEN
C
C         WHEN AN EQUAL SIGN OCCURS BETWEEN THE PARENTHESES, THIS IS
C         A BACKSPACE STATEMENT
C
            IF(L2 .AND. L3) THEN
               IF(IE .GT. J .AND. IE .LT. KB) GO TO 13
C
C         CASE WHEN A LEFT OR RIGHT PARENTHESIS IS MISSING
C
            ELSE IF(L2 .AND. .NOT.L3) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               LEXEC = LTRUE
               GO TO 22
            ELSE IF(.NOT.L2 .AND. L3) THEN
               WRITE (0,102) ISN
               IREC0 = IREC0 + 1
               LEXEC = LTRUE
               GO TO 22
C
C         WHEN NO PARENTHESES EXIST, AN EQUAL SIGN EXISTANCE IMPLIES
C         AN ARITHMETIC STATEMENT
C
            ELSE IF(.NOT.L2 .AND. .NOT.L3) THEN
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               LEXEC = LTRUE
               GO TO 22
            END IF
         END IF
C
C         DETERMINE IF UNBALANCED PARENTHESES EXIST
C
      ELSE
         GO TO 22
      END IF
C
C         TEST FOR A NUMERICAL UNIT NUMBER WITHOUT PARENTHESES
C
      IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
         CALL CUNIT
         IF(L) THEN
            GO TO 15
         ELSE
            GO TO 22
         END IF
      END IF
C
C         TEST FOR A VARIABLE UNIT NAME WITHOUT PARENTHESES
C
      IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1   CSTMT(J:J) .EQ. CUNDER) THEN
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         JA = KB - J + 1
         JB = KB
         CALL CUNIT
         GO TO 22
      END IF
C
C         A LEFT PARENTHESIS EXISTS, SO A LIST MUST EXIST
C
 13   IF(L) THEN
         J = J + 1
         JA = J
         JB = J + 5
C
C         TEST IF UNIT IS SPECIFIED AND ADJUST SUBSCRIPTS IF TRUE
C         J IS POSITIONED ONE CHARACTER AFTER THE EQUAL SIGN OF UNIT=
C
         IF(CSTMT(JA:JB) .EQ. 'UNIT=') J = J + 6
C
C         PROCESS IF A UNIT VARIABLE NAME OR A UNIT NUMBER
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER .OR. (CSTMT(J:J) .GE. C0 .AND.
     2      CSTMT(J:J) .LE. C9)) THEN
            DO 14 I = J,KB
            IF(CSTMT(I:I) .EQ. COMMA .OR. CSTMT(I:I) .EQ. CRPAR) THEN
               JA = J
               JB = I - 1
               CALL CUNIT
               IF(CSTMT(I:I) .EQ. CRPAR) GO TO 22
               JA = I
               GO TO 15
            END IF
 14         CONTINUE
         END IF
      END IF
C
C         PROCESS THE REMAINDER OF THE LIST
C
 15   DO 21 I = JA,KB
C
C         TEST IF A BLANK OCCURS
C
      IF(CSTMT(I:I) .EQ. CBLANK(1:1)) GO TO 22
C
C         TEST FOR A SEPARATOR
C
      IF(CSTMT(I:I) .EQ. COMMA) THEN
C
C         TEST IF AN IOLIST ARGUMENT
C
         IF(CSTMT(I+1:I+7) .EQ. 'IOSTAT=') THEN
            IA = I + 8
            DO 18 JC = IA,KB
            IF(CSTMT(JC:JC) .EQ. COMMA .OR. CSTMT(JC:JC) .EQ. CLPAR .OR.
     1         CSTMT(JC:JC) .EQ. CRPAR) THEN
               IB = JC - IA
               NA = JC
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               IVCNT = IB
               CWORK(1:IB) = CSTMT(IA:JC-1)
               IWORK = ISN + 128
               CALL CHKNME (CSTMT)
C
C         IF A LEFT PARENTHESIS OCCURS, THIS INDICATES A VARIABLE NAME
C         IS SUBSCRIPTED
C
               IF(CSTMT(JC:JC) .EQ. CLPAR) THEN
                  L1 = LTRUE
                  JD = JC + 1
C
C         THE SUBSCRIPT IS A NUMERICAL VALUE
C
                  IF(CSTMT(JD:JD) .GE. C0 .AND. CSTMT(JD:JD) .LE.
     1               C9) THEN
                     LA = LTRUE
                     CALL NUMBER (CSTMT,LA,JD,II,FP,IFP)
                     IF(.NOT.LINCL) CALL INSERT (II)
                     JA = IFP + 1
                     IF(CSTMT(JA:JA) .EQ. CRPAR) L1 = LFALSE
                     IF(CSTMT(JA+1:JA+1) .EQ. CRPAR) GO TO 22
                     IF(CSTMT(JA+1:JA+1) .EQ. COMMA) JA = JA + 1
                     GO TO 15
                  END IF
C
C         THE SUBSCRIPT IS A VARIABLE NAME
C
 16               IF(CSTMT(JD:JD) .GE. CAA .AND. CSTMT(JD:JD) .LE.
     1               CZZ .OR. CSTMT(JD:JD) .EQ. CUNDER) THEN
                     CWORK(1:52) = CBLK52(1:52)
                     JBITS = 0
                     DO 17 IE = JD,KB
                     IF(CSTMT(IE:IE) .EQ. CRPAR .OR. CSTMT(IE:IE) .EQ.
     1                  COMMA) THEN
                        IB = IE - JD
                        NA = IE
                        CWORK(1:52) = CBLK52(1:52)
                        JBITS = 0
                        IVCNT = IB
                        CWORK(1:IB) = CSTMT(JD:IE-1)
                        IWORK = ISN + 128
                        CALL CHKNME (CSTMT)
C
C         DETERMINE IF END OF THE STATEMENT
C
                        IF(CSTMT(IE:IE) .EQ. CRPAR) THEN
                           IF(IE+1 .GE. KB) THEN
                              GO TO 22
                           ELSE
                              IF(CSTMT(IE+1:IE+1) .EQ. COMMA) THEN
                                 JA = IE + 1
                                 GO TO 15
                              END IF
                           END IF
                        END IF
C
C         DETERMINE IF THE STATEMENT CONTINUES
C
                        IF(CSTMT(IE:IE) .EQ. COMMA) THEN
                           IF(CSTMT(IE:IE+2) .EQ. 'ERR') GO TO 19
                           JD = IE + 1
                           GO TO 16
                        END IF
                     END IF
 17                  CONTINUE
                  END IF
               END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS OCCURS
C
               IF(CSTMT(JC:JC) .EQ. CRPAR) THEN
                  IF(L1) THEN
                     L1 = LFALSE
                     GO TO 19
                  END IF
               ELSE
                  GO TO 22
               END IF
               IF(CSTMT(JC:JC) .EQ. COMMA) THEN
                  JA = JC
                  GO TO 15
               END IF
            END IF
 18         CONTINUE
         END IF
C
C         TEST IF AN ERR ARGUMENT
C
 19      IF(CSTMT(I+1:I+4) .EQ. 'ERR=') THEN
            IA = I + 5
            DO 20 JC = IA,KB
C
C         TEST IF A VARIABLE NAME OCCURS WHERE A STATEMENT NUMBER
C         SHOULD
C
            IF(CSTMT(JC:JC) .GE. CAA .AND. CSTMT(JC:JC) .LE. CZZ .OR.
     1         CSTMT(JC:JC) .EQ. CUNDER .OR. CSTMT(JC:JC) .EQ. CDOL)
     2         THEN
               IF(.NOT.LINCL) THEN
                  WRITE (0,100) ISN
                  IREC0 = IREC0 + 1
               END IF
               GO TO 22
            END IF
            IF(CSTMT(JC:JC) .EQ. COMMA .OR. CSTMT(JC:JC) .EQ. CRPAR)
     1         THEN
               IB = IA - JC
               CALL NUMBER (CSTMT,LTRUE,IA,II,FP,IFP)
               IIB = II + 128
               IISN = ISN + 128
               CWR(1:4) = CIB(1:4)
               CWR(5:8) = CISN(1:4)
               IF(.NOT.LINCL) THEN
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR
               END IF
               IF(CSTMT(JC:JC) .EQ. CRPAR) GO TO 22
               IF(CSTMT(JC:JC) .EQ. COMMA) THEN
                   JA = JC
                   GO TO 15
               END IF
            END IF
 20         CONTINUE
         END IF
      END IF
 21   CONTINUE
C
C         ROUTINE EXIT
C
 22   RETURN
      END
C
C
C     ******************************************************************
C
C     PURPOSE
C
C     THIS SUBPROGRAM PROCESSES THE BLOCK DATA SUBROUTINE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBAR   - CHARACTER VARIABLE, THE CHARACTER: |
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CSTMT  - CHARACTER VARIABLE, THE FORTRAN STATEMENT BEING
C                  PROCESSED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         ID     - COUNT OF LEFT AND RIGHT PARENTHESES IN THE STATEMENT.
C                  IF AN EQUAL SIGN OCCURS AND IS NOT ENCAPSULATED IN
C                  MATCHED LEFT AND RIGHT PARENTHESES, THE STATEMENT
C                  IS NOT A BLOCK DATA STATEMENT.
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - LOCATION OF THE CURRENT CHARACTER IN CSTMT
C         JA     - THE END LOCATION IN CWORK WHERE THE NAME ARGUMENT
C                  IS TO BE PLACED. THE LENGTH OF THE NAME.
C         KB     - LOCATION OF THE FINAL CHARACTER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR LOCERR
C
C     ******************************************************************
C
      SUBROUTINE STMT05
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         VERIFY THIS IS A BLOCK DATA STATEMENT
C
      J = KF + 8
      JA = KB - J
      LEXEC =  LFALSE
      IF(CSTMT(KF:J) .EQ. 'BLOCKDATA') THEN
         J = J + 1
      ELSE
         GO TO 11
      END IF
C
C         COUNT PARENTHESES AND DETERMINE IF AN EQUAL SIGN EXISTS
C
      ID = 0
      LEXEC =  LTRUE
      DO 10 I = J,KB
      IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
      IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         IF(ID .EQ. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
      END IF
 10   CONTINUE
C
C         TEST IF AN ARGUMENT NAME EXISTS
C
      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
      LEXEC = LTRUE
      LZEND = LFALSE
      IF(CSTMT(J:J) .NE. CBLANK(1:1)) THEN
C
C         MOVE THE NAME TO THE WORK AREA AND PLACE IT IN THE NAME TABLE.
C         A BLOCK DATA NAME CAN NOT BE A STRUCTURE COMPOUND NAME.
C         CWORK(37:37) CONTAINS '|' WHEN A VARIABLE NAME IS NOT TO HAVE
C         ITS TYPE AND LENGTH PRINTED BECAUSE THAT NAME DOES NOT HAVE
C         THOSE CHARACTERISTICS.
C
         NA = KB
         IVCNT = JA
         CWORK(1:JA) = CSTMT(J:KB)
         CWORK(32:32) = CSS
         IWORK = ISN + 128
         CALL CHKNME (CSTMT)
         GO TO 11
      END IF
C
C         SET ROUTINE NAME IN THE PRINT HEADER
C
      CFMTH(64:95) = CBLK52(1:32)
      CFMTH(64:73) = 'BLOCK DATA'
      CPGNME(1:32) = 'BLOCK DATA'//CBLK52(1:22)
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE BYTE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLEN   - CHARACTER VARIABLE, THE FIRST CHARACTER IS @ TO
C                  INDICATE A LOGICAL*1 TYPE STATEMENT FOR THE BYTE
C                  STATEMENT
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - THE DATA TYPE CODE. IT IS L FOR THE BYTE STATEMENT
C         I      - SUBSCRIPT VARIABLE
C         IRET0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - ISN OF THE CURRENT STATEMENT
C         I1     - COUNT OF LEFT AND RIGHT PARENTHESES
C         I2     - START LOCATION FOR PROCESSING IN ROUTINE TYPLST
C         I3     - LOCATION OF A COMMA TERMINATING DATA FOR A VARIABLE
C                  SPECIFICATION, OR THE END OF THE RECORD
C         I4     - SUBSCRIPT VARIABLE
C         I5     - COUNT OF THE NUMBER OF SLASHES
C         I6     - LOCATION OF THE LEFT PARENTHESIS TERMINATING A
C                  VARIABLE NAME
C         I7     - LOCATION OF THE RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS LOCATED BY I6
C         I2WK1  - PROVIDE THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE LAST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JBITS  - THE BIT SWITCHES INDICATING USAGE
C         JC     - COUNT OF THE NUMBER OF SLASHES IN THE STATEMENT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         THE [LENGTH] SPECIFICATION DOES NOT OCCUR FOR THE BYTE
C         STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR LOCERR TYPLST
C
C     COMMENTS
C
C         BYTE IS PROCESSED AS A LOGICAL*1 STATEMENT; ALTHOUGH, IT CAN
C         HAVE NUMERICAL VALUES DEFINED. ITS DQTA TYPE CODE IS SET TO
C         A IN OUTPUT TABALE 2.
C
C         BYTE MAY NOT HAVE LENGTH SPECIFICATION.
C
C     *****************************************************************
C
      SUBROUTINE STMT06
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN
      LOGICAL*1   L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALANC
     1ED SLASHES')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         VERIFY THIS IS A BYTE STATEMENT
C
      J = KF + 3
      LEXEC =  LFALSE
      IF(CSTMT(KF:J) .EQ. 'BYTE') THEN
         CLEN(1:7) = CBLANK(1:7)
         J = J + 1
         JC = 0
         LEXEC =  LTRUE
C
C         DETERMINE IF THIS IS AN EXPRESSION
C
         DO 10 I = J,KB
C
C         COUNT THE SLASHES IN THE STATEMENT
C
         IF(CSTMT(I:I) .EQ. CSLASH) JC = JC + 1
         IF(CSTMT(I:I) .EQ. CEQ .AND. MOD(JC,2).EQ. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 12
         END IF
 10      CONTINUE
C
C
C         THIS IS BYTE STATEMENT; TEST FOR UNBALANCED SLASHES.
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         LEXEC = LTRUE
         LFORCE = LTRUE
         IF(MOD(JC,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         PLACE TYPE CODE
C
         CLEN(1:7) = CBLANK(1:7)
         CTYPED(1:1) = CAA
         CLEN(1:1) = C1
C
C         PROCESS THE REMAINDER OF THE BYTE STATEMENT; THE
C         STATEMENT MAY CONTAIN THREE OF THE POSSIBLE SPECIFICATI0NS.
C         THE LENGTH SPECIFICATION IS NEVER PROVIDED AS IT IS ALWAYS 1.
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE BYTE STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         I1 = 0
         I2 = J
         I5 = 0
         L2 = LFALSE
         DO 11 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I6 = I1
         END IF
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I7 = I1
         END IF
         IF(CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
         IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               I3 = I4
               I2WK1 = 0
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I6 .GT. 0 .AND. I7 .GT. 0) THEN
                  L2 = LTRUE
               ELSE
                  L2 = LFALSE
               END IF
               CALL TYPLST (CTYPED,CLEN,I2,I3,L2)
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I4 .EQ. KB) GO TO 12
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                  I1 = 0
                  I2 = I4 + 1
                  I5 = 0
                  L2 = LFALSE
               END IF
            END IF
         END IF
 11      CONTINUE
      ELSE
         LEXEC = LFALSE
      END IF
C
C         ROUTINE EXIT
C
 12   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE CALL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: /
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSC    - CHARACTER VARIABLE, THE LETTER: c
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE
C                  STATEMENT BEING PROCESSED. E - ENTRY, F - FUNCTION,
C                  S - SUBROUTINE, s - CALL
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         FCONFT - DOUBLE PRECISION ARRAY OF ALL REAL CONSTANTS OCCURING
C                  IN THE PROGRAM BEING ANALYZED
C         FP     - DOUBLE PRECISION VALUE OF A FLOATING POINT NUMBER
C                  CONVERTED FROM ASCII
C         I      - SUBSCRIPT VARIABLE
C         IB     - RETURN VALUE OF AN INTEGER CONSTANT IN BINARY
C         ICONF  - COUNT OF THE NUMBER IF REAL CONSTANTS IN FCONFT
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - COUNT OF THE NUMBER OF LEFT AND RIGHT PARENTHESES;
C                  ONE IS ADDED WHEN A LEFT PARENTHESIS OCCURS, AND ONE
C                  IS SUBTRACTED WHEN A LEFT PARENTHESIS OCCURS.
C         I2     - SUBSCRIPT VARIABLE
C         I3     - SUBSCRIPT VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE START OF A FIELD
C         JB     - WORK AREA
C         J1     - LOCATION OF THE LEFT PARENTHSIS STARTING THE ARGUMENT
C                  LIST SPECIFICATIONS
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL RIGHT
C                  RIGHT PARENTHESIS OCCURS
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THIS SUBROUTINE IS
C                  ENTERED FROM SUBROUTINE COMPRS, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN ROUTINE COMPRS IS TO
C                  BE INFORMED A CALL STATEMENT EXISTS, SET FALSE TO
C                  INDICATE THE STATEMENT IS NOT A CALL STATEMENT.
C         NARGSW - SAVE AREA FOR THE VALUE OF NARGS WHILE PROCESSING
C                  A CALL STATEMENT.
C
C     COMMENTS
C
C         A MAXIMUM OF 200 DIFFERENT SUBPROGRAM NAMES PER ROUTINE BEING
C         ANALYZED ARE ALLOWED. A TOTAL OF 4000 DEFINED ENTRY, FUNCTION
C         AND SUBROUTINE STATEMENTS ARE ALLOWED FOR AN ENTIRE PROGRAM.
C         ARGUMENTS OF A CALL STATEMENT MAY BE A COMPOUND VARIABLE.
C
C         A SUBPROGRAM NAME FROM AN ENTRY, FUNCTION, OR SUBROUTINE
C         STATEMENT WILL NOT HAVE THE CORRECT TYPE AND LENGTH
C         CHARACTERISTICS WHEN USED AS AN ARGUMENT IN A CALL STATEMENT.
C         THE TABLE LISTINGS FOR THE CURRENT SUBPROGRAM WILL NOT BE
C         CORRECT FOR THE SUBPROGRAM ARGUMENT. IF AN EXTERNAL STATEMENT
C         DECLARES THE ARGUMENT NAME, THE TYPE CODE WILL BE SET TO S,
C         THE CODE FOR A SUBROUTINE. LENGTH WILL BE SET TO THE FORTRAN
C         STANDARD OR TO COMPLY WITH AN IMPLICIT STATEMENT REQUIREMENTS.
C
C         NO ERROR MESSAGE WILL BE WRITTEN CONCERNING LENGTH AND TYPE
C         INCONSISTANCIES WHEN GLOBAL ANALYSIS IS REQUESTED FOR THIS
C         CASE.
C
C     SUBROUTINES CALLED
C
C         ARGLST EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT07 (L1,L2)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1, L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1            JBITS), (CNAME(1),IENAME(1,1))
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' CALL LACKS LEFT PARENTHESIS')
 101  FORMAT(' ISN:',I6,' CALL LACKS RIGHT PARENTHESIS')
C
C         BLANK CHARACTER WORK AREA
C
      JBITS = 0
C
C         VERIFY THIS IS A CALL STATEMENT
C
      J = KF + 3
      LEXEC =  LFALSE
      IF(CSTMT(KF:J) .NE. 'CALL') GO TO 11
      J = J + 1
      JA = J
      LEXEC =  LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION STATEMENT.
C         WHEN AN EQUAL SIGN EXISTS, THIS IS NOT A CALL STATEMENT.
C         ALSO COUNT THE LEFT AND RIGHT PARENTHESES.
C
      JB = 0
      DO 10 I = J,KB
      IF(CSTMT(I:I) .EQ. CEQ .AND. JB .EQ. 0) THEN
         IF(L1) RETURN
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         GO TO 11
      END IF
      IF(CSTMT(I:I) .EQ. CLPAR) JB = JB + 1
      IF(CSTMT(I:I) .EQ. CRPAR) JB = JB - 1
 10   CONTINUE
C
C         VERIFY THE LEFT AND RIGHT ARGUMENTS ENCLOSING PARENTHESES
C         EXIST
C
      LEXEC = LTRUE
      IF(JB .GT. 0) THEN
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
         IF(CSTMT(KB:KB) .NE. CRPAR) THEN
            WRITE (0,101) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         THIS IS A CALL STATEMENT
C
C         RETURN TO SUBROUTINE COMPRS WHEN L1 IS TRUE
C
      IF(L1) THEN
         L2 = LTRUE
         RETURN
      END IF
C
C         INITIALIZATION FOR ARGUMENT PROCESSING
C
      JA = J
      CTYPED = CCC
      NARGSW = NARGS
      LCALL = LTRUE
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CALL ARGLST (CTYPED,CSTMT,KB)
      LCALL = LFALSE
      NARGS = NARGSW
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         ROUTINE EXIT
C
 11   LCALL = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE CHARACTER STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CI2WK1 - CHARACTER VARIABLE EQUIVALENCED TO I2WK1
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A DATA TYPE
C                  DEFINITION
C         CLENSV - CHARACTER VARIABLE, THE LENGTH SPECIFICATION FOR THE
C                  ENTIRE CHARACTER STATEMENT
C         CLENWK - CHARACTER STATEMENT, USED TO STORE THE ASCII TEXT
C                  FORM OF THE LENGTH DERIVED FROM AN EXPRESSION
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARATER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - THE DATA TYPE CODE. IT IS C FOR CHARACTER TYPE
C         CWK52  - CHARACTER VARIABLE, USED TO CONSTRUCT THE AN RECORD
C                  TO PROCESS A LENGTH DEFINITION SPECIFIED AS A
C                  PARAMETER VARIABLE IN ROUTINE CHKNME.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C0     - CHARACTER VARIABLE, A ZERO: 0
C         C9     - CHARACTER VARIABLE, A NINE: 9
C         I      - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF THE DATA TYPE LENGTH FIELD
C         ID     - LOCATION OF THE END OF THE DATA TYPE LENGTH FIELD
C         II     - THE VALUE OF THE DEFINED LENGTH DERIVED FROM AN
C                  EXPRESSION SPECIFICATION. IT MUST BE CONVERTED
C                  TO TEXT FORMAT FOR THE OUTPUT LISTING, OR IT IS THE
C                  SPECIFIED NUMERICAL LENGTH.
C         ILIST  - COUNT OF THE NUMBER OF VARIABLES IN A CHARACTER
C                  STATEMENT
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN TABLE CPARAM
C         IPGNME - LENGTH OF A FUNCTION NAME
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IREC7  - COUNT OF THE NUMBER OF RECORDS ON UNIT 7
C         IRET   - A RETURN CODE, >0 MATCH EXISTS, <0 NO MATCH EXISTS
C         ISN    - ISN OF THE CURRENT STATEMENT
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  THE VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I2WK1  - USED TO CONVERT A BINARY INTEGER TO TEXT DIGITS, AND
C                  PROVIDE THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST
C         IWK52  - EQUIVALENCED TO CWK52
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE
C         I5     - COUNT OF THE NUMBER OF SLASHES NOT ENCAPSULATED
C                  WITHIN PARENTHESES
C         I6     - COUNT OF THE NUMBER OF DECIMAL DIGITS IN II AS IT
C                  IS CONVERTED TO TEXT DIGITS
C         I7     - POWER OF TEN TO THE I6TH POWER
C         I8     - LOCATION TO PLACE A DIGIT CONVERTED TO TEST FORMAT IN
C                  CLEN
C         I9     - LOCATION OF A LEFT PARENTHESIS TERMINATING A VARIABLE
C                  NAME
C         I10    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS AT THE LOCATION IN I9
C         I11    - SUBSCRIPT VARIABLE
C         I12    - NUMBER OF DIGITS IN IN CLENWK
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE LAST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JB     - LOCATION OF THE CHARACTER AFTER AN ASTERISK, IF IT
C                  EXISTS
C         JC     - COUNT OF THE NUMBER OF SLASHES IN THE STATEMENT
C         JD     - DO LOOP PARAMETER, THE MAXIMUM END OF A POSSIBLE
C                  NUMERICAL FIELD DEFINING THE DATA TYPE LENGTH
C         JE     - THE END LOCATION OF A LENGTH SPECIFICATION FOR A
C                  VARIABLE
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LARITH - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS WITHIN AN EXPRESSION DEFINING THE
C                  LENGTH OF THE CHARACTER VARIABLE. SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT IN A
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN NO LEFT PARENTHESIS
C                  IS FOUND, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH IS SPECIFED
C                  FOR THE ENTIRE STATEMENT HAS BEEN ENTERED IN CLEN,
C                  SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME DEFINED AS A CHARACTER VARIABLE,
C         IT HAS FOLLOWING FORM:
C
C         CHARACTER[*LENGTH] [NAME] [(DIMENSION)] [/DATA/]
C
C         WHEN THE VARIABLE NAME DEFINED AS A CHARACTER VARIABLE IS
C         DEFINED WITHIN A STRUCTURE, IT HAS THE FORM:
C
C         CHARACTER[*LENGTH] [NAME] [(DIMENSION)]
C
C         BOTH [DIMENSION] AND [LENGTH] SPECIFICATIONS MAY BE AN
C         EXPRESSION OF VARIABLES AND CONSTANTS. VARIABLE SPECIFICATIONS
C         MUST HAVE BEEN DEFINED IN A PARAMETER STATEMENT TO BE VALID,
C         AND THEY MAY NOT HAVE SUBSCRIPTS.
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT LOCERR NUMBER PARAEV STMT29 TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT08
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100), IWK52(13), IPARAM(13,4000)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK, CWK52
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7   CLEN, CLENWK, CLENSV
      LOGICAL*1     LARITH, L1, L2, L4
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CWK52,IWK52),
     2(CPARAM,IPARAM)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALAN
     1CED SLASHES')
 101  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION ERROR OR IT EXCEEDS 7 DIG
     1ITS')
 102  FORMAT(' ISN:',I6,' NOT A PARAMETER VARIABLE: ',A32)
 103  FORMAT(I7)
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      CLENSV(1:7) = CBLANK(1:7)
      CLENWK(1:7) = CBLANK(1:7)
      LEXEC =  LFALSE
      L1 = LFALSE
      L2 = LFALSE
      LFORCE = LFALSE
      IFP = 0
C
C         VERIFY THIS IS A CHARACTER STATEMENT
C
      J = KF + 8
      IF(CSTMT(KF:J) .EQ. 'CHARACTER') THEN
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT
C
         ID = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
         IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(ID .EQ. 0) THEN
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 18
            END IF
         END IF
 10      CONTINUE
C
C         THIS IS A CHARACTER STATEMENT
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         J = J + 1
         JA = J + 7
         JC = 0
         CTYPED(1:1) = CCC
         LFORCE = LTRUE
C
C         INDICATE THIS IS NOT AN ARITHMETIC STATEMENT
C
         LEXEC =  LTRUE
C
C     ******************************************************************
C     *                                                                *
C     *              LENGTH SPECIFICATION PROCESSING                   *
C     *                                                                *
C     ******************************************************************
C
C         WHEN AN ASTERISK FOLLOWS 'CHARACTER', THEN THE LENGTH THE
C         SPECIFICATION FOLLOWS THE ASTERISK. THIS LENGTH SPECIFICATION
C         IS THE FOR ALL VARIABLES SPECIFIED IN THE STATEMENT UNLESS
C         INDIVIUAL VARIABLE SPECIFICATIONS EXIST.
C
C
C         J IS THE LOCATION AFTER THE FINAL R IN 'CHARACTER'.
C         LOCATE THE NEXT NONBLANK CHARACTER FOLLOWING 'CHARACTER'.
C
         DO I = J,KB
         IF(CSTMT(I:I) .NE. ' ') THEN
            IF(CSTMT(I:I) .NE. CASTER(1:1)) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               CLENSV(1:1) = C1
            ELSE
               GO TO 11                   ! AN ASTERISK FOLLOWS
            END IF
C
C         LOCATE THE FIRST ALPHABETIC CHARACTER OR UNDERSCORE AFTER THE
C         LENGTH ERROR
C
            IF(CSTMT(I:I) .EQ. CLPAR) THEN
               I1 = 0
               DO I2 = I,KB
               IF(CSTMT(I2:I2) .EQ. CLPAR) I1 = I1 + 1
               IF(CSTMT(I2:I2) .EQ. CRPAR) I1 = I1 - 1
               IF(I1 .EQ. 0) THEN
                  DO I3 = I2,KB
                  IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ
     1               .OR. CSTMT(I3:I3) .EQ. CUNDER) THEN
                     J = I3
                     GO TO 15
                  END IF
                  END DO
               END IF
               END DO
            END IF
         END IF
         END DO
 11      IF(CSTMT(J:J) .EQ. CASTER) THEN
C
C         SET THE STARTING POSITION OF THE FIELD FOLLOWING THE ASTERISK
C
            JB = J + 1
C
C         DETERMINE IF A DIGIT FOLLOWS THE ASTERISK; WHEN TRUE, THE
C         NUMERIC VALUE IS THE LENGTH CHARACTERISTIC OF THE VARIABLE.
C
            IF(CSTMT(JB:JB) .GE. C0 .AND. CSTMT(JB:JB) .LE. C9) THEN
               CALL NUMBER (CSTMT,LTRUE,JB,II,FP,IFP)
               CALL INSERT (II)
               CLEN(1:IFP-JB+1) = CSTMT(JB:IFP)
               CLENSV(1:7) = CLEN(1:7)
            END IF
C
C         DETERMINE IF A LEFT PARENTHESIS FOLLOWS THE ASTERISK
C
            IF(CSTMT(JB:JB) .EQ. CLPAR(1:1)) THEN
C
C         A LEFT PARENTHESIS FOLLOWING AN ASTERISK MAY BE OF TWO FORMS:
C         1. (*) OR 2. A MATHEMATICAL EXPRESSION.
C
C         TEST FOR THE (*) LENGTH SPECIFICATION
C
               IF(CSTMT(JB:JB+2) .EQ. '(*)') THEN
                  CLEN(1:7) = '(*)'//CBLANK(1:4)
                  CLENSV(1:7) = CLEN(1:7)
                  JE = JB + 3
               END IF
               LARITH = LFALSE
C
C         DETERMINE THE END OF THE LENGTH SPECIFICATION WHEN THE
C         SPECIFICATION IS ENCAPSULATED IN PARENTHESES
C
               DO I = JB,KB
C
C         DETERMINE IF ANY ARITHMETIC OPERATOR OCCURS WITHIN THE LENGTH
C         SPECIFICATION
C
               IF(CSTMT(I:I) .EQ. CPLUS(1:1) .OR. CSTMT(I:I) .EQ.
     1            CMINUS(1:1) .OR. CSTMT(I:I) .EQ. CSLASH(1:1)) THEN
                  LARITH = LTRUE
               ELSE IF(CSTMT(I:I) .EQ. CASTER(1:1)) THEN
                  IF(CSTMT(I+1:I+1) .EQ. CLPAR) THEN
                     LARITH = LFALSE
                  ELSE
                     LARITH = LTRUE
                  END IF
               END IF
C
C         THE OCCURENCE OF A COMMA OR THE FINAL CHARACTER OF THE
C         STATEMENT TERMINATES THE LENGTH SPECIFICATION
C
               IF(CSTMT(I:I) .EQ. COMMA(1:1)) JE = I - 2
               IF(CSTMT(I:I) .EQ. CLPAR(1:1)) I1 = I1 + 1
               IF(CSTMT(I:I) .EQ. CRPAR(1:1)) I1 = I1 - 1
               IF(I1 .EQ. 0) THEN
                  IF(I .EQ. KB) THEN
                     JE = I - 1
                  ELSE
                     JE = I
                  END IF
                  GO TO 12
               END IF
               END DO
C
C         EITHER A NUMBER OR A VARIABLE NAME FOLLOWS THE LEFT
C         PARENTHESIS TO SPECIFY THE LENGTH
C
 12            J = JE + 1
               JB = JB + 1
               JE = JE - 1
C
C         WHEN A VARIABLE NAME IS SPECIFIED AS THE LENGTH OF A CHARACTER
C         VARIABLE, IT MUST HAVE BEEN PREVIOUSLY DEFINED IN A PARAMETER
C         STATEMENT. OTHERWISE, THIS DEFINTION IS AN ERROR.
C
C         DETERMINE IF AN EXPRESSION EXISTS; EITHER A VARIABLE NAME OR A
C         DIGIT MAY OCCUR FIRST
C
               IF(CSTMT(JB:JB) .GE. CAA .AND. CSTMT(JB:JB) .LE. CZZ .OR.
     1            CSTMT(JB:JB) .EQ. CUNDER .OR. CSTMT(JB:JB) .GE.
     2            C0(1:1) .AND. CSTMT(JB:JB) .LE. C9(1:1)) THEN
C
C         WHEN ARITHMETIC OPERATORS EXIST, AN EXPRESSION SPECIFIES THE
C         LENGTH OF THE CHARACTER VARIABLE BEING DEFINED
C
                  IF(LARITH) THEN
                     CALL PARAEV (JB,JE,II)
C
C         CONVERT THE DETERMINED LENGTH TO TEXT FORMAT
C
                     CLEN(1:7) = CBLANK(1:7)
                     CWORK(37:37) = CTYPED(1:1)
                     IF(II .EQ. 0) THEN
C
C         WHEN THE LENGTH EVALUATES TO ZERO
C
                        CWORK(38:38) = C0(1:1)
                        GO TO 15
                     ELSE
C
C         WHEN THE LENGTH IS NOT ZERO, CONVERT TO TEXT FORMAT
C
                        WRITE (CLENWK,103) II
                        I2WK1 = 0
                        DO 13 I = 1,7
                        IF(CLENWK(I:I) .EQ. CBLANK) THEN
                           GO TO 13
                        ELSE
                           I2WK1 = I2WK1 + 1
                           CLEN(I2WK1:I2WK1) = CLENWK(I:I)
                        END IF
 13                     CONTINUE
                        CLENWK(1:7) = CLEN(1:7)
                        L2 = LTRUE
                        J = JE + 1
                        IF(CSTMT(J:J) .EQ. CRPAR(1:1)) J = J + 1
                        GO TO 15
                     END IF
                  ELSE
C
C         DETERMINE IF THE LENGTH SPECIFICATION IS NUMERIC OR A VARIABLE
C         NAME
C
                     IF(CSTMT(JB:JB) .GE. C0 .AND. CSTMT(JB:JB) .LE. C9)
     1                  GO TO 130
C
C         NO ARITHMETIC OPERATORS EXIST IN THE LENGTH SPECIFICATION,
C         BUT A VARIABLE NAME DOES EXIST. JB IS THE START LOCATION AND
C         JE IS THE END LOCATION OF THE VARIABLE NAME USED TO DEFINE
C         THE LENGTH SPECFICATION OF THE VARIABLE USED TO DEFINED THE
C         LENGTH CHARACTERISTIC. IT MUST BE A PARAMETER VARIABLE, OR
C         AN INTEGER VARIABLE FROM AN ENTRY, FUNCTION, OR SUBROUTINE
C         STATEMENT.
C
                     CWK52(1:52) = CBLK52(1:52)
                     CWK52(1:JE-JB+1) = CSTMT(JB:JE)
                     CALL TABSRH (CPARAM,IP,52,1,32,CWK52,1,32,IRET,
     1                            4000)
C
C         DETERMINE IF THE VARIABLE NAME IS DEFINED IN A PARAMETER
C         STATEMENT.
C
                     IF(IRET .GT. 0) THEN
                        CLENWK(1:7) = CPARAM(IRET)(38:44)
                        CALL ITOC (IPARAM(12,IRET),CLENSV,1,7)
C
C         DETERMINE THE NUMBER OF CHARACTERS IN THE LENGTH SPECIFICATION
C
                        I11 = 1
                        DO WHILE(CLENWK(I11:I11) .EQ. CBLANK)
                        I11 = I11 + 1
                        END DO
C
C         THE VALUE OF I11 IS THE FIRST NUMERIC CHARACTER IN CLENWK
C
                        I12 = 7 - I11 + 1
C
C         MOVE THE LENGTH SPECIFICATION TO CLEN
C
                        CLEN(1:7) = CBLANK(1:7)
                        CLEN(1:I12) = CLENWK(I11:7)
                     ELSE
                        IREC0 = IREC0 + 1
                        WRITE (0,102) ISN,CWK52(1:32)
C
C         NO PARAMETER VALUE DEFINED, FORCE LENGTH TO 1
C
                        CLEN(1:7) = C1//CBLANK(1:6)
                        CLENWK(1:7) = CLEN(1:7)
                     END IF
C
C         CREATE RECORD TO WRITE ON UNIT 7, THE LIST OF USED VARIABLES
C         FOR PARAMETER DEFINED LENGTH SPECIFICATIONS
C
                     IWK52(9) = ISN + 128
                     CWK52(37:37) = CII
                     CWK52(38:44) = CLEN(1:7)
                     IWK52(12) = 0
                     IF(.NOT.LINCL) IWK52(12) = IBSET(IWK52(12),15)
                     IWK52(12) = IBSET(IWK52(12),14)
                     IWK52(13) = I12
                     WRITE (7,REC=IREC7) CWK52(1:52)
                     IREC7 = IREC7 + 1
                  END IF
               END IF
C
C         LOCATE THE END OF THE NUMERICAL FIELD
C
 130           IF(CSTMT(JB:JB) .GE. C0(1:1) .AND. CSTMT(JB:JB) .LE.
     1            C9(1:1)) THEN
                  DO 14 I = JB,KB
                  IF(.NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE.
     1               C9)) THEN
                  IC = I - JB
                  ID = I - 1
                  IF(IC .GT. 7) THEN
                     IF(.NOT.LINCL) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                     IC = 7
                     ID = JA + 6
                  END IF
                  CLEN(1:IC) = CSTMT(JB:ID)
                  CLENWK(1:7) = CLEN(1:7)
                  L2 = LTRUE
                  J = I
                  IF(CSTMT(JB-1:JB-1) .EQ. CLPAR(1:1)) J = J + 1
                  JA = J + 7
                  GO TO 15
                  END IF
 14            CONTINUE
               END IF
            END IF
         END IF
C
C         END OF LENGTH CHARACTERISTIC SPECIFICATION
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
 15      IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
            KF = J
            CALL STMT29 (CTYPED,CLEN)
            GO TO 18
         END IF
C
C         SCAN FOR SLASHES OCCURRING IN A CHARACTER STATEMENT
C
         JC = 0
         DO 16 I = J,KB
         IF(CSTMT(I:I) .EQ. CSLASH) JC = JC + 1
C
C         DETERMINE IF AN ARITHMETIC STATEMENT
C
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            CTYPED(1:1) = CBLANK(1:1)
            CALL EXPR (KF,KB,LFALS,CSTMT)
            GO TO 18
         END IF
 16      CONTINUE
C
C         WRITE MESSAGE WHEN UNMATCHED SLASHES EXIST
C
         IF(MOD(JC,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         PROCESS THE REMAINDER OF THE CHARACTER STATEMENT; THE
C         STATEMENT MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIFICATI0NS.
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE CHARACTER STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
         CWORK(1:52) = CBLK52(1:52)
         CLEN(1:7) = CLENSV(1:7)
         JBITS = 0
         IF(IFP .GT. 0) J = IFP + 1
         JBITS = 0
         I1 = 0
         I2 = J
         I5 = 0
         I9 = 0
         I10 = 0
         ILIST = 0
         DO 17 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME IN THE
C         CHARACTER STATEMENT
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I9 = I4
         END IF
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I10 = I4
         END IF
         IF(I1 .EQ. 0 .AND. CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
         IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               I3 = I4
               IF(I5 .GT. 0) I2WK1 = I5
               LFORCE = LTRUE
               ILIST = ILIST + 1
C
C         RESTORE THE STATEMENT'S GENERAL LENGTH FOR ALL VARIABLES IN
C         THE CHARACTER STATEMENT WHEN NONE IS DEFINED
C
               IF(ILIST .GT. 1) THEN
                  IF(CLEN(1:7) .EQ. CBLANK(1:7)) CLEN = CLENSV
               END IF
C
C         WHEN THE END OF THE STATEMENT OCCURS, PLACE THE VARIABLE
C         NAME IN CWORK
C
               IF(.NOT.(CSTMT(I4:I4) .GE. C0 .AND. CSTMT(I4:I4) .LE. C9)
     1            )THEN
                  CWORK(37:37) = CCC
                  IF(I4 .EQ. KB) THEN
                     CWORK(1:KB-I2+1) = CSTMT(I2:KB)
                     CWORK(38:44) = CLEN(1:7)
                  ELSE
                     CWORK(1:I4-I2) = CSTMT(I2:I4-1)
                     CWORK(38:44) = CLEN(1:7)
                  END IF
               END IF
               IF(.NOT.LINCL) LFORCE = LTRUE
C
C         FORCE THE TYPE AND LENGTH CHARACTERISTICS TO BE RESET IN
C         ROUTINE TYPLST
C
               LFORCE = LTRUE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I9 .GT. 0 .AND. I10 .GT. 0) THEN
                  L4 = LTRUE
               ELSE
                  L4 = LFALSE
               END IF
C
C         DETERMINE IF THE LENGTH CHARACTERISTIC IN CLEN IS BLANK
C
               IF(CLEN(1:7) .EQ. CBLANK(1:7)) THEN
C
C         DETERMINE IF CLENSV IS BLANK
C
                  IF(CLENSV(1:7) .NE. CBLANK(1:7)) THEN
                     CLEN(1:7) = CLENSV(1:7)
                     CWORK(38:44) = CLENSV(1:7)
                  END IF
               END IF
               CALL TYPLST (CTYPED,CLEN,I2,I3,L4)
               LFORCE = LFALSE
               CLEN(1:7) = CLENSV(1:7)
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I4 .EQ. KB) GO TO 18
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                  I1 = 0
                  I2 = I4 + 1
                  I5 = 0
                  I9 = 0
                  I10 = 0
               END IF
            END IF
         END IF
 17      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 18   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE CLOSE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - LOCATION OF THE END OF AN ARGUMENT
C         IC     - LENGTH OF A VARIABLE NAME OR FIELD
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN CCONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         ID     - INDEX VALUE OF THE ARGUMENT TO BE PROCESSED IN ARRAY
C                  CLIST IN ROUTINE CIOLST
C         II     - RETURN VALUE OF AN INTEGER NUMBER FROM SUBROUTINE
C                  NUMBER
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN IOUTC
C         IREC0  - COUNT OF THE NUMBER OF ERROR MESSAGE ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISNUM  - TABLE OF STATEMENT NUMBERS FOUND IN THE PROGRAM AND
C                  THE ISN WHERE IT IS DEFINED. WORD 1 IS THE STATEMENT
C                  NUMBER VALUE, WORD 2 IS THE ISN
C         I1     - LOCATION OF THE FIRST CHARACTER AFTER AN EQUAL SIGN
C         I2     - COUNT OF THE NUMBER PARENTHESES FOUND.  ONE IS ADDED
C                  IF A LEFT PARENTHESIS OCCURS, ONE IS SUBTRACTED IF A
C                  RIGHT PARENTHESIS OCCURS
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JA     - LOCATION OF THE FINAL RIGHT PARENTHESIS ENDING THE
C                  CONTROL LIST ARGUMENTS
C         JD     - LOCATION OF THE CURRENT CHARACTER
C         JE     - LOCATION OF THE FIRST CHARACTER IN THE UNIT FIELD
C         JF     - SAVE AREA FOR THE VALUE IN J
C         JG     - END LOCATION OF A VARIABLE NAME OR NUMBER
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE
C         LB     - LOGICAL VARIABLE, WORK VARIABLE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE BY ROUTINE CIOLST WHEN A
C                  DISP OR DISPOSE COMMAND WAS FOUND
C         L2     - LOGICAL VARIABLE, SET TRUE BY ROUTINE CIOLST WHEN AN
C                  ERR COMMAND WAS FOUND
C         L3     - LOGICAL VARIABLE, SET TRUE BY ROUTINE CIOLST WHEN AN
C                  IOSTAT COMMAND WAS FOUND
C         L4     - LOGICAL VARIABLE, SET TRUE BY ROUTINE CIOLST WHEN A
C                  STATUS COMMAND WAS FOUND
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A COMMA IS DETECTED,
C                  SET FALSE OTHERWISE.
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A LITERAL, SET FALSE OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A VARIABLE, SET FALSE OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C
C     COMMENTS
C
C     THE CLOSE STATEMENT MAY HAVE THE FOLLOWING CONTROL LIST PARMAETERS
C     ERR, DISP, DISPOSE, IOSTAT, STATUS, UNIT
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 121 CHAR-
C                  ACTERS OR LESS
C
C     SUBROUTINES CALLED
C
C         CIOLST CUNIT EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT09
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 LA, LB, L1, L2, L3, L4, L5, L6, L7, L8, L9
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/    ID,LB,L6,L7,L8,L9,LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO CLOSING COMMA OR RIGHT OR LEFT PARENTHESIS
     1')
 101  FORMAT(' ISN:',I6,' INPUT-OUTPUT CONTROL LIST PARAMETER ERROR')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      ID = 0
      L5 = LFALSE
      LEXEC =  LFALSE
C
C         VERIFY THIS IS A CLOSE STATEMENT, IT HAS ONLY A COMMAND
C         LIST
C
      J = KF + 4
      IF(CSTMT(KF:J) .EQ. 'CLOSE') THEN
         J = J + 1
C
C         DETERMINE IF THIS MAY BE AN ARITHMETIC STATEMENT
C
         I2 = 0
         DO 10 JE = J,KB
C
C         IF AN EQUAL SIGN OUTSIDE PARENTHESES, THIS IS NOT A
C         CLOSE STATEMENT
C
         IF(CSTMT(JE:JE) .EQ. CLPAR) I2 = I2 + 1
         IF(CSTMT(JE:JE) .EQ. CRPAR) I2 = I2 - 1
         IF(CSTMT(JE:JE) .EQ. CEQ .AND. I2 .EQ. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 19
         END IF
C
C         IF A COLON OR AN ARITHMETRIC OPERATOR EXIST, THEN THIS IS
C         NOT A CLOSE STATEMENT
C
         LEXEC = LTRUE
         IF(CSTMT(JE:JE) .EQ. CPLUS .OR. CSTMT(JE:JE) .EQ. CMINUS .OR.
     1      CSTMT(JE:JE) .EQ. CASTER .OR. CSTMT(JE:JE) .EQ. CSLASH .OR.
     2      CSTMT(JE:JE) .EQ. COLON) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 19
         END IF
 10      CONTINUE
C
C         SET LOGICAL SWITCHES
C
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LFALSE
C
C         VERIFY THAT A LEFT PARENTHESIS FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
C
C         LEFT PARENTHESIS FOLLOWS THE CLOSE, SO THE UNIT IS SPECIFIED
C         WITH ENCAPULATING PARENTHESES
C
            JE = J + 1
C
C         IF A DIGIT IS THE FIRST CHARACTER AFTER THE LEFT PARENTHESIS,
C         THIS IS A NUMERICAL UNIT SPECIFICATION WITHOUT UNIT=
C
            IF(CSTMT(JE:JE) .GE. C0 .AND. CSTMT(JE:JE) .LE. C9)
     1         THEN
C
C         PROCESS A UNIT DESIGNATED AS A DIGIT, IT MUST BE THE FIRST
C         ARGUMENT
C
               CALL CUNIT
               JE = J + 1
               JF = JE
               GO TO 12
            END IF
C
C         SCAN FOR END OF THE FIRST ARGUMENT, IT MAY BE THE UNIT
C         DESIGNATION
C
            DO 11 I1 = JE,KB
C
C         TEST FOR A COMMA OR A RIGHT PARENTHESIS
C
            IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CRPAR)
     1         GO TO 12
 11         CONTINUE
C
C         NO COMMA EXISTS; TEST FOR A VARIABLE NAME UNIT WITHOUT THE
C         UNIT= DESIGNATION
C
            IF(CSTMT(JE:JE+4) .NE. 'UNIT=') THEN
               IF(CSTMT(JE:JE) .GE. CAA .AND. CSTMT(JE:JE) .EQ. CZZ .OR.
     1            CSTMT(JE:JE) .EQ. CUNDER) THEN
                  CALL CUNIT
                  JE = J + 1
                  JF = JE
                  GO TO 12
               END IF
               GO TO 12
            END IF
         ELSE
C
C         NO LEFT PARENTHESIS FOLLOWS THE CLOSE STATEMENT, THIS IS AN
C         ERROR
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
            GO TO 19
         END IF
C
C         SEARCH FOR ARGUMENTS WITH AN EQUAL SIGN FOLLOWING THE
C         UNIT DESIGNATION
C
C         IF THE INDEX VALUE OF JE POINTS TO A COMMA IN CSTMT(JE:JE),
C         THEN INCREMENT JE BY ONE TO THE NEXT CHARACTER AND BYPASS
C         ANY FURTHER UNIT INDENTIFICATION PROCESSING
C
 12      IF(CSTMT(JE:JE) .EQ. COMMA) THEN
            JE = JE + 1
            JF = JE
            L5 = LTRUE
         END IF
 13      DO 18 I = JE,KB
C
C         TEST IF A COMMA WAS FOUND
C
            IF(L5) THEN
               L5 = LFALSE
               GO TO 16
            END IF
C
C         TEST IF AN EQUAL SIGN WAS FOUND
C
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            I1 = I + 1
C
C         SCAN BACKWARDS TO LOCATE THE START OF THE COMMAND ARGUMENT
C
            DO 14 IA = JE,I
            IB = I - (IA - JE + 1)
            IF(CSTMT(IB:IB) .EQ. CLPAR .OR. CSTMT(IB:IB) .EQ. COMMA)
     1         THEN
               JF = IB + 1
               GO TO 16
            END IF
 14         CONTINUE
C
C         IF THE CHARACTER PRECEDING THE START CHARACTER IS A COMMA,
C         A LEFT PARENTHESIS, OR A RIGHT PARENTHESIS, DO NOT WRITE A
C         DIAGNOSTIC MESSAGE
C
            IF(CSTMT(IB-1:IB-1) .EQ. CLPAR .OR. CSTMT(IB-1:IB-1) .EQ.
     1         COMMA) GO TO 16
            GO TO 15
         END IF
         GO TO 18
C
C         AN ERROR OCCURRED, NO CLOSING COMMA OR LEFT PARENTHESIS
C
 15      IF(.NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 19
         END IF
C
C         DETERMINE WHICH ARGUMENT IS TO BE PROCESSED. THESE ARE
C         DISP, DISPOSE, ERR, IOSTAT, STATUS, AND UNIT
C
 16      J = JF
         JG = JF + 1
C
C         TEST IF UNIT CONTROL ARGUMENT
C
         IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
            CALL CUNIT
            JG = J
            GO TO 17
         END IF
C
C         TEST FOR A DISPOSE OR DISP CONTROL ARGUMENT
C
         IF(.NOT.L1) THEN
            ID = 11
            LA = LFALSE
            LB = L1
            L6 = LTRUE
            L7 = LTRUE
            L8 = LFALSE
            L9 = LFALSE
            CALL CIOLST
         END IF
         IF(LA) THEN
            LA = LFALSE
            J = JB
            JG = JB
            GO TO 17
         END IF
C
C         TEST FOR A ERR CONTROL ARGUMENT
C
         IF(.NOT.L2) THEN
            ID = 13
            LA = LFALSE
            LB = L2
            L6 = LFALSE
            L7 = LFALSE
            L8 = LFALSE
            L9 = LTRUE
            CALL CIOLST
         END IF
         IF(LA) THEN
            LA = LFALSE
            J = JB
            JG = JB
            GO TO 17
         END IF
C
C         TEST FOR IOSTAT CONTROL ARGUMENT
C
         IF(.NOT.L3) THEN
            ID = 21
            LA = LFALSE
            LB = L3
            L6 = LFALSE
            L7 = LTRUE
            L8 = LFALSE
            L9 = LFALSE
            CALL CIOLST
         END IF
         IF(LA) THEN
            LA = LFALSE
            J = JB
            JG = JB
            GO TO 17
         END IF
C
C         TEST IF STATUS CONTROL ARGUMENT
C
         IF(.NOT.L4) THEN
            ID = 41
            LA = LFALSE
            LB = L4
            L6 = LTRUE
            L7 = LTRUE
            L8 = LFALSE
            L9 = LFALSE
            CALL CIOLST
         END IF
         IF(LA) THEN
            LA = LFALSE
            J = JB
            JG = JB
            GO TO 17
         END IF
C
C         IF LA IS FALSE, NO MATCH WAS FOUND, WRITE AN ERROR MESSAGE
C
         IF(.NOT.LA .AND. .NOT.LINCL) THEN
            WRITE (0,101) ISN
            IREC0 = IREC0 + 2
            GO TO 18
         END IF
C
C         DETERMINE IF THE END OF THE COMMAND LIST REACHED
C
 17      IF(CSTMT(JG:JG) .EQ. CRPAR) THEN
            J = JG
            GO TO  19
         ELSE
            JE = JG
            GO TO 13
         END IF
 18      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 19   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES COMMON AND RECORD STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBAR   - CHARACTER VARIABLE, THE CHARACTER: |
C         CBLANK - CHARACTYER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THESE CODES AND THEIR MEANINGS ARE:
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CLEN   - CHARACTER VARIABLE, THE LENGTH VALUE FOR THE ENTIRE
C                  TYPE STATEMENT. COL 1 WILL CONTAIN AN ASTERISK TO
C                  INDICATE THAT SUBROUTINE TYPLST IS PROCESSING A
C                  COMMON STATEMENT.
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM, INCLUDING ALL VARIABLE NAMES
C                  BROUGHT INTO A PROGRAM MODULE BY USING AN INCLUDE
C                  STATEMENT.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 C*32   8  CALLED SUBPROGRAM NAME
C                 33 - 34 I*4    9  ISN OF THE CALL STATEMENT
C                 37      C*1       SUBPROGRAM NAME DATA TYPE
C                 38 - 44 C*7   11  SUBPROGRAM NAME DATA LENGTH
C                 45 - 48 C*4   12  32 BIT SWITCHES FOR THE SUBPROGRAM
C                                   NAME ATTRIBUTES. IF BIT IS ZERO,
C                                   SWITCH IS OFF; IF BIT IS ONE,
C                                   SWITCH IS ON.
C                 49 - 52 I*4   13  NUMBER OF CHARACTERS IN THE CALLED
C                                   SUBPROGRAM NAME IN COLUMNS 1 - 32
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. THIS TABLE DOES NOT CONTAIN ANY THE VARIABLES
C                  IN A COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 500
C                  PARAMETER STATEMENTS IN A ROUTINE ARE ALLOWED
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  C*32   8  VARIABLE NAME
C                  33-36  I*4    9  ISN VALUE
C                  37-44  C*8   11  DATA TYPE & LENGTH
C                  45-48  I*4   12  NUMERIC VALUE OF INTEGER VARIABLES
C                                   ONLY. OTHER DATA TYPES LEAVE THIS
C                                   FIELD BLANK
C                  49 - 52  I*4 13  LENGTH OF THE VARIABLE NAME IN
C                                   COLS 1 - 32
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRECTB - TABLE OF RECORD VARIABLE NAMES AND THEIR LENGTH.
C                  A MAXIMUM OF 1000 RECORD VARIABLE NAME DEFINITIONS
C                  ARE ALLOWED.
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 C*32   8  STRUCTURE VARIABLE NAME
C                 33 - 64 C*32  16  RECORD VARIABLE NAME
C                 65 - 68 I*4   17  INTEGER VALUE OF THE LENGTH OF
C                                   THE RECORD DEFINITION
C         CREC11 - CHARACTER VARIABLE, EQUIVALENCED TO IREC11
C         CSEVEN - CHARACTER VARIABLE, A SEVEN CHARACTER WORK AREA USED
C                  TO DETERMINE IF A COMMON OR A RECORD STATEMENT IS
C                  BEING PROCESSED
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSTR   - TABLE OF ALL STRUCTURE NAMES FOR THE CURRRENT PROGRAM
C                  MODULE BEING PROCESSED. A MAXIMUM OF 1000 STRUCTURE
C                  DEFINITIONS MAY OCCUR.
C                  RECORD STURUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CTYPED - THE DATA TYPE CODE.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWK40  - CHARACTER VARIABLE, BUFFER TO CREATE A TABLE ENTRY
C                  FOR COMTBL
C         CWK44  - CHARACTER VARIABLE, WORK AREA TO CREATE A RECORD FOR
C                  OUTPUT UNIT 11; RECORD STRUCTURE IS:
C                  COLS TYPE WORD DESCRIPTION
C                  1-32 C*32   8  VARIABLE NAME
C                 33-36 I*4    9  LENGTH OF THE VARIABLE NAME IN COLS
C                                 1-32; SET NEGATIVE FOR THE COMMON
C                                 BLOCK NAME; SET POSITIVE FOR VARIABLE
C                                 NAMES BELONGING TO THE BLOCK.
C                    37 C*1       THE VARIABLE DATA TYPE IN COLS. 1-32
C                 38-44 C*7   11  THE VARIABLE'S LENGTH CHARACTERISTIC
C         CWK68  - CHARACTER VARIABLE, 68 CHARACTER BUFFER FOR INSERTION
C                  IN THE CRECTB TABLE. THIS TABLE DOES NOT CONTAIN
C                  VARIABLE NAMES DEFINED WITHIN A RECORD DEFINITION;
C                  ONLY THE RECORD DEFINTION STATEMENT NAMES ARE IN THIS
C                  TABLE.
C         CWK104 - CHARACTER VARIABLE, WORK AREA TO CREATE AN ENTRY FOR
C                  UNIT 11 AND CDIM; COLS, 33 -36 ARE NEGATIVE IF THE
C                  VARIABLE NAME IS A BLOCK NAME ENCAPSULATED IN SLASHES
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         ICOMKT - COUNT OF ENTRIES IN COMTBL, A LIST OF ALL COMMON
C                  BLOCK NAMES
C         ICTN   - THE VALUE TO ADD TO AN INTEGER DIGIT TO CONVERT IT
C                  TO A TEXT DIGIT, OT TO SUBTRACT FROM A TEXT DIGIT
C                  TO CONVERT IT TO AN INTEGER DIGIT.
C         ILEN   - LENGTH OF THE VARIABLE NAME, EQUIVALENCED TO CWK104
C         ILOC1  - LOCATION OF THE FIRST SLASH OF THE COMMON BLOCK
C                  NAME OR STRUCTURE NAME
C         ILOC2  - LOCATION OF THE LAST SLASH OF THE COMMON BLOCK
C                  NAME OR STRUCTURE NAME
C         IP     - NUMBER OF ENTRIES IN TABLE CPARAM, THE LIST OF
C                  INTEGER PARAMETER VARIABLE DEFINTIONS
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINITIONS
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IREC11 - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 11 (COMMON DEFINITIONS)
C         IRET   - RETURN VALUE FROM TABLE SEARCH
C         IRET1  - RETURN VALUE FROM TABLE SEARCH
C         IRET2  - RETURN VALUE FROM TABLE SEARCH
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISTR   - EQUIVALENCED TO CSTR
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK;
C                  THE ISN IS NEGATIVE WHEN THE VARIABLE NAME IS THE
C                  COMMON BLOCK NAME, POSITIVE OTHEERWISE
C         IZERO  - AN INTEGER ZERO VALUE
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  A VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I2WK1  - PROVIDE THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST. THIS VALUE MUST BE
C                  ZERO FOR COMMON OR RECORD STATEMENTS.
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE
C         I4WK1  - SAVE AREA OF THE LOCATION OF THE FIRST CHARACTER
C                  AFTER THE SECOND SLASH ENCAPSULATING A COMMON OR
C                  RECORD NAME
C         I5     - LOCATION OF THE FIRST CHARACTER FOLLOWING THE
C                  VARIABLE NAME OF A COMMON VARIABLE. IT IS USED TO
C                  TEST IF THE DIMENSION SPECIFICATIONS CONTAIN A
C                  DUMMY ARGUMENT, OR IF THE SUBSCRIPT VALUE IS A
C                  PARAMETER VARIABLE OF A DEFINED CONSTANT.
C         I6     - THE VALUE OF I4 + 1; THIS REPRESENTS THE POSSIBLE
C                  START LOCATION OF A VARIABLE NAME.
C         I7     - THE END LOCATION OF A POSSIBLE VARIABLE NAME
C         I8     - COUNT OF THE TOTAL NUMBER OF LEFT PARENTHESES
C         I9     - INDEX OF TABLE CIMPLE FOR THE FIRST CHARACTER OF A
C                  VARIABLE NAME
C         I10    - LOCATION OF A LEFT PARENTHESIS TERMINATING A
C                  NAME
C         I11    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS LOCATED BY I10
C         I12    - WORK AREA TO CREATE LENGTH DEFINITION FOR A RECORD
C                  FROM ITS STRUCTURE REFERENCE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE END OF THE BLOCK COMMON NAME
C         JB     - LENGTH OF THE BLOCK COMMON NAME
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         JC     - COUNT OF THE NUMBER OF SLASHES
C         JD     - LOCATION OF THE FIRST CHARACTER AFTER THE FINAL SLASH
C                  DELINEATING THE END OF A COMMON OR RECORD NAME
C         JE     - SUBSCRIPT VARIABLE
C         JISN   - THE ISN FOR A BLANK COMMON DEFINITION. EQUIVALENCED
C                  TO CWORK(9:12)
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT FOR A GIVEN NEST
C                  LEVEL OF THE UNION.
C         JNUM1  - NUMBER OF SUBSCRIPTS SPECIFIED FOR A DIMENSIONED
C                  VARIABLE IN CDIM, EQUIVALENCED TO CWK96
C         JSTART - THE STARTING VALUE OF A SUBSCRIPT RANGE FOR EACH
C                  SUBSCRIPT DEFINED FOR A VARIABLE.  DEFAULT VALUE IS 1
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUCT
C         JSTRUC - COUNT OF THE LEVELS OF NESTED STRUCTURE STATEMENTS.
C                  ONE IS ADDED WHEN A STRUCTURE STATEMENT IS PROCESSED,
C                  ONE IS SUBTRACTED WHEN AN END STRUCTURE STATEMENT IS
C                  PROCESSED. THIS CONTROL ENTRIES INTO TABLE CSTRN.
C         J1     - WORK VARIABLE, USED TO SELECT THE CORRECT DEFAULT
C                  TYPE AND LENGTH OF A COMMON VARIABLE
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KDNUM  - THE VALUE OF A DIMENSION SPECIFICATION, A MAXIMUM
C                  OF SEVEN MAY OCCUR. THIS VALUE MAY BE MODIFIED BY
C                  IFLL WHEN A DIMENSION RANGE IS SPECIFIED;
C                  EQUIVALENCED TO CWK96
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KLEN   - NUMBER OF CHARACTERS IN THE COMOM OR RECORD NAME.
C                  EQUIVALENCED TO CWK44(33:36)
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN ENTRY IS FOR ANALYSIS
C                  OF A RECORD STATEMENT, SET FALSE TO ANALYZE A COMMON
C                  STATEMENT
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LREC   - LOGICAL VARIABLE, SET TRUE WHEN PROCESSING A RECORD
C                  STATEMENT, SET FALSE OTHERWISE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A COMMON OR RECORD
C                  VARIABLE NAME IS DIMENSIONED, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE LENGTH HAS BEEN
C                  SET AND IS NOT TO BE CHANGED FOR A VARIABLE, SET
C                  FALSE OTHERWISE. THIS SWITCH IS USED TO INSURE THAT
C                  LENGTH CHARACTERISTICS ARE NOT CHANGED AFTER THEY HAVE
C                  BEEN SET WHEN MULTIPLE VARIABLE NAMES OCCUR.
C         L3     - LOGICAL VARIABLE, SET FALSE WHILE THE RECORD OR
C                  COMMON BLOCK NAME IS BEING PROCESSED, SET TRUE WHEN
C                  THE COMMON BLOCK OR RECORD VARIABLE NAMES ARE BEING
C                  PROCESSED
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE COMMON BLOCK
C                  CURRENTLY BEING PROCESSED IS BLANK COMMON, SET FALSE
C                  OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A COLON OCCURS WITHIN
C                  ENCAPSULATING LEFT AND RIGHT PARENTHESIS, SET FALSE
C                  OTHERWISE. THIS INDICATES A SUBSCRIPT DESIGNATION
C                  EXISTS WHEN FALSE.
C         L6     - LOGICAL VARIABLE, SET TRUE TO PREVENT WRITING A
C                  RECORD ON UNIT 11 FOR A COMMON VARIABLE. SET FALSE TO
C                  ALLOW WRITING A RECORD ON UNIT 11 FOR A COMMON
C                  VARIABLE IN ROUTINE TYPLST.
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN TWO SEQUENTIAL
C                  SLASHES OCCUR, SET FALSE OTHERWISE. THIS INDICATES A
C                  COMMON BLOCK IS BLANK COMMON. A RECORD STATEMENT CAN
C                  NOT HAVE A BLANK NAME.
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C         MAPLEN - MAXIMUM SIZE OF A MAP DEFINITION
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         THE COMMON BLOCK NAME FOR EITHER NAMED OR BLANK COMMON IS
C         PROCESSED BY THIS ROUTINE AND NOT IN ROUTINE TYPLST
C
C         A COMMON DEFINITION HAS THE FORM:
C
C         COMMON /{name1}/{variable list}, /{name2/{variable list}, ETC.
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         COMMON AND RECORD STATEMENTS CAN NOT CONTAIN VARIABLE LENGTH,
C         [LENGTH], AND DATA SPECIFICATIONS, [DATA]
C
C         WHEN COLUMN 37 OF CWORK CONTAINS THE CHARACTER, |, THIS WILL
C         CAUSE THE PRINT ROUTINE FOR VARIABLE NAMES TO OMIT ANY LENGTH
C         AND TYPE CODES. THIS IS USED TO PREVENT THE COMMON NAME FROM
C         BEING PROCESSED AS A NORMAL VARIABLE NAME.
C
C         A DIMENSIONED VARIABLE IN COMMON THAT HAS AS ITS DIMENSION
C         SPECIFICATION A DUMMY VARIABLE WHOSE VALUE IS KNOWN ONLY
C         DURING EXECUTION WILL NOT ALLOW THE TOTAL COMMON BLOCK LENGTH
C         TO BE COMPUTED ACCURATELY BY THIS PROGRAM.
C
C         NO VARIABLE IN A COMMON OR RECORD STATEMENT MAY BE A COMPOUND
C         VARIABLE NAME.
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C        11      - COMMON DEFINITIONS FOR NAMED AND BLANK COMMON
C                  THIS FILE IS USED IN SUBROUTINE PCOMM TO CREATE
C                  THE LISTING
C
C                  COLS  1 - 32 VARIABLE NAME
C                  COLS 33 - 36 LENGTH OF THE VARIABLE NAME IN COLS 1-32
C                               SET NEGATIVE IF THE COMMON BLOCK NAME,
C                               SET POSITIVE FOR ALL VARIABLES BELONGING
C                               TO THE BLOCK
C                  COLS 37 - 44 VARIABLE TYPE AND LENGTH DEFINITIONS
C
C                  IF THE COMMON BLOCK IS DEFINED AS BLANK COMMON,
C                  COLUMNS 9 - 12 CONTAIN THE INTEGER VALUE OF THE ISN.
C                  NAMED COMMON BLOCKS DO NOT USE THESE LOCATIONS FOR
C                  THIS PURPOSE SINCE THE VARIABLE NAME MAY BE UP TO 32
C                  CHARACTERS IN LENGTH. THIS PROVIDES THE ISN FOR BLANK
C                  COMMON WHEN THERE IS LENGTH DISCREPENCY BETWEEN
C                  SUBPROGRAM DEFINITIONS.
C
C     SUBROUTINES CALLED
C
C         BTEST CHKNME EXPR IBCLR IBSET ITOC SETTL TABINS TABSRH TBLSRH
C
C     *****************************************************************
C
      SUBROUTINE STMT10 (LA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ISTR(9,1000), JSTART(7), KDNUM(7)
      DIMENSION JMAP(20), MAPLEN(20,20)
      DIMENSION ICOMTB(10,200), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION, CWK44
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8, CKLEN
      CHARACTER*4     CI4WK1, CREC11
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*104 CWK104
      CHARACTER*7   CLEN, CSEVEN
      LOGICAL*1     LA, L1, L2, L3, L4, L5, L6, L7, L8
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /MUS/ JMAP, MAPLEN
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (I2WK1,CI2WK1), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWORK(9:12),JISN), (I4WK1,CI4WK1), (IREC11,CREC11)
      EQUIVALENCE (CWK104(33:36),ILEN), (CWK104(37:40),JNUM1),
     1(CWK104(41:68),KDNUM(1)), (CWK104(69:72),JSTART(1))
      EQUIVALENCE (CSTR,ISTR), (CWK8(2:2),CWK7)
      EQUIVALENCE (COMTBL,ICOMTB)
      EQUIVALENCE (CKLEN,KLEN)
C
C         DATA STATEMENTS
C
      DATA IZERO/0/
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALANC
     1ED SLASHES')
 101  FORMAT(' ISN:',I6,' DUMMY VARIABLE DIMENSIONING COMMON BLOCK ',
     1A32)
 102  FORMAT(' ISN:',I6,' LENGTH NOT DEFINED FOR STRUCTURE: ',A32)
 103  FORMAT(' ISN:',I6,' MORE THAN TWO SLASHES IN A RECORD STATEMENT')
 104  FORMAT(' ISN:',I6,' MORE THAN 200 COMMON BLOCKS')
 105  FORMAT(' ISN:',I6,' COMMON STATEMENT HAS ILLEGAL SYNTAX: ',A9)
C
C         INITIALIZE WORK AREAS
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CWK68(1:50) = CBLK52(1:50)
      CWK68(51:68) = CBLK52(1:18)
      CWK104(1:52) = CBLK52(1:52)
      CWK104(49:104) = CBLK52(1:52)
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      J = KF + 5
      JD = 0
      I5 = 0
      LEXEC =  LFALSE
      LFORCE = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L7 = LFALSE
C
C         SET STATEMENT DESIGNATION FOR COMPARE
C
      IF(LA) THEN
         CSEVEN = 'RECORD'
      ELSE
         CSEVEN = 'COMMON'
      END IF
C
C         SCAN FOR SLASHES OCCURRING IN A COMMON OR RECORD STATEMENT.
C         SLASHES ENCAPSULATE A COMMON BLOCK NAME OR A THE STRUCTURE
C         NAME OF A RECORD STATEMENT.
C
      JC = 0
      ILOC1 = 0
      ILOC2 = 0
      DO 9 I = J,KB
      IF(CSTMT(I:I) .EQ. CSLASH) THEN
         JC = JC + 1
         IF(LA) THEN
C
C         DETERMINE THE LOCATION OF THE RECORD SLASHES. THIS DELINEATES
C         THE STRUCTURE NAME REFERENCED.
C
            IF(JC .EQ. 1) ILOC1 = I
            IF(JC .EQ. 2) ILOC2 = I
         ELSE
C
C         DETERMINE IF A SLASH OCCURS WITHIN ENCAPSULATED PARENTHESES.
C         THIS IMPLIES THE COMMON STATEMENT CONTAINS VARIABLE DIMENSION
C         SPECIFICATIONS.
C
            DO JE = I,1,-1
            IF(CSTMT(JE:JE) .EQ. CLPAR) THEN
               DO I4 = I,KB
               IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
                  IF(I .GT. JE .AND. I .LT. I4) THEN
                     JC = JC - 1
                     GO TO 9
                  END IF
               END IF
               END DO
            END IF
            END DO
         END IF
         GO TO 9
      END IF
C
C       SCAN FOR AN EQUAL SIGN; IF FOUND THEN THIS IS AN ARITHMETIC
C       STATEMENT.
C
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         LSTART = LTRUE
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         GO TO 21
      END IF
 9    CONTINUE
C
C         IF AN ODD NUMBER OF SLASHES OCCUR, A SYNTAX ERROR EXISTS
C
      IF(MOD(JC,2) .GT. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         DETERMINE IF A RECORD STATEMENT HAS MORE THAN TWO SLASHES.
C
      IF(LA) THEN
         IF(JC .GT. 2) THEN
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
            GO TO 21
         END IF
      END IF
C
C         VERIFY THE STATEMENT
C
      IF(CSTMT(KF:J) .EQ. CSEVEN(1:6)) THEN
         J = J + 1
         LEXEC =  LTRUE
C
C         SET SWITCH FOR COMMON OR RECORD STATEMENT
C
         IF(LA) THEN
            JBITS = IBSET(JBITS,2)
         ELSE
            JBITS = IBSET(JBITS,11)
            JBITS = IBCLR(JBITS,2)
         END IF
C
C         DETERMINE IF THE INITIAL SLASH IS IMMEDIATELY FOLLOWED BY A
C         SLASH. THIS INDICATES THAT THIS COMMON BLOCK IS BLANK COMMON
C
 10      IF(CSTMT(J:J) .EQ. CSLASH .AND. CSTMT(J+1:J+1) .EQ. CSLASH)
     1      L7 = LTRUE
C
C         TEST IF THE FIRST NAME IS ENCAPSULATED IN SLASHES. WHEN
C         SLASHES EXIST, THE VARIABLE NAME IS THE COMMON BLOCK NAME,
C         OR IT IS THE STRUCTURE NAME FROM WHICH A RECORD VARIABLE
C         ACQUIRES ITS LENGTH DEFINITION. IF NO SLASH EXISTS, THEN THE
C         NAME MUST BE THE FIRST VARIABLE NAME IN BLANK COMMON.
C
         IF(CSTMT(J:J) .EQ. CSLASH .AND. .NOT.L7) THEN
            J = J + 1
C
C         FIND THE LIMIT OF THE NAMED COMMON BLOCK VARIABLE OR THE
C         STRUCTURE NAME IN A RECORD STATEMENT; NEITHER CAN BE A
C         STRUCTURE COMPOUND VARIABLE NAME. IF THE VARIABLE NAME IS A
C         STRUCTURE NAME, THEN THE STRUCTURE DEFINITION MUST PRECEDE
C         THE OCCURRENCE OF THE RECORD STATEMENT. A RECORD STATEMENT CAN
C         NOT BE NESTED.
C
            DO 12 I = J,KB
C
C         DETERMINE THE LOCATION OF THE CLOSING SLASH OF THE COMMON
C         BLOCK NAME OR THE STRUCTURE NAME OF THE RECORD SPECIFICATION,
C         AND SAVE THE LOCATION OF THE FIRST CHARACTER FOLLOWING THE
C         CLOSING SLASH.
C
            IF(CSTMT(I:I) .EQ. CSLASH) THEN
               JD = I + 1
               JA = I - 1
               JB = I - J
               NA = I
               IVCNT = JB
               ILEN = JB
C
C         DETERMINE IF TWO SEQUENTIAL SLASHES OCCUR IN A COMMON
C         STATEMENT. WHEN THIS OCCURS, THIS IS BLANK COMMON DEFINITION.
C
C         SAVE THE COMMON BLOCK NAME OR THE STRUCTURE NAME REFERRED TO
C         BY THE RECORD STATEMENT
C
               CWORK(1:JB) = CSTMT(J:JA)
C
C         TEST IF A COMMON OR RECORD STATEMENT
C
               IF(.NOT.LA) THEN
C
C         THIS IS A COMMON STATEMENT
C
                  IWORK = JB
                  CWK104(1:JB) = CWORK(1:JB)
                  IF(.NOT.LINCL) THEN
C
C         DETERMINE IF THE NUMBER OF COMMON BLOCK DEFINITIONS EXCEEDS
C         200 AND WRITE ERROR MESSAGE IF TRUE
C
                     IF(ICOMKT .GT. 200) THEN
                        WRITE (0,104)
                        IREC0 = IREC0 + 1
                        GO TO 110
                     END IF
                     ICOMKT = ICOMKT + 1
                     COMTBL(ICOMKT)(1:40) = CWORK(1:32)//CWORK(49:52)//
     1                                      CREC11(1:4)
C
C         DETERMINE IF A TYPE AND LENGTH HAVE BEEN DEFINED FOR THIS
C         VARIABLE
C
                     IF(CWORK(37:44) .EQ. CBLANK(1:8)) THEN
C
C         DETERMINE IF THE VARIABLE ALREADY HAS BEEN DEFINED
C
                        CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,
     1                               IRET,4000)
                        IF(IRET .GT. 0) THEN
C
C         USE THE PREVIOUS TYPE AND LENGTH DEFINITION OF THE VARIABLE
C
                           CWORK(37:44) = CNAME(IRET)(37:40)
                        ELSE
C
C         WHEN THE VARIABLE HAS NOT ALREADY BEEN DEFINED, USE THE
C         DEFAULT DESIGNATION
C
                           CWORK(37:44) = CBAR(1:1)//CBLANK(1:7)
                        END IF
                     END IF
                     IF(CWORK(37:37) .EQ. CBAR) KLEN = -IVCNT
                     CWK44(1:44) = CWORK(1:32)//CKLEN(1:4)//CWORK(37:44)
                     IF(.NOT.LINCL) THEN
                        WRITE (11,REC=IREC11) CWK44(1:44)
                        IREC11 = IREC11 + 1
                     END IF
 110                 CONTINUE
                  END IF
                  JNUM1 = 0
                  IWORK = ISN + 128
                  CWORK(37:44) = CBAR(1:1)//CBLANK(1:7)
                  JBITS = IBSET(JBITS,11)
                  JBITS = IBCLR(JBITS,13)
               ELSE
C
C         THIS IS A RECORD STATEMENT; SAVE THE STRUCTURE VARIABLE NAME
C         REFERRED TO BY THE RECORD STATEMENT.
C
                  CWK68(1:32) = CWORK(1:32)
                  CWORK(37:37) = CQUES
                  ILEN = JB
C
C         DETERMINE THE LENGTH OF THE STRUCTURE THE RECORD STATEMENT
C         REFERS TO
C
                  CALL TABSRH (CSTR,ISTRUC,36,1,32,CWK68,1,32,IRET,1000)
                  IF(IRET .GT. 0) THEN
                     CWK68(65:68) = CSTR(IRET)(33:36)
                     CI4WK1 = CSTR(IRET)(33:36)
                     CALL ITOC (I4WK1,CLEN,1,7)
                     CWORK(38:44) = CLEN(1:7)
C
C         ADD THE LENGTH OF THE RECORD TO A STRUCTURE LENGTH WHEN THE
C         RECORD OCCURS WITHIN A STRUCTURE DEFINITION
C
                  ELSE
                     IF(.NOT.LINCL) THEN
                        WRITE (0,102) ISN,CWK68(1:32)
                        IREC0 = IREC0 + 1
                     END IF
                  END IF
               END IF
               IWORK = ISN + 128
               IF(LA) THEN
                  JBITS = IBSET(JBITS,2)
               ELSE
                  JBITS = IBSET(JBITS,11)
               END IF
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C         THIS CALL TO ROUTINE CHKNME ADDS THE STRUCTURE NAME OF A
C         RECORD STATEMENT OR THE COMMON BLOCK NAME TO CNAME.
C
               CALL CHKNME (CSTMT)
               JC = JA + 2
               GO TO 14
            END IF
 12         CONTINUE
         ELSE
C
C         THE FIRST CHARACTER AFTER THE COMMAND IS NOT A SLASH
C
            IF(.NOT.LA) THEN
C
C         THIS IS A BLANK COMMON STATEMENT; SET UP CWORK
C
               L4 = LTRUE
               DO 13 I = J,KB
               IF(.NOT.(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ)
     1            .AND. .NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I)
     2            .LE.C9) .AND. .NOT.CSTMT(I:I) .EQ. CUNDER .AND.
     3             .NOT.CSTMT(I:I) .EQ. CDOL .OR. I .EQ. KB) THEN
                  IWORK = ISN + 128
                  IVCNT = 6
                  ILEN = 6
                  JISN = -ISN
                  IF(.NOT.LINCL) THEN
C
C         DETERMINE IF THE NUMBER OF COMMON BLOCK DEFINITIONS EXCEEDS
C         200 AND WRITE ERROR MESSAGE IT TRUE
C
                     IF(ICOMKT .GT. 200) THEN
                        WRITE (0,104)
                        IREC0 = IREC0 + 1
                        GO TO 120
                     END IF
                     ICOMKT = ICOMKT + 1
                     COMTBL(ICOMKT)(1:40) = CWORK(1:32)//CWORK(49:52)//
     1                                      CREC11(1:4)
C
C         DETERMINE IF A TYPE AND LENGTH HAVE BEEN DEFINED FOR THIS
C         VARIABLE
C
                     IF(CWORK(37:44) .EQ. CBLANK(1:8)) THEN
C
C         DETERMINE IF THE VARIABLE ALREADY HAS BEEN DEFINED
C
                        CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,
     1                               IRET,4000)
                        IF(IRET .GT. 0) THEN
C
C         USE THE PREVIOUS TYPE AND LENGTH DEFINITION OF THE VARIABLE
C
                           CWORK(37:44) = CNAME(IRET)(37:44)
                        ELSE
C
C         WHEN THE VARIABLE HAS NOT ALREADY BEEN DEFINED, USE THE
C         DEFAULT DESIGNATION
C
                           J1 = ICHAR(CWORK(1:1)) - ICTN
                           CWORK(37:44) = CIMPL(J1)(1:8)
                        END IF
                     END IF
                     IF(CWORK(1:6) .EQ. CBLANK(1:6) .AND. CWORK(37:44)
     1                  .EQ. CBLANK(1:8) .AND. IVCNT .EQ. IZERO)
     2                  GO TO 120
                     KLEN = IVCNT
                     CWK44(1:44) = CWORK(1:32)//CKLEN(1:4)//CWORK(37:40)
C
C         WRITE THE BLANK COMMON BLOCK NAME RECORD ON UNIT 11
C
                     IF(.NOT.LINCL) THEN
                        WRITE (11,REC=IREC11) CWK44(1:44)
                        IREC11 = IREC11 + 1
                     END IF
 120                 CONTINUE
                  END IF
                  IWORK = ISN + 128
                  CWORK(9:12) = CBLANK(1:4)
                  IF(CSTMT(J:J) .EQ. CSLASH) THEN
                     J = I
                  ELSE
                     IF(J .LE. 7) THEN
                        J = 7
                     ELSE
                        J = I - 2
                     END IF
                     JD = J
                  END IF
                  GO TO 14
               END IF
 13            CONTINUE
            END IF
         END IF
C
C         PROCESS THE REMAINDER OF THE COMMON OR RECORD STATEMENT AS
C         THOUGH IT IS A TYPE STATEMENT; COMMON STATEMENTS MAY CONTAIN
C         LENGTH SPECIFICATI0NS, BUT A RECORD VARIABLE NAME DERIVES ITS
C         LENGTH FROM THE STRUCTURE TO WHICH IT REFERS; SLASHES MAY
C         OCCUR ONLY FOR THE COMMON BLOCK NAME OR THE STRUCTURE NAME;
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO BEGIN
C         PROCESSING.
C
C         SCAN TO FIND THE ALL SPECIFICATIONS FOR EVERY VARIABLE NAME
C         IN THE COMMON OR RECORD STATEMENT. INDIVIDUAL VARIABLES MAY
C         HAVE DIMENSION SPECIFICATIONS. THE RECORD VARIABLE NAME HAS
C         LENGTH BUT NO DATA TYPE DEFINITION, AND IT MAY BE PLACED IN
C         A COMMON BLOCK. THE LENGTH IS DETERMINED BY THE STRUCTURE
C         LENGTH TO WHICH THE RECORD STATEMENT REFERS. IMPLICIT
C         STATEMENTS HAVE NO EFFECT ON ANY RECORD VARIABLE NAME.
C
 14      IF(JD .NE. 0) THEN
            J = JD
         ELSE
            J = I4WK1
         END IF
         I1 = 0
         I2 = J
C
C         CLEAR THE WORK AREA
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
C
C         SET SWITCH FOR COMMON OR RECORD STATEMENT
C
         IF(LA) THEN
            JBITS = IBSET(JBITS,2)
            J = ILOC2 + 1
         ELSE
            JBITS = IBSET(JBITS,1)
         END IF
C
C         SET THE START LOCATION OF THE FIRST COMMON OR RECORD VARIABLE
C         NAME
C
C        I2 = J
         L1 = LFALSE
C
C         LOOP FOR EACH VARIABLE NAME FOLLOWING THE COMMON DEFINITION
C         NAME OR THE RECORD STRUCTURE NAME
C
         IF(.NOT.L4) THEN
            J = NA + 1
            I2 = J
         END IF
         I10 = 0
         I11 = 0
         DO 20 I4 = J,KB
         L2 = LFALSE
         CWORK(37:44) = CBLANK(1:8)
         CTYPED(1:1) = CBLANK(1:1)
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME PART OF A
C         COMMON BLOCK OR A RECORD DEFINITION. THIS MAY INCLUDE
C         DIMENSION SPECIFICATIONS.
C
C         WHEN A LEFT PARENTHESIS OCCURS, IT TERMINATES A VARIABLE NAME,
C         AND IMPLIES A DIMENSION SPECIFICATION FOLLOWS THE VARIABLE
C         NAME.  I2 CONTIANS THE START LOCATION OF THE VARIABLE NAME.
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I8 = I1                         ! LOCATION OF LEFT PAREN
C
C         WHEN A LEFT PARENTHESIS OCCURS THIS VARIABLE IS DIMENSIONED
C
            I5 = I4
            I10 = I4
            L1 = LTRUE
         END IF
C
C         WHEN A RIGHT PARENTHESIS OCCURS AND I1 ASSUMES A ZERO VALUE,
C         THE END OF A DIMENSION SPECIFICATION FOR THE VARIABLE NAME HAS
C         BEEN REACHED
C
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I7 = I4 - 1
            I11 = I4                        ! LOCATION OF RIGHT PAREN
         END IF
C
C         TEST IF A COMMA IS ENCAPSULATED BY PARENTHESES. IF SO, CHECK
C         IF THE NEXT ARGUMENT IS A POSSIBLE VARIABLE NAME THAT IS NOT
C         DEFINED AS A PARAMETER VARIABLE FOR A DEFINED CONSTANT. WRITE
C         A DIAGNOSTIC MESSAGE WHEN THE VARIABLE IS NOT A PARAMETER
C         VARIABLE
C
         IF(CSTMT(I4:I4) .EQ. COMMA) THEN
C
C         WHEN A COMMA OCCURS AN NO PARENTHESES EXIST, THE VARIABLE
C         IS NOT DIMENSIONED
C
            IF(I8 .EQ. 0) THEN
               I5 = I4 - 1
            ELSE
               I5 = I4
            END IF
C
C         DETERMINE IF THE COMMA IS ENCAPSULATED WITHIN PARENTHESES.
C         DO NOT PROCESS UNTIL A COMMA NOT ENCAPSULATED WITHIN
C         PARENTHESES IS FOUND. WHEN L1 IS TRUE, THE VARIABLE IS
C         DIMENSIONED.
C
            IF(L1) THEN
C
C         DETERMINE IF NO OR BALANCED PARENTHESES EXIST
C
               IF(I1 .EQ. 0) THEN
                  I5 = I4
                  L6 = LFALSE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
                  IF(I10 .GT. 0 .AND. I11 .GT. 0) THEN
                     L8 = LTRUE
                  ELSE
                     L8 = LFALSE
                  END IF
C
C         WHEN THE INITIAL CHARACTER OF THE FIELD IS ALPHABETIC,
C         OCCURENCE OF A SLASH FOLLOWING THE CHARACTER BEFORE A
C         COMMA IS AN ILLEGAL SYNTAX. A MESSAGE WILL BE WRITTEN AND
C         ROUTINE TYPLST IS NOT CALLED.
C
                  IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ
     1               .OR. CSTMT(I2:I2) .EQ. CUNDER) THEN
                     DO J1 = I2,I5
                     IF(CSTMT(J1:J1) .NE. COMMA) THEN
                        IF(CSTMT(J1:J1) .EQ. CSLASH) THEN
                           WRITE (0,105) ISN,CSTMT(I2:I2+8)
                           IREC0 = IREC0 + 1
                           GO TO 140
                        END IF
                     END IF
                     END DO
                  END IF
                  CALL TYPLST (CTYPED,CLEN,I2,I5,L8)
 140              I10 = 0
                  I11 = 0
                  L1 = LFALSE
                  JC = I4 + 1
                  I8 = 0
C
C         DETERMINE IF THE END OF THE STATEMENT
C
                  IF(I4 .EQ. KB) GO TO 21
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
                  IF(CSTMT(I4:I4) .EQ. COMMA) THEN
C
C         WHEN THE A SLASH FOLLOWS A COMMA, THIS MUST BE A NEW COMMON
C         BLOCK NAME OR A NEW STRUCTURE NAME OF A RECORD STATEMENT
C
                     IF(CSTMT(I4:I4+1) .EQ. ',/') THEN
                        J = I4 + 1
                        CWORK(1:52) = CBLK52(1:52)
                        JBITS = 0
                        GO TO 10
                     END IF
                     I1 = 0
                     I2 = I4 + 1
                     I5 = 0
                     CWORK(1:32) = CBLK52(1:32)
                     JBITS = 0
                  END IF
C
C         SET SWITCH FOR COMMON OR RECORD STATEMENT
C
                  JBIT = 0
                  IF(LA) THEN
                    JBITS = IBSET(JBITS,2)
                  ELSE
                    JBITS = IBSET(JBITS,1)
                  END IF
                  GO TO 20
               ELSE
                  GO TO 20
               END IF
            ELSE
C
C         SET INDEX VALUES FOR I2 WHEN A COMMA OCCURS, BUT NO DIMENSION
C         SPECIFICATION EXISTS. I2 IS THE LOCATION OF THE FIRST
C         CHARACTER OF THE VARIABLE NAME.
C
               IF(.NOT.L3) L3 = LTRUE
            END IF
         END IF
         IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB)
     1      THEN
            IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ .OR.
     1         CSTMT(I2:I2) .EQ. CUNDER) THEN
C
C         THE FIELD IS A VARIABLE NAME; DETERMINE THE END LOCATION OF
C         THE VARIABLE NAME.
C
               DO 15 I = I2,KB
               IF(.NOT.(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ
     1            .OR. CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9
     2            .OR. CSTMT(I:I) .EQ. CUNDER .OR. CSTMT(I:I) .EQ. CDOL)
     3            .OR. I .EQ. KB) THEN
                  IF(I .LT. KB) THEN
                     I7 = I - 1
                  ELSE
                     IF(CSTMT(I:I) .EQ. COMMA .OR. CSTMT(I:I) .EQ.
     1                  CRPAR) THEN
                        I7 = KB - 1
                     ELSE
                        I7 = KB
                     END IF
                  END IF
C
C         MOVE THE VARIABLE NAME INTO THE WORK AREA
C
                  IVCNT = I7 - I2 + 1
                  CWORK(1:IVCNT) = CSTMT(I2:I7)
C
C         INDICATE THE VARIABLE IS DIMENSIONED
C
                  IF(CSTMT(I7+1:I7+1) .EQ. CLPAR) THEN
                     IF(LA) THEN
                        L1 = LTRUE
                     ELSE
                        L1 = LFALSE
                     END IF
                  END IF
C
C         SET COMMON SWITCH ON, SET THE STRUCTURE SWITCH OFF, AND SET
C         THE COMMON DEFINITION SWITCH OFF
C
                  JBITS = IBCLR(JBITS,6)
                  JBITS = IBCLR(JBITS,11)
C
C         DETERMINE IF A RECORD OR COMMON STATEMENT IS BEING PROCESSED
C
                  IF(LA) THEN
                     GO TO 17
                  ELSE
                     GO TO 16
                  END IF
               END IF
 15            CONTINUE
               GO TO 17
C
C         SEARCH PARAMETER DEFINITION TABLE OF INTEGER VARIABLES FOR
C         COMMON STATEMENTS ONLY
C
 16            CALL TABSRH (CPARAM,IP,52,1,32,CWORK,1,32,IRET,4000)
               IF(IRET .LE. 0) THEN
                  IF(.NOT.LINCL .AND. I1 .NE. 0) THEN
                     WRITE (0,101) ISN,CWORK(1:ILEN)
                     IREC0 = IREC0 + 1
C
C         RESTORE WORK AREA TO BLANKS
C
                     CWORK(1:I7-I5) = CBLK52(1:I7-I5)
                  END IF
               END IF
            END IF
         END IF
C
C         WHEN BALANCED PARENTHESES EXIST, A COMMA TERMINATES THE
C         VARIABLE NAME SPECIFICATIONS OR THE END OF THE STATEMENT
C         OCCURS
C
 17      IF(I1 .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
C
C         DETERMINE IF THIS IS A SUBSCRIPTED VARIABLE
C
               IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
                  L5 = LFALSE
                  DO 18 JE = I5,I4
                  IF(CSTMT(JE:JE) .EQ. COLON) L5 = LTRUE
 18               CONTINUE
                  IF(.NOT.L5) THEN
                     L2 = LTRUE
                     JBITS = IBSET(JBITS,17)
                  END IF
               END IF
               L5 = LFALSE
C              CWORK(1:52) = CBLK52(1:52)
C              JBITS = 0
C
C         SET SWITCHES FOR COMMON OR RECORD STATEMENT
C
               IF(LA) THEN
C
C         SET CODES FOR RECORD STATEMENT
C
                  IF(JUNION .GT. 0) JBITS = IBSET(JBITS,5)
                  JBITS = IBSET(JBITS,2)
                  CWORK(37:37) = CQUES
C
C         INSERT THE RECORD VARIABLE NAME INTO THE WORK AREA
C
                  CWK68(33:62) = CWORK(1:32)
C
C         OBTAIN THE RECORD LENGTH FROM THE STRUCTURE DEFINITION TABLE
C         AND MOVE THE LENGTH TO CWK68
C
                  CALL TABSRH (CSTR,ISTRUC,36,1,32,CWK68,1,32,IRET,1000)
                  CWK68(65:68) = CSTR(IRET)(33:36)
C
C         SET THE LENGTH OF THE RECORD STATEMENT VARIABLE NAME
C
                  CWORK(37:37) = CQUES
                  WRITE(CWK7,'(I7)') ISTR(9,IRET)
C
C         INSERT THE RECORD VARIABLE NAME INTO ITS TABLE
C
                  CALL TABINS (CRECTB,IRECD,68,33,64,CWK68,33,64,IRET,
     1                         1000)
                  I13 = 0
                  DO I12 = 1,7
                  IF(CWK7(I12:I12) .NE. CBLANK(1:1)) I13 = I13 + 1
                  END DO
                  IF(I13 .EQ. 1) THEN
                     CWORK(38:38) = CWK7(7:7)
                  ELSE IF(I13 .EQ. 2) THEN
                     CWORK(38:39) = CWK7(6:7)
                  ELSE IF(I13 .EQ. 3) THEN
                     CWORK(38:40) = CWK7(5:7)
                  ELSE IF(I13 .EQ. 4) THEN
                     CWORK(38:41) = CWK7(4:7)
                  ELSE IF(I13 .EQ. 5) THEN
                     CWORK(38:42) = CWK7(3:7)
                  ELSE IF(I13 .EQ. 6) THEN
                     CWORK(38:43) = CWK7(2:7)
                  END IF
                  IWORK = ISN + 128
                  IF(L1) JBITS = IBSET(JBITS,17)
               ELSE
C
C         DETERMINE IF THIS COMMON VARIABLE NAME HAS ALREADY HAD ITS
C         TYPE AND LENGTH DEFINED. SINCE THIS IS A VARIABLE IN A COMMON
C         BLOCK, IT CAN NOT BE A COMPOUND VARIABLE. THIS MEANS THE
C         VARIABLE CAN NOT BE DEFINED IN A STRUCTURE OR RECORD
C         STATEMENT. WHEN A STRUCTURE OR RECORD STATEMENT OCCURS, THERE
C         MAY BE MULTIPLE OCCURENCES OF THE SAME VARIABLE NAME. THE
C         FOLLOWING CODE DISTINGUISHES THE VARIABLES SO THAT LENGTH AND
C         BIT SWITCHS ARE CORRECTLY SET.
C
                  JBITS = IBSET(JBITS,1)
                  JBITS = IBCLR(JBITS,2)
                  IF(CWORK(37:44) .EQ. CBLANK(1:8)) THEN
                     CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,
     1                           4000)
                     IF(IRET .GT. 0) THEN
                        IF(BTEST(IENAME(12,IRET),2) .OR.
     1                     BTEST(IENAME(12,IRET),6) .OR.
     2                     BTEST(IENAME(12,IRET),13)) THEN
                           IF(CNAME(IRET+1)(1:32) .EQ. CWORK(1:32))
     1                        THEN
                              IF(.NOT.(BTEST(IENAME(12,IRET+1),2)
     1                           .OR. BTEST(IENAME(12,IRET+1),6)
     2                           .OR. BTEST(IENAME(12,IRET+1),13)))
     3                           THEN
                                 IENAME(12,IRET+1) =
     1                           IBSET(IENAME(12,IRET+1),1)
                                 CLEN(1:7) = CNAME(IRET+1)(38:44)
                                 CWORK(37:44) = CNAME(IRET+1)(37:44)
                                 L2 = LTRUE
                               END IF
                            END IF
                            IF(CNAME(IRET-1)(1:32) .EQ. CWORK(1:32))
     1                         THEN
                               IF(.NOT.(BTEST(IENAME(12,IRET-1),2)
     1                            .OR. BTEST(IENAME(12,IRET-1),6)
     2                            .OR. BTEST(IENAME(12,IRET-1),13)))
     3                            THEN
                                  IENAME(12,IRET-1) =
     1                            IBSET(IENAME(12,IRET-1),1)
                                  CLEN(1:7) = CNAME(IRET-1)(38:44)
                                  CWORK(37:44) = CNAME(IRET-1)(37:44)
                                  L2 = LTRUE
                               END IF
                            END IF
                        END IF
                     END IF
                  ELSE
                     CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,
     1                            4000)
                  END IF
                  IF(.NOT.L2) THEN
                     IF(IRET .GT. 0) THEN
                        IF(CNAME(IRET)(37:44) .NE. CBLANK(1:8)) THEN
                           CWORK(37:44) = CNAME(IRET)(37:44)
                           GO TO 19
                        END IF
                     ELSE
C
C         THE VARIABLE NAME HAS NOT BEEN DEFINED YET, USE THE DEFAULT
C         DEFINITION
C
                        CALL SETTL (CWORK)
                     END IF
                  END IF
C
C         WRITE THE COMMON NAME DATA ON UNIT 11
C
 19               IF(.NOT.L1) THEN
C
C         DETERMINE IF A TYPE AND LENGTH HAVE BEEN DEFINED FOR THIS
C         VARIABLE
C
                     IF(CWORK(37:44) .EQ. CBLANK(1:8)) THEN
C
C         DETERMINE IF THE VARIABLE ALREADY HAS BEEN DEFINED
C
                        IF(LINCL) THEN
                           CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,
     1                                  IRET,4000)
                        ELSE
                           CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,
     1                                  IRET,4000)
                        END IF
                        IF(IRET .GT. 0) THEN
                           IF(CNAME(IRET)(37:37) .EQ. CBAR) THEN
C
C         DETERMINE THE DEFAULT TYPE AND LENGTH DEFINITION
C
                              J1 = ICHAR(CWORK(1:1)) - ICTN
                              CWORK(37:44) = CIMPL(J1)(1:8)
                              L6 = LTRUE
                           ELSE
                              CWORK(37:44) = CNAME(IRET)(37:44)
                           END IF
                        ELSE
C
C         WHEN THE VARIABLE HAS NOT ALREADY BEEN DEFINED, USE THE
C         DEFAULT DESIGNATION
C
                           J1 = ICHAR(CWORK(1:1)) - ICTN
                           CWORK(37:44) = CIMPL(J1)(1:8)
                        END IF
                     END IF
                     IF(IRET .LE. 0 .AND. CWORK(37:44) .NE. CBLANK(1:8))
     1                  THEN
                        KLEN = IVCNT
                        CWK44(1:44) = CWORK(1:32)//CKLEN(1:4)//
     1                  CWORK(37:44)
                        IF(.NOT.LINCL) THEN
                           WRITE (11,REC=IREC11) CWK44(1:44)
                           IREC11 = IREC11 + 1
                           END IF
                        L6 = LFALSE
                     END IF
                  END IF
               END IF
               I3 = I4
               I2WK1 = 0
               JBITS = IBSET(JBITS,15)
C
C         PROCESS THE COMMON OR RECORD VARIABLE NAMES; NOTE THAT A
C         COMPOUND VARIABLE NAME MAY NOT BE EXPLICITY PART OF A COMMON
C         BLOCK. ONLY THE VARIABLE NAMES DEFINED AS A RECORD CAN EXIST
C         IN COMMON. IF THE VARIABLE IS DIMENSIONED, CALL TYPLST;
C         OTHERWISE, CALL CHKNME.

               IF(L2) THEN
                  IF(CWORK(37:37) .NE. CBLANK(1:1)) CTYPED(1:1) =
     1               CWORK(37:37)
                  L6 = LTRUE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
                  IF(I10 .GT. 0 .AND. I11 .GT. 0) THEN
                     L8 = LTRUE
                  ELSE
                     L8 = LFALSE
                  END IF
                  CALL TYPLST (CTYPED,CLEN,I2,I4,L8)
                  L6 = LFALSE
               ELSE
C
C         DETERMINE THE VARIABLE NAME'S DEFAULT TYPE AND LENGTH
C
                  CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
                  IF(IRET .GT. 0 .AND. .NOT.LA) THEN
                     IF(BTEST(IENAME(12,IRET),11) .OR.
     1                  BTEST(IENAME(12,IRET),13))
     2                  CALL SETTL (CWORK)
                  END IF
C
C         DETERMINE IF THE VARIABLE IS A BLANK COMMON NAME. DO NOT
C         CALL CHKNME FOR THIS CASE.
C
                  IF(L7) THEN
                     IF(CWORK(1:1) .NE. CBLANK(1:1)) CALL CHKNME (CSTMT)
                  ELSE
C
C         WHEN THE VARIABLE IS A RECORD NAME, SET THE CORRECT LENGTH
C         AND TYPE CHARACTERISTICS.
C
                     CALL CHKNME (CSTMT)
                  END IF
C
C         SAVE THE COMMON VARIABLE NAME ON UNIT 11 WHEN THIS IS A
C         COMMON STATEMENT
C
                  IF(.NOT.LA .AND. IRET .GT. 0) THEN
                     KLEN = IVCNT
                     CWK44(1:44) = CWORK(1:32)//CKLEN(:4)//CWORK(37:44)
                     IF(.NOT.LINCL) THEN
                        WRITE (11,REC=IREC11) CWK44(1:44)
                       IREC11 = IREC11 + 1
                     END IF
                  END IF
               END IF
C
C         TEST FOR END OF THE STATEMENT
C
              IF(I4 .EQ. KB) GO TO 21
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                 I1 = 0
                 I2 = I4 + 1
                 I5 = 0
                 CWORK(1:32) = CBLK52(1:32)
                 JBITS = 0
               END IF
C
C         SET SWITCH FOR COMMON OR RECORD STATEMENT
C
               IF(LA) THEN
                 JBITS = IBSET(JBITS,2)
               ELSE
                 JBITS = IBSET(JBITS,1)
               END IF
            END IF
         END IF
C
C         WHEN A BLANK COMMON IS INDICATED BY TWO SEQUENTIAL SLASHES AND
C         THE CHARACTER FOLLOWING THE SECOND SLASH IS ALPHABETIC OR AN
C         UNDERSCORE, IT STARTS A NEW VARIABLE NAME
C
         IF(CSTMT(I4-1:I4) .EQ. '//' .AND. ((CSTMT(I4+1:I4+1) .GE. CAA
     1      .AND. CSTMT(I4+1:I4+1) .LE. CZZ) .OR. CSTMT(I4+1:I4+1) .EQ.
     2      CUNDER)) I2 = I4 + 1
 20      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 21   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE COMPLEX STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLEN   - CHARACTER VARIABLE, USED FOR LENGTH OF THE ENTIRE
C                  STATEMENT
C         CLENWK - CHARACTER STATEMENT, USED TO STORE THE ASCII TEXT
C                  FORM OF THE LENGTH DERIVED FROM AN EXPRESSION
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         C9     - CHARACTER VARIABLE, A NINE: 9
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARATER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, THE DATA TYPE CODE. IT IS B FOR
C                  THE COMPLEX TYPE
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C0  - CHARACTER VARIABLE, A ZERO: 0
C         I      - SUBSCRIPT VARIABLE
C         IARG   - VALUE OF THE VARIABLE LENGTH CHRACTERISITIC DEFINED
C                  BY AN EXPRESSION
C         IC     - LENGTH OF THE DATA TYPE LENGTH FIELD
C         ID     - LOCATION OF THE END OF THE DATA TYPE LENGTH FIELD
C         IPGNME - LENGTH OF A FUNCTION NAME
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - ISN OF THE CURRENT STATEMENT
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE.
C                  THE VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE
C         I5     - COUNT OF THE NUMBER OF SLASHES
C         I6     - LOCATION OF A LEFT PARENTHESIS FOR VARIABLE LENGTH
C                  SPECIFICATION, AND THE START OF THE EXPRESSSION.
C         I7     - LOCATION OF THE END OF THE EXPRESSION SPECIFYING
C                  THE LENGTH CHARACTERISTIC
C         I8     - NUMBER OF CHRACTERS IN THE ASCII LENGTH OF LENGTH
C                  DEFINED BY AN EXPRESSION
C         I9     - LOCATION OF A LEFT PARENTHESIS TERMINATING A
C                  VARIABLE NAME
C         I10    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LERT
C                  PARENTHESIS LOCATED BY I10
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - END LOCATION OF A POSSIBLE FUNCTION STATEMENT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN NO LEFT PARENTHESIS
C                  IS FOUND, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH IS SPECIFED
C                  FOR THE ENTIRE STATEMENT HAS BEEN ENTERED IN CLEN,
C                  SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK OCCURS
C                  AFTER COMPLEX, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE LENGTH
C                  CHARACTERISTIC HAS BEEN SET, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TO TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         A VARIABLE NAME DEFINED AS A COMPLEX VARIABLE HAS ITS
C         SPECIFICATIONS AS SHOWN BELOW:
C
C         COMPLEX[*LENGTH] [NAME] [(DIMENSION)] [/DATA/]
C
C         WHEN A COMPLEX VARIABLE IS DEFINED WITHIN A STRUCTURE, IT
C         HAS THE FOLLOWING FORM:
C
C         COMPLEX[*LENGTH] [NAME] [(DIMENSION)]
C
C         ALL FOUR MAY OCCUR IN A COMPLEX STATEMENT, AND THEIR
C         SEQUENCE IS IN THE ORDER SHOWN ABOVE. ONLY THE DIMENSION
C         AND LENGTH SPECIFICATION MAY BE AN EXPRESSION OF CONSTANTS
C         AND PARAMETER VARIABLES.
C
C         COLUMN 37 IN CWORK WILL CONTAIN '|' WHEN NO TYPE OR LENGTH
C         CHARACTERISTICS ARE DEFINED. A COMMON BLOCK NAME AND A
C         STRUCTURE NAME FIT THESE CRITERIA.
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT LOCERR NUMBER PARAEV STMT29 TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT11
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN, CLENWK
      LOGICAL*1   L1, L2, L3, L4, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALAN
     1CED SLASHES')
 101  FORMAT(' ISN:',I6,' COMPLEX VARIABLE HAS ILLEGAL LENGTH')
 102  FORMAT(I7)
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CLEN(1:7) = CBLK52(1:7)
      CLENWK(1:7) = CBLK52(1:7)
      LEXEC =  LFALSE
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      LFORCE = LFALSE
C
C         VERIFY THIS IS AN COMPLEX STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'COMPLEX') THEN
         J = J + 1
         JA = J + 7
C
C         TEST IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 18
         END IF
 10      CONTINUE
C
C         PLACE TYPE CODE FOR THE ENTIRE STATEMENT
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         CTYPED(1:1) = CBB
         LEXEC =  LTRUE
         LFORCE =  LTRUE
C
C         SET THE LENGTH SPECIFICATION FOR ALL VARIABLES IN THE
C         STATEMENT. THE LENGTH MAY NOT BE SPECIFIFED FOR THE ENTIRE
C         STATEMENT, BUT EACH VARIABLE DEFINED AS COMPLEX MAY HAVE AN
C         INDIVIDUAL LENGTH SPECIFICATION.
C
         IF(CSTMT(J:J) .EQ. CASTER) L3 = LTRUE
C
C         WHEN AN ASTERISK OCCURS, A LENGTH SPECIFICATION MUST FOLLOW
C
         IF(L3) THEN
C
C         DETERMINE IF A DIGIT FOLLOWS THE ASTERISK
C
            I4 = J + 1
            IF(CSTMT(I4:I4) .GE. C0 .AND. CSTMT(I4:I4) .LE. C9) THEN
               IF(.NOT.LINCL) THEN
                  CALL NUMBER (CSTMT,LTRUE,I4,II,FP,IFP)
                  CALL INSERT (II)
                  CLEN(1:IFP-I4+1) = CSTMT(I4:IFP)
                  CLENWK(1:IFP-I4+1) = CSTMT(I4:IFP)
                  J = IFP + 1
                  L4 = LTRUE
C
C         DETERMINE IF THE LENGTH SPECIFICATION IS INVALID
C
                  IF(II .NE. 8 .AND. II .NE. 16) THEN
                     WRITE (0,101) ISN
                     IREC0 = IREC0 + 1
                     CLEN(1:7) = C8//CBLANK(1:6)
                     CLENWK(1:7) = CLEN(1:7)
                     II = 8
                  END IF
               END IF
C
C         DETERMINE IF THIS A COMPLEX FUNCTION STATEMENT
C
               J = IFP + 1
               IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
                  GO TO 13
               ELSE
                  GO TO 14
               END IF
            END IF
C
C         WHEN A LEFT PARENTHESIS FOLLOWS THE ASTERISK, THE LENGTH IS
C         DEFINED AS AN EXPRESSION FOR THE ENTIRE STATEMENT.
C
            I6 = J + 1
            IF(CSTMT(I6:I6) .EQ. CLPAR(1:1)) THEN
               I6 = I6 + 1
               I9 = 0
C
C         LOCATE THE END OF THE EXPRESSION
C
               DO 12 I4 = I6,KB
               IF(CSTMT(I4:I4) .EQ. CLPAR(1:1)) I9 = I9 + 1
               IF(CSTMT(I4:I4) .EQ. CRPAR(1:1)) THEN
                  I7 = I4 + I9 - 1
                  CALL PARAEV (I6,I7,IARG)
                  IF(IARG .NE. 8 .AND. IARG .NE. 16 .AND. .NOT.LINCL)
     1               THEN
                     WRITE (0,101) ISN
                     IREC0 = IREC0 + 1
                     IARG = 8
                  END IF
                  WRITE (CLENWK,102) IARG
                  DO 11 I10 = 1,7
                  IF(CLENWK(I10:I10) .GE. C0(1:1) .AND.
     1               CLENWK(I10:I10) .LE. C9(1:1)) THEN
                     I8 = 8 - I10
                     CLEN(1:I8) = CLENWK(I10:7)
                     CLENWK(1:7) = CLEN(1:7)
                     J = I7 + 2
                     L2 = LTRUE
                     GO TO 13
                  END IF
 11               CONTINUE
               END IF
 12            CONTINUE
            END IF
C
C         TEST IF THE LENGTH IS NUMERIC
C
            J = J + 1
            IF(CSTMT(J:J) .GE. C0(1:1) .AND. CSTMT(J:J) .LE.
     1         C9(1:1)) THEN
               CLEN(1:1) = CSTMT(J:J)
               CLENWK(1:7) = CLEN(1:7)
               J = J + 1
               JA = J + 7
               L2 = LTRUE
            ELSE
               CLEN(1:1) = C8
            END IF
            GO TO 13
         END IF
C
C         WHEN NO ASTERISK EXISTS, ONLY A VARIABLE NAME FOLLOWS WITHOUT
C         ANY LENGTH SPECIFICATION; USE THE DEFAULT LENGTH VALUE.
C
         JA = J + 7
         CLEN(1:1) = C8
C
C         WHEN THERE IS NO LEFT PARENTHESIS FOLLOWING AN INTEGER, TEST
C         IF A VARIABLE NAME FOLLOWS; NO EXPRESSION MAY OCCUR.
C
        IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR. CSTMT(J:J)
     1     .EQ. CUNDER) THEN
           CLEN(1:1) = C8
           GO TO 13
        END IF
C
C         WHEN THERE IS NO LEFT PARENTHESIS AFTER THE COMPLEX, CHECK IF
C         A NUMERICAL CONSTANT FOLLOWS; NO EXPRESSION MAY OCCUR.
C
         IF(CSTMT(J:J) .GE. C0(1:1) .AND. CSTMT(J:J) .LE.
     1      C9(1:1)) THEN
            J = J + 1
            CLEN(1:1) = CSTMT(J:J)
            JA = J + 7
         ELSE
            CLEN(1:1) = C4
         END IF
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
 13      IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
            KF = J
            CALL STMT29 (CTYPED,CLEN)
            GO TO 18
         END IF
C
C         PROCESS THE REMAINDER OF THE COMPLEX STATEMENT; THE
C         STATEMENT MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIFICATI0NS.
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE COMPLEX STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
 14      CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         I1 = 0
         I2 = J
         I5 = 0
         I9 = 0
         I10 = 0
         DO 17 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I9 = I4
         END IF
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I10 = I4
         END IF
         IF(CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS. IF THE
C         FINAL CHARACTER IS REACHED IT HAS THE SAME EFFECT AS A COMMA.
C
         IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               I3 = I4
C
C         DETERMINE IF THE VARIABLE NAME HAS A LENGTH SPECIFICATION
C
               DO 15 I10 = I2,I3
               IF(CSTMT(I10:I10) .EQ. CASTER(1:1)) THEN
                  GO TO 16
               ELSE
                  IF(.NOT.L2 .AND. .NOT.L4) CLEN(1:1) = C8
               END IF
 15            CONTINUE
 16            LFORCE = LTRUE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I9 .GT. 0 .AND. I10 .GT. 0) THEN
                  L6 = LTRUE
               ELSE
                  L6 = LFALSE
               END IF
               CALL TYPLST (CTYPED,CLEN,I2,I3,L6)
               LFORCE = LFALSE
               CLEN(1:7) = CLENWK(1:7)
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I4 .EQ. KB) GO TO 18
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                  I1 = 0
                  I2 = I4 + 1
                  I5 = 0
                  I9 = 0
                  I10 = 0
                  CWORK(1:52) = CBLK52(1:52)
                  JBITS = 0
               END IF
            END IF
         END IF
 17      CONTINUE
C
C         CHECK FOR BALANCED SLASHES
C
         IF(I5 - MOD(JA,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         ROUTINE EXIT
C
 18   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES A CONTINUE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWR    - CHARACTER VARIABLE, THE WRITE BUFFER FOR UNIT 4
C                  CONTAINING THE STATEMENT NUMBER AND ITS ISN
C         IIB    - THE STATEMENT NUMBER + 128; EQUIVALENCED TO CWR(1:4)
C         IISN   - THE ISN WHERE THE STATEMENT NUMBER IS USED;
C                  EQUIVALENCED TO CWR(5:8)
C         IREC4  - THE COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 4
C         J      - LOCATION OF THE CURRENT PROCESSED IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C
C     SUBROUTINES CALLED
C
C         EXPR NUMBER
C
C     *****************************************************************
C
      SUBROUTINE STMT12
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWR, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWR(1:4),IIB), (CWR(5:8),IISN),
     2(CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         TEST IF A CONTINUE STATEMENT
C
      J = KF + 7
      LEXEC =  LFALSE
      IF(CSTMT(KF:J) .EQ. 'CONTINUE') THEN
C
C         TEST IF AN ARITHMETIC STATEMENT
C
         IF(KB .GT. J) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
      ELSE
         GO TO 11
      END IF
C
C         A CONTINUE STATEMENT EXISTS, CATALOG THE ENDING STATEMENT
C         NUMBER IF ANY
C
      LEXEC =  LTRUE
      DO 10 I = 1,5
      IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9) THEN
         CALL NUMBER (CSTMT,LTRUE,I,II,FP,IFP)
         IIB = II + 128
         IISN = ISN + 128
         IF(.NOT.LINCL) THEN
            IREC4 = IREC4 + 1
            WRITE (4,REC=IREC4) CWR
            GO TO 11
         END IF
      END IF
 10   CONTINUE
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE DATA STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLEN   - CHARACTER VARIABLE, THE LENGTH VALUE FOR THE ENTIRE
C                  TYPE STATEMENT
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CTYPED  - THE DATA TYPE CODE.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         I      - SUBSCRIPT VARIABLE
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - COUNTER FOR THE NUMBER OF LEFT PARENTHESES.  A VALUE
C                  OF 1 IS ADDED FOR EVERY LEFT PARTHESIS THAT OCCURS,
C                  AND A VALUE OF 1 IS SUBTRACTED FOR EVERY RIGHT
C                  PARENTHESIS OCCURRING.
C         I2     - LOCATION OF THE STARTING CHARACTER OF A DATA VARIABLE
C                  SPECIFICATION
C         I3     - LOCATION OF THE FINAL CHARACTER OF A DATA VARIABLE
C                  SPECIFICATION
C         I4     - SUBSCRIPT VARIABLE
C         I5     - COUNTER OF THE NUMBER OF SLASHES FOR EACH VARIABLE
C                  IN THE DATA STATEMENT
C         I6     - LOCATION OF THE INITIAL LEFT PARENTHESIS IN AN
C                  IMPLIED DO LOOP
C         I7     - SAVE AREA FOR THE VALUE OF J WHEN AN IMPLIED DO LOOP
C                  EXISTS
C         I8     - SAVE AREA FOR THE LOCATION OF THE FINAL CHARACTER IN
C                  THE DATA STATEMENT
C         I9     - WORK AREA
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         J1     - LOCATION OF THE INITIAL SLASH OF DATA SPECIFICATION
C                  FOR A VARIABLE
C         J2     - LOCATION OF THE INITIAL SLASH OF A DATA SPECIFICAT-
C                  ION FOR A VRIABLE
C         J3     - COUNT OF THE TOTAL NUMBER OF SLASHES
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KB     - LOCATION OF THE LAST CHARACTER IN THE STATEMENT
C         KBB    - SAVE AREA OF KB FOR THIS ROUTINE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY THE
C                  DATA TYPE STATEMENT, SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHEIS
C                  HAS BEEN FOUND, SET FALSE OTHERWISE OR WHEN A
C                  MATCHING RIGHT PARENTHESIS IS FOUND
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN HAS
C                  BEEN FOUND, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN IMPLIED DO LOOP
C                  EXISTS. IT INDICATES DATA SPECIFICATIONS FOR THE
C                  VARIABLE IN THE IMPLIED DO LOOP FOLLOWS. SET FALSE
C                  OTHERWISE.
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN THE INITIAL SLASH
C                  OF DATA DEFINITIONS OCCURS, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE. IT ALWAYS SET TO
C                  FALSE FOR DATA STATEMENTS.
C
C     COMMENTS
C
C         DATA STATEMENTS HAVE [NAME] AND [DATA] SPECIFICATIONS.
C         THEY CAN NOT HAVE A [DIMENSION] OR [LENGTH] SPECIFIED.
C
C         NO HOLLERITH OR LITERAL FIELDS SHOULD OCCUR SINCE THEY HAVE
C         BEEN REPLACED IN ROUTINE COMPRS.
C
C     SUBROUTINES CALLED
C
C         EXPR LOCERR PIOLST TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT13
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN
      LOGICAL*1 L1, L2, L3, L5, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' DATA SPECIFICATION LACKS BALANCED SLASHES')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      LEXEC = LFALSE
      LFORCE = LFALSE
      I1 = 0
      J1 = 0
      J2 = 0
      J3 = 0
      KBB = KB
C
C         SCAN FOR AND COUNT SLASHES OCCURRING IN A DATA STATEMENT
C
      DO 10 I = KF,KBB
      IF(CSTMT(I:I) .EQ. CSLASH) THEN
         J3 = J3 + 1
         L5 = LTRUE
      END IF
      IF(J1 .EQ. 0 .AND. CSTMT(I:I) .EQ. COMMA) J1 = I
      IF(J2 .EQ. 0 .AND. CSTMT(I:I) .EQ. CSLASH) J2 = I
 10   CONTINUE
C
C         VERIFY THIS IS A DATA STATEMENT
C
      J = KF + 3
      IF(CSTMT(KF:J) .EQ. 'DATA') THEN
         J = J + 1
         LEXEC =  LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION STATEMENT
C
         DO 11 I = J,KBB
C
C         COUNT THE MATCHED PARENTHESES
C
         IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
         IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
C
C         IF AN EQUAL SIGN IS ENCAPSULATED WITHIN MATCHING SLASHES,
C         THE EQUAL SIGN IS PART OF SPECIFIED DATA - PROBABLY IN A
C         LITERAL OR HOLLERITH FIELD DESIGNATION.
C
            IF(L5 .AND. AMOD(FLOAT(J3),2.) .EQ. 0. .AND. J2 .GT. 0)
     1         GO TO 12
C
C         IF AN UNBALANCED PARENTHESES ENCAPSULATING AN EQUAL SIGN
C         EXISTS, IT IS A DATA STATEMENT
C
            IF(I1 .GT. 0) THEN
               GO TO 12
C
C         IF NOT, THIS IS A ARITHMETIC EXPRESSION STATEMENT
C
            ELSE
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 17
            END IF
         END IF
 11      CONTINUE
C
C         WHEN A DATA STATEMENT OCCURS AFTER THE INITIAL EXECUTABLE
C         STATEMENT, WRITE AN ERROR MESSAGE
C
 12      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
C
C         PROCESS THE REMAINDER OF THE DATA STATEMENT; THE STATEMENT MAY
C         CONTAIN ONLY DATA SPECIFICATI0NS. IF PARENTHESES OCCUR, THEY
C         INDICATE AN IMPLIED DO LOOP IS USED TO DETERMINE THE VARIABLE
C         AND ITS LOCATIONS WHERE THE DATA ARE TO BE STORED, OR A
C         COMPLEX VARIABLE SPECIFICATION.
C
C         DETERMINE IF AN ODD NUMBER OF SLASHES OCCUR. THIS IS AN ERROR
C
         IF(AMOD(FLOAT(J3),2.) .GT. 0. .AND. J3 .GT. 1) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE DATA STATEMENT. A
C         COMPLETE SPECIFICATION INCLUDES THE VARIABLE NAME, DIMENSION
C         SPECIFICATIONS, LENGTH SPECIFICATION, AND DATA SPECIFICATIONS
C         FOR THE VARIABLE. NO DIMENSION OR LENGTH SPECIFICATIONS MAY
C         OCCUR IN A DATA STATEMENT.
C
         JBITS = 0
         I1 = 0
         I2 = J
         I5 = 0
         L5 = LFALSE
         DO 16 I4 = J,KBB
C
C         INDICATE AN EQUAL SIGN EXISTS
C
         IF(CSTMT(I4:I4) .EQ. CEQ) THEN
            L2 = LTRUE
         END IF
C
C         COUNT THE SLASHES
C
         IF(CSTMT(I4:I4) .EQ. CSLASH) THEN
            IF(I5 .EQ. 0) L5 = LTRUE
            I5 = I5 + 1
            J1 = I4
C
C         SET LEFT BOUNDARY OF THE FIELD TO BE PROCESSED BY TYPLST
C         WHEN AN IMPLIED DO LOOP EXISTS
C
            IF(L3) THEN
               L3 = LFALSE
               I2 = I4
            END IF
C
C         TEST IF THE END OF THE STATEMENT IS A SLASH
C
            IF(CSTMT(I4:I4) .EQ. CSLASH .AND. I4 .EQ. KBB) THEN
C
C         DETERMINE IF THE DATA SPECIFICATION IS A LITERAL
C
               IF(I4 - J1 .EQ. 2 .AND. CSTMT(J1+1:J1+1) .EQ. CSYMCF
     1            .AND. CSTMT(J1+2:J1+2) .EQ. CSLASH(1:1)) GO TO 17
               GO TO 15
            END IF
         END IF
C
C         WHEN AN INITIAL SLASH HAS BEEN FOUND, SKIP TO THE NEXT SLASH
C
         IF(L5) THEN
            IF(MOD(I5,2) .EQ. 0) L5 = LFALSE
            GO TO 15
         END IF
C
C         WHEN A COMMA OCCURS, IT TERMINATES A DATA SPECIFICATION IF
C         AN ODD NUMBER OF SLASHES OCCUR
C
         IF(CSTMT(I4:I4) .EQ. COMMA) THEN
            IF(MOD(I5,2) .GT. 0) THEN
               I3 = I4
               CTYPED(1:1) = CBLANK(1:1)
               CLEN(1:7) = CBLANK(1:7)
               L6 = LFALSE
               CALL TYPLST (CTYPED,CLEN,I2,I3,L6)
               GO TO 16
            END IF
         END IF
C
C         SAVE THE LOCATION OF THE INITIAL LEFT PARENTHESIS IF ONE
C         EXISTS
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            IF(I1 .EQ. 1) I6 = I4
         END IF
C
C         SAVE THE LOCATION OF THE FINAL RIGHT PARENTHSIS IF ONE EXISTS
C
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
C
C         TEST IF THE RIGHT PARENTHESIS IS FOLLOWED BY A SLASH
C         INDICATING DATA SPECIFICATIONS FOLLOW
C
            IF(CSTMT(I4+1:I4+1) .EQ. CSLASH) THEN
               L5 = LTRUE
               IF(.NOT.L2) GO TO 16
            END IF
C
C         WHEN THE FINAL RIGHT PARENTHESIS IS FOUND, THIS ENDS THE
C         DEFINITION OF AN IMPLIED DO LOOP DEFINING A VARIABLE NAME.
C         THIS IMPLIED DO LOOP IS PROCESSED AS A READ OR WRITE
C         INPUT-OUTPUT LIST.
C
            IF(I1 .EQ. 0 .AND. L2) THEN
               I7 = J
               I8 = KB
               J = I6
               KB = I4
               CALL PIOLST
               J = I7
               KB = I8
               L3 = LTRUE
               L2 = LFALSE
               GO TO 16
            END IF
         END IF
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
 15      IF(I1 .EQ. 0) THEN
            IF(MOD(I5,2) .EQ. 0) THEN
               IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KBB) THEN
                  CWORK(1:52) = CBLK52(1:52)
                  JBITS = 0
                  I3 = I4
                  CTYPED(1:1) = CBLANK(1:1)
                  CLEN(1:7) = CBLANK(1:7)
                  L6 = LFALSE
                  CALL TYPLST (CTYPED,CLEN,I2,I3,L6)
C
C         TEST FOR END OF THE STATEMENT
C
                  IF(I4 .EQ. KBB .OR. I3 .EQ. KBB) GO TO 17
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
                  IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                     I1 = 0
                     I2 = I4 + 1
                     I5 = 0
                  END IF
               END IF
            END IF
         END IF
 16      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 17   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE DECODE AND ENCODE STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IIB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - LOCATION OF THE END OF AN ARGUMENT
C         IC     - LENGTH OF A VARIABLE NAME OR FIELD
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN CCONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         ID     - INDEX VALUE OF THE ARGUMENT TO BE PROCESSED IN ARRAY
C                  CLIST IN ROUTINE CIOLST
C         II     - RETURN VALUE OF AN INTEGER NUMBER FROM SUBROUTINE
C                  NUMBER
C         IIB    - EQUIVALENCED TO CIB
C         IISN   - EQUIVALENCED TO CISN
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN IOUTC
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         ISNUM  - TABLE OF STATEMENT NUMBERS FOUND IN THE PROGRAM AND
C                  THE ISN WHERE IT IS DEFINED. WORD 1 IS THE STATEMENT
C                  NUMBER VALUE, WORD 2 IS THE ISN
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         I3     - LOCATION OF THE START OF A VARIABLE NAME
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JA     - LOCATION OF THE FINAL RIGHT PARENTHESIS ENDING THE
C                  CONTROL LIST ARGUMENTS
C         JB     - END LOCATION OF A VARIABLE NAME OR NUMBER
C         JD     - LOCATION OF THE CURRENT CHARACTER
C         JE     - LOCATIN OF THE FIRST CHARACTER IN THE UNIT FIELD
C         JF     - SAVE AREA FOR THE VALUE IN J
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ERR COMMAND IN THE
C                  INPUT-OUTPUT COMMAND LIST IS PROCESSED BY ROUTINE
C                  CIOLST, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN IOSTAT COMMAND IN
C                  THE INPUT-OUTPUT COMMAND LIST IS PROCESSED BY ROUTINE
C                  CIOLST, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN IOSTAT COMMAND IN
C                  THE INPUT-OUTPUT COMMAND LIST IS NOT ALLOWED, SET
C                  FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A LITERAL, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A VARIABLE, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C
C     COMMENT
C
C         INPUT-OUTPUT COMMAND LIST IS PROCESSED BY ROUTINE CIOLST
C
C         THE CODING FORM FOR DECODE AND ENCODE ARE:
C
C         DECODE (EXPRESSION,FORMAT,VARIABLE,ERR=nn,IOSTAT=nn) (IOLIST)
C
C         DECODE IS EQUIVALENT TO A READ STATEMENT.
C         ENCODE IS EQUIVALENT TO A WRITE STATEMENT.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C        10      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C
C     SUBROUTINES CALLED
C
C         CIIOLST EXPR IBSET INSERT NUMBER PIOLST VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT14
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*8 CIB,CISN
      LOGICAL*1   LA, LB, L1, L2, L3, L4, L5, L6, L7
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/    ID,LB,L4,L5,L6,L7,LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO CLOSING COMMA OR RIGHT OR LEFT PARENTHESIS
     1')
 101  FORMAT(' ISN:',I6,' THIRD ARGUMENT OF ENCODE OR DECODE IS NOT A VA
     1RABLE NAME')
 102  FORMAT(' ISN:',I6,' INVALID INPUT-OUTPUT CONTROL COMMAND FOR ENCOD
     1E OR DECODE')
C
C         VERIFY THIS IS A DECODE OR AN ENCODE STATEMENT
C
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      LEXEC =  LFALSE
      J = KF + 5
      IF(CSTMT(KF:J) .EQ. 'DECODE' .OR. CSTMT(KF:J) .EQ. 'ENCODE') THEN
         J = J + 1
C
C         IF AN EQUAL SIGN OCCURS THAT IS NOT ENCAPSULATED WITHIN
C         PARENTHESES, THIS IS AN ARITHMETIC STATEMENT
C
         IA = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) IA = IA + 1
         IF(CSTMT(I:I) .EQ. CRPAR) IA = IA - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(IA .EQ. 0) THEN
               CALL EXPR(KF,KB,LFALSE,CSTMT)
               GO TO 22
            END IF
         END IF
 10      CONTINUE
C
C         VERIFY THAT A LEFT PARENTHESIS FOLLOWS THE STATEMENT
C
         LEXEC = LTRUE
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            JE = J + 1
C
C         SCAN FOR THE FIRST ARGUMENT, IT MUST BE THE NUMBER OF
C         CHARACTERS TO BE TRANSLATED WHEN I2 = 1, AND THE FORMAT
C         DESIGNATION WHEN I2 = 2, AND THE VARIABLE NAME CONTAINING
C         THE SOURCE OF THE RECODING WHEN I2 = 3
C
            DO 14 I2 = 1,3
C
C         BLANK CHARACTER WORK AREA
C
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            I3 = JE
            DO 12 I1 = JE,KB
C
C         FOR THE THIRD TIME THROUGH THE LOOP, THE ARGUMENT MUST BE A
C         VARIABLE NAME
C
            IF(I2 .EQ. 3) THEN
C
C         TEST FOR A COMMA, A LEFT PARENTHESIS, OR A RIGHT PARENTHESIS
C
               IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CLPAR
     1            .OR. CSTMT(I1:I1) .EQ. CRPAR) THEN
C
C         DETERMINE IF IT IS VARIABLE NAME
C
                  IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I3:I3) .LE. CZZ
     1               .OR. CSTMT(I3:I3) .EQ. CUNDER) THEN
                     IC = I1 - I3
                     IVCNT = IC
                     CWORK(1:IC) = CSTMT(I3:I1-1)
                     IWORK = ISN + 128
                     IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
                     CALL VSETUP (I3,I1-1,IC,LFALSE,LFALSE,CSTMT)
                     IF(CSTMT(I1:I1) .EQ. CDOT) THEN
                        CWORK(1:IC) = CBLK52(1:IC)
                        I3 = I1 + 1
                        GO TO 12
                     END IF
                     GO TO 13
                  ELSE
                     IF(.NOT.LINCL) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                     GO TO 12
                  END IF
               END IF
            END IF
C
C         WHEN I2 = 1 OR 2, TEST FOR A COMMA OR A PERIOD
C
            IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CDOT) THEN
C
C         PROCESS A LENGTH DESIGNATION, IT MUST BE THE FIRST ARGUMENT
C         DETERMINE IF IT IS A NUMERIC VALUE
C
               IF(CSTMT(I3:I3) .GE. C0 .AND. CSTMT(I3:I3) .LE. C9)
     1            THEN
                  CALL NUMBER (CSTMT,LTRUE,I3,II,FP,IFP)
                  IF(I2 .EQ. 1 .AND. .NOT.LINCL) CALL INSERT (II)
                  IF(I2 .EQ. 2 .AND. .NOT.LINCL) THEN
                     IIB = II + 128
                     IISN = ISN + 128
                     CWR(1:4) = CIB(1:4)
                     CWR(5:8) = CISN(1:4)
                     IREC4 = IREC4 + 1
                     WRITE (4,REC=IREC4) CWR
                  END IF
                  GO TO 13
               END IF
C
C         DETERMINE IF IT IS VARIABLE NAME
C
               IF(CSTMT(I3:I3) .GE. CAA .AND. CSTMT(I3:I3) .LE. CZZ .OR.
     1            CSTMT(I3:I3) .EQ. CUNDER) THEN
                  IC = I1 - I3
                  IVCNT = IC
                  CWORK(1:IC) = CSTMT(I3:I1-1)
                  IWORK = ISN + 128
                  IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
                  CALL VSETUP (I3,I1-1,IC,LFALSE,LFALSE,CSTMT)
                  IF(CSTMT(I1:I1) .EQ. CDOT) THEN
                     CWORK(1:IC) = CBLK52(1:IC)
                     I3 = I1 + 1
                     GO TO 12
                  END IF
                  GO TO 13
               ELSE
                  IF(.NOT.LINCL) THEN
                     WRITE (0,101) ISN
                     IREC0 = IREC0 + 1
                  END IF
               END IF
            END IF
 12         CONTINUE
 13         JE = I1 + 1
 14         CONTINUE
            GO TO 15
         ELSE
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
            GO TO 22
         END IF
C
C         TEST IF THE END OF THE CONTROL LIST
C
 15      IF(CSTMT(JE-1:JE-1) .EQ. CRPAR) THEN
            J = JE
            GO TO 21
         END IF
C
C         PROCESS FOR ARGUMENTS WITH AN EQUAL SIGN FOLLOWING THE
C         VARIABLE NAME DESIGNATION WHEN I2 = 3
C
         DO 20 I = JE,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            I1 = I + 1
C
C         SCAN BACKWARDS TO LOCATE THE START OF THE ARGUMENT FIELD
C
            DO 16 IA = I,JE-1,-1
            IF(CSTMT(IA:IA) .EQ. CLPAR .OR. CSTMT(IA:IA) .EQ. COMMA)
     1         THEN
               JF = IA + 1
               GO TO 18
            END IF
 16         CONTINUE
C
C         AN ERROR OCCURRED, NO CLOSING COMMA OR LEFT OR RIGHT
C         PARENTHESIS
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
            GO TO 22
         END IF
         GO TO 20
C
C         DETERMINE IF ANY ILLEGAL INPUT-OUTPUT CONTROL COMMANDS EXIST
C
 18      IF(CSTMT(JF:JF+2) .NE. 'ERR' .AND. CSTMT(JF:JF+5) .NE. 'IOSTAT'
     1      .AND. .NOT.L3) THEN
            IF(.NOT.LINCL) THEN
               WRITE (0,102) ISN
               IREC0 = IREC0 + 1
            END IF
            L3 = LTRUE
         END IF
C
C         DETERMINE WHICH ARGUMENT IS TO BE PROCESSED. THESE ARE
C         ERR AND IOSTAT.
C
         J = JF
         IF(.NOT.L1) THEN
            ID = 13
            LA = LFALSE
            LB = L1
            L4 = LFALSE
            L5 = LFALSE
            L6 = LFALSE
            L7 = LTRUE
            CALL CIOLST
            J = JF
            IF(LA) THEN
               L1 = LTRUE
               GO TO 18
            END IF
         END IF
         IF(.NOT.L2) THEN
            ID = 21
            LA = LFALSE
            LB = L2
            L4 = LFALSE
            L5 = LTRUE
            L6 = LFALSE
            L7 = LFALSE
            CALL CIOLST
            J = JF
            IF(LA) THEN
               L2 = LTRUE
               GO TO 18
            END IF
         END IF
C
C         DETERMINE IF THE END OF THE COMMAND LIST REACHED
C
         IF(CSTMT(JB:JB) .EQ. CRPAR) THEN
            J = JB + 1
            GO TO  21
         ELSE
            JE = JB
            GO TO 15
         END IF
 20      CONTINUE
C
C         TEST IF AN INPUT-OUTPUT LIST EXISTS
C
 21      IF(CSTMT(J:J) .GE. CAA .OR. CSTMT(J:J) .LE. CZZ .OR. CSTMT(J:J)
     1      .EQ. CUNDER .OR. CSTMT(J:J) .EQ. CLPAR) CALL PIOLST
      END IF
C
C         ROUTINE EXIT
C
 22   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE DIMENSION OR VIRTUAL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABEL, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLEN   - CHARACTER VARIABLE, THE LENGTH VALUE FOR THE ENTIRE
C                  TYPE STATEMENT
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN: -
C         CPLUS  - CHARACTER STATEMENT, A PLUS SIGN: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED WITH THE STATEMENT NUMBER ABSENT OR
C                  REMOVED
C         CTYPED - CHARACTER VARIABLE, THE DATA TYPE CODE
C         CWK    - CHARACTER VARIABLE, THE WORK AREA USED TO SET UP
C                  THE COMPARE TO DETERMINE IF THIS MAY BE AN ARITHMETIC
C                  STATEMENT.
C         I      - SUBSCRIPT VARIABLE
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - COUNT OF THE NUMBER OF LEFT AND RIGHT PARENTHESES
C                  ONE IS ADDED FOR A LEFT PARENTHESIS, ONE IS
C                  SUBTRACTED FOR A RIGHT PARENTHESIS
C         I2     - COUNT OF THE NUMBER OF SLASHES THAT OCCUR OUTSIDE
C                  ENCAPSULATING PARENTHESES
C         I2WK2  - COUNT OF SLASHES THAT OCCUR OUTSIDE ENCAPSULATING
C                  PARENTHESES
C         I3     - SUBSCRIPT VARIABLE
C         I4     - COUNT OF THE TOTAL NUMBER OF PARENTHESES, BOTH LEFT
C                  AN RIGHT. IT IS USED TO CHECK THAT THE TOTAL NUMBER
C                  OF PARENTHESES ARE A MULIPLE OF TWO.
C         I5     - LOCATION OF THE START THE DO STATEMENT SUBSCRIPT
C                  VARIABLE NAME (THE INDEX VARIABLE)
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE END OF THE BLOCK COMMON NAME
C         JB     - LENGTH OF THE BLOCK COMMON NAME
C         J1     - SAVE AREA FOR THE START OF THE DIMENSION LIST
C         J2     - LOCATION OF THE END OF A SINGLE DIMENSIONED VARIABLE
C                  SPECIFICATION
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN PROCESSING THE
C                  VIRTUAL STATEMENT, SET FALSE WHEN PROCESSING A
C                  DIMENSION STATEMENT
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L2     - LOGICAL VARIABLE, SET TRUE TO INDICATE ALL VARIABLES
C                  ARE DIMENSIONED
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         ONLY [NAME] AND [DIMENSION] SPECIFICATIONS MAY BE USED IN A
C         DIMENSION STATEMENT. DIMENSION SPECIFICATIONS MAY BE INTEGERS
C         OR INTEGER VARIABLE NAMES WHICH MUST HAVE BEEN DEFINED IN A
C         PRIOR PARAMETER STATEMENT TO BE VALID, OR ARE ONE OF A SUB-
C         PROGRAM'S ARGUMENTS IN ITS ARGUMENT LIST.
C
C     SUBROUTINES CALLED
C
C         EXPR IBSET LOCERR TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT15 (LA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*9 CWK
      CHARACTER*7 CLEN
      LOGICAL*1   LA, L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         DATA STATEMENTS
C
      DATA L2/.FALSE./
C
C         SAVE STATEMENT
C
      SAVE
C
C         INITIALIZATION
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      LEXEC =  LFALSE
      I1 = 0
      I2 = 0
      I4 = 0
      CWK(1:9) = CBLK52(1:9)
C
C         DETERMINE IF A DIMENSION OR VIRTUAL STATEMENT IS BEING
C         PROCESSED
C
      IF(LA) THEN
         I3 = 6
         CWK(1:7) = 'VIRTUAL'
      ELSE
         I3 = 8
         CWK(1:9) = 'DIMENSION'
      END IF
C
C         VERIFY THIS IS A DIMENSION OR VIRTUAL STATEMENT
C
      J = KF + I3
      IF(CSTMT(KF:J) .EQ. CWK(1:J)) THEN
         J = J + 1
C
C         IF AN EQUAL SIGN OCCURS, THIS IS NOT A DIMENSION OR VIRTUAL
C         STATEMENT.
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 13
         END IF
 10      CONTINUE
C
C         SET THE ISN FOR THE DIMENSION OR VIRTUAL STATEMENT
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         LEXEC = LTRUE
         IWORK = ISN + 128
C
C         SET THE BIT SWITCH FOR A DIMENSION STATEMENT. THERE IS NO
C         SEPARATE SWITCH FOR VIRTUAL.
C
         JBITS = IBSET(JBITS,17)
C
C         SCAN FOR EACH VARIABLE IN THE DIMENSION STATEMENT
C
         J1 = J
 11      DO 12 I3 = J1,KB
C
C         COUNT PARENTHESES
C
         IF(CSTMT(I3:I3) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I4 = I4 + 1
         END IF
         IF(CSTMT(I3:I3) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I4 = I4 + 1
         END IF
C
C         DETERMINE THE LOCATION OF A COMMA NOT ENCAPSULATED WITHIN
C         PARENTHESES. THAT COMMA'S LOCATION IS THE END OF THE
C         DIMENSION SPECIFICATION FOR ONE VARIABLE NAME. VARIABLES
C         J1 AND J2 SPECIFY THE FIRST AND LAST CHARACTERS DEFINING THE
C         DIMENSION SPECIFICATIONS FOR A SINGLE VARIABLE.
C
         IF(CSTMT(I3:I3) .EQ. COMMA .OR. I3 .EQ. KB) THEN
            IF(I1 .EQ. 0 .AND. MOD(I4,2) .EQ. 0) THEN
               J2 = I3
               I2WK1 = I2
               CTYPED(1:1) = CBLANK(1:1)
               CLEN(1:7) = CBLANK(1:7)
               CWORK(37:44) = CBLANK(1:8)
               LFORCE = LFALSE
               CALL TYPLST (CTYPED,CLEN,J1,J2,L2)
C
C         WHEN I3 IS NOT THE FINAL CHARACTER OF THE STATEMENT, ANOTHER
C         DIMENSION SPECIFICATION FOLLOWS. RESET COUNTERS AND THE START
C         LOCATION FOR THE NEXT VARIABLE.
C
               IF(I3 .LT. KB) THEN
                  J1 = I3 + 1
                  I2 = 0
                  I4 = 0
                  GO TO 11
               END IF
            END IF
         END IF
 12      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE DO STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARACTER: A
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CIIB   - CHARACTER VARIABLE, EQUIVALENCED TO IIB
C         CIISN  - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, THE CHARACTER: (
C         CMINUS - CHARACTER VARIABLE, THE CHARACTER: -
C         COMMA  - CHARACTER VARIABLE, THE CHARATCER: ,
C         CPLUS  - CHARACTER VARIABLE, THE CHARACTER: +
C         CRPAR  - CHARACTER VARIABLE, THE CHARACTER: )
C         CSLASH - CHARACTER VARIABLE, THE CHARACTER: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER: Z
C         C0     - CHARACTER VARIABLE, A ZERO CHARACTER
C         C101   - CHARACTER VARIABLE, FORMAT STATEMENT
C         C102   - CHARACTER VARIABLE, FORMAT STATEMENT
C         C103   - CHARACTER VARIABLE, FORMAT STATEMENT
C         C6     - CHARACTER VARIABLE, A SIX CHARACTER
C         C9     - CHARACTER VARIABLE, A NINE CHARACTER
C         FP     - RETURN OF A FLOATING POINT NUMBER FROM SUBROUTINE
C                  NUMBER (NOT USED)
C         IA     - WORK VARIABLE
C         ICOM   - COUNT OF THE TOTAL NUMBER OF COMMAS IN THE STATEMENT
C         ICOM1  - LOCATION OF THE FIRST COMMA NOT ENCAPSULATED BETWEEN
C                  LEFT AND RIGHT PARENTHESES
C         ICOM2  - LOCATION OF THE SECOND COMMA NOT ENCAPSULATED BETWEEN
C                  LEFT AND RIGHT PARENTHESES
C         IEQ    - LOCATION OF THE FIRST EQUAL SIGN
C         IFP    - THE LOCATION OF THE FINAL DIGIT OF THE TERMINATING
C                  STATEMENT NUMBER IN TYPES 1 AND 3 DO STATEMENTS,
C                  AND ALSO DESIGNATES THE START LOCATION OF EITHER THE
C                  DO STATEMENT INDEX VARIABLE OR THE CHARACTERS
C                  'WHILE('.
C         IIB    - RETURN VALUE OF AN INTEGER CONVERTED FROM TEXT
C                  TO BINARY INTEGER FORMAT
C         IISN   - THE INTERNAL STATEMENT NUMBER OF THE DO LOOP END
C                  STATEMENT NUMBER + 128
C         IREC0  - NUMBER OF REC0RDS WRITTEN ON UNIT 0
C         IREC4  - NUMBER OF REC0RDS WRITTEN ON UNIT 4
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         I1     - THE START LOCATION OF A FIELD OR A SUBSCRIPT VARIABLE
C         I2     - THE END LOCATION OF A VARIABLE NAME AND WORK AREA
C         I3     - DO INDEX VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER IN A STATEMENT
C         JA     - SUBSCRIPT VARIABLE
C         JBITS  - BIT SWITCHS IN CWORK(45:48)
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KBB    - SAVE AREA FOR THE VALUE OF KB UPON ENTERING THIS
C                  SUBROUTINE
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LCOM1  - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST COMMA NOT
C                  ENCAPSULATED BETWEEN PARENTHESES IS FOUND, SET FALSE
C                  OTHERWISE
C         LCOM2  - LOGICAL VARIABLE, SET TRUE WHEN THE SECOND COMMA NOT
C                  ENCAPSULATED BETWEEN PARENTHESES IS FOUND, SET FALSE
C                  OTHERWISE
C         LCOM3  - LOGICAL VARIABLE, SET TRUE WHEN THE MORE THAN TWO
C                  COMMAS NOT ENCAPSULATED BETWEEN PARENTHESES ARE
C                  FOUND, SET FALSE OTHERWISE
C         LEQ    - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EQUAL
C                  SIGN IS FOUND, SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         LWHILE - LOGICAL VARIABLE, SET TRUE WHEN A 'DO WHILE'
C                  STATEMENT EXISTS, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A COMMA PRECEDES A
C                  NUMERICAL DIGIT, SET FALSE OTHERWISE. WHEN TRUE, THIS
C                  SWITCH PREVENTS A DIGIT FROM BEING TREATED AS A
C                  VARIABLE.
C         M      - COUNTER OF PARENTHESES.  ONE IS ADDED FOR EACH RIGHT
C                  PARENTHESIS, ONE IS SUBTRACTED FOR EACH LEFT PAREN-
C                  THESIS FOUND
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C
C     COMMENTS
C
C         THE TYPES OF DO STATEMENTS ARE:
C         1. DO nn I = EXPR1,EXPR2,EXPR3
C         2. D0 I = EXPR1,EXPR2,EXPR3
C         3. DO nn WHILE (logical expression)
C         4. DO WHILE (logical expression)
C
C         TYPE 1 AND 3 ARE TERMINATED BY;
C              nn CONTINUE
C         TYPES 2 AND 4 ARE TERMINATED BY:
C              END DO
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT NUMBER VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT16
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUN ION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIIB, CIISN
      LOGICAL*1 LEQ, LCOM1, LCOM2, LCOM3, LWHILE, L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
      EQUIVALENCE (CIIB,IIB), (CIISN,IISN), (CWK8(2:2),CWK7)
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NOT A FORTRAN STATEMENT')
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA AND INITIALIZE ROUTINE
C
      CWORK(1:52) = CBLK52(1:52)
      IEQ = 0
      ICOM = 0
      ICOM1 = 0
      ICOM2 = 0
      JBITS = 0
      LEXEC =  LFALSE
      LEQ = LFALSE
      LCOM1 = LFALSE
      LCOM2 = LFALSE
      LCOM3 = LFALSE
      LWHILE = LFALSE
      LFORCE = LFALSE
C
C         SAVE THE LOCATION OF THE FINAL CHARACTER OF THE CURRENT
C         STATEMENT
C
      KBB = KB
C
C         VERIFY THIS IS A DO STATEMENT
C
      J = KF + 1
C
C         LOOP TO DETERMINE THE LOCATION OF AN EQUAL SIGN
C
      DO 10 JA = 1,KB
C
C         DETERMINE IF THE CHARACTER IS AN EQUAL SIGN
C
      IF(CSTMT(JA:JA) .EQ. CEQ) THEN
C
C         DETERMINE IF MORE THAN ONE EQUAL SIGN EXISTS. AN EQUAL SIGN
C         OCCURRING IN A LITERAL DOES NOT CAUSE THIS MESSAGE, SINCE
C         ALL LITERALS ARE REMOVED FROM ALL STATEMENTS BY SUBROUTINE
C         COMPRS. NO FURTHER PROCESSING OCCURS AFTER THE SECOND EQUAL
C         SIGN IS DETECTED.
C
         IF(LEQ) THEN
            IREC0 = IREC0 + 1
            WRITE (0,100) ISN
            GO TO 16
         END IF
C
C         SAVE THE LOCATION OF THE FIRST EQUAL SIGN
C
         IEQ = JA
         LEQ = LTRUE
      END IF
 10   CONTINUE
C
C         DETERMINE THE LOCATION OF THE TWO POSSIBLE COMMAS NOT
C         ENCAPSULATED WITHIN PARENTHESES THAT REPRESENT THE BOUNDARIES
C         OF THE DO STATEMENT PARAMETERS
C
      M = 0
      DO 11 JA = IEQ,KB
      IF(CSTMT(JA:JA) .EQ. CLPAR) M = M + 1
      IF(CSTMT(JA:JA) .EQ. CRPAR) M = M - 1
      IF(CSTMT(JA:JA) .EQ. COMMA .AND. M .EQ. 0) THEN
         ICOM = ICOM + 1
         IF(.NOT.LCOM1) THEN
            LCOM1 = LTRUE
            ICOM1 = JA
         END IF
         IF(LCOM1 .AND. .NOT.LCOM2 .AND. JA .NE. ICOM1) THEN
            LCOM2 = LTRUE
            ICOM2 = JA
         END IF
      END IF
 11   CONTINUE
C
C         WHEN MORE THAN TWO COMMAS EXIST THAT ARE NOT ENCAPSULATED
C         BETWEEN LEFT AND RIGHT PARENTHESES, SET SWITCH LCOM3
C
      IF(LCOM1 .AND. LCOM2 .AND. ICOM .GT. 2) LCOM3 = LTRUE
C
C         DETERMINE IF THE STATEMENT IS A MATHEMATICAL EXPRESSION
C
C         WHEN THE FIRST TWO CHARACTERS ARE NOT 'DO' AND WHEN AN EQUAL
C         SIGN EXISTS AND NO COMMAS OR MORE THAN TWO COMMAS EXIST THAT
C         ARE NOT ENCAPSULATED BETWEEN LEFT AND RIGHT PARENTHESES, THIS
C         STATEMENT IS CONSIDERED TO BE AN ARITHMETIC STATEMENT.
C
      IF(LEQ) THEN
         IF(.NOT.LCOM1 .OR. LCOM3) THEN
            LEXEC = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 18
         END IF
      ELSE
C
C         WHEN NO EQUAL SIGN EXISTS, DETERMINE IF A NUMERICAL VALUE
C         FOLLOWS 'DO' OR 'WHILE' FOLLOWS 'DO'
C
C         LOCATE THE THE INITIAL ALPHABETIC CHARACTER
C
         DO 111 JA = 3,KB
         IF(CSTMT(JA:JA) .GE. CAA .AND. CSTMT(JA:JA) .LE. CZZ .OR.
     1      CSTMT(JA:JA) .EQ. CUNDER) THEN

C         WHEN THE FIRST ALPHABETIC CHARACTER IS FOUND, DETERMINE IF
C         THIS IS A 'DO WHILE'
C
            IF(CSTMT(JA:JA+4) .EQ. 'WHILE') THEN
               LWHILE = LTRUE
C
C         DETERMINE IF A TERMINATING STATEMENT NUMBER EXISTS
C
               IF(CSTMT(3:3) .GE. C0 .AND. CSTMT(3:3) .LE. C9) THEN
                  GO TO 112
               ELSE
C
C         NO TERMINATING STATEMENT NUMBER EXISTS; A LOGICAL STATEMENT
C         MUST FOLLOW.
C
                  IFP = 3
                  GO TO 12
               END IF
            ELSE
C
C         WHEN NO EQUAL SIGN EXISTS, WRITE ERROR MESSAGE. NO FURTHER
C         PROCESSING OF THE STATEMENT OCCURS.
C
               IREC0 = IREC0 + 1
               WRITE (0,100) ISN
               GO TO 18
            END IF
         END IF
 111     CONTINUE
      END IF
C
C         DETERMINE WHICH TYPE OF DO STATEMENT THE CURRENT STATEMENT
C         BELONGS
C
      IF(.NOT.(CSTMT(3:3) .GE. C0 .AND. CSTMT(3:3) .LE. C9)) THEN
C
C         THIS IS TYPE 2 OR 4 (NO STATEMENT NUMBER EXISTS)
C
         IFP = 3
         GO TO 12
      END IF
C
C    *******************************************************************
C    *                                                                 *
C    *    DETERMINE THE TERMINATING STATEMENT NUMBER OF THE TYPE 1 OR 3*
C    *    DO STATEMENT: DO nn I = EXPR1,EXPR2,EXPR3 OR                 *
C    *                  DO nn WHILE (logical expression)               *
C    *                                                                 *
C    *******************************************************************
C
C         DETERMINE THE INTEGER VALUE OF THE TERMINATING STATEMENT
C         NUMBER AND WRITE IT ON UNIT 4
C
 112  CALL NUMBER (CSTMT,LTRUE,3,IIB,FP,IFP)
      IIB = IIB + 128
      IISN = ISN + 128
      CWR(1:4) = CIIB(1:4)
      CWR(5:8) = CIISN(1:4)
      IREC4 = IREC4 + 1
      WRITE (4,REC=IREC4) CWR
C
C         SINCE THE TERMINATING STATEMENT NUMBER FOR THE DO LOOP HAS
C         JUST BEEN PROCESSED, SET THE LOCATION OF THE START OF THE
C         FIELD FOLLOWING THE STATEMENT NUMBER.
C
      IFP = IFP + 1
C
C     *****************************************************************
C     *                                                               *
C     *   PROCESS THE DO INDEX VARIABLE NAME OR THE 'WHILE('          *
C     *                                                               *
C     *****************************************************************
C
C         DETERMINE IF THE STATEMENT IS A DO WHILE STATEMENT OR A
C         STANDARD DO STATEMENT
C
 12   IA = IFP + 5
      IF(CSTMT(IFP:IA) .EQ. 'WHILE(') THEN
C
C         THIS IS A 'DO WHILE' OR A 'DO nn WHILE' STATEMENT
C
C         WHEN THE LOGICAL EXPRESSION DOES NOT TERMINATE WITH A RIGHT
C         PARENTHESIS, WRITE ERROR MESSAGE. NO FURTHER PROCESSING
C         OCCURS AFTER THIS MESSAGE.
C
         IF(CSTMT(KB:KB) .NE. CRPAR) THEN
            IREC0 = IREC0 + 1
            WRITE (0,100) ISN
            GO TO 18
         END IF
C
C         PROCESS A LOGICAL EXPRESSION OF A 'DO WHILE' OR 'DO nn WHILE'
C         STATEMENT
C
         CALL EXPR (IA,KB,LFALSE,CSTMT)
         GO TO 18
      ELSE
C
C         THIS IS A STANDARD 'DO I =' OR 'DO nn I =' STATEMENT
C
C         THE DO LOOP INDEX VARIABLE STARTS AT THE LOCATION SPECIFIED
C         BY IFP AND TERMINATES AT THE CHARACTER PRECEDING THE EQUAL
C         SIGN. THE INDEX VARIABLE MAY BE A COMPOUND VARIABLE.
C
         CALL VSETUP (IFP,IEQ-1,IEQ-IFP,LFALSE,LFALSE,CSTMT)
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   PROCESS THE DO PARAMETER EXPRESSIONS FOR TYPES 1 AND 2       *
C     *           DO nn I = EXPR1,EXPR2,EXPR3                          *
C     *           DO I = EXPR1,EXPR2,EXPR3                             *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF MORE THAN TWO COMMAS EXIST OR NO COMMAS EXIST IN
C         THE DO STATEMENT. NO FURTHER PROCESSING OCCURS AFTER THIS
C         MESSAGE.
C
      IF((.NOT.LCOM1 .OR. LCOM3) .AND. .NOT.LWHILE) THEN
         IREC0 = IREC0 + 1
         WRITE (0,100) ISN
         GO TO 18
      END IF
C
C         PROCESS THE FIRST PARAMETER EXPRESSION
C
      I1 = IEQ + 1
      I2 = ICOM1 - 1
C
C         DETERMINE IF AN ARITHMETIC OPERATOR OR LEFT PARENTHESIS EXIST
C
      DO 13 I3 = I1,I2
C
C         DETERMINE IF THE FIRST PARAMETER IS A NUMERICAL CONSTANT
C
      IF(CSTMT(I3:I3) .GE. C0 .AND. CSTMT(I3:I3) .LE. C9 .AND. I1 .EQ.
     1   I3) THEN
         CALL NUMBER (CSTMT,LTRUE,I3,IIB,FP,IFP)
         CALL INSERT (IIB)
         GO TO 14
      END IF
C
C      DETERMINE IF THE PARAMETER IS AN ARITHMETIC EXPRESSION OR IF
C      A SUBSCRIPT EXISTS. PARENTHESES FOR A SUBSCRIPT ARE TREATED
C      AS AN EXPRESSION.
C
      IF(CSTMT(I3:I3) .EQ. CPLUS .OR. CSTMT(I3:I3) .EQ. CMINUS .OR.
     1   CSTMT(I3:I3) .EQ. CASTER .OR. CSTMT(I3:I3) .EQ. CSLASH .OR.
     2   CSTMT(I3:I3) .EQ. CLPAR) THEN
C
C         DETERMINE IF THE FIRST PARAMETER IS A SIGNED NUMBER OR AN
C         EXPRESSION
C
         DO 130 JA = I1,I2
C
C         THE OCCURRENCE OF AN ALPHABETIC CHARACTER INDICATES THE
C         PARAMETER IS AN ARITHMETIC EXPRESSION
C
         IF(CSTMT(JA:JA) .GE. CAA .AND. CSTMT(JA:JA) .LE. CZZ .OR.
     1      CSTMT(JA:JA) .EQ. CUNDER) THEN
            KB = ICOM1 - 1
            CALL EXPR (JA,KB,LFALSE,CSTMT)
            GO TO 14
         END IF
 130     CONTINUE
C
C         WHEN NO ALPHABETIC CHARACTER OCCURS IN THE PARAMETER, IT
C         CONTAINS ONLY ARITHMETIC OPERATORS AND DIGITS
C
         IF(.NOT.(CSTMT(I3:I3) .GE. C0 .AND. CSTMT(I3:I3) .LE. C9))
     1      THEN
            IB = ICOM1 - I1
            CALL NUMBER (CSTMT,LTRUE,I3,IIB,FP,IFP)
            CALL INSERT (IIB)
            GO TO 14
         END IF
      END IF
 13   CONTINUE
C
C         WHEN THE CHARACTER AT I1 IS ALPHABETIC AND NO ARITHMETIC
C         OPERATOR OCCURS, ONLY A VARIABLE NAME EXISTS.
C
      IF(CSTMT(I1:I1) .GE. CAA .AND. CSTMT(I1:I1) .LE. CZZ .OR.
     1   CSTMT(I1:I1) .EQ. CUNDER) THEN
          I3 = I2 - I1 + 1
          CALL VSETUP (I1,I2,I3,LFALSE,LFALSE,CSTMT)
          GO TO 14
      END IF
C
C         DETERMINE IF THE PARAMETER IS A VARIABLE. THE VARIABLE MAY BE
C         A COMPOUND VARIABLE, BUT IT CAN NOT BE PART OF AN EXPRESSION;
C         SINCE AN ARITHMETIC EXPRESSION HAS ALREADY BEEN PROCESSED.
C
      IF(IB .GT. KB) IB = KB
      IF(CSTMT(IA-1:IA-1) .EQ. COMMA .AND. CSTMT(IA:IA) .GE. C0 .AND.
     1   CSTMT(IA:IA) .LE. C9) THEN
         L1 = LFALSE
      ELSE
         L1 = LTRUE
      END IF
      IF(L1 .AND. (CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ
     1   .OR. CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(I3:I3) .GE. CAA .AND.
     2   CSTMT(I3:I3) .LE. CZZ .OR. CSTMT(I3:I3) .EQ. CUNDER)) THEN
         CALL VSETUP (IA,IB,IC,LFALSE,LFALSE,CSTMT)
         GO TO 14
      ELSE IF(CSTMT(I1:I1) .GE. CAA .AND. CSTMT(I1:I1) .LE. CZZ .OR.
     1   CSTMT(I1:I1) .EQ. CUNDER) THEN
         IC = I2 - I1 + 1
         CALL VSETUP (I1,I2,IC,LFALSE,LFALSE,CSTMT)
         GO TO 14
      ELSE
         IB = ICOM1 - IA
         CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
         GO TO 14
      END IF
C
C         DETERMINE IF THE PARAMETER IS A NUMERIC VALUE
C
      IF(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IC:IC) .LE. C9) THEN
         IB = ICOM1 - IA
         CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
      END IF
C
C         PROCESS THE SECOND PARAMETER EXPRESSION
C
 14   IA = ICOM1 + 1
      KB = KBB
C
C         DETERMINE IF ONLY TWO DO LOOP PARAMETERS EXIST
C
      IF(LCOM1) THEN
         IF(LCOM2) THEN
            IB = ICOM2 - 1
         ELSE
            IB = KB
         END IF
      END IF
      DO 15 I = IA,IB
C
C      DETERMINE IF THE PARAMETER IS AN ARITHMETIC EXPRESSION OR IF
C      A SUBSCRIPT EXISTS. PARENTHESES FOR A SUBSCRIPT ARE TREATED
C      AS AN EXPRESSION.
C
      IF(CSTMT(I:I) .EQ. CPLUS .OR. CSTMT(I:I) .EQ. CMINUS .OR.
     1   CSTMT(I:I) .EQ. CASTER .OR. CSTMT(I:I) .EQ. CSLASH .OR.
     2   CSTMT(I:I) .EQ. CLPAR) THEN
C
C         DETERMINE IF THE SECOND PARAMETER IS A SIGNED NUMBER OR AN
C         EXPRESSION
C
         DO 140 IC = IA,IB
C
C         THE OCCURRENCE OF AN ALPAHETIC CHARACTER INDICATES THE
C         PARAMETER IS AN ARITHMETIC EXPRESSION
C
         IF(CSTMT(IC:IC) .GE. CAA .AND. CSTMT(IC:IC) .LE. CZZ .OR.
     1      CSTMT(IC:IC) .EQ. CUNDER) THEN
            KB = ICOM2 - 1
            CALL EXPR (IA,IB,LFALSE,CSTMT)
            GO TO 16
         END IF
 140     CONTINUE
C
C         WHEN NO ALPHABETIC CHARACTERS OCCUR IN THE PARAMETER, IT
C         CONTAINS ONLY ARITHMETIC OPERATORS AND DIGITS
C
         IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9))
     1      THEN
            IB = ICOM2 - IA
            CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
            CALL INSERT (IIB)
            GO TO 16
         END IF
C
C         WHEN THE FIRST CHARACTER OF THE EXPRESSION IS NOT A NUMBER,
C         PROCESS AN EXPRESSION
C
         IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9))
     1      THEN
            KB = ICOM2 - 1
            CALL EXPR (IA,IB,LFALSE,CSTMT)
            GO TO 16
         END IF
      END IF
 15   CONTINUE
C
C         WHEN IA AND IB ARE EQUAL, DETERMINE IF THE CHARACTER IS A
C         NUMERICAL DIGIT
C
      IF(IA .EQ. IB) THEN
         IF(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9) GO TO 150
      END IF
C
C         DETERMINE IF THE PARAMETER IS A VARIABLE. THE VARIABLE MAY BE
C         A COMPOUND VARIABLE, BUT IT CAN NOT BE PART OF AN EXPRESSION;
C         SINCE AN ARITHMETIC EXPRESSION HAS ALREADY BEEN PROCESSED.
C
      IF(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ .OR.
     1   CSTMT(IA:IA) .EQ. CUNDER) THEN
         CALL VSETUP (IA,IB,IC,LFALSE,LFALSE,CSTMT)
         GO TO 16
      END IF
C
C         DETERMINE IF THE PARAMETER IS A NUMERIC VALUE
C
 150  IF(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IC:IC) .LE. C9) THEN
         IB = ICOM1 - IA
         CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
         CALL INSERT ( IIB)
      END IF
C
C         DETERMINE IF A THIRD PARAMETER EXISTS
C
 16   IF(.NOT.LCOM2) GO TO 18
      KB = KBB
      IA = ICOM2 + 1
      IB = KBB
      DO 17 I = IA,IB
C
C      DETERMINE IF THE PARAMETER IS AN ARITHMETIC EXPRESSION OR IF
C      A SUBSCRIPT EXISTS. PARENTHESES FOR A SUBSCRIPT ARE TREATED
C      AS AN EXPRESSION.
C
      IF(CSTMT(I:I) .EQ. CPLUS .OR. CSTMT(I:I) .EQ. CMINUS .OR.
     1   CSTMT(I:I) .EQ. CASTER .OR. CSTMT(I:I) .EQ. CSLASH .OR.
     2   CSTMT(I:I) .EQ. CLPAR) THEN
C
C         DETERMINE IF THE THIRD PARAMETER IS A SIGNED NUMBER OR AN
C         EXPRESSION
C
         DO 160 IC = IA,IB
C
C         THE OCCURRENCE OF AN ALPHABETIC CHARACTER INDICATES THE
C         PARAMETER IS AN ARITHMETIC EXPRESSION
C
         IF(CSTMT(IC:IC) .GE. CAA .AND. CSTMT(IC:IC) .LE. CZZ .OR.
     1      CSTMT(IC:IC) .EQ. CUNDER) THEN
            KB = KBB
            CALL EXPR (IA,IB,LFALSE,CSTMT)
            GO TO 18
         END IF
 160     CONTINUE
C
C         WHEN NO ALPAHABETIC CHARCTER OCCUR IN THE PARAMETER, IT
C         CONTAINS ONLY ARITHMETIC OPERATORS AND DIGITS
C
         IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9))
     1      THEN
            IB = KBB - IA
            CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
            CALL INSERT (IIB)
            GO TO 18
         END IF
C
C         WHEN THE FIRST CHARACTER OF THE EXPRESSION IS NOT A NUMBER,
C         PROCESS AN EXPRESSION
C
         IF(.NOT.(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IA:IA) .LE. C9))
     1      THEN
            CALL EXPR (IA,IB,LFALSE,CSTMT)
            GO TO 18
         END IF
      END IF
 17   CONTINUE
C
C         DETERMINE IF THE PARAMETER IS A VARIABLE. THE VARIABLE MAY BE
C         A COMPOUND VARIABLE, BUT IT CAN NOT BE PART OF AN EXPRESSION;
C         SINCE AN ARITHMETIC EXPRESSION HAS ALREADY BEEN PROCESSED.
C
      IF(CSTMT(IA:IA) .GE. CAA .AND. CSTMT(IA:IA) .LE. CZZ .OR.
     1   CSTMT(IA:IA) .EQ. CUNDER) THEN
         IF(.NOT.(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9))
     1      THEN
            CALL VSETUP (IA,IB,IC,LFALSE,LFALSE,CSTMT)
            GO TO 18
         END IF
      END IF
C
C         DETERMINE IF THE PARAMETER IS A NUMERIC VALUE
C
      IF(CSTMT(IA:IA) .GE. C0 .AND. CSTMT(IC:IC) .LE. C9) THEN
         CALL NUMBER (CSTMT,LTRUE,IA,IIB,FP,IFP)
         CALL INSERT (IIB)
      END IF
C
C         RESTORE THE ORIGINAL VALUE OF KB
C
 18   KB = KBB
      LEXEC = LTRUE
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM PROCESSES THE DO WHILE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSTMT  - CHARACTER VARIABLE, THE STATEMENT BEING PROCESSED
C         ID     - END OF THE LOGICAL EXPRESSION
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         I1     - COUNT OF PARENTHESES, ADD ONE FOR A LEFT, SUBTRACT
C                  ONE FOR RIGHT
C         I2     - LOCATION OF THE INITIAL LEFT PARENTHESIS
C         I3     - LOCATION OF THE FINAL LEFT PARENTHESIS
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST LEFT
C                  PARENTHESIS IS FOUND, SET FALSE OTHERWISE
C
C     SUBROUTINES CALLED
C
C         EXPR
C
C     ******************************************************************
C
C     SUBROUTINE STMT17
C
C         IMPLICIT STATEMENT
C
C     IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
C     DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
C    1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
C    2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
C    3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
C    4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
C    5JCONFT(4000), JSTR(20)
C     DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
C     CHARACTER*6606  CSTMT
C     CHARACTER*132   CREC, CSREC, CSAVST
C     CHARACTER*104   CDIM
C     CHARACTER*92    CLITWK
C     CHARACTER*82    CFMTL
C     CHARACTER*80    CIFILE
C     CHARACTER*72    CVARST
C     CHARACTER*68    CRECTB, CWK68
C     CHARACTER*56    CSUBTB
C     CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
C     CHARACTER*44    CUNION
C     CHARACTER*40    COMTBL
C     CHARACTER*36    CSTR, CSTRNM
C     CHARACTER*32    CEXTNL, COUTV, CWK32
C     CHARACTER*8     CBLANK, CIMPL, CWK8
C     CHARACTER*7     CWK7
C     CHARACTER*2     CI2WK1
C     CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
C    1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
C    2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
C     CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
C     CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
C    1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
C    2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
C    3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
C    4                CUNDER
C     REAL*8          FCONFT, FP
C     INTEGER*2       ISRECL, I2WK1
C     LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
C    1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
C    2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
C    3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
C    4                LZEND
C     LOGICAL*1       L1
C
C         COMMON STATEMENTS
C
C     COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
C    1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
C    2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
C     COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
C     COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
C    1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
C    2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
C    3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
C     COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
C    1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
C    2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
C     COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
C    1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
C    2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
C    3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
C    4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
C    5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
C     COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
C    1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
C    2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
C    3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
C     COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
C    1               CWK32, CWK68
C     COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
C    1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
C    2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
C    3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
C     EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
C    1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         FORMAT STATEMENTS
C
C100  FORMAT(' ISN:',I6,' NOT A FORTRAN STATEMENT')
C
C         SAVE STATEMENT
C
C     SAVE
C
C         BLANK CHARACTER WORK AREA AND INITIALIZE ROUTINE
C
C     CWORK(1:52) = CBLK52(1:52)
C     JBITS = 0
C     L1 = LFALSE
C
C         VERIFY THIS IS A DO WHILE STATEMENT
C
C     J = KF + 6
C     LEXEC =  LFALSE
C     IF(CSTMT(KF:J) .EQ. 'DOWHILE') THEN
C        J = J + 1
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS NOT A DO WHILE
C         STATEMENT
C
C        I1 = 0
C        DO 10 I = J,KB
C        IF(CSTMT(I:I) .EQ. CEQ) THEN
C           CALL EXPR (KF,KB,LFALSE,CSTMT)
C           GO TO 11
C        END IF
C
C         LOCATE THE START OF THE LOGIC CONDITION
C
C        IF(CSTMT(I:I) .EQ. CLPAR .AND. L1) THEN
C           IF(I1 .EQ. 0) I2 = I
C           I1 = I1 + 1
C           L1 = LTRUE
C           END IF
C
C         LOCATE THE END OF THE LOGIC CONDITION
C
C        IF(CSTMT(I:I) .EQ. CRPAR .AND. L1) THEN
C           I1 = I1 - 1
C           IF(I1 .EQ. 0) I3 = I
C        END IF
C10      CONTINUE
C
C         A DO WHILE STATEMENT EXISTS, ANALYZE THE LOGICAL CONDITION
C
C        LEXEC = LTRUE
C        IF(I2 .NE. 0 .AND. I3 .NE. 0) THEN
C           KF = KF + 2
C           CALL EXPR (I2,I3,LFALSE,CSTMT)
C        ELSE
C           WRITE (0,100) ISN
C           IRE0 = IREC0 + 1
C        END IF
C     END IF
C
C         ROUTINE EXIT
C
C11   RETURN
C     END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE DOUBLE COMPLEX AND DOUBLE
C        PRECISION STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLEN   - CHARACTER VARIABLE, LENGTH OF THE DATA TYPE
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, DATA TYPE CODE; IT IS E FOR
C                  THE DOUBLE COMPLEX TYPE, AND D FOR DOUBLE PRECISION
C                  TYPE
C         I      - SUBSCTRIPT VARIABLE
C         IPGNME - LENGTH OF THE FUNCTION NAME
C         IREC0  - COUNT OF THE NUMBER OF ERROR MESSAGES ON UNIT 0
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  THE VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I2WK1  - COUNT OF THE NUMBER SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES; VALUE PASSED TO ROUTINE TYPLST
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE
C         I5     - COUNT OF THE NUMBER OF SLASHES
C         I6     - SUBSCRIPT VARIABLE AND WORK AREA
C         I7     - SUBSCRIPT VARIABLE
C         I8     - THE VALUE OF KB FOR DO LOOPS
C         I9     - LENGTH OF THE ILLEGAL LENGTH SPECIFICATION FIELD
C                  THE LENGTH FIELD IN THE STATEMENT
C         I10    - LOCATION OF A LEFT PARENTHESIS TERMINATING A VARIABLE
C                  NAME
C         I11    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS LOCATED BY I10
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - ADJUSTMENT FOR THE END OF A STATMENT IDENTIFIER
C         JC     - COUNT OF THE NUMBER OF SLASHES IN THE STATEMENT
C         KB     - LOCATION OF THE FINAL CHARACTER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH
C                  SPECIFICATION EXISTS FOR DOUBLE COMPLEX OR DOUBLE
C                  PRECISION, SET FALSE OTHERWISE.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHESIS
C                  EXISTS FOR DOUBLE COMPLEX OR DOUBLE PRECISION
C                  STATEMENT, SET FALSE OTHERWISE. WHEN AN ASTERISK
C                  PRECEDES A LEFT PARENTHESIS, AN ILLEGAL LENGTH
C                  SPECIFICATION EXISTS IN THE STATEMENT.
C         L4     - LOGICAL VARIABLE, SET TRUE IF LENGTH A SPECIFICATION
C                  HAS BEEN REMOVED FROM THE STATEMENT, SET FALSE
C                  OTHERWISE.
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         ONLY THE [DIMENSION] SPECIFICATION MAY BE AN EXPRESSION FOR
C         EACH SUBSCRIPT
C
C     SUBROUTINES CALLED
C
C         EXPR LOCERR STMT29 TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT18
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN
      LOGICAL*1   L2, L3, L4, L5
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' END STATEMENT MISSING')
 101  FORMAT(' ISN:',I6,' ASTERISK IS ILLEGAL IN THIS STATEMENT')
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CLEN(1:7) = CBLANK(1:7)
      LEXEC =  LFALSE
      LFORCE = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
C
C         VERIFY THIS IS A DOUBLE STATEMENT
C
      J = KF + 5
      IF(CSTMT(KF:J) .EQ. 'DOUBLE') THEN
         J = J + 1
         JA = J + 6
         LFORCE = LTRUE
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS AN ARITHMETIC
C         STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 17
         END IF
 10      CONTINUE
C
C         DETERMINE IF AN ASTERISK OCCURS IN THIS STATEMENT
C
 11      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         I8 = KB
         DO 14 I = 1,I8
         IF(CSTMT(I:I) .EQ. CLPAR) L3 = LTRUE
         IF(.NOT.L3 .AND. CSTMT(I:I) .EQ. CASTER) L2 = LTRUE
         IF(L2) THEN
C
C         WRITE AN ERROR MESSAGE
C
            IF(.NOT.L4) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
            END IF
C
C         REMOVE THE LENGTH SPECIFICATION FROM THE STATEMENT.
C
            DO 12 I6 = I+1,I8
            IF(.NOT.(CSTMT(I6:I6) .GE. C0 .AND. CSTMT(I6:I6) .LE. C9))
     1         THEN
C
C         SHIFT ALL CHARACTERS TO THE RIGHT OF THE ALPHABETIC CHARACTER
C         LEFT TO REMOVE THE BLANKS INSERTED ABOVE.
C
               I9 = I6 - I
               I7 = I8 - I9
               CSTMT(I:I7) = CSTMT(I6:I8)
               CSTMT(I7+1:I8) = CBLANK(1:I9)
               KB = I7
               GO TO 13
            END IF
 12         CONTINUE
 13         L2 = LFALSE
            L3 = LFALSE
            L4 = LTRUE
            GO TO 11
         END IF
 14      CONTINUE
C
C         DETERMINE IF DOUBLE COMPLEX
C
         LEXEC = LTRUE
         JA = J + 6
         IF(CSTMT(J:JA) .EQ. 'COMPLEX') THEN
            J = JA + 1
C
C         PLACE TYPE CODE
C
            CTYPED(1:1) = CEE
            CLEN(1:2) = '16'
C
C         DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION STATEMENT
C
            IF(.NOT.LZEND) THEN
C
C         AN END STATEMENT PRECEDED THE FUNCTION STATEMENT
C
               IF(ISN .GT. 1) THEN
                  WRITE (0,100) ISN
                  IREC0 = IREC0 + 1
                  LENDS = LTRUE
                  LZEND = LTRUE
               END IF
            END IF
            GO TO 15
         END IF
C
C         DETERMINE IF DOUBLE PRECISION
C
         IF(CSTMT(J:J+8) .EQ. 'PRECISION') THEN
            J = J + 9
C
C         PLACE TYPE CODE
C
            CTYPED(1:1) = CDD
            CLEN(1:1) = C8
         END IF
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
 15      IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
            KF = J
            CALL STMT29 (CTYPED,CLEN)
            GO TO 17
         END IF
C
C         THE STATEMENT IS NOT A FUNCTION, PROCESS IT AS EITHER A
C         DOUBLE PRECISION OR A DOUBLE COMPLEX STATEMENT
C
C         THE STATEMENT MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIF-
C         ICATI0NS. THE VALUE IN J IS THE LOCATION OF THE FIRST
C         CHARACTER TO BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         I1 = 0
         I2 = J
         I6 = 0
         I10 = 0
         I11 = 0
         DO 16 I5 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
         IF(CSTMT(I5:I5) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I10 = I5
         END IF
         IF(CSTMT(I5:I5) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I11 = I5
         END IF
         IF(I1 .EQ. 0 .AND. CSTMT(I5:I5) .EQ. CSLASH) I6 = I6 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
         IF(I1 .EQ. 0 .AND. MOD(I6,2) .EQ. 0) THEN
            IF(CSTMT(I5:I5) .EQ. COMMA .OR. I5 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               I3 = I5
               IF(I5 .GT. 0) I2WK1 = I5
               LFORCE = LTRUE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I10 .GT. 0 .AND. I11 .GT. 0) THEN
                  L5 = LTRUE
               ELSE
                  L5 = LFALSE
               END IF
               IF(CLEN(1:1) .EQ. CBLANK(1:1)) CLEN(1:1) = C8
               CALL TYPLST (CTYPED,CLEN,I2,I3,L5)
               LFORCE = LFALSE
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I5 .EQ. KB) GO TO 16
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I5:I5) .EQ. COMMA) THEN
                  I1 = 0
                  I2 = I5 + 1
C                 I5 = 0
                  CLEN(1:7) = CBLANK(1:7)
               END IF
            END IF
         END IF
 16      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 17   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE ELSE AND ELSEIF STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         I      - SUBSCRIPT VARIABLE
C         ISN    - THE ISN VALUE OF THE CURRENT STATEMENT
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         KB     - LOOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C
C     SUBROUTINES CALLED
C
C         EXPR STMT31
C
C     *****************************************************************
C
      SUBROUTINE STMT19
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' ELSE STATEMENT MISPELLED')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC =  LFALSE
C
C         VERIFY THIS IS AN ELSE STATEMENT
C
      J = KF + 3
      IF(CSTMT(KF:J) .EQ. 'ELSE') THEN
         J = J + 1
         LEXEC =  LTRUE
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS AN ARITHMETIC
C         STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LEXEC =  LFALSE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 12
         END IF
 10      CONTINUE
C
C         WHEN ELSE IS FOLLOWED BY IF, THIS IS AN ELSEIF STATEMENT
C
         IF(CSTMT(J:J+1) .EQ. 'IF') THEN
            KF = J
            CALL STMT31 (LFALSE,*12,*12)
            GO TO 12
         END IF
         GO TO 12
      ELSE
         GO TO 12
      END IF
C
C         TEST IF AN ILLEGAL ELSE STATEMENT
C
      IF(CSTMT(J:J) .EQ. CBLANK(1:1)) GO TO 12
C
C         ELSE STATEMENT IS MISPELLED
C
      IF(ISN .GT. 0 .AND. .NOT.LINCL) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE VARIOUS FORMS OF THE END
C        STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         IRET   - RETURN VARIABLE CHOICE, SET TO 1 FOR A NORMAL
C                  DO STATEMENT, SET TO 2 TO PROCESS THIS STATEMENT
C                  AS AN EXPRESSION
C         ID     - COUNT PARENTHESES, ADD 1 FOR A LEFT PARENTHESIS,
C                  SUBTRACT 1 FOR A RIGHT PARENTHESIS
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JE     - LOCATION OF THE ENXT CHARACTER FOLLOWING A COMMA OR
C                  A RIGHT PARENTHESIS
C         JSTRUC - COUNT OF THE LEVELS OF STRUCTURE STATEMENTS. ONE IS
C                  ADDED WHEN A STRUCTURE STATEMENT IS PROCESSED, ONE
C                  IS SUBTRACTED WHEN AN END STRUCTURE STATEMENT IS
C                  PROCESSED.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS PROCESSED AND THE
C                  ARGUMENT IS A VARIABLE NAME; THIS PERMITS A SEARCH
C                  FOR POSSIBLE SUBSCRIPT VARIABLES OR CONSTANTS.
C                  SET FALSE OTHERWISE. THIS IS USED TO FORCE A NEW LOOP
C                  SEQUENCE IN THE CALLING ROUTINE.
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF A FORTRAN ROUTINE HAS BEEN READ. SET FALSE
C                  OTHERWISE.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT RETURNS TO ZERO.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         LWR    - LOGICAL VARIABLE, SET TRUE WHEN A TRUE END STATEMENT
C                  OCCURS TO FORCE WRITE OUT FOR THE CURRENT ROUTINE
C                  BEING PROCESSED, SET FALSE OTHERWISE
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A COMMA OR RIGHT
C
C                  PAREMTHESIS OCCUR, SET FALSE OTHERWISE. THIS IS USED
C                  TO SKIP PROCESSING OF A UNIT ARGUMENT SINCE IT HAS
C                  ALREADY BEEN PROCESSED.
C
C     COMMENTS
C
C         END, END FILE, END WHILE ARE EXECUTABLE STATEMENTS
C
C         END STRUCTURE AND END UNION ARE NOT EXECUTABLE STATEMENTS
C
C     SUBROUTINES CALLED
C
C         ESTRUC EUNION EXPR LOCERR STMT23
C
C     *****************************************************************
C
      SUBROUTINE STMT21 (*)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (CWORK(45:48),JBITS),
     1(CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,'END STATEMENT ILLEGAL IN AN INCLUDE STATEMENT')
C
C         VERIFY THIS IS AN END STATEMENT OF SOME KIND
C
      J = KF + 2
      IRET = 1
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'END') THEN
         J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION
C
         IF(J .NE. KB) THEN
            DO 10 I = J,KB
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               LEXEC = LTRUE
               GO TO 11
            END IF
 10         CONTINUE
         END IF
C
C         DETERMINE IF AN ENDFILE STATEMENT
C
         LEXEC = LTRUE
         IF(CSTMT(J:J+3) .EQ. 'FILE') THEN
            LSTART = LTRUE
            CALL STMT23
            LEXEC = LTRUE
            GO TO 11
         END IF
C
C         THIS IS AN END STRUCTURE STATEMENT
C
         IF(CSTMT(J:J+8) .EQ. 'STRUCTURE') THEN
            IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
            CALL ESTRUC
            LEXEC = LTRUE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            IF(JSTRUC .EQ. 0) LSTRUC = LFALSE
         END IF
C
C         THIS IS AN END UNION STATEMENT
C
         IF(CSTMT(J:J+4) .EQ. 'UNION') THEN
            IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
            CALL EUNION
            LEXEC = LTRUE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
         END IF
C
C         THIS IS AN END WHILE STATEMENT
C
         IF(CSTMT(J:J+2) .EQ. 'WHI') THEN
            LSTART = LTRUE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
            LEXEC = LTRUE
            GO TO 11
         END IF
C
C         THIS IS AN END STATEMENT TERMINATING A PROGRAM OR SUBPROGRAM
C
         IF(KB .EQ. 3) THEN
            IF(.NOT.LINCL) THEN
               LENDS = LTRUE
               LWR = LTRUE
               LZEND = LTRUE
            ELSE
               IREC0 = IREC0 + 1
               WRITE (0,100) ISN
            END IF
         END IF
      END IF
 11   RETURN IRET
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE ENDFILE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS: (
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS: )
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         I      - SUBSCRIPT VARIABLE
C         ID     - COUNT OF THE NUMBER OF PARENTHESES
C         IE     - INDEX VALUE OF THE ARGUMENT IN ARRAY CLIST TO BE
C                  PROCESSED
C         IREC0  - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         I1     - SUBSCRIPT VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JB     - END LOCATION OF A VARIABLE NAME OR NUMBER
C         JE     - SUBSCRIPT VARIABLE, THE LOCATION OF THE INTIAL
C                  CHARACTER OF AN ARGUMENT
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE
C         LB     - LOGICAL VARIABLE, SET TRUE ONCE AN ERR ARGUMENT IS
C                  PROCESSED, SET FALSE OTHERWISE
C         LC     - LOGICAL VARIABLE, SET TRUE ONCE AN IOSTAT ARGUMENT IS
C                  PROCESSED, SET FALSE OTHERWISE
C         LD     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT IS PROCESSED AND THE ARGUMENT
C                  IS A VARIABLE NAME; THIS PERMITS A SEARCH FOR
C                  POSSIBLE SUBSCRIPT VARIABLES OR CONSTANTS, SET FALSE
C                  OTHERWISE.
C         LE     - LOGICAL VARIABLE, SET TRUE WHEN A PARTICULAR COMMAND
C                  LIST ARGUMENT HAS BEEN PROCESSED, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST ARGUMENT
C                  IS PROCESSED, I.E., THE UNIT DESIGNATION
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A LITERAL, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A VARIABLE, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE MAY
C                  BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         END FILE IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         CIOLST CUNIT EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT23
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3CVARST(1000), FCONFT(4000), ICONIT(2,2000),
     4IENAME(13,4000), IOUTC(100), ISNUM(2,1000), ISRECL(20),
     5JCONFT(4000), JSTR(20)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      LOGICAL*1 LA, LB, LC, LD, LE, L1, L2, L3, L4, L5
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/ IE, LE, L2, L3, L4, L5, LD
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' DUPLICATE ERR ARGUMENT IN ENDFILE')
 101  FORMAT(' ISN:',I6,' DUPLICATE IOSTAT ARGUMENT IN ENDFILE')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      L1 = LFALSE
      LEXEC = LFALSE
      LB = LFALSE
      LC = LFALSE
C
C         VERIFY THIS IS AN ENDFILE STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'ENDFILE') THEN
         J = J + 1
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT; IT IS IF AN
C         EQUAL SIGN IN NOT ENCAPSULATED WITHIN PARENTHESES
C
         ID = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
         IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(ID .EQ. 0) THEN
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 13
            END IF
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         VERIFY THAT A LEFT PARENTHESIS FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            J = J + 1
C
C         TEST FOR UNIT DESIGNATION WITH PARENTHESES, IT MUST BE THE
C         FIRST ARGUMENT
C
            CALL CUNIT
C
C         LOOP FOR THE REMAINING ARGUMENTS OF THE CONTROL LIST
C
 11         DO 12 I1 = J,KB
C
C         TEST FOR A COMMA OR A RIGHT PARENTHESIS; THIS CAUSES THE
C         UNIT DESIGNATION TO BE SKIPPED OVER.
C
            IF(CSTMT(I1:I1) .EQ. COMMA .OR. CSTMT(I1:I1) .EQ. CRPAR)
     1         THEN
               IF(.NOT.L1) THEN
                  L1 = LTRUE
                  JE = I1 + 1
                  IF(I1 .EQ. KB) THEN
                     GO TO 13
                  END IF
               END IF
C
C         PROCESS THE ERR= ARGUMENT
C
               IF(CSTMT(I1:I1) .EQ. COMMA) J = I1 + 1
               IF(CSTMT(J:J+2) .EQ. 'ERR') THEN
C
C         WRITE DUPLICATE ERR ARGUMENT SPECIFICATION MESSAGE
C
                  IF(LB) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,101) ISN
                  END IF
                  IE = 13
                  LD = LFALSE
                  LE = LFALSE
                  L2 = LFALSE
                  L3 = LFALSE
                  L4 = LFALSE
                  L5 = LFALSE
                  CALL CIOLST
                  LA = LD
                  LB = LE
                  IF(LA) THEN
                     J = J + 1
                     LA = LFALSE
                     IF(J .GE. KB) THEN
                        GO TO 13
                     ELSE
                        GO TO 11
                     END IF
                  END IF
               END IF
C
C         PROCESS THE IOSTAT = ARGUMENT
C
               IF(CSTMT(J:J+5) .EQ. 'IOSTAT') THEN
C
C         WRITE DUPLICATE IOSTAT ARGUMENT SPECIFICATION MESSAGE
C
                  IF(LC) THEN
                     IREC0 = IREC0 + 1
                     WRITE (0,100) ISN
                  END IF
                  IE = 21
                  LD = LFALSE
                  LE = LFALSE
                  L2 = LFALSE
                  L3 = LTRUE
                  L4 = LFALSE
                  L5 = LFALSE
                  CALL CIOLST
                  LC = LE
                  LA = LD
                  IF(LA) THEN
                     J = J + 1
                     LA = LFALSE
                     IF(J .GE. KB) THEN
                        GO TO 13
                     ELSE
                        GO TO 11
                     END IF
                  END IF
               END IF
            END IF
 12         CONTINUE
         ELSE
C
C         NO PARENTHESES EXIST, ONLY A NUMBER OR VARIABLE NAME IS
C         SPECIFIED AS THE UNIT
C
            CALL CUNIT
         END IF
      END IF
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE ENTRY STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE
C                  DEFINITION RECORD OF A SUBPROGRAM; LENGTH IS
C                  1496 CHARACTERS
C         CDEFWK - CHARACTER VARIABLE, WORK BUFFER TO SAVE A DEFINITION
C                  RECORD OF A SUBPROGRAM; LENGTH IS 1496 CHARACTERS.
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE
C                  STATEMENT BEING PROCESSED. C - CALL, E - ENTRY,
C                  S - SUBROUTINE
C         CTYPSV - CHARACTER VARIABLE, SAVED VALUE OF CTYPED EXISTING
C                  BEFORE AN ENTRY STATEMENT OCCURRED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         IPGNME - ENTRY NAME CHARACTER LENGTH
C         IREC1  - COUNT OF THE NUMBER OF RECORDS ON UNIT 1
C         IREC3  - COUNT OF THE NUMBER OF RECORDS ON UNIT 3
C         IREC10 - RECORD COUNT FOR UNIT 10
C         IRET   - SET TO A VALUE OF 1 WHEN AN ELSE STATEMENT IS
C                  PROCESSED; SET TO A VALUE OF 2 WHEN A VARIABLE STARTS
C                  WITH ENTRY
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         I1     - SUBSCRIPT VARIABLE
C         I2     - START SUBSCRIPT VALUE FOR BLANKING VARIABLE CDEF
C         I3     - END SUBSCRIPT VALUE FOR BLANKING VARIABLE CDEF
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JNARG  - NUMBER OF ARGUMENTS IN AN ENTRY STATEMENT
C         JVCNT  - LENGTH OF THE ENTRY NAME
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KNARG  - NUMBER OF ARGUMENTS IN A SUBROUTINE STATEMENT
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LCALLW - LOGICAL VARIABLE, SAVE AREA FOR LCALL WHILE AN
C                  ENTRY STATEMENT IS BEING PROCESSED.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT.
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 3.
C         LTESTW - LOGICAL VARIABLE, SAVE AREA FOR LTEST WHILE
C                  AN ENTRY STATEMENT IS BEING PROCESSED.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         NARGS  - NUMBER OF ARGUMENTS IN AN ENTRY STATEMENT
C         NARGSW - SAVE AREA FOR NARGS WHILE PROCESSING AN ENTRY
C                  STATEMENT.
C
C     COMMENTS
C
C         ENTRY IS AN EXECUTABLE STATEMENT.
C         VARIABLE CDEFWK IS USED TO SAVE VARIABLE CDEF FOR A SUBPROGRAM
C         THAT IS CURRENTLY BEING PROCESSED. AN ENTRY STATEMENT ALWAYS
C         OCCURS AFTER A FUNCTION OR SUBROUTINE STATEMENT. PROCESSING
C         AN ENTRY STATEMENT WILL DESTROY THE FUNCTION OR ENTRY DATA
C         NECESSARY FOR CHECKING THE CONSISTANCY OF ARGUMENTS TYPE AND
C         LENGTH VALUES IN ROUTINE ARGCHK.
C         IN ROUTINE ARGCHK.
C
C         ALL ARGUMENTS OF AN ENTRY STATEMENT ARE DUMMY VARIABLES.
C         NO DUMMY VARIABLE MAY BE A COMPOUND VARIABLE, OR ANY TYPE
C         OF EXPRESSION (ARITHMETIC, LOGICAL, CHARACTER).
C
C     SUBROUTINES CALLED
C
C         ARGLST EXPR IBSET
C
C     *****************************************************************
C
      SUBROUTINE STMT25
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED, CTYPSV
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LCALLW, LTESTW
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
      EQUIVALENCE (CDEF(49:52),JVCNT), (CDEF(53:56),JNARG)
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
C
C         VERIFY THIS IS AN ENTRY STATEMENT
C
      J = KF + 4
      IF(CSTMT(KF:J) .EQ. 'ENTRY') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS AN ARITHMETIC
C         EXPRESSSION STATEMENT
C
         DO 10 I1 = J,KB
         IF(CSTMT(I1:I1) .EQ. CEQ) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            LEXEC = LFALSE
            GO TO 14
         END IF
 10      CONTINUE
      ELSE
         LEXEC = LFALSE
         GO TO 14
      END IF
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
      LEXEC = LTRUE
      LCALLW = LCALL
      LCALL = LFALSE
C
C         SAVE THE SUBROUTINE CDEF RECORD IN ORDER TO CONTINUE
C         PROCESSING THE CURRENT SUBROUTINE WHERE THE ENTRY STATEMENT
C         OCCURS
C
      CDEFS(1:1496) = CDEF(1:1496)
C
C         THIS IS AN ENTRY STATEMENT; FIND THE END OF THE ENTRY NAME.
C
      NARGSW = NARGS
      LTESTW = LTEST
      LTEST = LTRUE
      DO 12 I = J,KB
C
C         WHEN NO LEFT PARENTHESIS IS FOUND PRIOR TO THE FINAL CHARACTER
C         OF THE STATEMENT, THERE ARE NO ARGUMENTS, AND J & KB ARE THE
C         START AND END LOCATIONS OF THE ENTRY NAME.
C
      IF(I .EQ. KB .OR. CSTMT(I:I) .EQ. CLPAR) THEN
         IWORK = ISN + 128
         IVCNT = I - J
         IF(I .EQ. KB) CWORK(1:IVCNT) = CSTMT(J:I)
         IF(CSTMT(I:I) .EQ. CLPAR) CWORK(1:IVCNT) = CSTMT(J:I-1)
         GO TO 13
      END IF
 12   CONTINUE
C
C         PROCESS THE ARGUMENTS OF THE ENTRY STATEMENT
C
 13   JA = J
      CTYPSV(1:1) = CTYPED(1:1)
      CTYPED(1:1) = CEE
      JBITS = IBSET(JBITS,8)
      KNARG = JNARG
      CTYPED(1:1) = CTYPSV(1:1)
      CALL ARGLST (CTYPED,CSTMT,KB)
      CTYPED(1:1) = CTYPSV(1:1)
C
C         WRITE THE ENTRY RECORD ONTO UNIT 3
C
      IF(LGLOBL) THEN
         IREC3 = IREC3 + 1
         WRITE (3,REC=IREC3) CDEF(1:1496)
C
C         RESTORE THE SUBROUTINE CDEF RECORD IN ORDER TO CONTINUE
C         PROCESSING THE CURRENT SUBROUTINE WHERE THE ENTRY STATEMENT
C         OCCURS
C
         CDEF(1:1496) = CDEFS(1:1496)
         LTEST = LTESTW
      END IF
C
C         RESTORE THE ORIGINAL VALUE OF LCALL
C
 14   LCALL = LCALLW
      NARGS = NARGSW
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE EQUIVALENCE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE APHABETIC CHARACTER: A
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CCC    - CHARACTER VARIABLE, THE LETTER: C
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32. THE
C                                  WORD LENGTH IS IN COLS. 38-44 IN
C                                  ARRAY CNAME.
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CEXTNL - CHARACTER VARIABLE, TABLE OF ALL EXTERNAL STATEMENT
C                  NAMES IN A ROUTINE BEING ANALYZED. THIS IS A GLOBAL
C                  TABLE CONTAINING ALL SUBPROGRAM NAMES DEFINED IN
C                  ANY ROUTINE IN THE CURRENT PROGRAM BEING PROCESSED.
C         CF101  - CHARACTER VARIABLE, THE ERROR MESSAGE THAT A VARIABLE
C                  USES CHARACTER RANGE SPECIFICATIONS, BUT THE VARIABLE
C                  IS NOT DEFINED AS A CHARACTER VARIABLE
C         CF102  - CHARACTER VARIABLE, THE ERROR MESSAGE THAT A VARIABLE
C                  USES SUBSCRIPTS, BUT THE VARIABLE IS NOT DIMENSIONED
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1, USED TO
C                  CONVERT AN INTEGER VALUE TO TEXT FORM
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         COLON  - CHARACTER VARIABLE, A COLON, :
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CUNDER - CHARACTER VARIABLE, AND UNDERSCORE CHARACTER: _
C         CWK80  - CHARACTER VARIABLE, USED TO WRITE UNIT 12 IN BINARY
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CZZ    - CHARACTER VARIABLE, THE ALPHABETIC CHARACTER: Z
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - THE VALUE OF A NUMBER RETURNED AS FLOATING POINT
C                  SINGLE PRECISION
C         I      - SUBSCRIPT VARIABLE
C         IA     - THE START LOCATION OF AN EQUIVALENCED GROUP OF
C                  VARIABLE NAMES
C         IC     - THE LENGTH OF A VARIABLE NAME AND WORK AREA FOR
C                  SUBSCRIPTING VALUES
C         ICOLON - LOCATION OF A COLON
C         ICOMMA - LOCATION OF A COMMA
C         ID     - THE END LOCATION OF A VARIABLE NAME OR LOCATION OF
C                  A CLOSING FINAL RIGHT PARENTHESIS
C         IE     - LOCATION OF AN INITIAL LEFT PARENTHESIS
C         IEXTNL - COUNT OF THE NUMBER OF ENTRIES IN CEXTLN
C         IFP    - LOCATION OF THE FIRST CHARACTER AFTER THE END OF A
C                  NUMERICAL FIELD. THIS IS RETURNED BY SUBROUTINE
C                  NUMBER.
C         II     - THE ARITHMETIC INTEGER VALUE OF A NUMBER
C         IIB    - THE END LOCATION OF AN EQUIVALENCED GROUP OF VARIABLE
C                  NAMES
C         IJ     - WORK AREA FOR SUBSCRIPTS
C         ILPAR  - LOCATION OF THE LEFT PARENTHESIS THAT TERMINATES
C                  A VARIABLE NAME
C         ILPAR1 - LOCATION OF A LEFT PARENTHESIS THAT MATCHES A RIGHT
C                  PARENTHESIS
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IREC0  - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 0
C         IREC12 - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 12
C         IRPAR  - LOCATION OF THE RIGHT PARENTHESIS THAT TERMINATES
C                  A VARIABLE NAME
C         IRET   - RETURN CODE FROM TABSRH INDICATING THE LOCATION OF
C                  IN VARIABLE NAME IN ARRAY CDIM
C         IRET1  - RETURN CODE FROM TABSRH INDICATING THE LOCATION OF
C                  IN VARIABLE NAME IN ARRAY CNAME
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVARKT - COUNT OF THE NUMBER OF SUBSCRIPTS FOR A VARIABLE
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IVEND  - DO LOOP PARAMETER, LOCATION OF THE FINAL CHARACTER
C                  OF A VARIABLE IN AN EQUIVALENCE GROUP
C         IVINI  - DO LOOP PARAMETER, LOCATION OF THE INITIAL CHARACTER
C                  OF A VARIABLE IN AN EQUIVALENCE GROUP
C         IWK80  - EQUIVALENCED TO CWK80
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         IX     - WORK AREA, USED TO COMPUTE THE VARIABLE NAME'S LENGTH
C         I2WK1  - SUBSCRIPT VARIABLE, EQUIVALENCED TO CI2WK1
C         J      - LOCATION OF THE CHARACTER BEING PROCESSED
C         JA     - LOCATION OF A COLON
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         JC     - COUNT OF PARENTHESES, ADD ONE FOR A LEFT AND SUBTRACT
C                  ONE FOR A RIGHT PARENTHESES.
C         JDIM   - NUMBER OF ENTRIES IN THE DIMENSION TABLE, CDIM
C         JEQKNT - KOUNT OF THE NUMBER OF VARIABLE NAMES OCCURRING
C                  WITHIN AN EQUIVALENCED GROUP
C         JEQNME - THE START AND END LOCATION OF EACH VARIABLE IN AN
C                  EQUIVALENCE GROUP; WORD 1 IS THE START AND WORD 2
C                  IS THE END LOCATION OF THE VARIABLE NAME
C         JGRP   - THE START AND END LOCATION OF AN EQUIVALENCE GROUP.
C                  WORD 1 IS THE START LOCATION; WORD 2 IS THE END
C                  LOCATION IN CSTMT. MAXIMUM OF 200 ALLOWED.
C         JF     - SUBSCRIPT VARIABLE
C         JGRPKT - COUNT OF THE NUMBER OF EQUIVALENCE GROUPS IN A SINGLE
C                  EQUIVALENCE STATEMENT
C         JLEFT  - LEFT LOCATIION OF A SUBSCRIPT SEPARATOR
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF THE STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT. IT IS USED TO FORCE
C                  PROCESSING OF A NEW STATEMENT.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE A VARIABLE HAS A LEFT
C                  PARENTHESIS, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A SUBSCRIPT EXISTS;
C         L3     - LOGICAL VARIABLE, SET TRUE TO INDICATE A COLON OCCURS
C                  WITHIN A VARIABLE SPECIFICATION, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER IS FOUND IN A VARIABLE NAME, SET FALSE
C                  OTHERWISE
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         12 - LIST OF VARIABLES IN AN EQUIVALENCED GROUP, RECORD
C              LENGTH IS 80 CHARACTERS.
C
C              RECORD STRUCTURE:
C
C              COLS TYPE WORD DESCRIPTION
C              1-32 C*32   8  VARIABLE NAME
C             33-36 I*4    9  ISN VALUE; SET NEGATIVE TO INDICATE THE
C                             VARIABLE IN COLS. 1-32 IS THE INITIAL
C                             VARIABLE OF AN EQUIVALENCED GROUP; ALL
C                             OTHER VARIABLE NAMES BELONGING TO THE SAME
C                             GROUP HAVE A POSITIVE VALUE.
C             37-40 I*4   10  INTEGER VALUE OF THE NUMBER OF SUBSCRIPTS
C             41-44 I*4   11  INTEGER VALUE OF THE STARTING LOCATION OF
C                             A CHARACTER VARIABLE SUBSTRING
C             45-48 I*4   12  INTEGER VALUE OF THE FIRST SUBSCRIPT
C             49-52 I*4   13  INTEGER VALUE OF THE SECOND SUBSCRIPT
C             53-56 I*4   14  INTEGER VALUE OF THE THIRD SUBSCRIPT
C             57-60 I*4   15  INTEGER VALUE OF THE FOURTH SUBSCRIPT
C             61-64 I*4   16  INTEGER VALUE OF THE FIFTH SUBSCRIPT
C             65-68 I*4   17  INTEGER VALUE OF THE SIXTH SUBSCRIPT
C             69-72 I*4   18  INTEGER VALUE OF THE SEVENTH SUBSCRIPT
C             73-76 I*4   19  BIT SWITCHES
C             77-80 I*4   20  ASSOCIATE VARIABLE INDEX OF THE RECORD
C
C     COMMENTS
C
C         EQUIVALENCE IS NOT AN EXECUTABLE STATEMENT AND A VARIABLE NAME
C         CAN NOT BE A COMPOUND NAME. MAP IS USED FOR COMPOUND NAMES.
C
C         ALL SPECIFIED SUBSCRIPT AND CHARACTER RANGE VALUES MAY BE
C         INTEGERS ONLY.  NO VARIABLE NAME MAY BE USED AS A SUBSCRIPT
C         OR A CHARACTER RANGE SPECIFICATION IN AN EQUIVALENCE STATEMENT
C
C         BIT SWITCH 18 IS SET TO OFF (ZERO) FOR EACH RECORD WRITTEN
C         ON UNIT 12. ONCE A RECORD IS PROCESSED BY ROUTINE PEQUIV,
C         BIT 18 IS SET TO ON (ONE).
C
C         THE FORM OF AN EQUIVALENCE STATEMENT IS:
C
C         EQUIVALENCE (NAME1,NAME2,...,NAMEn)
C
C         NAMEn MAY HAVE [SUBSCRIPT VALUES] OR [CHARACTER RANGE VALUES]
C
C         [SUBSCRIPT VALUES] AND [CHARACTER RANGE VALUES] ARE OPTINAL,
C         BUT (NAMEn) IS REQUIRED.
C
C     SUBROUTINES CALLED
C
C         BTEST CHKNME EXPR IBSET INSERT LOCERR NUMBER SETTL TABSRH
C
C     *****************************************************************
C
      SUBROUTINE STMT26
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         DIMENSION STATEMENTS FOR THIS ROUTINE ONLY
C
      DIMENSION IWK80(20), JGRP(2,200), JEQNME(2,20)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*109   CF101
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*84    CF102
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*80 CWK80
      LOGICAL*1    LA, L1, L2, L3, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CWK80,IWK80), (CWK8(2:2),CWK7),
     2(CNAME(1),IENAME(1,1)), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CF101/'('' ISN:'',I6,'' EQUIVALENCED VARIABLE '',AXX'', HAS A
     1 CHARACTER RANGE SPECIFIED BUT IS NOT A CHARACTER VARIABLE'')'/
      DATA CF102/'('' ISN:'',I6,'' EQUIVALENCED VARIABLE '',AXX'', USES
     1SUBSCRIPTS BUT IS NOT DIMENSIONED'')'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO LEFT OR RIGHT PARENTHESIS AFTER EQUIVALENCE
     1')
 102  FORMAT(' ISN:',I6,' EQUIVALENCE VARIABLE SUBSCRIPTS AND RANGE SPEC
     1IFICATIONS MUST BE NUMERIC')
 103  FORMAT(' ISN:',I6,' SUBSCRIPT COUNT ERROR FOR EQUIVALENCED VARIABL
     1E: ',A32)
 104  FORMAT(' ISN:',I6,' MORE THAN 200 EQUIVALENCE GROUPS')
C
C         VERIFY THIS IS AN EQUIVALENCE STATEMENT
C
      J = KF + 10
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'EQUIVALENCE') THEN
C
C         LOCATION OF THE LEFT PARENTHESIS OF THE FIRST EQUIVALENCE
C         GROUP
C
         J = J + 1
         LA = LFALSE
         LEXEC = LTRUE
C
C         IF AN EQUAL SIGN OCCURS, THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 28
         END IF
 10      CONTINUE
C
C         THIS IS A VALID EQUIVALENCE STATEMENT.
C         INITIALIZE THE UNIT 12 RECORD WORK AREA
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         JGRPKT = 0
         CWORK(1:52) = CBLK52(1:52)
         CWK80(1:50) = CBLK52(1:50)
         CWK80(51:80) = CBLK52(1:30)
         DO 11 I = 9,18
         IWK80(I) = 0
 11      CONTINUE
C
C         SET THE ISN VALUE FOR THE UNIT 12 OUPUT RECORD
C
         IWK80(9) = ISN
C
C         CHECK OF A LEFT PARENTHESIS FOLLOWS THE STATEMENT.
C
         IF(CSTMT(J:J) .NE. CLPAR) THEN
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS TERMINATES THE STATEMENT
C
         IF(CSTMT(KB:KB) .NE. CRPAR) THEN
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
C
C         INITALIZE THE EQUIVALENCED GROUP BOUNDARY LIMITS ARRAY
C
         DO 12 I = 1,200
         JGRP(1,I) = 0
         JGRP(2,I) = 0
 12      CONTINUE
C
C         DETERMINE THE LOWER AND UPPER BOUNDARIES OF ALL EQUIVALENCED
C         GROUPS OF VARIABLE NAMES. THE VALUE OF VARIABLE J IS THE
C         LOCATION OF THE LEFT PARENTHESIS DEFINING THE START OF AN
C         EQUIVALENCE GROUP.
C
 13      JC = 0
         L6 = LFALSE
         DO 14 I = J,KB
C
C         COUNT THE LEFT AND RIGHT PARENTHESES
C
         IF(CSTMT(I:I) .EQ. CLPAR) THEN
            JC = JC + 1
C
C         SAVE THE LOCATION OF THE INITIAL LEFT PARENTHESIS
C
            IF(I .EQ. J) IE = I
         END IF
         IF(CSTMT(I:I) .EQ. CRPAR) THEN
            JC = JC - 1
            IF(JC .EQ. 0) THEN
               L6 = LTRUE
               ID = I
            END IF
         END IF
         IF(CSTMT(I:I) .EQ. COMMA .OR. I .EQ. KB) THEN
            IF(L6) THEN
               JGRPKT = JGRPKT + 1
C
C         SET THE LOCATION BOUNDARY FOR AN EQUIVALENCED GROUP
C
               IF(JGRPKT .LE. 200) THEN
                  JGRP(1,JGRPKT) = IE
                  JGRP(2,JGRPKT) = ID
                  IF(I .EQ. KB) THEN
                     JGRP(2,JGRPKT) = I
                     GO TO 15
                  ELSE
                     J = I + 1
                     GO TO 13
                  END IF
               ELSE
                  WRITE (0,104) ISN
                  IREC0 = IREC0 + 1
               END IF
            END IF
         END IF
 14      CONTINUE
C
C         AT THIS POINT IN PROCESSING, THE TABLE OF START AND END
C         LOCATIONS OF EACH EQUIVALENCE GROUP IS COMPLETE.
C
C         PROCESS EACH EQUIVALENCED GROUP TO IDENTIFY ALL VARIABLES
C         WITHIN THE GROUP
C
 15      DO 27 I = 1,JGRPKT
C
C         SET THE LEFT AND RIGHT LOCATIONS OF THE CURRENT EQUIVALENCE
C         GROUP. THE LEFT BOUNDARY WILL BE A LEFT PARENTHESIS, AND THE
C         RIGHT BOUNDARY WILL BE A RIGHT PARENTHESIS.
C
         IA = JGRP(1,I) + 1
         IIB = JGRP(2,I) - 1
C
C         INITIALIZE THE EQUIVALENCE GROUP VARIABLE NAME COUNT
C
         JEQKNT = 0
         L6 = LFALSE
         I2WK1 = 0
C
C         SCAN THE EQUIVALENCE GROUP FROM LEFT TO RIGHT TO IDENTIFY
C         ALL VARIABLES THAT ARE EQUIVALENCED
C
         DO 17 IJ = IA,IIB
C
C         LOCATE THE END OF THE CURRENT VARIABLE'S SPECIFICATION
C
C         COUNT THE MATCHING PARENTHESES, IF ANY
C
         IF(CSTMT(IJ:IJ) .EQ. CLPAR) I2WK1 = I2WK1 + 1
         IF(CSTMT(IJ:IJ) .EQ. CRPAR) I2WK1 = I2WK1 - 1
C
C         DETERMINE THE NUMBER OF VARIABLES WITHIN THE CURRENT
C         EQUIVALENCE GROUP AND SAVE THE FIRST AND LAST CHARACTER
C         LOCATION OF EACH VARIABLE INCLUDING ANY SUBSCRIPT AND
C         CHARACTER RANGE SPECIFICATIONS
C
         IF(.NOT.L6) THEN
C
C         DETERMINE IF THIS CHARACTER IS THE INITIAL CHARACTER OF A
C         VARIABLE NAME
C
            IF(CSTMT(IJ:IJ) .GE. CAA .AND. CSTMT(IJ:IJ) .LE. CZZ .OR.
     1         CSTMT(IJ:IJ) .EQ. CUNDER) THEN
C
C         THE FIRST ALPHABETIC CHARACTER HAS BEEN FOUND
C
               JEQKNT = JEQKNT + 1
               JEQNME(1,JEQKNT) = IJ
               L6 = LTRUE
C
C         DETERMINE IF THE CURRENT VARIABLE NAME IS A SINGLE CHARACTER
C         AND TERMINATES THE CURRENT EQUIVALENCE GROUP
C
               IF(IJ .EQ. IIB .AND. (CSTMT(IJ:IJ) .GE. CAA .AND.
     1            CSTMT(IJ:IJ) .LE. CZZ .OR. CSTMT(IJ:IJ) .EQ. CUNDER
     2            .OR. CSTMT(IJ:IJ) .EQ. CDOL)) THEN
                  JEQNME(2,JEQKNT) = IJ
                  GO TO 18
               END IF
            END IF
         ELSE
C
C         WHEN A COMMA OCCURS, IT MAY TERMINATE A VARIABLE'S
C         SPECIFICATIONS
C
            IF(CSTMT(IJ:IJ) .EQ. COMMA) THEN
C
C         WHEN A COMMA IS NOT ENCAPSULATED BY LEFT AND RIGHT
C         PARENTHESIS, IT IS THE END OF A VARIABLE NAME. CASES 2,
C         3, AND 4 TERMINATE THE SPECIFICATION FOR THE CURRENT VARIABLE
C         WITHIN THE EQUIVALENCE GROUP.
C
               IF(I2WK1 .EQ. 0) THEN
C
C         DETERMINE IF THE END OF AN EQUIVALENCE GROUP
C
C         CASE 1: ),(  ; THIS CASE DETERMINES THAT THE COMMA IS THE END
C                OF THE CURRENT EQUIVALENCE GROUP.
C
                  IF(CSTMT(IJ-1:IJ+1) .EQ. '),(') THEN
                     JEQNME(2,JEQKNT) = IJ
                     L6 = LFALSE
                     GO TO 18
                  END IF
C
C         CASE 2: A,A  ; THIS CASE DETERMINES THAT THE COMMA IS THE
C                 END OF A VARIABLE NAME, AND THAT THE PRIOR AND
C                 FOLLOWING CHARACTERS ARE PART OF EQUIVALENCED
C                 VARIABLE NAMES.
C
                  IF((CSTMT(IJ-1:IJ-1) .GE. CAA .AND. CSTMT(IJ-1:IJ-1)
     1               .LE. CZZ .OR. CSTMT(IJ-1:IJ+1) .EQ. CUNDER .OR.
     2               CSTMT(IJ-1:IJ-1) .EQ. CDOL) .AND. (CSTMT(IJ+1:IJ+1)
     3               .GE. CAA .AND. CSTMT(IJ+1:IJ+1) .LE. CZZ .OR.
     4               CSTMT(IJ+1:IJ+1) .EQ. CUNDER))
     5               GO TO 16
C
C         CASE 3: ),A  ; THIS CASE DETERMINES THAT THE COMMA IS THE
C                 END OF A VARIABLE NAME, BUT THAT ANOTHER NAME FOLLOWS.
C                 THE PRIOR VARIABLE HAS EITHER SUBSCRIPT OR CHARACTER
C                 RANGE SPECIFICATIONS OR BOTH.
C
                  IF(CSTMT(IJ-1:IJ) .EQ. '),' .AND. (CSTMT(IJ+1:IJ+1)
     1                .GE. CAA .AND. CSTMT(IJ+1:IJ+1) .LE. CZZ .OR.
     2                CSTMT(IJ+1:IJ+1) .EQ. CUNDER)) GO TO 16
C
C         CASE 4: n,A  ; THIS CASE DETERMINES THAT THE COMMA IS THE
C                 END OF A VARIABLE NAME, AND THAT ANOTHER VARIABLE
C                 NAME FOLLOWS.
C
                  IF((CSTMT(IJ-1:IJ-1) .GE. C0 .AND. CSTMT(IJ-1:IJ-1)
     1                .LE. C9 .AND. CSTMT(IJ+1:IJ+1) .LE. CZZ .OR.
     2                CSTMT(IJ+1:IJ+1) .EQ. CUNDER)) GO TO 16
C
C         CASE 5: n,n  : THIS CASE DETERMINES THAT THE COMMA IS NOT
C                 THE END OF THE EQUIVALENCE GROUP, BUT THAT THE DIGITS
C                 PRIOR TO AND AFTER THE COMMA ARE PART OF A SUBSCRIPT
C                 SPECIFICATION.
C
                  IF(CSTMT(IJ-1:IJ-1) .GE. C0 .AND. CSTMT(IJ-1:IJ-1)
     1               .LE. C9 .AND. CSTMT(IJ+1:IJ+1) .GE. C0 .AND.
     2               CSTMT(IJ+1:IJ+1) .LE. C9) GO TO 17
C
C         THE END OF A VARIABLE NAME HAS BEEN LOCATED; SET UP TO SEARCH
C         ANOTHER VARIABLE WITHIN THE GROUP
C
 16               IF(IJ+1 .GE. IIB) THEN
                     IF(CSTMT(IJ+1:IJ+1) .EQ. CRPAR) THEN
                        JEQNME(2,JEQKNT) = IJ
                     ELSE
                        JEQNME(2,JEQKNT) = IJ - 1
                     END IF
                  ELSE
                     JEQNME(2,JEQKNT) = IJ - 1
                  END IF
                  I2WK1 = 0
                  L6 = LFALSE
               END IF
            ELSE
C
C         DETERMINE IF THE END OF THE EQUIVALENCE STATEMENT HAS BEEN
C         REACHED
C
               IF(IJ .EQ. IIB) THEN
                  JEQNME(2,JEQKNT) = IJ
                  GO TO 18
               END IF
            END IF
         END IF
C
C         LOOP TO PROCESS THE NEXT CHARACTER
C
 17      CONTINUE
C
C         UPON COMPLETION OF THE LOOP, ALL START AND ENDING LOCATIONS
C         OF EACH VARIABLE WITHIN AN EQUIVALENCE GROUP ARE KNOWN.
C
C         PROCESS EACH VARIABLE NAME WITHIN THE CURRENT GROUP TO
C         CREATE AN OUTPUT RECORD FOR UNIT 12
C
 18      IVARKT = 0
C
C         PROCESS EACH VARIABLE WITHIN AN EQUIVALENCE GROUP
C
         DO 26 I4WK1 = 1,JEQKNT
         IVINI = JEQNME(1,I4WK1)
         IVEND = JEQNME(2,I4WK1)
         ILPAR = 0
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
C
C         DETERMINE IF ANY PARENTHESES OCCUR WITHIN EACH VARIABLE
C
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         DO 180 IJ = IVINI,IVEND
         IF(CSTMT(IJ:IJ) .EQ. CLPAR) L1 = LTRUE
         IF(CSTMT(IJ:IJ) .EQ. COLON) L3 = LTRUE
         IF(CSTMT(IJ:IJ) .EQ. COMMA .OR. CSTMT(IJ:IJ) .EQ. CRPAR) THEN
            IF(L1 .AND. .NOT.L3) L2 = LTRUE
         END IF
 180     CONTINUE
C
C         WHEN THE CHARACTER FOLLOWING THE FINAL CHARACTER IN IVEND
C         IS A COMMA, NO SUBSCRIPT OR CHARACTER RANGE SPECFICATIONS
C         EXIST
C
         IF(.NOT.L1 .AND. .NOT.L2) THEN
            IVARKT = IVARKT + 1
            IC = IVEND - IVINI + 1
            CWK80(1:IC) = CSTMT(IVINI:IVEND)
            CWORK(1:IC) = CSTMT(IVINI:IVEND)
C
C         SET THE VALUE OF THE NUMBER OF CHARACTERS IN THE VARIABLE
C         NAME
C
            IVCNT = IC
C
C         DETERMINE IF THE VARIABLE NAME IS THE FIRST VARIABLE WITHIN
C         AN EQUIVALANCE GROUP. WHEN A RECORD IS WRITTEN ON UNIT 12,
C         A NEGATIVE VALUE IN IWK80(9) INDICATES THE START OF A NEW
C         EQUIVALENCE GROUP WHEN SUBROUTINE PEQUIV EXECUTES TO DETERMINE
C         THE ADDRESSES IN COMMON WHERE THE VARIABLES WITHIN THE GROUP
C         GROUP ARE LOCATED.
C
            IF(IVARKT .EQ. 1) THEN
               IWK80(9) = -IVCNT
            ELSE
               IWK80(9) = IVCNT
            END IF
            IF(LINCL) THEN
               IWORK = -(ISN + 128)
            ELSE
               IWORK = ISN + 128
            END IF
C
C         SET BIT TO INDICATE THE VARIABLE EXISTS WITHIN AN EQUIVALENCE
C         STATEMENT
C
            JBITS = IBSET(JBITS,3)
            IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED AND SET ITS BIT
C         SWITCH
C
            CALL TABSRH (CDIM,JDIM,104,1,32,CWORK,1,32,IRET,1000)
            IF(IRET .GT. 0) JBITS = IBSET(JBITS,17)
C
C         OBTAIN THE TYPE AND LENGTH CHARACTERISTICS OF THE VARIABLE
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) CWORK(37:40) = CNAME(IRET)(37:44)
            IF(IRET .GT. 0) THEN
               CWORK(37:44) = CNAME(IRET)(37:44)
            ELSE
               CALL SETTL (CWORK)
            END IF
C
C         CATALOG THE VARIABLE NAME. IT IS NOT NECESSARY TO CHECK IF
C         THE VARIABLE IS A COMPOUND NAME, BECAUSE EQUIVALENCED
C         VARIABLES CAN NOT BE COMPOUND VARIABLE NAMES.
C
            CALL CHKNME (CSTMT)
            GO TO 24
         END IF
C
C         PROCESS THE SUBSCRIPT OR CHARACTER RANGE SPECIFICATIONS
C
         ICOLON = 0
         DO 19 IJ = IVINI,IVEND
C
C         DETERMINE THE LOCATION OF THE END OF THE VARIABLE NAME
C
         IF(CSTMT(IJ:IJ) .EQ. CLPAR .OR. CSTMT(IJ:IJ) .EQ. CRPAR .OR.
     1      CSTMT(IJ:IJ) .EQ. COMMA) THEN
            IF(CSTMT(IJ:IJ) .EQ. CLPAR) ILPAR = IJ
            IX = IJ - 1
            IVARKT = IVARKT + 1
            IC = IJ - IVINI
            CWK80(1:IC) = CSTMT(IVINI:IX)
            CWORK(1:IC) = CSTMT(IVINI:IX)
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN PLACED IN CNAME
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) CWORK(37:44) = CNAME(IRET)(37:44)
            IF(IVARKT .EQ. 1) THEN
               IWK80(9) = -IC
            ELSE
               IWK80(9) = IC
            END IF
            IF(LINCL) THEN
               IWORK = -ISN
            ELSE
               IWORK = ISN
            END IF
C
C         DETERMINE IF THE VARIABLE HAS ALREADY BEEN PLACED IN CNAME
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               CWORK(37:44) = CNAME(IRET)(37:44)
            ELSE
               CALL SETTL (CWORK)
            END IF
            IVCNT = IC
            JBITS = IBSET(JBITS,3)
            IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
            CALL TABSRH (CDIM,JDIM,104,1,32,CWORK,1,32,IRET,1000)
            IF(IRET .GT. 0) JBITS = IBSET(JBITS,17)
C
C         CATALOG THE VARIABLE NAME
C
            CALL CHKNME (CSTMT)
C
C         WHEN THE VARIABLE HAS A CHARACTER RANGE SPECIFICATION, VERIFY
C         IT IS A CHARACTER VARIABLE
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
            IF(IRET1 .GT. 0 .AND. L2 .AND. ICOLON .GT. 0) THEN
               IF(CNAME(IRET1)(37:37) .NE. CCC) THEN
C
C         CREATE FORMAT CF101 TO WRITE AN ERROR MESSAGE
C
                  WRITE (CI2WK1,'(I2)') IC
                  IF(IC .LT. 10) THEN
                     CF101(40:41) = CI2WK1(2:2)//CBLANK(1:1)
                  ELSE
                     CF101(40:41) = CI2WK1(1:2)
                  END IF
                  WRITE (0,CF101) ISN,CWORK(1:IVCNT)
                  IREC0 = IREC0 + 1
               END IF
            END IF
C
C         WHEN THE VARIABLE HAS SUBSCRIPTS, VERIFY IT IS DIMENSIONED
C
            IF(IRET .LT. 0 .AND. .NOT.L2 .AND. L3 .AND. BTEST(JBITS,17))
     1         THEN
C
C         CREATE FORMAT CF102 TO WRITE AN ERROR MESSAGE
C
               WRITE (CI2WK1,'(I2)') IC
               IF(IC .LT. 10) THEN
                  CF102(40:41) = CI2WK1(2:2)//CBLANK(1:1)
               ELSE
                  CF102(40:41) = CI2WK1(1:2)
               END IF
               WRITE (0,CF102) ISN,CWORK(1:IVCNT)
               IREC0 = IREC0 + 1
            END IF
            GO TO 190
         END IF
 19      CONTINUE
C
C         WHEN A COMMA FOLLOWS THE VARIABLE NAME, NO SUBSCRIPT OR
C         CHARACTER RANGE SPECIFICATIONS EXIST
C
 190     IX = IX + 1
         IF(CSTMT(IX:IX) .EQ. COMMA) GO TO 24
C
C         WHEN A LEFT PARENTHESIS FOLLOWS THE VARIABLE NAME, A
C         SUBSCRIPT OR RANGE SPECIFICATION EXISTS
C
         IF(CSTMT(IX:IX) .EQ. CLPAR) THEN
            L3 = LFALSE
            ILPAR1 = 0
            ICOLON = 0
C
C         SCAN BACKWARDS FROM THE END OF THE VARIABLE'S SPECIFICATION
C         TO DETERMINE IF A COLON EXISTS
C
            DO 20 IJ = IVEND,IX,-1
C
C         IF A COLON EXISTS, A RANGE SPECIFICIATION EXISTS. SAVE THE
C         LOCATION OF THE COLON
C
            IF(CSTMT(IJ:IJ) .EQ. COLON) ICOLON = IJ
C
C         WHEN A MATCHING LEFT PARENTHESIS IS FOUND, SAVE ITS LOCATION
C
            IF(CSTMT(IJ:IJ) .EQ. CLPAR) THEN
               ILPAR1 = IJ
               GO TO 200
            END IF
 20         CONTINUE
C
C         PROCESS THE CHARACTER RANGE SPECIFICATION
C
 200        IF(ICOLON .GT. 0) THEN
C
C         CONVERT THE STARTING CHARACTER RANGE VALUE TO INTEGER
C
               L3 = LTRUE
               JF = ILPAR1 + 1
C
C         DETERMINE IF THE INITIAL CHARACTER IS A NUMERIC DIGIT
C
               IF(.NOT.(CSTMT(JF:JF) .GE. C0 .AND. CSTMT(JF:JF) .LE.
     1            C9)) THEN
                  WRITE (0,102) ISN
                  IREC0 = IREC0 + 1
               END IF
               CALL NUMBER (CSTMT,LTRUE,JF,II,FP,IFP)
               IF(.NOT.LINCL) CALL INSERT (II)
               IWK80(11) = II
C
C         CONVERT THE ENDING CHARACTER RANGE VALUE TO INTEGER
C
               JF = ICOLON + 1
C
C         DETERMINE IF THE INITIAL CHARACTER IS A NUMERIC DIGIT
C
               IF(.NOT.(CSTMT(JF:JF) .GE. C0 .AND. CSTMT(JF:JF) .LE.
     1            C9)) THEN
                  WRITE (0,102) ISN
                  IREC0 = IREC0 + 1
               END IF
               CALL NUMBER (CSTMT,LTRUE,JF,II,FP,IFP)
               IF(.NOT.LINCL) CALL INSERT (II)
            ELSE
C
C         NO CHARACTER RANGE SPECIFICATION EXISTS
C
               IWK80(11) = 0
            END IF
C
C         IF THE LEFT PARENTHESIS LOCATION IS THE SAME AS THE LOCATION
C         OF THE LEFT PARENTHESIS THAT TERMINATES THE VARIABLE NAME,
C         NO SUBSCRIPT SPECIFICATION EXISTS.
C
            IF(ILPAR1 .EQ. ILPAR .AND. IVEND .LT. ILPAR) THEN
               GO TO 24
            ELSE
C
C         A SUBSCRIPT SPECIFICATION EXISTS
C
C         WHEN THE VARIABLE HAS SUBSCRIPTS, VERIFY IT IS DIMENSIONED
C
               IF(IRET .LT. 0 .AND. L2) THEN
C
C         CREATE FORMAT CF102 TO WRITE AN ERROR MESSAGE
C
                  WRITE (CI2WK1,'(I2)') IC
                  IF(IC .LT. 10) THEN
                     CF102(40:41) = CI2WK1(2:2)//CBLANK(1:1)
                  ELSE
                     CF102(40:41) = CI2WK1(1:2)
                  END IF
                  WRITE (0,CF102) ISN,CWORK(1:IVCNT)
                  IREC0 = IREC0 + 1
               END IF
               IVARKT = 0
               DO 21 IJ = ILPAR,IVEND
C
C         LOCATE THE CLOSING RIGHT PARENTHESIS
C
               IF(CSTMT(IJ:IJ) .EQ. CRPAR) THEN
                  IRPAR = IJ
                  GO TO 22
               END IF
 21            CONTINUE
C
C         PROCESS THE SUBSCRIPT ARGUMENT VALUES
C
 22            ICOMMA = 0
               JLEFT = ILPAR
               DO 23 IJ = ILPAR,IRPAR
C
C         DETERMINE THE END OF A SUBSCRIPT SPECIFICATION
C
               IF(CSTMT(IJ:IJ) .EQ. COMMA .OR. CSTMT(IJ:IJ) .EQ. CRPAR)
     1            THEN
C
C         COUNT THE NUMBER OF COMMAS BETWEEN THE LEFT AND RIGHT
C         PARENTHESES. THE NUMBER OF SUBSCRIPTS IS ICOMMA + 1
C
                  IF(CSTMT(IJ:IJ) .EQ. COMMA) ICOMMA = ICOMMA + 1
C
C         CONVERT THE SUBSCRIPT VALUE TO INTEGER
C
                  IVARKT = IVARKT + 1
C
C         WHEN NO COMMAS OCCUR, ONLY A SINGLE SUBSCRIPT OCCURS
C
                  IF(CSTMT(IJ:IJ) .EQ. CRPAR .OR. CSTMT(IJ:IJ) .EQ.
     1               COMMA) THEN
                     JF = IJ - 1
                  ELSE
                     JF = JLEFT + 1
                  END IF
C
C         DETERMINE IF THE INITIAL CHARACTER IS A NUMERIC DIGIT
C
                  IF(.NOT.(CSTMT(JF:JF) .GE. C0 .AND. CSTMT(JF:JF) .LE.
     1               C9)) THEN
                     WRITE (0,102) ISN
                     IREC0 = IREC0 + 1
                  END IF
                  CALL NUMBER (CSTMT,LTRUE,JF,II,FP,IFP)
                  IF(.NOT.LINCL) CALL INSERT (II)
                  IWK80(IVARKT+11) = II
                  JLEFT = IJ + 1
               END IF
 23            CONTINUE
C
C         SET THE NUMBER OF SUBSCRIPTS COUNT FOR THE RECORD ON UNIT 12
C
               IWK80(10) = IVARKT
C
C         DETERMINE IF MORE THAN SEVEN SUBSCRIPTS EXIST
C
               IF(IVARKT .GT. 7) THEN
                  WRITE (0,103) CWK80(1:32)
                  IREC0 = IREC0 + 1
               END IF
            END IF
C
C         A LEFT PARENTHESIS DOES NOT TERMINATE A VARIABLE NAME
C
         END IF
C
C         THE RECORD FOR UNIT 12 IS NOW COMPLETE
C
 24      IREC12 = IREC12 + 1
         IWK80(20) = IREC12
         WRITE (12,REC=IREC12) CWK80(1:80)
C
C         INITIALIZE THE UNIT 12 RECORD WORK AREA
C
         CWORK(1:52) = CBLK52(1:52)
         CWK80(1:50) = CBLK52(1:50)
         CWK80(51:80) = CBLK52(1:30)
         DO 25 IJ = 9,18
         IWK80(IJ) = 0
 25      CONTINUE
 26      CONTINUE
 27      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 28   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE EXTERNAL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEXTNL - CHARACTER VARIABLE, TABLE OF ALL EXTERNAL STATEMENT
C                  NAMES IN A ROUTINE BEING ANALYZED
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         II     - SAVE AREA FOR I WHEN SUBROUTINE CHKNME IS CALLED
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         IRET   - RETURN CODE
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - THE LOCATION OF THE INITIAL CHARACTER OF A FIELD
C         JB     - THE LOCATION OF THE END CHARACTER OF A FIELD
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         JC     - THE LENGTH OF A FIELD
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C
C     COMMENTS
C
C         EXTERNAL IS NOT AN EXECUTABLE STATEMENT
C
C         AT THE TIME THE EXTERNAL STATEMENT IS PROCESSED, NO
C         DETERMINATION CAN BE MADE WHETHER THE VARIABLE NAME IS A
C         SUBROUTINE OR A FUNCTION DEFINITION. BIT SWITCH 9 IS SET TO
C         INDICATE IT IS A SUBROUTINE, BUT ROUTINE CHKNME WILL CHANGE
C         FROM BIT 9 TO BIT 10 TO INDICATE THE NAME IS A FUNCTION IF
C         A MATCH IS FOUND IN THE INTRINSIC FUNCTION TABLE.
C
C         WHEN A FUNCTION OR SUBROUTINE NAME IS USED AS AN ARGUMENT,
C         THE EXTERNAL STATEMENT IS REQUIRED.
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR IBCLR LOCERR TABINS TABSRH
C
C     *****************************************************************
C
      SUBROUTINE STMT27
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NO SUBPROGRAM SPECIFIED IN AN EXTERNAL STATEME
     1NT')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      II = 0
      JBITS = 0
      IRET = 1
      LEXEC = LFALSE
C
C         VERIFY THIS IS AN EXTERNAL STATEMENT
C
      J = KF + 7
      IF(CSTMT(KF:J) .EQ. 'EXTERNAL') THEN
         J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 12
         END IF
 10      CONTINUE
C
C         DETERMINE IF A SUBPROGRAM NAME FOLLOWS THE EXTERNAL TEXT
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         IF(CSTMT(J:J) .EQ. CBLK52(1:1) .OR. .NOT.(CSTMT(J:J) .GE. CAA
     1      .AND. CSTMT(J:J) .LE. CZZ .OR. CSTMT(J:J) .EQ. CUNDER)) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
C
C         SCAN FOR SUBROUTINE AND FUNCTION NAMES
C
         LEXEC = LTRUE
         JA = J
         DO 11 I = J,KB
C
C         WHEN A COMMA EXISTS, IT IS THE END OF A SUBROUTINE OR
C         FUNCTION NAME
C
         IF(CSTMT(I:I) .EQ. COMMA) THEN
            JB = I - 1
            JC = I - JA
C
C         WHEN THE FINAL CHARACTER OF THE STATEMENT IS BEING PROCESSED,
C         IT IS END OF A SUBROUTINE OR FUNCTION NAME
C
         ELSE IF(I .EQ. KB) THEN
            JB = I
            JC = I - JA + 1
         END IF
         IF(CSTMT(I:I) .EQ. COMMA .OR. I .EQ. KB) THEN
            IVCNT = JC
            CWORK(1:JC) = CSTMT(JA:JB)
            IWORK = ISN + 128
C
C         DETERMINE IF THE SUBPROGRAM NAME HAS ALREADY BEEN CATALOGED
C
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
               JBITS = IBSET(JBITS,21)
               IF(CNAME(IRET)(37:38) .NE. CBLANK(1:2)) THEN
C
C         THE EXTERNAL VARIABLE NAME IS A FUNCTION
C
                  IENAME(12,IRET) = IBSET(IENAME(12,IRET),10)
               ELSE
C
C         THE EXTERNAL VARIABLE NAME IS A SUBROUTINE
C
                  IENAME(12,IRET) = IBSET(IENAME(12,IRET),9)
               END IF
               CWORK(37:44) = CNAME(IRET)(37:44)
               CWORK(45:48) = CNAME(IRET)(45:48)
            ELSE
C
C         THE SUBPROGRAM NAME IS NOT CATALOGUED YET; ASSUME IT IS A
C         SUBROUTINE
C
               CWORK(37:44) = CBLANK(1:8)
               CWORK(37:37) = CBAR(1:1)
               JBITS = IBSET(JBITS,9)
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
            END IF
            II = I
            CALL CHKNME (CSTMT)
            IF(BTEST(IENAME(12,IRET),7)) IENAME(12,IRET) =
     1         IBCLR(IENAME(12,IRET),7)
            JA = I + 1
         END IF
C
C         INSERT THE EXTERNAL SUBPROGRAM NAME INTO THE SAVE TABLE
C
         IF(CWORK(1:32) .NE. CBLK52(1:32))
     1      CALL TABINS (CEXTNL,IEXTNL,32,1,32,CWORK,1,32,IRET,1000)
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         IF(II .GE. KB) GO TO 12
 11      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE FUNCTION STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CFMTH  - CHARACTER VARIABLE, THE LISTING HEADER
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A CHARACTER
C                  DEFINITION
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE
C                  STATEMENT BEING PROCESSED. C - CALL, E - ENTRY,
C                  F - FUNCTION, S - SUBROUTINE
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         IA     - START LOCATION OF THE FUNCTION NAME
C         IB     - END LOCATION OF THE FUNCTION NAME
C         IC     - WORK AREA, THE NUMBER OF CHARACTERS TO BE PLACED IN
C                  CFMTH
C         ID     - LOCATION OF AN ASTERISK IN THE STATEMENT BEING
C                  PROCESSED
C         IE     - LOCATION OF THE INITAL LEFT PARENTHESIS IN THE
C                  STATEMENT BEING PROCESSED
C         IFP    - LOCATION OF THE FIRST CHARACTER AFTER THE END OF A
C                  NUMERICAL FIELD. THIS IS RETURNED BY SUBROUTINE
C                  NUMBER.
C         IG     - LOCATION OF INITIAL CHARACTER AFTER THE INITIAL LEFT
C                  PARENTHESIS
C         IH     - SUBSCRIPT VARIABLE
C         II     - VALUE OF THE DEFINED LENGTH OF THE FUNCTION TYPE
C         IPGNME - FUNCTION NAME CHARACTER LENGTH
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - LENGTH OF THE FUNCTION NAME, EQUIVALENCED TO CWORK AT
C                  COLUMNS 49 - 52
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I2WK1  - SUBSCRIPT VARIABLE AND WORK AREA
C         I4WK1  - WORK AREA USED TO CONTAIN THE LOCATION WHERE THE
C                  FUNCTION NAME IS TO BE PLACED IN CFMTH, THE LISTING
C                  FORMAT HEADER FILE
C         J      - LOCATION OF THE CURRENT CHARACTER BEING PROCESSED IN
C                  THE STATEMENT
C         JA     - LOCATION OF THE INITIAL CHARACTER AFTER FUNCTION IN
C                  STATEMENT BEING PROCESSED
C         JB     - LOCATION OF THE FINAL CHARACTER OF THE FUNCTION NAME
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         JC     - THE LENGTH OF THE FUNCTION NAME
C         JD     - LOCATION OF THE CHARACTER IMMEDIATELY FOLLOWING AN
C                  ASTERISK, AND THE LOCATION OF THE FINAL DIGIT OF A
C                  TYPE LENGTH SPECIFICATION
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 16.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK OCCURS,
C                  SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LEFT PARENTHSIS
C                  OCCURS, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK OCCURS
C                  PRIOR TO THE FUNCTION KEY WORD, SET FALSE OTHERWISE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C         NARGM  - TOTAL NUMBER OF ARGUMENTS FOR THE FUNCTION
C
C     COMMENTS
C
C         FUNCTION IS NOT AN EXECUTABLE STATEMENT
C
C         A FUNCTION HAS THREE FORMS. THESE ARE:
C
C           CASE 1: NO TYPE OR LENGTH SPECIFICATIONS
C              FUNCTION (FUNCTION NAME) {ARGUMENT LIST)
C
C           CASE 2: TYPE AND LIST SPECIFIED PRIOR TO THE KEYWORD
C                   FUNCTION
C              {TYPE}*{LENGTH} FUNCTION (FUNCTION NAME) {ARGUMENT LIST}
C
C           CASE 3: TYPE SPECIFIED PRIOR TO THE KEYWORD
C              {TYPE} FUNCTION (FUNCTION NAME) {ARGUMENT LIST}
C
C           CASE 4: LENGTH SPECIFICATION FOLLOWS A VARIABLE NAME
C              FUNCTION (FUNCTION NAME) {VARIABLE*{LENGTH},...}
C
C           CASE 5: LENGTH SPECIFICATION FOLLOWS THE FUNCTION KEYWORD IS
C                   AN ILLEGAL SYNTAX
C              FUNCTION {*NUMBER} (FUNCTION NAME) {ARGUMENT LIST}
C
C           FIELDS WITHIN CURLY BRACKETS ARE OPTIONAL
C
C         SUBROUTINE ARGLST IS CALLED ONLY WHEN ARGUMENTS EXIST. THE
C         FUNCTION NAME IS NOT PROCESSED BY ARGLST UNLIKE THE ENTRY AND
C         SUBROUTINE STATEMENTS.
C
C         ALL ARGUMENTS OF A FUNCTION STATEMENT ARE DUMMY VARIABLES.
C         A DUMMY VARIABLE CAN NOT BE A COMPOUND VARIABLE.
C
C     SUBROUTINES CALLED
C
C         ARGLST CHKNME EXPR IBSET INSERT LOCERR NUMBER SETTL
C
C     *****************************************************************
C
      SUBROUTINE STMT29 (CTYPED,CLEN)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*72    CVARST
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN
      CHARACTER*1 CTYPE, CTYPED
      LOGICAL*1   L1, L2, L3
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' A FUNCTION STATEMENT MUST HAVE AN ISN 0F 1')
 101  FORMAT(' ISN:',I6,' END STATEMENT MISSING')
 102  FORMAT(' ISN:',I6,' MULTIPLE FUNCTION LENGTHS ARE DEFINED')
C103  FORMAT(' ISN:',I6,' FUNCTION HAS A DEFINED LENGTH, BUT NO DATA TYP
C    1E IS DEFINED'/T13,A59)
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      ID = 0
      IE = 0
      IG = 0
C
C         VERIFY THIS IS A POSSIBLE FUNCTION STATEMENT
C
      J = KF + 7
      IF(CSTMT(KF:J) .NE. 'FUNCTION') GO TO 14
      J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
      DO 10 I = J,KB
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         LSTART = LTRUE
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         GO TO 14
      END IF
 10   CONTINUE
C
C         DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION STATEMENT
C
      IF(LZEND) THEN
C
C         AN END STATEMENT PRECEDED THE FUNCTION STATEMENT
C
         IF(ISN .GT. 1) THEN
            WRITE (0,101) ISN
            IREC0 = IREC0 + 1
            LENDS = LTRUE
            LZEND = LFALSE
         END IF
      END IF
C
C         WRITE ERROR MESSAGE THIS STATMENT IS NOT THE FIRST EXECUTABLE
C         STATEMENT
C
      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
C
C         INDICATE THIS IS A FUNCTION STATEMENT
C
      JBITS = IBSET(JBITS,10)
      LTEST = LTRUE
C
C         VERIFY THE FUNCTION STATEMENT IS THE FIRST NON-COMMENT
C         STATEMENT OF THE FORTRAN CODE
C
      IF(ISN .GT. 1) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         DETERMINE IF A LENGTH CHARACTERISTIC PRECEDES THE KEY WORD
C         FUNCTION
C
      IF(CSTMT(KF-1:KF-1) .GE. C0 .AND. CSTMT(KF-1:KF-1) .LE. C9)
     1   L3 = LTRUE
C
C         SET THE LOCATION OF THE START OF THE FUNCTION'S NAME
C
      IA = J
C
C         SCAN TO LOCATE THE FUNCTION NAME END
C
      JA = J
      LEXEC = LTRUE
      DO 11 I = J,KB
C
C         SEARCH FOR AN ASTERISK; IF FOUND, IT IS THE RIGHT BOUNDARY OF
C         THE FUNCTION NAME, AND THE LENGTH CHARACTERISTIC OCCURS AFTER
C         THE FUNCTION KEY WORD.
C
      IF(CSTMT(I:I) .EQ. CASTER) THEN
         L1 = LTRUE
         ID = I
         IF(CSTMT(I+1:I+1) .GE. C0 .AND. CSTMT(I+1:I+1) .LE. C9 .OR.
     1      CSTMT(I+1:I+1) .EQ. CUNDER) THEN
            DO I2WK1 = I+2,KB
               IF(CSTMT(I2WK1:I2WK1) .GE. CAA .AND.
     1            CSTMT(I2WK1:I2WK1) .LE. CZZ .OR.
     2            CSTMT(I2WK1:I2WK1) .EQ. CUNDER) THEN
                  IE = I2WK1 - 1
                  IG = I2WK1
                  GO TO 11
               END IF
            END DO
         END IF
         GO TO 11
      END IF
C
C         SEARCH FOR A LEFT PARENTHSIS; IF FOUND, IT IS THE RIGHT
C         BOUNDARY OF THE FUNCTION NAME OR THE LENGTH SPECIFICATION.
C         THE OCCURRENCE OF A LEFT PARENTHESIS INDICATES AN ARGUMENT
C         LIST EXISTS, BUT AT THIS STAGE OF THE ANALYSIS, THE START
C         LOCATION OF THE FUNCTION NAME IS NOT KNOWN.
C
      IF(CSTMT(I:I) .EQ. CLPAR) THEN
         L2 = LTRUE
C
C         DETERMINE IF AN ASTERISK OCCURS BEFORE THE LEFT PARENTHESIS.
C         IF NONE OCCUR, NO LENGTH SPECIFICATION IS PROVIDED.
C
         IB = I - 1
         IE = I
         IPGNME = IB - IA + 1
         JC = IPGNME
         GO TO 12
      END IF
 11   CONTINUE
C
C         DETERMINE IF MULTIPLE LENGTH SPECIFICATIONS HAVE BEEN
C         SPECIFIED
C
      IF(L1 .AND. L3) THEN
         WRITE (0,102) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         IF NEITHER AN ASTERISK NOR A LEFT PARENTHESIS EXIST, SET I TO
C         LOCATION OF THE FINAL CHARACTER OF THE STATEMENT PLUS ONE.
C         THIS MEANS THE FUNCTION HAS NO ARGUMENTS AND NO LENGTH
C         SPECIFIED.
C
      IF(.NOT.L1 .AND. .NOT.L2) THEN
         I = KB + 1
         IA = J
         JA = J
         JB = KB
         JC = KB - J + 1
         IPGNME = JC
C
C         AN ASTERISK EXISTS, BUT A LEFT PARENTHESIS DOES NOT
C
      ELSE IF(L1 .AND. .NOT.L2) THEN
         IB = KB
         JC = KB - IA + 1
      END IF
C
C         SET FUNCTION NAME LEFT AND RIGHT LOCATION LIMITS
C
 12   IF(L1) THEN
         JB = ID - 1
      ELSE
         IF(L2) THEN
            JB = IE - 1
            IPGNME = IB - IA + 1
         END IF
      END IF
      NA = JB + 1
      IVCNT = IPGNME
      I4WK1 = 64 + IPGNME - 1
      CWORK(1:IVCNT) = CSTMT(JA:JB)
      IWORK = ISN + 128
C
C         PLACE THE FUNCTION NAME IN CFMTH FOR THE OUTPUT LISTING
C
      CPGNME(1:32) = CBLK52(1:32)
      CPGNME(1:JC) = CSTMT(JA:JB)
      CFMTH(64:JC+64) = CWORK(1:JC)
      CFMTH(I4WK1+1:94) = CBLK52(1:IC)
      LPROG = LTRUE
C
C         DETERMINE THE TYPE AND LENGTH CHARACTERISTICS
C
      IF(CWORK(37:37) .EQ. CBLANK(1:1)) CWORK(37:37) = CTYPED(1:1)
      IF(CWORK(38:44) .EQ. CBLANK(1:7)) THEN
         IF(CSTMT(ID:ID) .EQ. CASTER) THEN
            DO IH = ID+1,KB
            IF(CSTMT(IH:IH) .GE. C0 .AND. CSTMT(IH:IH) .LE. C9) THEN
               CONTINUE
            ELSE
               CLEN(1:IH-ID-1) = CSTMT(ID+1:IH-1)
               GO TO 13
            END IF
            END DO
         END IF
      END IF
C
C         WHEN IT EXISTS, SET LOCATION OF THE INITIAL DIGIT OF THE
C         LENGTH SPECIFICATION FIELD
C
 13   IF(L1) THEN
         J = I + 1
         JD = ID + 1
         JB = I - 1
         JC = IE - JD
         CWORK(38:44) = CLEN(1:7)
C
C         PLACE THE LENGTH CONSTANT IN THE INTEGER CONSTANT TABLE AND
C         IN THE WORK VARIABLE
C
         CALL NUMBER (CSTMT,LTRUE,JD,II,FP,IFP)
         IF(.NOT.LINCL) CALL INSERT (II)
         JD = IFP
      END IF
C
C         DETERMINE IF A LENGTH SPECIFICATION EXISTS
C
      IF(CLEN(1:7) .NE. CBLANK(1:7)) CWORK(38:44) = CLEN(1:7)
C
C         WHEN NO LENGTH SPECIFICATION EXISTS, BUT A TYPE DEFINITION
C         DOES EXIST, ASSIGN THE DEFAULT LENGTH FROM CIMPL. A FUNCTION
C         NAME CAN NOT BE IN THE MASTER FILE TABLE (CNAME) YET, SO NO
C         TYPE OR LENGTH CHARACTERISTICS ARE DEFINED IN THE TABLE.
C
      IF(CLEN(1:7) .EQ. CBLANK(1:7) .AND. CTYPED(1:1) .NE.
     1   CBLANK(1:1)) CALL SETTL (CWORK)
C
C         PLACE THE FUNCTION NAME IN THE VARIABLE NAME TABLE; IT CAN
C         NOT BE A COMPOUND VARIABLE NAME
C
      JBITS = IBSET(JBITS,10)
      CALL CHKNME (CSTMT)
C
C         IF A LEFT PARENTHESIS OCCURRED, AN ARGUMENT LIST FOLLOWS;
C         PROCESS THE ARGUMENT LIST
C
      IF(L2) THEN
         CWK8(1:8) = CWORK(37:44)
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         J = IE
C        LCALL = LFALSE
C
C         INDICATE THIS IS A FUNCTION STATEMENT BY CHANGING THE VALUE
C         OF CTYPE FOR ROUTINE ARGLST
C
         CTYPED = CFF
         J = IE
         IF(CSTMT(IE:IE+1) .NE. '()') CALL ARGLST (CFF,CSTMT,KB)
         NARGM = NARGS
         LCALL = LFALSE
      END IF
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE GO TO STATEMENTS
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN: -
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT ADJUSTMENT VALUE
C         IB     - LOCATION OF THE LAST CHARACTER OF A VARIABLE NAME
C         IC     - LENGTH OF A VARIABLE NAME
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN CCONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         II     - VALUE OF AN INTEGER NUMBER CONVERTED FROM ASCII
C         IISN   - THE ISN VALUE PLUS 128 OF A NUMBER SAVED ON UNIT 4
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE IF AN ASSIGNED GO TO
C                  LIST IS TO BE PROCESSED, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE VARIABLE NAME OF
C                  AN ASSIGN GO TO STATEMENT HAS BEEN PROCESSED, SET
C                  FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN EXPRESSSION EXISTS
C                  FOR THE GO TO ARGUMENT NUMBER FOR A COMPUTED GO TO,
C                  SET FALSE OTHERWISE
C         M      - SAVE AREA FOR THE VALUE OF THE I SUBSCRIPT VARIABLE
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         GO TO IS AN EXECUTABLE STATEMENT. NO NUMERICAL VALUE IN A
C         GO TO STATEMENT IS PROCESSED BY SUBROUTINE INSERT.
C
C     SUBROUTINES CALLED
C
C         EXPR NUMBER SETTL TABSRH VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT30
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION IWR(2), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
      LOGICAL*1   L1, L2, L3
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CSUBTB,JSUBTB)
      EQUIVALENCE (CIB(1:4),IIB), (CISN(1:4),IISN), (CWK8(2:2),CWK7)
      EQUIVALENCE (CWR(1:4),IWR(1)), (CWR(5:8),IWR(2))
C
C         SAVE STATEMENT
C
      SAVE
C
C         INITIALIZATION
C
      IA = 0
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      LEXEC = LFALSE
C
C         VERIFY THIS IS A GO TO STATEMENT
C
      J = KF + 3
      IF(CSTMT(KF:J) .EQ. 'GOTO') THEN
         J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 17
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN UNCONDITIONAL GO TO STATEMENT
C
         IF(CSTMT(J:J) .GE. C0(1:1) .AND. CSTMT(J:J) .LE. C9(1:1)) THEN
            IF(.NOT.LINCL) THEN
               CALL NUMBER (CSTMT,LTRUE,J,II,FP,IFP)
               IIB = II + 128
               IISN = ISN + 128
               CWR(1:4) = CIB(1:4)
               CWR(5:8) = CISN(1:4)
               IREC4 = IREC4 + 1
               WRITE (4,REC=IREC4) CWR(1:8)
            END IF
            GO TO 17
         END IF
C
C         DETERMINE IF THIS IS A COMPUTED GO TO STATEMENT
C
 11      IF(CSTMT(J:J) .EQ. CLPAR .OR. L2) THEN
C
C         TEST IF THE VARIABLE NAME OF AN ASSIGNED GO TO WAS PROCESSED
C
            IF(L2) THEN
               L2 = LFALSE
               GO TO 12
            END IF
C
C        SEARCH FOR THE END OF THE NUMBER FIELD
C
            J = J + 1
 12         DO 13 M = J,KB
            IF(CSTMT(M:M) .EQ. COMMA .OR. CSTMT(M:M) .EQ. CRPAR) THEN
               CALL NUMBER (CSTMT,LTRUE,J,II,FP,IFP)
               IIB = II + 128
               IISN = ISN + 128
               CWR(1:4) = CIB(1:4)
               CWR(5:8) = CISN(1:4)
               IF(.NOT.LINCL) THEN
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR
               END IF
C
C         SET J TO THE START OF THE NEXT STATEMENT NUMBER
C
               IF(CSTMT(M:M) .EQ. COMMA) THEN
                  J = M + 2
               ELSE
                  J = M + 1
               END IF
C
C         DETERMINE IF THE END OF THE GO TO LIST
C
               IF(CSTMT(M:M) .EQ. CRPAR) THEN
                  IF(CSTMT(M+1:M+1) .EQ. COMMA) THEN
                     J = M + 2
                  ELSE
                     J = M + 1
                  END IF
                  IF(L1) GO TO 17
                  GO TO 14
               END IF
               J = M + 1
               GO TO 12
            END IF
 13         CONTINUE
C
C         IF A RIGHT PARENTHESIS OCCURS, THIS IS THE END OF THE GO TO
C         LIST; TEST IF AN EXPRESSSION OR A SINGLE VARIABLE FOLLOWS.
C
 14         DO 15 M = J,KB
C
C         TEST FOR A LEFT PARENTHESIS
C
            IF(CSTMT(M:M) .EQ. CLPAR) THEN
               L3 = LTRUE
               GO TO 15
            END IF
C
C         TEST FOR AN ARITHMETIC OPERATOR
C
            IF(CSTMT(M:M) .EQ. CPLUS .OR. CSTMT(M:M) .EQ. CMINUS .OR.
     1         CSTMT(M:M) .EQ. CASTER .OR. CSTMT(M:M) .EQ. CSLASH)
     2         L3 = LTRUE
 15         CONTINUE
C
C         IF THE GO TO VARIABLE IS AN EXPRESSION, PROCESS IT IN
C         ROUTINE EXPR
C
            IF(L3) THEN
               LEXEC = LTRUE
               CALL EXPR (J,KB,LFALSE,CSTMT)
               GO TO 17
C
C         A SINGLE VARIABLE NAME RATHER THAN AN EXPRESSION EXISTS.
C         THIS CAN BE A COMPOUND VARIABLE NAME.
C
            ELSE
               IC = KB - J + 1
               IVCNT = IC
               CWORK(1:IC) = CSTMT(J:KB)
               IWORK = ISN + 128
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
               IF(IRET .GT. 0) THEN
                  CWORK(37:44) = CNAME(IRET)(37:44)
               ELSE
                  CALL SETTL (CWORK)
               END IF
               CALL VSETUP (J,KB,IC,LFALSE,LFALSE,CSTMT)
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               GO TO 17
            END IF
         END IF
C
C         TEST FOR AN ASSIGNED GO TO STATEMENT
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
C
C         THIS IS AN ASSIGNED GO TO STATEMENT; SEARCH FOR A LEFT
C         PARENTHESIS OR A COMMA
C
            DO 16 M = J,KB
            IF(CSTMT(M:M) .EQ. CLPAR .OR. CSTMT(M:M) .EQ. COMMA) THEN
               IB = M - 1
               IC = M - J
               IVCNT = IC
               CWORK(1:IC) = CSTMT(J:IB)
               IWORK = ISN + 128
               CALL VSETUP (J,IB,IC,LFALSE,LFALSE,CSTMT)
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               L1 = LTRUE
               IF(CSTMT(M:M) .EQ. COMMA) J = M + 2
               IF(CSTMT(M:M) .EQ. CLPAR) J = M + 1
               L2 = LTRUE
               GO TO 11
            END IF
 16         CONTINUE
         END IF
      END IF
C
C         ROUTINE EXIT
C
 17   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE IF STATEMENT AND THE LOGICAL
C        CONDITION FOR A DO WHILE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CDOT   - CHARACTER VARIABLE, A PERIOD
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IB
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCD - CHARACTER VARIABLE, THE HEX NUMBER: CD; THIS IS USED
C                  TO REPLACE ALL LOGICAL OPERANDS IN THE FORTRAN
C                  STATEMENT. IT WAS CHOSEN TO PREVENT ANY CONFLICT
C                  WITH ANY CHARACTERS USED FOR SPECIAL SYSTEM FUNCTIONS
C                  UNDER EITHER ASCII OR EBCDIC CODING SYSTEMS.
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - THE VALUE OF A NUMBER RETURNED AS FLOATING POINT
C                  SINGLE PRECISION
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - THE END CHARACTER OF A FIELD
C         IC     - LENGTH OF A VARIABLE NAME
C         IFP    - LOCATION OF THE FINAL CHARACTER IN A SCIENTIFIC
C                  NOTATION NUMBER
C         II     - THE VALUE OF NUMBER AS AN INTEGER
C         IIB    - THE END LOCATION OF AN EQUIVALENCED GROUP OF VARIABLE
C                  NAMES
C         IISN   - THE ISN VALUE PLUS 128 OF A NUMBER SAVED ON UNIT 4
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         IRET   - ALTERNATE RETURN VALUE; 1 CONTINUES IN LINE EXECUTION
C                  2 PROCESSES THE SECONDARY STATEMENT
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - LOCATION OF THE FIRST CHARACTER FOLLOWING THE LEFT
C                  LEFT PARENTHESIS OR PARENTHESES IN THE IF STATEMEMT
C         I2     - LOCATION OF THE FINAL RIGHT PARENTHESIS OF THE
C                  LOGICAL PART OF AN IF STATEMENT
C         I2WK1  - COUNT OF COMMAS
C         I3     - COUNT OF THE NUMBER OF LEFT PARENTHESES BETWEEN THE
C                  LEFT AND RIGHT PARENTHESES DELINEATING THE LOGICAL
C                  CONDITION OF AN IF STATEMENT
C         I4WK1  - COUNTER OF PARENTHESES IN THE LOGIC TEST PORTION OF
C                  IF STATEMEMT
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE ENDING CHARACTER OF THE LOGIC PORTION
C         JB     - LOCATION OF THE START OF THE SECOND STATEMENT NUMBER
C                  IN AN ARITHMETIC IF STATEMENT
C         JC     - THE LENGTH OF A FIELD
C         JD     - LOCATION OF A PERIOD IN A STRUCTURE COMPOUND VARIABLE
C                  NAME
C         JJ     - SAVE VALUE OF J WHEN SUBROUTINE NUMBER IS CALLED
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KBSAVE - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT. THIS SAVES THE VALUE OF KB UPON ENTRY
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  TO THIS ROUTINE
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         L      - LOGICAL VARIABLE, SET TRUE WHEN A STATEMENT NUMBER
C                  HAS BEEN PROCESSED AS PART OF AN ARITHMETIC IF, SET
C                  FALSE OTHERWISE
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN THE NUMBER CONVER-
C                  SION IS TO INTEGER, SET FALSE IF FLOATING POINT
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A SUBSCRIPTING
C                  CHARACTER EXISTS, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A DIGIT EXISTS,
C                  SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A LOGICAL OPERATOR
C                  OR RELATION OPERATOR EXIST, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST CHARACTER
C                  IS ALPHABETIC, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN THE LOGICAL CONDITION
C                  FOR A DO WHILE STATEMENT IS TO BE PROCESSED, SET
C                  FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS IN THE LOGIC PORTION, SET FALSE
C                  WISE
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN OCCURS,
C                  SET FALSE OTHERWISE.
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN SUBROUTINE EXPR HAS
C                  BEEN EXCUTED, SET FALSE OTHERWISE.
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         IF IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR NUMBER
C
C     *****************************************************************
C
      SUBROUTINE STMT31 (L5,*,*)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*8 CWR
      CHARACTER*4 CIB, CISN
      LOGICAL*1 L1, L2, L3, L4, L5, L6, L7, L8
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CSUBTB,JSUBTB)
      EQUIVALENCE (CIB,IIB), (CISN,IISN), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' LOGICAL CONDITION OF A DO WHILE OR IF STATEMEN
     1T LACKS PARENTHESES')
 101  FORMAT(' ISN:',I6,' ARITHMETIC IF LACKS THREE STATEMENT NUMBERS')
 102  FORMAT(' ISN:',I6,' ILLEGAL CHARACTER IN IF STATEMENT: ',A5)
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      IRET = 1
      KBSAVE = KB
      L3 = LFALSE
      L7 = LFALSE
      LEXEC = LFALSE
C
C         VERIFY THIS IS AN IF STATEMENT
C
      J = KF + 1
      IF(CSTMT(KF:J+1) .EQ. 'IF(' .OR. L5) THEN
C
C         DETERMINE IF THIS IS THE LOGICAL CONDITION FOR A DO WHILE
C         STATEMENT
C
         IF(L5) THEN
            JA = KB
            GO TO 22
         END IF
         J = J + 1                        ! LOCATION OF LEFT PARENTHESIS
         I1 = 0
C
C         DETERMINE LOCATION OF THE MATCHING RIGHT PARENTHESES OF THE IF
C         STATEMENT. THE LEFT AND RIGHT BOUNDARIES OF THE LOGICAL PART
C         OF THE IF STATEMENT IS THEN KNOWN.
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            I4WK1 = 0
            DO 10 I = J,KB
C
C         DETERMINE IF A LOGICAL OPERATOR OCCURS WITHIN THE LOGICAL
C         CONDITION FOR THE IF STATEMENT
C
            IF(CSTMT(I:I) .EQ. CSYMCD) L3 = LTRUE
C
C         DETERMINE THE LOCATION OF THE FIRST CHARACTER AFTER 'IF('.
C         THIS LOCATION IS USED TO PASS THE START LOCATION OF THE
C         LOGICAL CONDITION IN THE IF STATEMENT WHEN MULTIPLE LEFT
C         PARENTHESES OCCUR IMMEDIATELY FOLLOWING THE IF.
C
C         DETERMINE THE LOCATION OF THE FIRST CHARACTER THAT IS NOT
C         A LEFT PARENTHESIS. THIS LOCATION IS USED TO PASS THE START
C         LOCATION OF THE LOGICAL CONDITION IN THE IF STATEMENT WHEN
C         MULTIPLE LEFT PARENTHESES OCCUR IMMEDIATELY FOLLOWING THE IF.
C
            IF(CSTMT(I:I) .NE. CLPAR .AND. I1 .EQ. 0) I1 = I
C
C         COUNT PARENTHESES
C
            IF(CSTMT(I:I) .EQ. CLPAR) I4WK1 = I4WK1 + 1
            IF(CSTMT(I:I) .EQ. CRPAR) I4WK1 = I4WK1 - 1
C
C         DETERMINE IF AN EQUAL SIGN OCCURS INSIDE ENCAPSUALTING
C         PARENTHESES
C
            IF(I4WK1 .GT. 0 .AND. CSTMT(I:I) .EQ. CEQ) L7 = LTRUE
C
C         SET THE RIGHT BOUNDARY OF THE TEST CONDITION FIELD
C
            IF(I4WK1 .EQ. 0 .AND. CSTMT(I:I) .EQ. CRPAR) THEN
               JA = I - 1
               GO TO 11
            END IF
 10         CONTINUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT. WHEN THE
C         VARIABLE NAME IS IF WITHOUT SUBSCRIPT VALUES. THIS WILL HAVE
C         THE FORM OF IF= OR IFX= WHERE X IS AN UNDERSCORE, AN ALPHA-
C         BETIC CHARACTER, A DIGIT, OR A DOLLAR SIGN
C
            IA = KF + 2
            IF(L7) THEN
               IF(CSTMT(IA:IA) .EQ. CEQ .OR. CSTMT(IA:IA) .GE. CAA
     1            .AND. CSTMT(IA:IA) .LE. CZZ .OR. CSTMT(IA:IA) .GE.
     2            C0(1:1) .OR. CSTMT(IA:IA) .LE. C9(1:1) .OR.
     3            CSTMT(IA:IA) .EQ. CUNDER .OR. CSTMT(IA:IA) .EQ. CDOL)
     4            THEN
                  CALL EXPR (KF,KB,LFALSE,CSTMT)
                  GO TO 28
               END IF
            END IF
C
C         NO PARENTHESES FOUND, WRITE ERROR MESSAGE
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
            GO TO 28
         END IF
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
 11      LEXEC = LTRUE
         L8 = LFALSE
C
C         DETERMINE IF A LOGICAL OPERATOR IS THE FIRST CHARACTER AFTER
C         THE LEFT PARENTHESIS
C
         IF(CSTMT(I1:I1) .EQ. CSYMCD .OR. L3 .OR. CSTMT(J:J) .EQ.
     1      CLPAR) THEN
            L8 = LTRUE
            CALL EXPR (I1,JA,LFALSE,CSTMT)
C
C         DETERMINE IF THE TEXT FOLLOWING THE RIGHT PARENTHESIS OF
C         'IF(...)' IS AN ALPHABETIC CHARACTER. WHEN TRUE, IT MAY BE A
C         COMPLETE FORTRAN STATEMENT.
C
            IF(CSTMT(JA+2:JA+5) .EQ. 'THEN') GO TO 13
C
C         LOOP TO SKIP OVER MULTIPLE RIGHT PARENTHESES FOLLOWING THE
C         LOGICAL CONDITION FOR THE IF STATEMENT
C
            DO 12 I = JA,KBSAVE
            IF(CSTMT(I:I) .NE. CRPAR) THEN
               IF(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ
     1            .OR. CSTMT(I:I) .EQ. CUNDER .OR. CSTMT(I:I)
     2            .EQ. CDOL .AND. CSTMT(I:I+3) .NE. 'THEN') GO TO 14
               IF(CSTMT(I:I) .EQ. CGG) GO TO 14
            END IF
 12         CONTINUE
            GO TO 28
         END IF
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE WHETHER THIS IS A BLOCK IF STATEMENT               *
C     *                                                                *
C     ******************************************************************
C
 13      IF(CSTMT(JA+2:JA+5) .EQ. 'THEN' .AND. .NOT.L8) THEN
            LEXEC = LTRUE
            CALL EXPR (I1,JA,LFALSE,CSTMT)
            GO TO 28
         END IF
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE IF A STATEMENT IMMEDIATELY FOLLOWS THE CLOSING     *
C     *   RIGHT PARENTHESIS OF THE LOGICAL IF CONDITION.               *
C     *                                                                *
C     ******************************************************************
C
 14      IF(CSTMT(JA+2:JA+2) .GE. CAA .AND. CSTMT(JA+2:JA+2) .LE. CZZ
     1      .OR. CSTMT(JA+2:JA+2) .GE. CUNDER .AND. CSTMT(JA+2:JA+6)
     2      .NE. 'THEN') THEN
C
C         BLANK THE IF(...) PORTION OF THE STATEMENT TO PROCESS THE
C         REMAINING PORTION OF THE STATEMENT
C
            I1 = JA + 1
            IF(I1 .LE. 52) THEN
               CSTMT(1:I1) = CBLK52(1:I1)
            ELSE
               DO 15 I = 1,I1
               CSTMT(I:I) = CBLANK(1:1)
 15            CONTINUE
            END IF
C
C         MOVE THE REMAINING TEXT IN THE STATEMENT LEFT TO COLUMN ONE
C
            KB = KBSAVE
            I2 = I1 + 1
            DO 16 I = I2,KB
            I3 = I - I2 + 1
            CSTMT(I3:I3) = CSTMT(I:I)
            CSTMT(I:I) = CBLANK(1:1)
            IF(I .EQ. KB) KB = I3
 16         CONTINUE
            IRET = 2
            GO TO 28
         END IF
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE IF THIS IS AN ARITHMETIC STATEMENT WHEN THE        *
C     *   VARIABLE NAME IS IF AND AN EQUAL SIGN FOLLOWS THE FIRST      *
C     *   RIGHT PARENTHESIS. THIS WILL HAVE THE FORM OF IF(I)=         *
C     *                                                                *
C     ******************************************************************
C
         IF(CSTMT(JA+2:JA+2) .EQ. CEQ) THEN
            LEXEC = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 28
         END IF
C
C         DETERMINE IF AN ARITHMETIC IF STATEMENT
C
         JB = JA + 2
         IF(CSTMT(JB:JB) .GE. C0(1:1) .AND. CSTMT(JB:JB) .LE. C9(1:1))
     1      THEN
C
C         WHEN AN ARITHMETIC IF STATEMENT OCCURS, DETERMINE THE NUMBER
C         OF STATEMENT NUMBERS SPECIFIED.
C
            I2WK1 = 0
            L7 = LFALSE
            DO 17 IA = JB,KBSAVE
            IF(CSTMT(IA:IA) .EQ. COMMA) I2WK1 = I2WK1 + 1
            IF(CSTMT(IA:IA) .EQ. CEQ .OR. CSTMT(IA:IA) .EQ. CPLUS .OR.
     1         CSTMT(IA:IA) .EQ. CMINUS .OR. CSTMT(IA:IA) .EQ. CASTER
     2         .OR. CSTMT(IA:IA) .EQ. CSLASH) L7 = LTRUE
 17         CONTINUE
C
C         DETERMINE IF THREE STATEMENT NUMBERS ARE SPECIFIED
C
            IF(I2WK1 .LT. 2 .OR. I2WK1 .GT. 3) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               IRET = 1
               GO TO 28
            END IF
C
C         WHEN AN EQUAL SIGN OR ARITHMETIC OPERATOR EXISTS AFTER THE
C         LOGICAL IF CONDITI0N AND THE INITIAL CHARACTER IS NOT
C         ALPHABETIC, AN SYNTAX ERROR EXISTS
C
            IF(L7) THEN
               IF(.NOT.(CSTMT(JB:JB) .GE. CAA .AND. CSTMT(JB:JB) .LE.
     1         CZZ) .OR. CSTMT(JB:JB) .NE. CUNDER) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102) ISN,CSTMT(JB-2:JB+2)
               END IF
            END IF
C
C         WHEN AN EQUAL SIGN OCCURS AFTER THE LOGICAL IF CONDITI0N, AN
C         ARITHMETIC EXPRESSION STATEMENT EXISTS.
C
            IF(L7) THEN
               CALL EXPR (JB,KBSAVE,LFALSE,CSTMT)
               GO TO 28
            END IF
            CALL NUMBER (CSTMT,LTRUE,JB,II,FP,IFP)
            IIB = II + 128
            IISN = ISN + 128
            CWR(1:4) = CIB(1:4)
            CWR(5:8) = CISN(1:4)
            IF(.NOT.LINCL) THEN
               IREC4 = IREC4 + 1
               WRITE (4,REC=IREC4) CWR
            END IF
C
C         SEARCH FOR THE SECOND AND THIRD STATEMENT NUMBERS IN AN
C         ARITHMETIC IF STATEMENT
C
            L = LFALSE
            DO 18 IA = JB,KB
            IF(CSTMT(IA:IA) .EQ. COMMA .OR. IA .EQ. KB) THEN
               JC = IA + 1
               CALL NUMBER (CSTMT,LTRUE,JC,II,FP,IFP)
               IIB = II + 128
               IISN = ISN + 128
               CWR(1:4) = CIB(1:4)
               CWR(5:8) = CISN(1:4)
               IF(.NOT.LINCL) THEN
                  IREC4 = IREC4 + 1
                  WRITE (4,REC=IREC4) CWR
               END IF
               JB = JC
               IF(.NOT.L) THEN
                  L = LTRUE
                  GO TO 18
               ELSE
                  GO TO 19
               END IF
            END IF
 18         CONTINUE
C
C         PROCESS THE ARITHMETIC CONDITION EXPRESSION
C
 19         IB = JA
C
C         SCAN TO DETERMINE IF ANY ARITHMETIC OPERATORS OR SUBSCRIPTS
C         OCCUR; IF TRUE, THEN AN EXPRESSION NEEDS TO BE PROCESSED.
C
            DO 20 IA = J,IB
            IF(CSTMT(IA:IA) .EQ. CPLUS .OR. CSTMT(IA:IA) .EQ. CMINUS
     1          .OR. CSTMT(IA:IA) .EQ. CSLASH .OR. CSTMT(IA:IA) .EQ.
     2          CASTER .OR. CSTMT(IA:IA) .EQ. CLPAR .OR. CSTMT(IA:IA)
     3          .EQ. CRPAR .OR. CSTMT(IA:IA) .EQ. COLON .OR.
     4          CSTMT(IA:IA) .EQ. COMMA) THEN
                LEXEC = LTRUE
                CALL EXPR (I1,IB,LFALSE,CSTMT)
                GO TO 28
            END IF
 20         CONTINUE
C
C         THE LOGICAL CONDITION OF THE IF STATEMENT IS A SINGLE VARIABLE
C         NAME; DETERMINE IF THIS IS A STRUCTURE COMPOUND VARIABLE NAME.
C
            JD = J
            DO 21 IA = J,IB
            IF(CSTMT(IA:IA) .EQ. CDOT) THEN
               IC = IA - JD
               NA = IA
               IVCNT = IC
               IWORK = ISN + 128
               CWORK(1:IC) = CSTMT(JD:IA)
               CALL CHKNME (CSTMT)
               CWORK(1:32) = CBLK52(1:32)
               JD = IA + 1
            END IF
 21         CONTINUE
C
C         IF NO OPERATORS OR SUBSCRIPTS FOUND, IT IS A VARIABLE NAME
C         OR THE FINAL NODE OF A STRUCTURE COMPOUND VARIABLE NAME
C
            IF(JD .EQ. J) THEN
               IC = JA - J + 1
            ELSE
               IC = IB - JD
            END IF
            NA = JA + 1
            IVCNT = IC
            CWORK(1:IC) = CSTMT(J:JA)
            IWORK = ISN + 128
            CALL CHKNME (CSTMT)
            GO TO 28
         END IF
C
C         WHEN NOT AN ARITHMETIC IF STATEMENT, IT IS A LOGICAL IF.
C         THE CONDITIONAL LOGIC TEST BOUNDARIES ARE SET. DETERMINE
C         IF ANY LOGICAL OPERATORS EXIST.
C
 22      L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LFALSE
         L6 = LFALSE
C
C         CHECK IF THE INITIAL CHARACTER IS A LEFT PARENTHESIS
C
         IF(CSTMT(J:J) .EQ. CLPAR) J = J + 1
C
C         PROCESS THE PORTION OF THE STATEMENT ENCAPSULATED IN PAREN-
C         THESES TO SET LOGIC SWITCHES
C
         DO 23 I = J,JA
C
C         DETERMINE IF THE FIRST CHARACTER IS AN ALPHABETIC CHARACTER
C
         IF(I .EQ. J) THEN
            IF(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ .OR.
     1         CSTMT(I:I) .EQ. CUNDER) L4 = LTRUE
         END IF
C
C         DETERMINE IF AN ARITHMETIC OPERATOR EXISTS
C
         IF(CSTMT(I:I) .EQ. CPLUS .OR. CSTMT(I:I) .EQ. CMINUS .OR.
     1      CSTMT(I:I) .EQ. CSLASH .OR. CSTMT(I:I) .EQ. CASTER)
     2      L6 = LTRUE
C
C         DETERMINE IF SUBSCRIPTING EXISTS
C
         IF(CSTMT(I:I) .EQ. CLPAR .OR. CSTMT(I:I) .EQ. CRPAR .OR.
     1      CSTMT(I:I) .EQ. COLON .OR. CSTMT(I:I) .EQ. COMMA) L1 = LTRUE
C
C             DETERMINE IF A DIGIT EXISTS
C
         IF(CSTMT(I:I) .GE. C0(1:1) .AND. CSTMT(I:I) .LE. C9(1:1))
     1      L2 = LTRUE
 23      CONTINUE
C
C         TEST FOR A STRUCTURE COMPOUND VARIABLE NAME
C
         JD = J
         DO 24 IA = J,JA
         IF(CSTMT(IA:IA) .EQ. CDOT .AND. (CSTMT(IA-1:IA-1) .GE. CAA
     1      .AND. CSTMT(IA-1:IA-1) .LE. CZZ .OR. CSTMT(IA-1:IA-1) .GE.
     2      C0(1:1) .AND. CSTMT(IA-1:IA-1) .LE. C9(1:1) .OR.
     3      CSTMT(IA-1:IA-1) .EQ. CUNDER .OR. CSTMT(IA-1:IA-1) .EQ.
     4      CDOL) .AND. (CSTMT(IA+1:IA-1) .LE. CAA .AND.
     5      CSTMT(IA+1:IA+1) .LE. CZZ .OR. CSTMT(IA+1:IA+1) .EQ.
     6      CUNDER)) THEN
            IC = IA - JD
            NA = IA
            IVCNT = IC
            CWORK(1:IC) = CSTMT(JD:IA-1)
            IWORK = ISN + 128
            CALL CHKNME (CSTMT)
            CWORK(1:32) = CBLK52(1:32)
            JD = JD + 1
         END IF
 24      CONTINUE
C
C         THE SINGLE VARIABLE IS A NOT A COMPOUND VARIABLE NAME OR THIS
C         IS THE FINAL NODE OF THE COMPOUND NAME
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
            IF(JD .EQ. 0) THEN
               IC = JA - J + 1
            ELSE
               IC = JA - JD
            END IF
            NA = JA + 1
            IVCNT = IC
            CWORK(1:IC) = CSTMT(J:JA)
            IWORK = ISN + 128
            CALL CHKNME (CSTMT)
         END IF
         IF(CSTMT(J:J) .GE. C0(1:1) .AND. CSTMT(J:J) .LE. C9(1:1))
     1      CALL NUMBER (CSTMT,LTRUE,J,II,FP,IFP)
C
C         DETERMINE IF A BLOCK IF STATEMENT
C
         JB = JA + 2
         JC = JA - 1
C
C         THIS IS A LOGICAL IF STATEMENT, SET UP TO PROCESS THE
C         SECONDARY STATEMENT
C
         DO 26 I = JC,KB
         IF(CSTMT(I:I) .EQ. CRPAR) THEN
            DO 25 IA = 1,I
            CSTMT(IA:IA) = CBLANK(1:1)
 25         CONTINUE
            GO TO 27
         END IF
 26      CONTINUE
 27      IRET = 2
      END IF
C
C         ROUTINE EXIT
C
 28     RETURN IRET
        END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE IMPLICIT STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CDASH  - CHARACTER VARIABLE, A DASH: -
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY
C                  IS 8 CHARACTERS IN LENGTH, CHARACTER ONE CONTAINS
C                  AN ALPHABETIC CODE FOR AN IMPLICIT DECLARATION
C                  FOR EACH LETTER OF THE ALPHABET; THESE CODES AND
C                  THEIR MEANINGS ARE:
C
C                  CHARACTER 1
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C                    BLANK   UNDEFINED
C
C                  CHARACTERS 2 - 8
C
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER
C         CI2WK1 - CHARACTER VARIABLE, WORK ARRAY TO CONVERT ALPHABETIC
C                  CHARACTERS INTO A SUBSCRIPT VARIABLE VALUE.
C                  EQUIVALENCED TO I2WK1
C         CI2WK2 - CHARACTER VARIABLE, WORK ARRAY TO CONVERT ALPHABETIC
C                  CHARACTERS INTO A SUBSCRIPT VARIABLE VALUE.
C                  EQUIVALENCED TO I2WK2
C         CLEN   - CHARACTER VARIABLE, THE DEFINED LENGTH OF THE
C                  VARIABLES STARTING WITH THE SPECIFIED ALPHABETIC
C                  CHARACTER
C         CLENS  - CHARACTER VARIABLE, THE DEFINED LENGTH OF THE
C                  VARIABLES STARTING WITH THE SPECIFIED ALPHABETIC
C                  CHARACTER. THIS CONTAINS THE DEFAULT VALUE
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE THE
C                  DATA TYPE OF VARIABLES
C         CUNDER - CHARACTER VARIABLE, AN UNDERSCORE: _
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         FP     - THE VALUE OF A NUMBER RETURNED AS FLOATING POINT
C                  SINGLE PRECISION
C         I      - SUBSCRIPT VARIABLE
C         IB     - LOCATION OF THE END OF A FUNCTION NAME
C         IC     - LENGTH OF THE FUNCTION NAME
C         ICTN   - THE VALUE TO ADD TO AN ALPHABETIC NONNUMERIC
C                  CHARACTER TO CONVERT IT TO AN ALGEBRAIC NUMERIC VALUE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IFP    - LOCATION OF THE FIRST CHARACTER AFTER THE END OF A
C                  NUMERICAL FIELD. THIS IS RETURNED BY SUBROUTINE
C                  NUMBER.
C         II     - THE INTEGER VALUE OF A NUMBER
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IREC3  - THE COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 3
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - COUNT OF THE PARENTHESES, ONE IS ADD FOR A LEFT
C                  PARENTHESIS, ONE IS ADDED FOR RIGHT PARENTHESIS.
C         I2WK1  - WORK ARRAY TO CONVERT ALPHABETIC CHARACTERS INTO
C                  A SUBSCRIPT VARIABLE VALUE
C         I2WK2  - WORK ARRAY TO CONVERT ALPHABETIC CHARACTERS INTO
C                  A SUBSCRIPT VARIABLE VALUE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - SUBSCRIPT VARIABLE
C         JB     - LOCATION OF THE START OF A VARIABLE NAME
C         JC     - LOCATION OF THE START OF A VARIABLE NAME AFTER A
C                  COMMA
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LNONE  - LOGICAL VARIABLE, SET TRUE WHEN AN IMPLICIT NONE
C                  IS SPECIFIED FOR A PROGRAM OR SUBPROGRAM, SET FALSE
C                  OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE IF A DASH IS FOUND, SET
C                  FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE IF DEFINED LENGTH IS
C                  SPECIFIED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         IMPLICIT IS NOT AN EXECUTABLE STATEMENT.
C
C         WHEN AN IMPLICIT NONE STATEMENT OCCURS, NO OTHER IMPLICIT
C         STATEMENTS MAY OCCUR WITHIN A PROGRAM OR SUBPROGRAM.
C
C         WHEN AN UNDEFINED FUNCTION NAME IS DETECTED, THE TYPE AND
C         LENGTH WILL BE FORCED TO THE FORTRAN STANDARD DEFAULT
C         REGARDLESS OF AN IMPLICIT NONE STATEMENT. THIS ACTION OCCURS
C         IN THE ROUTINE THAT DETECTS THE UNDEFINED FUNCTION USE.
C
C         FORM:
C         IMPLICIT TYPE[*len] (a, [a],...), TYPE[*len] (a, [a],...)
C         TYPE IS: CHARACTER, COMPLEX, INTEGER, LOGICAL, REAL
C         len IS:  THE LENGTH OF THE DATA TYPE
C         a IS:    A SINGLE ALPHABETIC CHARACTER OR A RANGE OF
C                  ALPHABETIC CHARACTERS. EXAMPLE: (A-F)
C
C     SUBROUTINES CALLED
C
C         BTEST EXPR INSERT LOCERR NUMBER SETTL
C
C     *****************************************************************
C
      SUBROUTINE STMT32
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CDARG(30), IDARG(12,30)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(1,200), NFLOC(30)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*48    CDARG
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1, CI2WK2
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN, CLENS
      CHARACTER*1 CTYPED
      LOGICAL*1 L1, L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (I2WK2,CI2WK2), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7)
      EQUIVALENCE (CDEF(57:1496),CDARG,IDARG), (CDEF(45:48),IDBSW),
     1(CDEF(49:52),IDVLEN), (CDEF(53:56),IDNARG), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' UNBALANCED PARENTHESES')
 101  FORMAT(' ISN:',I6,' MULTIPLE IMPLICIT STATEMENTS NOT ALLOWED.')
C
C         DETERMINE IF AN IMPLICIT NONE STATEMENT HAS ALREADY OCCURRED.
C         MULTIPLE IMPLICIT STATEMENTS ARE NOT ALLOWED IN THIS CASE,
C         AND THEY ARE NOT PROCESSED.
C
      IF(LNONE) THEN
         IREC0 = IREC0 + 1
         WRITE (0,101) ISN
         GO TO 22
      END IF
C
C         INITIALIZATION
C
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      CLENS(1:7) = CBLANK(1:7)
      LNONE = LFALSE
      LEXEC = LFALSE
      I1 = 0
C
C         VERIFY THIS IS AN IMPLICIT STATEMENT
C
      J = KF + 7
      IF(CSTMT(KF:J) .EQ. 'IMPLICIT') THEN
C
C         DETERMINE IF ANY UNMATCH PARENTHESES
C
         DO 10 I = J,KB
            IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
            IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
            IF(I .EQ. KB .AND. I1 .NE. 0) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
               GO TO 22
            END IF
 10      CONTINUE
 11      J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 12 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            LEXEC = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 22
         END IF
 12      CONTINUE
C
C         DETERMINE IF THIS IS AN IMPLICIT NONE STATEMENT
C
        IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
        LEXEC = LTRUE
        IF(CSTMT(J:J+3) .EQ. 'NONE') THEN
           DO 13 I = 1,27
           CIMPL(I)(1:8) = CBLANK(1:8)
 13        CONTINUE
C
C         SET SWITCH TO INDICATE AN IMPLICIT NONE EXISTS
C
           LNONE = LTRUE
           GO TO 22
        END IF
C
C         DETERMINE IF THIS IS AN IMPLICIT UNDEFINED STATEMENT
C
        IF(CSTMT(J:J+8) .EQ. 'UNDEFINED') THEN
           J = J + 9
           CTYPED(1:1) = CBLANK(1:1)
           L2 = LFALSE
           GO TO 16
        END IF
C
C         THIS IS AN IMPLICIT STATEMENT, DETERMINE THE TYPE
C
         IF(CSTMT(J:J+8) .EQ. 'CHARACTER') THEN
            CTYPED(1:1) = CCC
            CLEN(1:1) = C1(1:1)
            J = J + 9
            GO TO 14
         END IF
         IF(CSTMT(J:J+6) .EQ. 'COMPLEX') THEN
            CTYPED(1:1) = CBB
            CLEN(1:1) = C8(1:1)
            J = J + 7
            GO TO 14
         END IF
         IF(CSTMT(J:J+14) .EQ. 'DOUBLEPRECISION') THEN
            CTYPED(1:1) = CDD
            CLEN(1:1) = C8(1:1)
            J = J + 15
            GO TO 14
         END IF
         IF(CSTMT(J:J+12) .EQ. 'DOUBLECOMPLEX') THEN
            CTYPED(1:1) = CEE
            CLEN(1:2) = '16'
            J = J + 13
            GO TO 14
         END IF
         IF(CSTMT(J:J+6) .EQ. 'INTEGER') THEN
            CTYPED(1:1) = CII
            CLEN(1:1) = C4(1:1)
            J = J + 7
            GO TO 14
         END IF
         IF(CSTMT(J:J+6) .EQ. 'LOGICAL') THEN
            CTYPED(1:1) = CLL
            CLEN(1:1) = C4(1:1)
            J = J + 7
            GO TO 14
         END IF
         IF(CSTMT(J:J+3) .EQ. 'REAL') THEN
            CTYPED(1:1) = CRR
            CLEN(1:1) = C4(1:1)
            J = J + 4
         END IF
C
C         INITIALIZATION FOR EACH SPECIFICATION
C
 14      L1 = LFALSE
         L2 = LFALSE
         I2WK1 = 0
         I2WK2 = 0
C
C         DETERMINE IF A LENGTH SPECIFICATION EXISTS
C
         IF(CSTMT(J:J) .EQ. CASTER) THEN
            J = J + 1
C
C         LOCATE THE END OF THE LENGTH SPECIFICATION
C
            DO 15 IA = J,KB
            IF(CSTMT(IA:IA) .EQ. CLPAR) THEN
               IB = IA - 1
               IC = IA - J
               CLENS(1:IC) = CSTMT(J:IB)
C
C         CONVERT LENGTH FROM ASCII TO BINARY AND SAVE IT IN THE TABLE
C
               CALL NUMBER (CSTMT,LTRUE,J,II,FP,IFP)
               IF(.NOT.LINCL) CALL INSERT (II)
C
C         ADJUST TYPE CODE FOR REAL*8
C
               IF(CSTMT(J-5:J-2) .EQ. 'REAL' .AND. CLENS(1:IC) .EQ.
     1            C8(1:1)) CTYPED(1:1) = CDD
C
C         ADJUST TYPE CODE FOR COMPLEX*16
C
               IF(CSTMT(J-8:J-2) .EQ. 'COMPLEX' .AND. CLENS(1:IC) .EQ.
     1            '16') CTYPED(1:1) = CEE
               J = J + 1
               L2 = LTRUE
               GO TO 16
               END IF
 15         CONTINUE
C
C         NO LENGTH SPECIFICATION, SET INDEX BEYOND THE LEFT
C         PARENTHESIS
C
         END IF
C
C         FIND THE END OF A LIST OF ALPHABETIC CHARACTERS
C
 16      DO 20 I = J,KB
         IF(CSTMT(I:I) .EQ. CRPAR) THEN
            IA = J
            IF(CSTMT(J:J) .EQ. CLPAR) IA = J + 1
            IB = I - 1
C
C         SCAN FOR THE INDIVIDUAL LETTERS OF THE ALPHABET
C
            L1 = LFALSE
            I2WK1 = 0
            I2WK2 = 0
            DO 19 JA = IA,IB
            IF(JA .EQ. IA) JC = JA
            IF(JA .EQ. IB) GO TO 18
C
C         DETERMINE IF A DASH EXISTS
C
            IF(CSTMT(JA:JA) .EQ. CDASH) THEN
C
C         DETERMINE THE RANGE LIMITS FOR A MULTIPLE SPECIFICATION
C
               IF(CSTMT(JA+1:JA+1) .EQ. CUNDER) THEN
                  I2WK2 = 27
               ELSE
                  CI2WK2(IDXE:IDXE) = CSTMT(JA+1:JA+1)
                  I2WK2 = I2WK2 - ICTN
               END IF
               CI2WK1(IDXE:IDXE) = CSTMT(JA-1:JA-1)
               I2WK1 = I2WK1 - ICTN
C
C         SET THE VALUES FOR THE IMPLICIT SAVE ARRAY RANGE IN CIMPL
C
               DO 17 JB = I2WK1,I2WK2
               CIMPL(JB)(1:1) = CTYPED(1:1)
               IF(L2) THEN
                  CIMPL(JB)(2:8) = CLENS(1:7)
               ELSE
                  CIMPL(JB)(2:8) = CLEN(1:7)
               END IF
 17            CONTINUE
               L1 = LFALSE
               I2WK1 = 0
               I2WK2 = 0
               IF(CSTMT(JA+2:JA+2) .EQ. COMMA) THEN
                  J = JA + 3
                  IF(J .GT. I) GO TO 11
                  GO TO 16
               END IF
               IF(CSTMT(JA+2:JA+2) .EQ. CRPAR) THEN
                  J = JA + 3
                  IF(J .GT. I) GO TO 11
                  GO TO 16
               END IF
            END IF
C
C         DETERMINE THE START LOCATION OF A FIELD WHEN A COMMA EXISTS
C         TEST FOR THE END OF A SPECIFICATION
C
 18         IF(CSTMT(JA:JA) .EQ. COMMA .OR. JA .EQ. IB) THEN
               JC = IA
               IF(CSTMT(JA:JA) .EQ. COMMA) JC = JA - 1
               IF(.NOT.L1) THEN
C
C         NO RANGE SPECIFIED, SET THE INDEX VALUE FOR A SINGLE ALPHA-
C         BETIC CHARACTER
C
                  I2WK1 = 0
                  IF(CSTMT(JC:JC) .EQ. CUNDER) THEN
                     I2WK1 = 27
                  ELSE
                     CI2WK1(IDXE:IDXE) = CSTMT(JC:JC)
                     I2WK1 = I2WK1 - ICTN
                  END IF
C
C         SET THE VALUES FOR THE IMPLICIT SAVE ARRAY IN CIMPL
C
C                 CIMPL(I2WK1)(1:1) = CTYPED(1:1)
                  CIMPL(I2WK1)(IDXE:IDXE) = CTYPED(1:1)
                  IF(L2) THEN
                     CIMPL(I2WK1)(2:8) = CLENS(1:7)
                  ELSE
                     CIMPL(I2WK1)(2:8) = CLEN(1:7)
                  END IF
                  L1 = LFALSE
                  I2WK1 = 0
                  I2WK2 = 0
                  J = JA + 1
                  GO TO 16
               END IF
            END IF
 19         CONTINUE
            IF(I .EQ. KB) GO TO 22
            J = I + 1
            IF(CSTMT(J:J) .EQ. COMMA) GO TO 11
         END IF
 20      CONTINUE
      END IF
C
C         SCAN THE MASTER VARIABLE NAME TABLE TO CORRECT TYPE AND
C         LENGTH CODES OF VARIABLE NAMES PRECEDING THE IMPLICIT
C         STATEMENT. THIS CASE CAN ONLY BE DUMMY ARGUMENTS IN ENTRY,
C         FUNCTION, AND SUBROUTINE STATEMENTS.
C
      DO 21 I = 1,INAME
      IF(BTEST(IENAME(12,I),8) .OR. BTEST(IENAME(12,I),9) .OR.
     1   BTEST(IENAME(12,I),10)) GO TO 21
      CALL SETTL (CNAME(I))
C     I2WK1 = 0
C     CI2WK1(1:1) = CNAME(I)(1:1)
C     I2WK1 = I2WK1 - ICTN
C     CNAME(I)(37:44) = CIMPL(I2WK1)(1:8)
 21   CONTINUE
 22   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE INCLUDE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CFILEB - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAMES
C                  THAT ARE TO BE PROCESSED. MAXIMUM OF 10 ALLOWED.
C         CIFILE - CHARACTER VARIABLE, LIST OF FILES OCCURRING IN
C                  INCLUDE STATEMENTS
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CIWORK - CHARACTER VARIABLE, WORK AREA FOR OPENING INCLUDE
C                  STATEMENT FILES
C         CNAME  - CHARACTER VARIABLE, THE ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM MODULE, ICLUDING ALL VARIABLE
C                  NAMES BROUGHT INTO THE MODULE BY INCLUDE STATEMENTS
C         CSAVST - CHARACTER VARIABLE, SAVE AREA FOR THE INCLUDE
C                  STATEMENT BEING PROCESSED
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CSIMPL - CHARACTER VARIABLE, SAVE AREA FOR VARIABLE CIMPL.
C                  THE VALUES OF THE FORTRAN VARIABLE STANDARD DEFAULT
C                  TYPE AND LENGTH DEFINITIONS ARE SAVED IN THIS ARRAY
C                  FOR EACH ENTRYINTO THIS SUBROUTINE. IT IS USED TO
C                  RESTORE CIMPL TO ITS ORIGINAL STATUS AFTER AN
C                  INCLUDE STATEMENT IS PROCESSED.
C         CSREC  - SAVE AREA FOR THE NEXT TWO RECORDS OF THE CURRENT
C                  FORTRAN PROGRAM, SUBPROGRAM, OR INCLUDE FILE
C                  FOLLOWING THE INCLUDE STATEMENT. THIS RECORD IS USED
C                  RESTORE THE RECORDS TO CONTINUE PROCESSING AFTER AN
C                  INCLUDE FILE FORTRAN CODE PROCESSING IS COMPLETE. THE
C                  SECOND SUBSCRIPT VALUE OF 1 IS THE FIRST RECORD AFTER
C                  THE FIRST INCLUDE, 2 IS THE FIRST RECORD AFTER THE
C                  SECOND INCLUDE, ETC. THE SUBSCRIPT VALUE IS THE
C                  NESTED LEVEL.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWK80  - CHARCTER VARIABLE, WORK AREA TO SAVE THE CURRENT
C                  DIRECTORY OF THE FIRST FORTRAN SOURCE FILE ON UNIT 1
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT CONTROL, START VALUE
C         IB     - SUBSCRIPT CONTROL, END VALUE
C         IEOF   - INDICATES AN END OF FILE WHEN IT EQUALS -1
C         IERR   - RETURN VALUE FROM IOSTAT IN A READ STATEMENT
C         ILOCBS - LOCATION OF THE FIRST BACKSLASH IN THE FIRST INPUT
C                  FILE ON INIT 6
C         ILOCR  - LOCATION OF THE END OF THE FILE NAME SPECIFIED IN
C                  THE INCLUDE STATEMENT
C         INAME  - COUNT OF THE NUMBER OF ENTRIES IN CNAME
C         INPUT  - INPUT UNIT NUMBER FOR SOURCE FORTRAN CODE. NORMALLY,
C                  ITS VALUE IS 5, BUT THE OCCURRENCE OF AN INCLUDE
C                  STATEMENT CAUSES IT TO BE MODIFIED SO THAT THE
C                  INCLUDED FILE MAY BE PROCESSED. WHEN MODIFIED, THE
C                  VALUES ARE FROM 21 THROUGH 46 DEPENDING WHETHER
C                  NESTED INLUDE STATEMENTS OCCUR.
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS WHEN THE
C                  STATEMENT IS PROCESSED
C         ISRECL - SAVE AREA FOR LENGTH OF EACH RECORD IN VARIABLE CSREC
C                  THE SECOND SUBSCRIPT VALUE OF 1 IS THE FIRST RECORD,
C                  2 IS THE SECOND RECORD.
C         I1     - NUMBER OF CHARACTERS IN THE STATEMENT SAVED IN ISREC.
C                  THIS VALUE IS PLACED IN ISRECL.
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JINCL  - COUNT OF THE NUMBER OF INCLUDE STATEMENT FILE NAMES
C                  CURRENTLY ACTIVE. USED AS AN INDEX FOR PROCESSING
C                  NESTED INCLUDE STATEMENTS.
C         JLOCBS - LOCATION OF THE FIRST BACKSLASH IN THE CURRENT
C                  INCLUDE STATEMENT
C         JSNA   - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS WHEN THE STATEMENT IS
C                  READ, EXCEPT COMMENTS AND CONTINUTION STATEMENTS
C         KB     - LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C         KD     - LOCATION OF THE FINAL STATEMENT OF THE NEW RECORD
C                  FROM UNIT INPUT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KISN   - SAVE AREA FOR THE ISN OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         KSNA   - SAVE AREA FOR JSNA OF THE CURRENT STATEMENT WHEN
C                  THE INITIAL INCLUDE FILE IS BEING PROCESSED. NESTED
C                  INCLUDE FILES AFTER THE FIRST DO NOT CHANGE THIS
C                  VALUE.
C         LEXIST - LOGICAL VARIABLE, SET TRUE IF AN INCLUDE FILE
C                  REQUESTED BY THE CURRENT PROGRAM BEING ANALYZED
C                  EXISTS, SET FALSE OTHERWISE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LSAVE  - LOGICAL VARIABLE, SAVE AREA FOR THE VALUE OF LSTART
C                  UPON ENTRY TO THIS SUBROUTINE. IT IS USED TO RESTORE
C                  LSTART TO ITS ORIGINAL VALUE AFTER THE INCLUDE
C                  STATEMENT PROCESSING IS COMPLETE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT, JSTRUC, RETURNS TO ZERO.
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE AFTER THE DIRECTORY OF
C                  THE FIRST FORTRAN INPUT HAS BEEN SAVED IN CWK80,
C                  SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE CURRENT INCLUDE
C                  FILE SPECIFICATION CONTAINS A DIRCTORY ADDRESS, SET
C                  FALSE OTHERWISE
C         NB     - SAVE AREA FOR THE VALUE OF KB WHILE PROCESSING
C                  INCLUDE FILES.
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C
C     COMMENTS
C
C     INCLUDE IS NOT AN EXECUTABLE STATEMENT
C
C     THE OCCURENCE OF AN INCLUDE STATEMENT WITHIN A PROGRAM BEING
C     ANALYZED WILL CAUSE THE FILE CONTAINING THE FORTRAN SOURCE CODE
C     TO BE BROUGHT INTO THE CURRENT PROGRAM. NO CODE FROM THE INCLUDED
C     FILE WILL APPEAR IN THE OUTPUT LISTING FOR THE CURRENT PROGRAM.
C     THE ONLY STATEMENTS FXREF PROCESSES IN THE INCLUDED CODE ARE:
C     1. A NESTED INCLUDE STATEMENT, 2. ALL TYPE DEFINITION
C     STATEMENTS, 3. DIMENSION STATEMENTS, 4. PARAMETER STATEMENTS,
C     5. COMMON STATEMENTS, 6. EQUIVALENCE STATEMENTS. THESE ARE
C     PROCESSED SO THAT THE OUTPUT TABLES WILL HAVE THE CORRECT
C     DEFINITIONS IN THE LISTINGS. NO OTHER FORTRAN STATEMENTS FROM THE
C     INCLUDED FILE WILL BE PROCESSED.
C
C     IF A VARIABLE NAME IN THE INCLUDED CODE IS NOT REFERENCED IN THE
C     CURRENT PROGRAM BEING PROCESSED, THAT VARIABLE WILL NOT APPEAR IN
C     ANY OUTPUT LISTING.
C
C     FXREF PERMITS NESTED INCLUDE STATEMENTS UP TO AND INCLUDING 7
C     LEVELS. OS/2 LIMITS A SINGLE PROGRAM TO 20 SIMULTANEOUSLY OPEN
C     FILES. THE FXREF USES UNITS 0 - 12 AS WORK, INPUT, AND OUTPUT
C     FILES. UNIT 13 IS RESERVED FOR DEBUGGING USE, LEAVING UNITS 14
C     THROUGH 20 AS POSSIBLE INPUT FILES FOR NESTED INCLUDE STATEMENTS.
C
C     THE ARRAYS AND VARIABLES USED FOR INCLUDE STATEMENTS ALLOW
C     NESTING UP TO 20 INCLUDE FILES, BUT IT IS NECESSARY TO INCREASE
C     THE LIMIT OF 20 SIMULTANEOUSLY OPEN FILES TO 33 IN ORDER TO
C     ALLOW THE GREATER INCLUDE STATEMENT NESTING DEPTH. FXREF DOES
C     NOT DO THIS, BUT A USER COULD MODIFY THE PROGRAM TO PERMIT THE
C     NESTING DEPTH TO ANY LEVEL DESIRED.
C
C     MOST FORTRAN COMPILERS ALLOWING THE INCLUDE STATEMENT HAVE LIMITS
C     ON THE DEPTH LEVEL PERMITTED. SOME COMPILERS DO NOT USE THE
C     INCLUDE STATEMENT. CONSEQUENTLY, FORTRAN PROGRAMS THAT DO NOT USE
C     AN INCLUDE STATEMENT ARE NOT AFFECTED BY THE RESTRICTION OF FXREF
C     T0 SEVEN INCLUDE LEVELS.
C
C     A FILE CALLED BY THE INCLUDE STATEMENT MUST NOT CONTAIN AN END
C     STATEMENT, AS THIS END STATEMENT WILL CAUSE FXREF TO TERMINATE
C     EXECUTION OF THE SUBPROGRAM CONTAINING THE INCLUDE STATEMENT
C     PREMATURELY.
C
C     SINCE AN INCLUDE STATEMENT MAY CONTAIN NONEXECUTABLE AND
C     EXECUTABLE STATEMENTS, NO TEST IS MADE TO DETERMINE IF A
C     NONEXECUTABLE STATEMENT OCCURS AFTER THE INITIAL EXECUTABLE
C     STATEMENT IN THE CURRENT PROGRAM MODULE BEING PROCESSED.
C
C     SUBROUTINES CALLED
C
C         EINCL EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT33
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CFILEB(10), CSIMPL(27), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEB, CIFILE, CWK80
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CSIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LSAVE, L1, L2
      LOGICAL*4       LEXIST
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /INFILE/ JFILES, CFILEB
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA L1/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' INCLUDE ARGUMENT NOT A LITERAL')
 101  FORMAT(' ISN:',I6,' INCLUDE FILE NOT FOUND'/1X,A80)
 102  FORMAT(' ISN:',I6,' MORE THAN 6 NESTED INCLUDE STATEMENTS')
 103  FORMAT(A72)
 104  FORMAT(A132)
 105  FORMAT(' ISN:',I6,' INCLUDE FILE NAME EXCEEDS 80 CHARACTERS')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
      IF(LEND) LEND = LFALSE
      IF(LWR) LWR = LFALSE
      IF(JSTRUC .GT. 0) JSTRUC = 0
C
C         VERIFY THIS IS AN INCLUDE STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'INCLUDE') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         WHEN THE NEXT CHARACTER IS A LITERAL, THIS IS AN INCLUDE
C         STATEMENT
C
         IF(CSTMT(J:J) .EQ. CSYMCF) THEN
            IF(JINCL .EQ. 1) LSAVE = LSTART
            LINCL = LTRUE
            GO TO 11
         ELSE
C
C         WHEN AN EQUAL SIGN OCCURS, THIS IS AN ARITHMETIC STATEMENT
C
            DO 10 I = J,KB
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               LINCL = LFALSE
               JINCL = 0
               LEXEC = LTRUE
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 16
            END IF
 10         CONTINUE
C
C         ARGUMENT ERROR
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
      ELSE
         GO TO 16
      END IF
C
C         COUNT THE INCLUDE NESTING LEVEL
C         DETERMINE IF THE MAXIMUM LEVEL OF INCLUDE STATEMENTS REACHED
C
 11   IF(JINCL .GT. 7) THEN
         JINCL = JINCL - 1
         GO TO 16
      END IF
C
C         SAVE THE ORIGINAL CIMPL DEFAULT TYPE AND LENGTH TABLE
C
      DO I = 1,27
      CSIMPL(I) = CIMPL(I)
      END DO
C
C         SAVE THE NEXT RECORD FROM THE CURRENT INPUT FORTRAN SOURCE;
C         IT WILL BE RESTORED WHEN THE CURRENT INCLUDE FILE HAS FINISHED
C         PROCESSING.
C
      CSREC(JINCL)(1:NCOLS) = CREC(1:NCOLS)
      ISRECL(JINCL) = NCOLS
      KISN = ISN
      KSNA = ISN
C
C         DETERMINE THE UNIT NUMBER FOR THIS INCLUDE FILE
C
      IF(INPUT .EQ. 5) THEN
         INPUT = 14
      ELSE
         INPUT = INPUT + 1
C
C         CHECK IF NESTED LEVEL IS GREATER THAN 6
C
         IF(INPUT .GT. 6) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
            JINCL = JINCL - 1
            GO TO 16
         END IF
      END IF
C
C         DETERMINE THE END LOCATION OF THE DIRECTORY OF THE FIRST
C         INPUT FILE ON UNIT 1. THIS IS DONE ONLY ONCE FOR A SINGLE
C         EXECUTION OF FXREF.
C
      IF(.NOT.L1) THEN
         ILOCBS = 0
         CWK80(1:80) = CBLK52(1:50)//CBLK52(1:30)
         DO I = 80,1,-1
         IF(CFILEB(1)(I:I) .EQ. CBSLAS(1:1)) THEN
            CWK80(1:I) = CFILEB(1)(1:I)
            ILOCBS = I
            L1 = LTRUE
            GO TO 110
         END IF
         END DO
      END IF
C
C         DETERMINE IF A DIRECTORY IS SPECIFIED IN THE INCLUDE FILE
C         SPECIFICATION
C
 110  L2 = LFALSE
      ILOCR = 0
      JBLOCBS = 0
      DO I = 80,1,-1
      IF(CIFILE(JINCL)(I:I) .EQ. CBLANK) THEN
         IF(CIFILE(JINCL)(I-1:I-1) .NE. CBLANK) ILOCR = I - 1
      END IF
      IF(CIFILE(JINCL)(I:I) .EQ. CBSLAS(1:1)) THEN
         L2 = LTRUE
         JLOCBS = I
         GO TO 111
      END IF
      END DO
C
C         CREATE A COMPLETE PATH NAME WHEN NO DIRECTORY IS SPECIFIED
C         WITHIN THE INCLUDE FILE NAME
C
 111  IF(.NOT.L2 .AND. L1) THEN
C
C         WHEN NO DIRECTORY EXISTS IN THE INCLUDE STATEMENT FILE
C         SPECIFICATION, CREATE A SYNTHETIC ONE USING THE INPUT
C         DIRECTORY FROM THE FIRST INPUT FILE OF UNIT 6.
C
         IF(JLOCBS .LE. 0) THEN
            CIFILE(JINCL)(ILOCBS+1:ILOCBS+ILOCR) =
     1         CIFILE(JINCL)(1:ILOCR)
            CIFILE(JINCL)(1:ILOCBS) = CWK80(1:ILOCBS)
            GO TO 112
         END IF
         IF(ILOCR+ILOCBS+1 .GT. 80) THEN
            WRITE(*,105) ISN,CIFILE(JINCL)(1:80)
            STOP 'FXREF CAN NOT PROCESS FILE NAME'
         END IF
      END IF
C
C         DETERMINE IF THE INCLUDE FILE EXISTS
C
 112  INQUIRE (FILE=CIFILE(JINCL),EXIST=LEXIST)
      IF(.NOT.LEXIST) THEN
         WRITE (*,101) ISN,CIFILE(JINCL)(1:80)
         STOP 'FXREF REQUIRES A MISSING FILE'
      END IF
C
C         OPEN THE NEW FILE CALLED BY THE INCLUDE STATEMENT
C
      OPEN (UNIT=INPUT,ACCESS='SEQUENTIAL',FILE=CIFILE(JINCL),
     1FORM='FORMATTED',ACTION='READ',STATUS='OLD')
C
C         WHEN A NEW INCLUDE FILE IS OPENED, INSURE THE STRUCTURE
C         SWITCH IS FALSE
C
      LSTRUC = LFALSE
C
C         READ THE INITIAL RECORD OF THE INCLUDE FILE INTO THE NEXT
C         RECORD BUFFER
C
 113  CREC(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      IF(NCOLS .EQ. 72) THEN
         READ (INPUT,103,IOSTAT=IERR) CREC(1:NCOLS)
      ELSE
         READ (INPUT,104,IOSTAT=IERR) CREC(1:NCOLS)
      END IF
C
C         WHEN THE RECORD IS A COMMENT OR A BLANK RECORD, GET ANOTHER
C         RECORD FOR PROCESSING. FOR AN INCLUDE FILE, THESE RECORDS
C         ARE NOT PROCESSD.
C
      IF(CREC(1:1) .EQ. CCC .OR. CREC(1:1) .EQ. CCS) GO TO 113
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN CREC
C
      DO 12 I = NCOLS,1,-1
      IF(CREC(I:I) .NE. CBLANK(1:1)) THEN
         KD = I
         GO TO 13
      END IF
 12   CONTINUE
C
C         WHEN THE DO LOOP TERMINATES NORMALLY, THE ENTIRE RECORD IS
C         FILLED WITH BLANKS
C
      GO TO 113
C
C         DETERMINE IF AN END OF FILE EXISTS
C
 13   IF(IERR .EQ. -1) THEN
C
C         RESTORE THE NEXT RECORD FOR THE CURRENT INPUT FORTRAN SOURCE
C         AND RESET THE UNIT NUMBER AND THE INCLUDE INDEX LEVEL VALUE
C
         CLOSE (INPUT)
         CREC(1:NCOLS) = CSREC(JINCL)(1:NCOLS)
         ISRECL(JINCL) = 0
         JINCL = JINCL - 1
         INPUT = INPUT - 1
         LEND = LFALSE
         LENDS = LFALSE
         LWR = LFALSE
C
C         DETERMINE IF ALL NESTED INCLUDE FILES ARE PROCESSED
C
         IF(INPUT .LT. 14) THEN
            INPUT = 5
            LSTRUC = LFALSE
         END IF
         GO TO 16
      END IF
      RETURN
C
C         THIS SECTION WILL PROCESS AN END OF FILE CONDITION FOR THE
C         CURRENT INCLUDE FILE
C
      ENTRY EINCL
C
C         CLOSE THE CURRENT INCLUDE FILE THAT HAS REACHED AN EOF
C
      CLOSE (INPUT)
C
C         THE NESTED STRUCTURE COUNT, JSTRUC, MUST BE SET TO ZERO FOR
C         EACH INCLUDE FILE
C
      JSTRUC = 0
C
C         RESTORE THE NEXT RECORD FOR THE CURRENT INPUT FORTRAN SOURCE
C         FILE AND RESET THE UNIT NUMBER AND THE INCLUDE INDEX VALUE
C
      CREC(1:NCOLS) = CSREC(JINCL)(1:NCOLS)
      CSREC(JINCL)(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      ISRECL(JINCL) = 0
      JINCL = JINCL - 1
      INPUT = INPUT - 1
C
C         DETERMINE IF THE CURRENT INCLUDE FILE THAT HAS REACHED AND
C         END OF FILE IS A NESTED INCLUDE FILE.
C
      IF(INPUT .LT. 14) THEN
         INPUT = 5
         ISN = KISN
         LINCL = LFALSE
         LSTART = LSAVE
      END IF
C
C         WHEN AN END OF THE INCLUDE FILE IS REACHED, SET OFF LENDS
C         TO PREVENT A FALSE END OF ROUTINE SITUATION, SINCE OTHER
C         STATEMENTS WILL PROBABLY FOLLOW THE INCLUDE STATEMENT.
C
      IF(LENDS) LENDS = LFALSE
C
C         TURN OFF THE END OF FILE INDICATOR
C
      IEOF = 0
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN CREC
C
      DO 15 I = NCOLS,1,-1
      IF(CSTMT(I:I) .NE. CBLANK(1:1)) THEN
         KB = I
         GO TO 16
      END IF
 15   CONTINUE
C
C         RESTORE ORIGINAL CIMPL VALUES FOR THE DEFAULT TYPE AND
C         LENGTH SPEFICATIONS
C
 16   DO I = 1,27
      CIMPL(I) = CSIMPL(I)
      END DO
      ISN = KISN
C
C         INSURE SWITCHES ARE RESET
C
      IF(LEND) LEND = LFALSE
      IF(LWR) LWR = LFALSE
      LSTRUC = LFALSE
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C    ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM PROCESSES THE INQUIRE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VAARIABLE, THE LETTER: A
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLPAR  - CHARACTER VARIABLE, THE CHARACTER: (
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, THE CHARACTER: )
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CUNDER - CHARACTER VAARIABLE, THE CHARACTER: _
C         CZZ    - CHARACTER VAARIABLE, THE LETTER: Z
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         IA     - LOCATION OF AN EQUAL SIGN WITHIN A FILE MANIPULATION
C                  ARGUMENT
C         IARG   - COUNT OF THE NUMBER OF CONTROL ARGUMENTS; A MAXIMUM
C                  OF 25 ARE ALLOWED FOR AN INQUIRE STATEMENT.
C         ID     - INDEX VALUE OF THE ARGUMENT IN ARRAY CLIST TO BE
C                  PROCESSED IN SUBROUTINE CIOLST
C         IREC0  - THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         I1     - COUNT OF THE NUMBER OF PARENTHESES. ONE IS ADDED WHEN
C                  A LEFT PARENTHESIS IS FOUND, ONE IS SUBTRACTED WHEN
C                  A RIGHT PARENTHESIS IS FOUND. ALSO USED AS A
C                  SUBSCRIPT
C         I2     - START LOCATION OF AN ARGUMENT VALUE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE; SKIPS FURTHER PROCESSING IN THE
C                  CURRENT ARGUMENT, AND FORCES PROCESSING OF THE NEXT
C                  ARGUMENT.
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT IS FOUND
C                  AND PROCESSED, SET FALSE OTHERWISE; PREVENTS
C                  PROCESSING OF A DUPLICATE ARGUMENT.
C         LBB    - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT IS FOUND
C                  AND PROCESSED, SET FALSE OTHERWISE
C         LC     - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST ARGUMENT
C                  IS PROCESSED, SET FALSE OTHERWISE
C         LD     - LOGICAL VARIABLE, SET FALSE IF THE FIRST ARGUMENT OF
C                  THE CONTROL LIST IS 'UNIT=', SET TRUE WHEN THE FIRST
C                  ARGUMENT IS 'FILE='.
C         LE     - LOGICAL VARIABLE, SET TRUE WHEN THE UNIT IS A
C                  VARIABLE NAME OR AN EXPRESSISON, SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A LITERAL, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A VARIABLE, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  IS FILE, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  IS UNIT, SET FALSE OTHERWISE
C     COMMENTS
C
C     A DEFAULT UNIT, i.e. AN ASTERISK, CAN NOT BE USED TO DESIGNATE
C     AN INPUT - OUTPUT UNIT.
C
C     THE INQUIRE STATEMENT MAY HAVE THE FOLLOWING CONTROL LIST
C     PARMETERS:
C     ACCESS, BINARY, BLANK, BLOCKSIZE, BUFFERCOUNT, CARRIAGECONTROL,
C     DIRECT, ERR, EXIST, FORM, FORMATTED, IOSTAT, KEYED, MODE, NAME,
C     NAMED, NEXTREC, NUMBER, OPENED, ORGANIZATION, RECL, RECORDTYPE,
C     SEQUENTIAL, UNFORMATTED
C
C     THE INQUIRE STATEMENT MAY SPECIFY THE UNIT AS EITHER A UNIT
C     NUMBER OR WITH THE 'FILE = ' PARAMETER. WHEN THE UNIT IS A
C     VARIABLE NAME, 'FILE = ' MUST BE USED, SINCE THE USE OF A
C     VARIABLE NAME ALONE CAN NOT DISTINGUISH WHETHER THE INQUIRE
C     STATMENT IS PERFORMING A UNIT OR A FILE INQUIRY. AN ERROR
C     MESSAGE IS CREATED WHEN NO UNIT OR FILE PARAMETER IS USED WITH
C     A VARIABLE NAME.
C
C     SUBROUTINES CALLED
C
C         CIOLST CUNIT EXPR
C
C     ******************************************************************
C
C         PROGRAM STATEMENT
C
      SUBROUTINE STMT34
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION LB(25), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA, LB, LBB, LC, LD, LE, L1, L2, L3, L4, L5, L6
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/ ID, LBB, L1, L2, L3, L4, LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' USE OF UNIT ''*'' NOT ALLOWED IN INQUIRE')
 101  FORMAT(' ISN:',I6,' INQUIRE HAS INSUFFICIENT ARGUMENTS')
 102  FORMAT(' ISN:',I6,' INQUIRE SPECIFIES A DUPLICATE ARGUMENT')
 103  FORMAT(' ISN:',I6,' INQUIRE LACKS LEFT PARENTHESIS')
 104  FORMAT(' ISN:',I6,' INQUIRE LACKS RIGHT PARENTHESIS')
 105  FORMAT(' ISN:',I6,' INQUIRE HAS AN INVALID ARGUMENT')
 106  FORMAT(' ISN:',I6,' INQUIRE ARGUMENTS ''FILE'' AND ''UNIT'' CAN N
     1OT OCCUR SIMULANTEOUSLY')
C
C         INITIALIZATION
C
      LA = LFALSE
      LC = LFALSE
      LE = LFALSE
      I2 = 0
      DO 10 I = 1,25
      LB(I) = LFALSE
 10   CONTINUE
C
C         VERIFY THIS IS AN INQUIRE STATEMENT
C
      J = KF + 6
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'INQUIRE') THEN
         J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            I1 = 0
            DO 11 I = J,KB
            IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
            IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               IF(I1 .EQ. 0) THEN
                  CALL EXPR (KF,KB,LFALSE,CSTMT)
                  GO TO 15
               END IF
            END IF
 11         CONTINUE
         END IF
C
C         DETERMINE IF A LEFT PARENTHESIS FOLLOWS
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            J = J + 1
         ELSE
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS ENDS THE STATEMENT
C
         IF(CSTMT(KB:KB) .NE. CRPAR) THEN
            WRITE (0,104) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         SET SWITCH TO INDICATE THE CURRENT STATEMENT IS NOT AN
C         ARITHMETIC STATEMENT
C
         LEXEC = LTRUE
         IARG = 1
C
C         BEGIN PROCESSING INQUIRE CONTROL OPTIONS LIST
C
 12      IA = 0
         I1 = 0
         LA = LFALSE
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LFALSE
         L5 = LFALSE
         L6 = LFALSE
         DO 14 I = J,KB
C
C         DETERMINE IF THE 'UNIT=' OR THE 'FILE=' ARGUMENT HAS ALREADY
C         BEEN PROCESSED
C
         IF(LC) GO TO 13
C
C         DETERMINE IF THIS IS THE FIRST ARGUMENT. THE FIRST ARGUMENT
C         MUST BE EITHER A FILE DESIGNATION: 'FILE=', A UNIT DESIGNATION
C         A NUMBER, OR AN ARITHMETIC EXPRESSION DETERMINING THE UNIT
C         NUMBER.
C
         IF(I .EQ. J .AND. .NOT.LC) THEN
            LC = LTRUE
C
C         DETERMINE IF THE FIRST ARGUMENT IS A DIGIT. THIS DESIGNATES
C         THE ARGUMENT IS A NUMERICAL UNIT NUMBER WITH NO 'UNIT='.
C
            IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) L3 = LTRUE
C
C         DETERMINE IF THE FIRST ARGUMENT IS 'UNIT='
C
            IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
               LD = LFALSE
               L6 = LTRUE
               I2 = J + 5
C
C         DETERMINE IF THE UNIT IS '*'
C
               IF(CSTMT(I2:I2) .EQ. CASTER) THEN
                  WRITE (0,100) ISN
                  IREC0 = IREC0 + 1
               END IF
C
C         DETERMINE IF THE UNIT IS NUMERICAL
C
               IF(CSTMT(I2:I2) .GE. C0 .AND. CSTMT(I2:I2) .EQ. C9)
     1            L3 = LTRUE
C
C         DETERMINE IF THE UNIT IS A VARIABLE NAME
C
               IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ .OR.
     1            CSTMT(I2:I2) .EQ. CUNDER) L2 = LTRUE
            END IF
C
C         DETERMINE IF THE FIRST ARGUMENT IS 'FILE='
C
            IF(CSTMT(J:J+4) .EQ. 'FILE=') THEN
               LD = LTRUE
               L5 = LTRUE
               I2 = J + 5
               ID = 17
C
C         DETERMINE IF THE FILE IS SPECIFIED AS A LITERAL
C
               IF(CSTMT(I2:I2) .EQ. CSYMCF) L1 = LTRUE
C
C         DETERMINE IF THE FILE IS A VARIABLE NAME
C
               IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ .OR.
     1            CSTMT(I2:I2) .EQ. CUNDER) L2 = LTRUE
               GO TO 13
            END IF
C
C         DETERMINE IF THE FIRST CHARACTER FOLLOWING THE LEFT
C         PARENTHESIS IS A VARIABLE NAME
C
            IF(.NOT.L2 .AND. .NOT.L3 .AND. .NOT.L5 .AND. ((CSTMT(J:J)
     1         .GE. CAA .AND. CSTMT(J:J) .LE. CZZ) .OR. CSTMT(J:J) .EQ.
     2         CUNDER)) LE = LTRUE
C
C         CALL THE CUNIT ROUTINE TO PROCESS THE FIRST ARGUMENT AS THE
C         UNIT DESIGNATION
C
            IF(.NOT.LD) THEN
               CALL CUNIT
               LB(IARG) = LTRUE
            END IF
C
C         DETERMINE IF THE CHARACTER AT LOCATION J IS A COMMA OR THE END
C         OF THE STATEMENT
C
            IF(J .GE. KB) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               GO TO 15
            END IF
            IF(CSTMT(J:J) .EQ. COMMA) THEN
               J = J + 1
            ELSE IF(I2. GT. J) THEN
               IF(CSTMT(J:J) .EQ. COMMA) J = J + 1
            END IF
C
C         DETERMINE IF THE FIRST ARGUMENT WAS PROCESSED CORRECTLY. THE
C         VALUE OF J IS THE LOCATION OF THE NEXT CHARACTER UNLESS IT IS
C         THE FINAL CHARACTER.
C
            IF(LA) THEN
               IF(J .GE. KB) THEN
                  WRITE (0,101) ISN
                  IREC0 = IREC0 + 1
                  GO TO 15
               END IF
               GO TO 13
            END IF
         END IF
C
C     *****************************************************************
C     *                                                               *
C     *      PROCESS FOR ALL PARAMETERS OTHER THAN THE FIRST          *
C     *                                                               *
C     *****************************************************************
C
C         SET UP FOR A VARIABLE NAME ARGUMENT
C
 13      IF(CSTMT(J:J+6) .EQ. 'ACCESS=') THEN
            I2 = J + 7
            ID = 1
            IARG = 2
         ELSE IF(CSTMT(J:J+6) .EQ. 'BINARY=') THEN
            I2 = J + 7
            ID = 4
            IARG = 3
         ELSE IF(CSTMT(J:J+5) .EQ. 'BLANK=') THEN
            I2 = J + 6
            ID = 5
            IARG = 4
         ELSE IF(CSTMT(J:J+9) .EQ. 'BLOCKSIZE=') THEN
            I2 = J + 10
            ID = 6
            IARG = 5
         ELSE IF(CSTMT(J:J+11) .EQ. 'BUFFERCOUNT=') THEN
            I2 = J + 12
            ID = 7
            IARG = 6
         ELSE IF(CSTMT(J:J+15) .EQ. 'CARRIAGECONTROL=') THEN
            I2 = J + 16
            ID = 8
            IARG = 7
         ELSE IF(CSTMT(J:J+6) .EQ. 'DIRECT=') THEN
            I2 = J + 7
            ID = 9
            IARG = 8
         ELSE IF(CSTMT(J:J+3) .EQ. 'ERR=') THEN
            I2 = J + 4
            ID = 13
            IARG = 25
         ELSE IF(CSTMT(J:J+5) .EQ. 'EXIST=') THEN
            I2 = J + 6
            ID = 14
            IARG = 9
         ELSE IF(CSTMT(J:J+4) .EQ.'FILE=') THEN
            IF(.NOT.L6) THEN
               I2 = J + 5
               ID = 16
               IARG = 12
            ELSE
               WRITE (0,106) ISN
               IREC0 = IREC0 + 1
               GO TO 15
            END IF
         ELSE IF(CSTMT(J:J+4) .EQ. 'FORM=') THEN
            I2 = J + 5
            ID = 18
            IARG = 10
         ELSE IF(CSTMT(J:J+9) .EQ. 'FORMATTED=') THEN
            I2 = J + 10
            ID = 19
            IARG = 11
         ELSE IF(CSTMT(J:J+6) .EQ. 'IOSTAT=') THEN
            I2 = J + 7
            ID = 21
            IARG = 12
         ELSE IF(CSTMT(J:J+5) .EQ. 'KEYED=') THEN
            I2 = J + 6
            ID = 23
            IARG = 13
         ELSE IF(CSTMT(J:J+4) .EQ. 'MODE=') THEN
            I2 = J + 5
            ID = 24
            IARG = 14
         ELSE IF(CSTMT(J:J+4) .EQ. 'NAME=') THEN
            I2 = J + 5
            ID = 25
            IARG = 15
         ELSE IF(CSTMT(J:J+5) .EQ. 'NAMED=') THEN
            I2 = J + 6
            ID = 26
            IARG = 16
         ELSE IF(CSTMT(J:J+7) .EQ. 'NEXTREC=') THEN
            I2 = J + 8
            ID = 27
            IARG = 17
         ELSE IF(CSTMT(J:J+6) .EQ. 'NUMBER=') THEN
            I2 = J + 7
            ID = 30
            IARG = 18
         ELSE IF(CSTMT(J:J+6) .EQ. 'OPENED=') THEN
            I2 = J + 7
            ID = 31
            IARG = 19
         ELSE IF(CSTMT(J:J+12) .EQ. 'ORGANIZATION=') THEN
            I2 = J + 13
            ID = 32
            IARG = 20
         ELSE IF(CSTMT(J:J+4) .EQ. 'RECL=') THEN
            I2 = J + 5
            ID = 35
            IARG = 21
         ELSE IF(CSTMT(J:J+10) .EQ. 'RECORDTYPE=') THEN
            I2 = J + 11
            ID = 37
            IARG = 22
         ELSE IF(CSTMT(J:J+10) .EQ. 'SEQUENTIAL=') THEN
            I2 = J + 11
            ID = 38
            IARG = 23
         ELSE IF(CSTMT(J:J+11) .EQ. 'UNFORMATTED=') THEN
            I2 = J + 12
            ID = 43
            IARG = 24
         ELSE IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
            IF(L5) THEN
               WRITE (0,106) ISN
               IREC0 = IREC0 + 1
               GO TO 15
            ELSE
               I2 = J + 5
               IARG = 29
               CALL CUNIT
               LB(IARG) = LTRUE
            END IF
C
C         INVALID ARGUMENT EXISTS
C
         ELSE IF(CSTMT(J:J) .NE. CSYMCF) THEN
            IF(LE) GO TO 15
               WRITE (0,105) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         DETERMINE IF THE ARGUMENT IS A VARIABLE NAME
C
         IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ .OR.
     1      CSTMT(I2:I2) .EQ. CUNDER) THEN
            L1 = LFALSE
            L2 = LTRUE
            L3 = LFALSE
            L4 = LFALSE
C
C         DETERMINE IF THE ARGUMENT IS A LITERAL
C
         ELSE IF(CSTMT(I2:I2) .EQ. CSYMCF) THEN
            L1 = LTRUE
            L2 = LFALSE
            L3 = LFALSE
            L4 = LFALSE
C
C         DETERMINE IF THE ARGUMENT IS A NUMBER
C
         ELSE IF(CSTMT(I2:I2) .GE. C0 .AND. CSTMT(I2:I2) .LE. C9) THEN
            L1 = LFALSE
            L2 = LFALSE
            L3 = LTRUE
            L4 = LFALSE
         END IF
C
C         CHECK FOR DUPLICATE ARGUMENTS
C
         IF(LB(IARG)) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         SET THE LOGICAL SWITCH TO PREVENT A DUPLICATE ARGUMENT
C
         LB(IARG) = LTRUE
         LBB = LB(IARG)
         CALL CIOLST
C
C         ROUTINE CIOLST SETS J TO THE START LOCATION OF THE NEXT
C         ARGUMENT
C
         IF(I1 .GE. KB) THEN
            GO TO 15
         ELSE
            IF(I2. GE. J) J = I2 + 2
            IF(J .GE. KB .OR. J + 1 .GE. KB) GO TO 15
            GO TO 12
         END IF
 14      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 15   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE INTEGER STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CGLEN  - CHARACTER VARIABLE, THE LENGTH SPECIFICATION FOR ALL
C                  VARIABLES LISTED IN THIS INTEGER STATEMENT, UNLESS
C                  SPECIFICALLY CHANGED FOR A SINGLE VARIABLE
C                  DECLARATION.
C         CII    - CHARACTER VARIABLE, THE CHARACTER: I
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI2WK1 - CHARACTER VARIABLE EQUIVALENCED TO I2WK1
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A DATA TYPE
C                  DEFINITION
C         CLENWK - CHARACTER STATEMENT, USED TO STORE THE ASCII TEXT
C                  FORM OF THE LENGTH DERIVED FROM AN EXPRESSION
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSAVE  - CHARACTER VARIABLE, THE TYPE AND LENGTH
C                  CHARACTERISTICS OF AN INTEGER STATEMENT. IT APPLIES
C                  TO ALL VARIABLES FOR THE STATEMENT UNLESS OTHERWISE
C                  SPECIFIED FOR AN INDIVIDUAL VARIABLE.
C         CSLASH - CHARATER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - THE DATA TYPE CODE. IT IS I FOR INTEGER TYPE
C         CWK32  - CHARACTER VARIABLE, USED TO SET UP A VARIABLE NAME
C                  FOR SEARCHING THE PARAMETER TABLE CPARAM
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C0     - CHARACTER VARIABLE, A ZERO: 0
C         C9     - CHARACTER VARIABLE, A NINE: 9
C         I      - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF THE DATA TYPE LENGTH FIELD
C         ID     - LOCATION OF THE END OF THE DATA TYPE LENGTH FIELD
C         ICTN   - ARITHMETIC VALUE TO BE SUBTRACTED FROM THE NUMERIC
C                  VALUE OF AN ALPHABETIC CHARACTER TO CREATE THE INDEX
C                  VALUE IN TABLE CIMPL
C         II     - THE VALUE OF THE DEFINED LENGTH DERIVED FROM AN
C                  EXPRESSION SPECIFICATION. IT MUST BE CONVERTED
C                  TO TEXT FORMAT FOR THE OUTPUT LISTING
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN TABLE CPARAM
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - A RETURN CODE, >0 MATCH EXISTS, <0 NO MATCH EXISTS
C         ISN    - ISN OF THE CURRENT STATEMENT
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  THE VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I2WK1  - USED TO CONVERT A BINARY INTEGER TO TEXT DIGITS, AND
C                  PROVIDE THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE AND WORKA AREA
C         I5     - COUNT OF THE NUMBER OF SLASHES NOT ENCAPSULATED
C                  WITHIN PARENTHESES
C         I6     - COUNT OF THE NUMBER OF DECINMAL DIGITS IN II AS IT
C                  IS CONVERTED TO TEXT DIGITS
C         I7     - POWER OF TEN TO I6 POWER
C         I8     - LOCATION TO PLACE A DIGIT CONVERTED TO TEST FORMAT IN
C                  CLEN
C         I9     - LOCATION OF A LEFT PARENTHESIS TERMINATING A VARIABLE
C                  NAME
C         I10    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS LOCATED BY I9
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE LAST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JB     - LOCATION OF THE CHARACTER AFTER AN ASTERISK, IF IT
C                  EXISTS
C         JC     - COUNT OF THE NUMBER OF SLASHES IN THE STATEMENT
C         JD     - DO LOOP PARAMETER, THE MAXIMUM END OF A POSSIBLE
C                  NUMERICAL FIELD DEFINING THE DATA TYPE LENGTH
C         JE     - THE END LOCATION OF A LENGTH SPECIFICATION FOR A
C                  VARIABLE
C         J1     - DO LOOP INDEX VARIABLE
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT FOR A GIVEN NEST
C                  LEVEL OF THE UNION. SUBSCRIPT 1 DESIGNATES THE UNION
C                  LEVEL, SUBSCRIPT 2 DESIGNATES THE MAP LEVEL
C         JUNION - COUNT OF THE LEVELS OF UNION STATEMENTS. ONE IS ADDED
C                  WHEN A UNION STATEMENT IS PROCESSED, ONE IS
C                  SUBTRACTED WHEN AN END UNION STATEMENT IS PROCESSED.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LARITH - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS WITHIN AN EXPRESSION DEFINING THE
C                  LENGTH OF THE CHARACTER VARIABLE. SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT RETURNS TO ZERO.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN NO LEFT PARENTHESIS
C                  IS FOUND, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH IS SPECIFED
C                  FOR THE ENTIRE STATEMENT HAS BEEN ENTERED IN CLEN,
C                  SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN NO *nn LENGTH IS
C                  SPECIFIED, SET FALSE OTHERWISE.
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A FUNCTION IS
C                  DECLARED, SET FALSE OTHERWISE
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN THE TYPE AND LENGTH
C                  CHARACTERISTICS ARE SET FROM THE DEFAULT VALUES IN
C                  TABLE CIMPL, SET FALSE OTHERWISE
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET5 FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FORM OF AN INTEGER VARIABLE NAME DEFINITION AND ITS
C         POSSIBLE SPECIFICATIONS ARE SHOWN BELOW:
C
C         INTEGER[*LENGTH] [NAME] [(DIMENSION)] [/DATA/]
C
C         ALL FOUR OF THE POSSIBLE SPECIFICATIONS MAY OCCUR, UNLESS THE
C         THE INTEGER IS DEFINED WITHIN A STRUCTURE. IN THIS CASE, THE
C         FORM OF THE INTEGER VARIABLE DEFINITION IS:
C
C         INTEGER[*LENGTH] [NAME] [(DIMENSION)]
C
C         BOTH [DIMENSION] AND [LENGTH] SPECIFICATIONS MAY BE AN
C         EXPRESSION OF VARIABLES AND CONSTANTS. VARIABLE SPECIFICATIONS
C         MUST HAVE BEEN DEFINED IN A PARAMETER STATEMENT TO BE VALID,
C         AND THEY MAY NOT HAVE SUBSCRIPTS.
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT LOCERR NUMBER PARAEV PAAEV TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT35
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION JMAP(20), MAPLEN(20,20), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CSAVE, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7   CGLEN, CLEN, CLENWK
      LOGICAL*1     LARITH, L1, L2, L4, L6, L8, L9
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /MUS/   JMAP, MAPLEN
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALAN
     1CED SLASHES')
 101  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION EXCEEDS 1 DIGIT')
 102  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION EQUALS ZERO')
 103  FORMAT(I7)
 104  FORMAT(' ISN:',I6,' INTEGER LENGTH NOT EQUAL TO 1, 2, OR 4')
 105  FORMAT(' ISN:',I6,' A DIGIT MUST FOLLOW AN ASTERISK')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      CSAVE(1:8) = CBLANK(1:8)
      CLENWK(1:7) = CBLANK(1:7)
      CGLEN(1:7) = CBLANK(1:7)
      LEXEC =  LFALSE
      L1 = LFALSE
      L2 = LFALSE
      L4 = LFALSE
      L6 = LFALSE
      L8 = LFALSE
      LFORCE = LFALSE
C
C         VERIFY THIS IS AN INTEGER STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'INTEGER') THEN
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT
C
         ID = 0
         LEXEC =  LTRUE
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
         IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(ID .EQ. 0) THEN
               LSTART = LTRUE
               CALL EXPR (KF,KBL,LFALSE,CSTMT)
               GO TO 21
            END IF
         END IF
 10      CONTINUE
      ELSE
         GO TO 21
      END IF
C
C         THIS IS AN INTEGER STATEMENT
C
      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
      J = J + 1
      LFORCE = LTRUE
      IF(CSTMT(J:J) .EQ. CASTER) THEN
         DO 11 I = J,KB
            IF(CSTMT(I:I+7) .EQ. 'FUNCTION') THEN
               JA = I + 7
               J = I
            ELSE
               JA = J + 7
            END IF
 11      CONTINUE
      END IF
      I2WK1 = 0
      JC = 0
      CTYPED(1:1) = CII
C
C         DETERMINE IF THE NAME IS A FUNCTION DECLARATION
C
      IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
C
C         SET THE LENGTH CHARACTERISTIC WHEN THE LENGTH VALUE PRECEDES
C         THE KEYWORD FUNCTION
C
         KF = J
         IF(CSTMT(J-1:J-1) .EQ. C1) THEN
            CLEN(1:1) = C1
         ELSE IF(CSTMT(J-1:J-1) .EQ. C2) THEN
            CLEN(1:1) = C2
         ELSE IF(CSTMT(J-1:J-1) .EQ. C4) THEN
            CLEN(1:1) = C4
         ELSE
            CLEN(1:1) = C4
         END IF
         KF = J
         CALL STMT29 (CTYPED,CLEN)
         GO TO 21
      END IF
C
C         DETERMINE IF AN ALPHABETIC CHARACTER FOLLOWS 'INTEGER'. THIS
C         MEANS NO LENGTH SPECIFCATION EXISTS, AND A VARIABLE NAME
C         FOLLOWS. SET THE LENGTH CHARACTERISTIC TO THE DEFAULT VALUE
C         OF 4.
C
      IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ) THEN
         CLEN(1:1) = C4(1:1)
         CTYPED(1:1) = CII
         CSAVE(1:1) = CTYPED(1:1)
      END IF
C
C         IF AN ASTERISK FOLLOWS 'INTEGER', THEN THE LENGTH
C         SPECIFICATION FOLLOWS THE ASTERISK
C
      IF(CSTMT(J:J) .EQ. CASTER) THEN
C
C         INDICATE THIS IS NOT AN ARITHMETIC STATEMENT
C
         LEXEC =  LTRUE
C
C         SET THE STARTING POSITION OF THE FIELD FOLLOWING THE ASTERISK
C
         JB = J + 1
C
C         DETERMINE IF A DIGIT FOLLOWS THE ASTERISK.
C
         IF(CSTMT(JB:JB) .GE. C0 .AND. CSTMT(JB:JB) .LE. C9) THEN
C
C         ONLY THE DIGITS 1, 2, OR 4 MAY FOLLOW THE ASTERISK
C
            IF(CSTMT(JB:JB) .EQ. C1 .OR. CSTMT(JB:JB) .EQ. C2 .OR.
     1         CSTMT(JB:JB) .EQ. C4) THEN
               II = 0
               IF(CSTMT(JB:JB) .EQ. C1) THEN
                  II = 1
               ELSE IF(CSTMT(JB:JB) .EQ. C2) THEN
                  II = 2
               ELSE IF(CSTMT(JB:JB) .EQ. C4) THEN
                  II = 4
               ELSE IF(II .EQ. 0) THEN
                  WRITE (0,104) ISN
                  IREC0 = IREC0 + 1
                  CLEN(1:7) = C4//CBLANK(1:6)
                  II = 4
               END IF
               CGLEN(1:7) = CSTMT(JB:JB)//CBLANK(1:7)
               CLEN(1:7) = CSTMT(JB:JB)// CBLANK(1:7)
               CSAVE(1:8) = CII//CSTMT(JB:JB)//CBLANK(1:6)
               CALL INSERT (II)
               J = JB + 1
               GO TO 17
            END IF
         END IF
C
C         DETERMINE IF A LEFT PARENTHESIS FOLLOWS THE ASTERISK. THIS
C         MEANS THE LENGTH OF THE INTEGER IS DEFINED AS AN EXPRESSION
C         OF DEFINED CONSTANTS IN PARAMETER STATEMENTS.
C
         IF(CSTMT(JB:JB) .EQ. CLPAR(1:1)) THEN
            LARITH = LFALSE
C
C         DETERMINE THE END OF THE LENGTH SPECIFICATION WHEN THE
C         SPECIFICATION IS ENCAPSULATED IN PARENTHESES
C
            DO 13 I = JB,KB
C
C         DETERMINE IF ANY ARITHMETIC OPERATOR OCCURS WITHIN THE LENGTH
C         SPECIFICATION
C
            IF(CSTMT(I:I) .EQ. CPLUS(1:1) .OR. CSTMT(I:I) .EQ.
     1         CMINUS(1:1) .OR. CSTMT(I:I) .EQ. CSLASH(1:1) .OR.
     2         CSTMT(I:I) .EQ. CASTER(1:1)) LARITH = LTRUE
C
C         THE OCCURENCE OF A COMMA OR THE FINAL CHARACTER OF THE
C         STATEMENT TERMINATES THE LENGTH SPECIFICATION
C
            IF(CSTMT(I:I) .EQ. COMMA(1:1)) JE = I - 2
            IF(CSTMT(I:I) .EQ. CLPAR(1:1)) I1 = I1 + 1
            IF(CSTMT(I:I) .EQ. CRPAR(1:1)) I1 = I1 - 1
            IF(I1 .EQ. 0) THEN
               IF(I .EQ. KB) THEN
                  JE = I - 1
               ELSE
                  JE = I
               END IF
               GO TO 14
            END IF
  13        CONTINUE
C
C         EITHER A NUMBER OR A VARIABLE NAME FOLLOWS THE LEFT
C         PARENTHESIS TO SPECIFY THE LENGTH
C
 14         J = JE + 1
            JB = JB + 1
            JE = JE - 1
C
C         WHEN A VARIABLE NAME IS SPECIFIED AS THE LENGTH OF A CHARACTER
C         VARIABLE, IT MUST HAVE BEEN PREVIOUSLY DEFINED IN A PARAMETER
C         STATEMENT. OTHERWISE, THIS DEFINTION IS AN ERROR.
C
C         DETERMINE IF AN EXPRESSION CASE; EITHER A VARIABLE NAME OR A
C         DIGIT MAY OCCUR FIRST
C
            IF(CSTMT(JB:JB) .GE. CAA .AND. CSTMT(JB:JB) .LE. CZZ .OR.
     1         CSTMT(JB:JB) .EQ. CUNDER .OR. CSTMT(JB:JB) .GE.
     2         C0(1:1) .AND. CSTMT(JB:JB) .LE. C9(1:1)) THEN
C
C         WHEN ARITHMETIC OPERATORS EXIST, AN EXPRESSION SPECIFIES THE
C         LENGTH OF THE CHARACTER VARIABLE BEING DEFINED
C
               IF(LARITH) THEN
                  CALL PARAEV (JB,JE,II)
C
C         CONVERT THE DETERMINED LENGTH TO TEXT FORMAT
C
                  CLEN(1:7) = CBLANK(1:7)
                  CWORK(37:37) = CTYPED(1:1)
                  IF(II .EQ. 0) THEN
                     WRITE (0,102) ISN
                     IREC0 = IREC0 + 1
C
C         WHEN THE LENGTH EVALUATES TO ZERO
C
                     CWORK(38:44) = C4(1:1)//CBLANK(1:6)
                     CLEN(1:7) = CWORK(38:44)
                     II = 4
                     GO TO 17
                  ELSE
C
C         WHEN THE LENGTH IS NOT ZERO, CONVERT TO TEXT FORMAT
C
                     WRITE (CLENWK,103) II
                     DO 15 I = 1,7
                     I2WK1 = 8 - I
                     CLEN(I:I) = CLENWK(I2WK1:I2WK1)
 15                  CONTINUE
                     CLENWK(1:7) = CLEN(1:7)
                     L2 = LTRUE
                     J = JE + 1
                     IF(CSTMT(J:J) .EQ. CRPAR(1:1)) J = J + 1
                     GO TO 17
                  END IF
               END IF
            END IF
C
C         LOCATE THE END OF THE NUMERICAL FIELD
C
            IF(CSTMT(JB:JB) .GE. C0(1:1) .AND. CSTMT(JB:JB) .LE.
     1         C9(1:1)) THEN
               DO 16 I = JB,KB
               IF(.NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE.
     1            C9)) THEN
                  IC = I - JB
                  ID = I - 1
                  IF(IC .GT. 1) THEN
                     IF(.NOT.LINCL) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                  END IF
                  IC = 1
                  ID = JA
               END IF
               CLEN(1:IC) = CSTMT(JB:ID)
               CLENWK(1:7) = CLEN(1:7)
C
C         DETERMINE IF THE LENGTH SPECIFICATION IS VALID FOR AN INTEGER
C
               IF(.NOT.(CLEN(1:1) .EQ. C1 .OR. CLEN(1:1) .EQ. C2 .OR.
     1            CLEN(1:1) .EQ. C4)) THEN
                  WRITE (0,104) ISN
                  IREC0 = IREC0 + 1
                  CLEN(1:7) = C4//CBLANK(1:6)
               END IF
               L2 = LTRUE
               J = I
               IF(CSTMT(JB-1:JB-1) .EQ. CLPAR(1:1)) J = J + 1
               JA = J + 7
               GO TO 17
 16            CONTINUE
            END IF
C
C         A NUMERICAL DIGIT DOES NOT FOLLOW AN ASTERISK
C
         ELSE
            WRITE (0,105) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         NO ASTERISK OCCURS THAT INDICATES A LENGTH SPECIFICATION, OR
C         THE LENGTH SPECIFICATION HAS BEEN PROCESSED ABOVE. SET THE
C         TYPE AND LENGTH CHARACTERISTICS FOR THE VARIABLE.
C
 17   IF(CSTMT(J:J) .NE. CASTER) THEN
         CLENWK(1:1) = CLEN(1:1)
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
         IF(CSTMT(J:J+7) .EQ. 'FUNCTION') THEN
C
C         SCAN FOR SLASHES OCCURRING IN AN INTEGER STATEMENT
C
            JC = 0
            DO 18 I = J,KB
            IF(CSTMT(I:I) .EQ. CSLASH) JC = JC + 1
C
C         DETERMINE IF AN ARITHMETIC STATEMENT
C
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               CTYPED(1:1) = CBLANK(1:1)
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 21
            END IF
 18         CONTINUE
            IF(MOD(JC,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IRET0 = IRET0 + 1
         END IF
      END IF
C
C         PROCESS THE REMAINDER OF THE INTEGER STATEMENT; THE
C         STATEMENT MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIFICATI0NS.
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE INTEGER STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
      CWORK(1:52) = CBLK52(1:52)
C     CLEN(1:7) = CGLEN(1:7)
      JBITS = 0
 19   I1 = 0
      I2 = J
      I5 = 0
      I9 = 0
      I10 = 0
      DO 20 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
      IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
         I1 = I1 + 1
         I9 = I4
      END IF
      IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
         I1 = I1 - 1
         I10 = I4
      END IF
      IF(I1 .EQ. 0 .AND. CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
      IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
         IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            I3 = I4
            IF(I5 .GT. 0) I2WK1 = I5
C
C         SET THE CORRECT LENGTH CHARACTERISTIC WHEN NO SPECIFIC VALUE
C         IS PROIVIDED FOR THE VARIABLE.
C
            IF(.NOT.L2 .AND. CLEN(1:7) .EQ. CBLANK(1:7))
     1         CLEN(1:1) = CGLEN(1:1)
            IF(LSTRUC) THEN
               LFORCE = LFALSE
            ELSE
               LFORCE = LTRUE
            END IF
C
C         DETERMINE IF THE VARIABLE IS SUBSCRIPTED
C
            IF(I9 .GT. 0 .AND. I10 .GT. 0) THEN
               L9 = LTRUE
            ELSE
               L9 = LFALSE
            END IF
            IF(.NOT.LINCL .AND. .NOT.LSTRUC) LFORCE = LTRUE
            CALL TYPLST (CTYPED,CLEN,I2,I3,L9)
            LFORCE = LFALSE
            IF(L8) THEN
               CLEN(1:7) = CSAVE(2:8)
            ELSE
               CLEN(1:7) = CLENWK(1:7)
            END IF
C
C         TEST FOR END OF THE STATEMENT
C
            IF(I4 .EQ. KB) GO TO 21
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
            IF(CSTMT(I4:I4) .EQ. COMMA) THEN
               J = I4 + 1
               GO TO 19
            END IF
         END IF
      END IF
 20   CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 21   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE INTRINSIC STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VAARIABLE, THE LETTER: A
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _
C         CZZ    - CHARACTER VARIABLE, THE LETTER: Z
C         I      - SUBSCRIPT VARIABLE
C         IREC0  - THE NUMBER OF RECORDS ON UNIT 0
C         ISN    - ISN OF THE CURRENT STATEMENT
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  THE VARIABLE'S SPECIFICATION GROUP. ALSE USED AS A
C                  WORK AREA.
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C
C     COMMENTS
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [DIMENSION] [LENGTH] [DATA]
C
C         BOTH [DIMENSION] AND [LENGTH] SPECIFICATIONS MAY BE AN
C         EXPRESSION OF VARIABLES AND CONSTANTS. VARIABLE SPECIFICATIONS
C         MUST HAVE BEEN DEFINED IN A PARAMETER STATEMENT TO BE VALID,
C         AND THEY MAY NOT HAVE SUBSCRIPTS.
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR IBSET LOCERR
C
C     *****************************************************************
C
      SUBROUTINE STMT36
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' AN INTRINSIC FUNCTION SPECIFICATION IS INVALID
     1')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC =  LFALSE
C
C         VERIFY THIS IS A INTRINSIC STATEMENT
C
      J = KF + 8
      IF(CSTMT(KF:J) .EQ. 'INTRINSIC') THEN
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT
C
         I1 = 0
         LEXEC =  LTRUE
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
         IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(I1 .EQ. 0) THEN
               LSTART = LTRUE
               CALL EXPR (J,KB,LFALSE,CSTMT)
               GO TO 13
            END IF
         END IF
 10      CONTINUE
C
C         THIS IS AN INTRINSIC STATEMENT
C
 11      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         J = J + 1
C
C         THE CHARACTER FOLLOWING 'INTRINSIC' MUST BE THE START OF A NEW
C         VARIABLE NAME
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
C
C         SCAN TO LOCATE THE END OF THE VARIABLE NAME
C
            DO 12 I = J,KB
            IF(CSTMT(I:I) .EQ. COMMA .OR. I .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               IF(CSTMT(I:I) .EQ. COMMA) THEN
                  I1 = I - 1
               ELSE IF(I .EQ. KB) THEN
                  I1 = KB
               END IF
               IF(I .GE. KB) THEN
                  IVCNT = I - J + 1       ! VARIABLE NAME LENGTH
               ELSE
                  IVCNT = I - J           ! VARIABLE NAME LENGTH
               END IF
               CWORK(1:IVCNT) = CSTMT(J:I1)       ! FUNCTION NAME
               IWORK = ISN + 128       ! ISN
               CWORK(37:37) = CBLK52(1:1)  ! DATA TYPE
               JBITS = IBSET(JBITS,10) ! FUNCTION SWITCH
               JBITS = IBSET(JBITS,16) ! FUNCTION SWITCH
               CALL CHKNME (CSTMT)
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               IF(CSTMT(I:I) .EQ. COMMA) THEN
                  J = I
                  GO TO 11
               END IF
               IF(I .EQ. KB) THEN
                  GO TO 13
               ELSE
                  GO TO 11
               END IF
            END IF
 12         CONTINUE
         ELSE
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE LOGICAL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CGLEN  - CHARACTER VARIABLE, THE LENGTH SPECIFICATION FOR ALL
C                  VARIABLES LISTED IN THIS LOGICAL STATEMENT, UNLESS
C                  SPECIFICALLY CHANGED FOR A SINGLE VARIABLE
C                  DECLARATION.
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI2WK1 - CHARACTER VARIABLE EQUIVALENCED TO I2WK1
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A DATA TYPE
C                  DEFINITION
C         CLENWK - CHARACTER STATEMENT, USED TO STORE THE ASCII TEXT
C                  FORM OF THE LENGTH DERIVED FROM AN EXPRESSION
C         CAA    - CHRACTER VARIABLE, THE CHARACTER: A
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CGLEN  - CHARACTER VARIABLE, THE LENGTH SPECIFICATION FOR ALL
C                  VARIABLES LISTED IN THIS INTEGER STATEMENT, UNLESS
C                  SPECIFICALLY CHANGED FOR A SINGLE VARIABLE
C                  DECLARATION.
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY
C                  IS 8 CHARACTERS IN LENGTH, CHARACTER ONE CONTAINS
C                  AN ALPHABETIC CODE FOR AN IMPLICIT DECLARATION
C                  FOR EACH LETTER OF THE ALPHABET; THESE CODES AND
C                  THEIR MEANINGS ARE:
C
C                  CHARACTER 1
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C                    BLANK   UNDEFINED
C
C                  CHARACTERS 2 - 8
C
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER
C         CLL    - CHRACTER VARIABLE, THE CHARACTER: L
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A CHARACTER
C                  DEFINITION
C         CZZ    - CHRACTER VARIABLE, THE CHARACTER: Z
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CLENWK - CHARACTER STATEMENT, USED TO STORE THE ASCII TEXT
C                  FORM OF THE LENGTH DERIVED FROM AN EXPRESSION
C         CMINUS - CHARACTER VARIABLE, A MINUS SIGN: -
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPLUS  - CHARACTER VARIABLE, A PLUS SIGN: +
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARATER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - THE DATA TYPE CODE. IT IS L FOR A LOGICAL TYPE
C         CUNDER - CHARACTER VARIABLE, THE CHARACTER: _
C         CWK31  - CHARACTER VARIABLE, USED TO SET UP A VARIABLE NAME
C                  FOR SEARCHING THE PARRAMETER TABLE CPARAM
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CZZ    - CHRACTER VARIABLE, THE CHARACTER: Z
C         C0     - CHARACTER VARIABLE, A ZERO: 0
C         C1     - CHARACTER VARIABLE, A ZERO: 1
C         C2     - CHARACTER VARIABLE, A ZERO: 2
C         C4     - CHARACTER VARIABLE, A ZERO: 4
C         C9     - CHARACTER VARIABLE, A NINE: 9
C         FP     - THE VALUE OF A NUMBER RETURNED AS FLOATING POINT
C                  SINGLE PRECISION
C         I      - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF THE DATA TYPE LENGTH FIELD
C         ICTN   - ARITHMETIC VALUE TO BE SUBTRACTED FROM THE NUMERIC
C                  VALUE OF AN ALPHABETIC CHARACTER TO CREATE THE INDEX
C                  VALUE IN TABLE CIMPL
C         ID     - LOCATION OF THE END OF THE DATA TYPE LENGTH FIELD
C         IFP    - LOCATION OF THE FIRST CHARACTER AFTER THE END OF A
C                  NUMERICAL FIELD. THIS IS RETURNED BY SUBROUTINE
C                  NUMBER.
C         II     - THE VALUE OF THE DEFINED LENGTH DERIVED FROM AN
C                  EXPRESSION SPECIFICATION. IT MUST BE CONVERTED
C                  TO TEXT FORMAT FOR THE OUTPUT LISTING
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN TABLE CPARAM
C         IPGNME - LENGTH OF A FUNCTION NAME
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IRET   - A RETURN CODE, >0 MATCH EXISTS, <0 NO MATCH EXISTS
C         ISN    - ISN OF THE CURRENT STATEMENT
C         I1     - WORK AREA TO DETERMINE IF PARENTHESES ARE CLOSED
C                  ONE IS ADDED FOR A LEFT PARENTHESIS; ONE IS
C                  SUBTRACED FOR A RIGHT PARENTHESIS. A COMMA
C                  ENCAPSULATED WITHIN PARENTHESES DOES NOT TERMINATE
C                  THE VARIABLE'S SPECIFICATION GROUP
C         I2     - START LOCATION OF A VARIABLE NAME
C         I2WK1  - USED TO CONVERT A BINARY LOGICAL TO TEXT DIGITS, AND
C                  PROVIDE THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST
C         I3     - END LOCATION OF THE VARIABLE NAMES' SPECIFICATIONS
C         I4     - SUBSCRIPT VARIABLE AND WORK AREA
C         I5     - COUNT OF THE NUMBER OF SLASHES NOT ENCAPSULATED
C                  WITHIN PARENTHESES
C         I6     - COUNT OF THE NUMBER OF DECINMAL DIGITS IN II AS IT
C                  IS CONVERTED TO TEXT DIGITS
C         I7     - POWER OF TEN TO I6 POWER
C         I8     - LOCATION TO PLACE A DIGIT CONVERTED TO TEST FORMAT IN
C                  CLEN
C         I9     - LOCATION OF A LEFT PARENTHESIS TERMINATING A VARIABLE
C                  NAME
C         I10    - LOCATION OF A RIGHT PARENTHESIS MATCHING THE LEFT
C                  PARENTHESIS LOCATED BY I9
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE LAST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JB     - LOCATION OF THE CHARACTER AFTER AN ASTERISK, IF IT
C                  EXISTS
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         JC     - COUNT OF THE NUMBER OF SLASHES IN THE STATEMENT
C         JD     - DO LOOP PARAMETER, THE MAXIMUM END OF A POSSIBLE
C                  NUMERICAL FIELD DEFINING THE DATA TYPE LENGTH
C         JE     - THE END LOCATION OF A LENGTH SPECIFICATION FOR A
C                  VARIABLE
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LARITH - LOGICAL VARIABLE, SET TRUE WHEN AN ARITHMETIC
C                  OPERATOR EXISTS WITHIN AN EXPRESSION DEFINING THE
C                  LENGTH OF THE CHARACTER VARIABLE. SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN NO LEFT PARENTHESIS
C                  IS FOUND, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A LENGTH IS SPECIFED
C                  FOR THE ENTIRE STATEMENT HAS BEEN ENTERED IN CLEN,
C                  SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK FOLLOWS
C                  THE LOGICAL STATEMENT, SET FALSE WHEN ONE DOES NOT
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED
C
C     COMMENTS
C
C         A VARIABLE NAME DEFINED AS A LOGICAL VARIABLE NAME HAS THE
C         FOLLOWING FORM:
C
C         LOGICAL[*LENGTH] [NAME] [(DIMENSION)] [/DATA/]
C
C         WHEN THE VARIABLE DEFINED AS A LOGICAL VARIABLE NAME AND IT
C         IS DEFINED WITHIN A STRUCTURE, IT HAS THE FOLLOWING FORM:
C
C         LOGICAL[*LENGTH] [NAME] [(DIMENSION)]
C
C         BOTH [DIMENSION] AND [LENGTH] SPECIFICATIONS MAY BE AN
C         EXPRESSION OF VARIABLES AND CONSTANTS. VARIABLE SPECIFICATIONS
C         MUST HAVE BEEN DEFINED IN A PARAMETER STATEMENT TO BE VALID,
C         AND THEY MAY NOT HAVE SUBSCRIPTS.
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT LOCERR NUMBER PARAEV STMT29 TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT37
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7   CGLEN, CLEN, CLENWK
      LOGICAL*1     LARITH, L1, L2, L3, L5
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALAN
     1CED SLASHES')
 101  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION EXCEEDS 1 DIGIT')
 102  FORMAT(' ISN:',I6,' LENGTH SPECIFICATION EQUALS ZERO')
 103  FORMAT(I7)
 104  FORMAT(' ISN:',I6,' LOGICAL LENGTH NOT EQUAL TO 1, 2, OR 4')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CTYPED(1:1) = CBLANK(1:1)
      CLEN(1:7) = CBLANK(1:7)
      CLENWK(1:7) = CBLANK(1:7)
      LEXEC =  LFALSE
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      LFORCE = LTRUE
C
C         VERIFY THIS IS A LOGICAL STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'LOGICAL') THEN
C
C         SCAN TO DETERMINE IF AN ARITHMETIC STATEMENT
C
         ID = 0
         LEXEC =  LTRUE
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) ID = ID + 1
         IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(ID .EQ. 0) THEN
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 21
            END IF
         END IF
 10      CONTINUE
C
C         THIS IS A LOGICAL STATEMENT
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         J = J + 1
 11      JA = J + 7
         JC = 0
         CTYPED(1:1) = CLL
C
C         WHEN THIS IS A LOGICAL STATEMENT, IT MUST OCCUR PRIOR TO THE
C         INITIAL EXECUTABLE STATEMENT. WRITE AN ERROR MESSAGE WHEN
C         THIS IS NOT TRUE.
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
C
C         DETERMINE IF AN ALPHABETIC CHARACTER FOLLOWS 'LOGICAL'. THIS
C         MEANS NO LENGTH SPECIFICATION EXISTS, AND A VARIABLE NAME
C         OR THE FUNCTION STATEMENT FOLLOWS. SET THE LENGTH
C         CHRACTERISTIC TO THE DEFAULT OF 4 FOR LOGICAL VARIABLES.
C
         I2WK1 = 0
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ) THEN
            I2WK1 = ICHAR(CSTMT(J:J)) - ICTN
         ELSE IF(CSTMT(J:J) .EQ. CUNDER) THEN
            I2WK1 = 27
         END IF
         IF(I2WK1 .NE. 0 .AND. CSTMT(J-1:J-1) .NE. COMMA) THEN
            CLEN(1:1) = C4(1:1)
            CGLEN(1:1) = C4(1:1)
C
C         DETERMINE IF THE ALPHABETIC CHARACTERS FOLLOWING LOGICAL
C         IS A FUNCTION STATEMENT OR A VARIABLE NAME
C
            IF(CSTMT(J:J+7) .EQ. 'FUNCTION') GO TO 17
            GO TO 19
         END IF
C
C         IF AN ASTERISK FOLLOWS 'LOGICAL', THEN THE LENGTH
C         SPECIFICATION FOLLOWS THE ASTERISK
C
         IF(CSTMT(J:J) .EQ. CASTER) THEN
C
C         INDICATE THIS IS NOT AN ARITHMETIC STATEMENT
C
            LEXEC =  LTRUE
            L3 = LTRUE
C
C         SET THE STARTING POSITION OF THE FIELD FOLLOWING THE ASTERISK
C
            JB = J + 1
C
C         DETERMINE IF A DIGIT FOLLOWS THE ASTERISK.
C
            IF(CSTMT(JB:JB) .GE. C0 .AND. CSTMT(JB:JB) .LE. C9) THEN
C
C         LOCATE THE END OF THE LENGTH DEFINITION NUMERICAL FIELD
C
               DO 12 I = JB,KB
               IF(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ .OR.
     1            CSTMT(I:I) .EQ. CUNDER) THEN
                  I4 = I - 1
                  CGLEN(1:I-JB) = CSTMT(JB:I4)
                  CLENWK(1:I-JB) = CSTMT(JB:I4)
                  CLEN(1:1) = CSTMT(JB:I4)
                  L2 = LTRUE
                  J = I
                  CALL NUMBER (CSTMT,L2,JB,II,FP,IFP)
                  IF(II .NE. 1 .AND. II .NE. 2 .AND. II .NE. 4 .AND.
     1               I-JB .GT. 1) THEN
                     WRITE (0,104) ISN
                     IREC0 = IREC0 + 1
                     CWORK(38:44) = C4//CBLANK(1:6)
                     CLEN(1:7) = CWORK(38:44)
                     II = 4
                  END IF
                  CALL INSERT (II)
                  GO TO 19
               END IF
 12            CONTINUE
            END IF
C
C         DETERMINE IF A LEFT PARENTHESIS FOLLOWS THE ASTERISK. THIS
C         MEANS THE LENGTH OF THE LOGICAL IS DEFINED AS AN EXPRESSION
C         OF DEFINED CONSTANTS IN PARAMETER STATEMENTS.
C
            IF(CSTMT(JB:JB) .EQ. CLPAR(1:1)) THEN
               LARITH = LFALSE
C
C         DETERMINE THE END OF THE LENGTH SPECIFICATION WHEN THE
C         SPECIFICATION IS ENCAPSULATED IN PARENTHESES
C
               DO 13 I = JB,KB
C
C         DETERMINE IF ANY ARITHMETIC OPERATOR OCCURS WITHIN THE LENGTH
C         SPECIFICATION
C
               IF(CSTMT(I:I) .EQ. CPLUS(1:1) .OR. CSTMT(I:I) .EQ.
     1            CMINUS(1:1) .OR. CSTMT(I:I) .EQ. CSLASH(1:1) .OR.
     2            CSTMT(I:I) .EQ. CASTER(1:1)) LARITH = LTRUE
C
C         THE OCCURENCE OF A COMMA OR THE FINAL CHARACTER OF THE
C         STATEMENT TERMINATES THE LENGTH SPECIFICATION
C
               IF(CSTMT(I:I) .EQ. COMMA(1:1)) JE = I - 2
               IF(CSTMT(I:I) .EQ. CLPAR(1:1)) I1 = I1 + 1
               IF(CSTMT(I:I) .EQ. CRPAR(1:1)) I1 = I1 - 1
               IF(I1 .EQ. 0) THEN
                  IF(I .EQ. KB) THEN
                     JE = I - 1
                  ELSE
                     JE = I
                  END IF
                  GO TO 14
               END IF
  13           CONTINUE
C
C         EITHER A NUMBER OR A VARIABLE NAME FOLLOWS THE LEFT
C         PARENTHESIS TO SPECIFY THE LENGTH
C
 14            J = JE + 1
               JB = JB + 1
               JE = JE - 1
C
C         WHEN A VARIABLE NAME IS SPECIFIED AS THE LENGTH OF A CHARACTER
C         VARIABLE, IT MUST HAVE BEEN PREVIOUSLY DEFINED IN A PARAMETER
C         STATEMENT. OTHERWISE, THIS DEFINTION IS AN ERROR.
C
C         DETERMINE IF AN EXPRESSION CASE; EITHER A VARIABLE NAME OR A
C         DIGIT MAY OCCUR FIRST
C
               IF(CSTMT(JB:JB) .GE. CAA .AND. CSTMT(JB:JB) .LE. CZZ .OR.
     1            CSTMT(JB:JB) .EQ. CUNDER .OR. CSTMT(JB:JB) .GE.
     2            C0(1:1) .AND. CSTMT(JB:JB) .LE. C9(1:1)) THEN
C
C         WHEN ARITHMETIC OPERATORS EXIST, AN EXPRESSION SPECIFIES THE
C         LENGTH OF THE CHARACTER VARIABLE BEING DEFINED
C
C                 IF(LARITH) THEN
                     CALL PARAEV (JB,JE,II)
C
C         CONVERT THE DETERMINED LENGTH TO TEXT FORMAT
C
                     CLEN(1:7) = CBLANK(1:7)
                     CWORK(37:37) = CTYPED(1:1)
                     IF(II .EQ. 0) THEN
                        WRITE (0,102) ISN
                        IREC0 = IREC0 + 1
C
C         WHEN THE LENGTH EVALUATES TO ZERO
C
                        CWORK(38:44) = C4//CBLANK(1:6)
                        CLEN(1:7) = CWORK(38:44)
                        II = 4
                        GO TO 17
                     ELSE
C
C         WHEN THE LENGTH IS NOT ZERO, CONVERT TO TEXT FORMAT
C
                        WRITE (CLENWK,103) II
                        DO 15 I = 1,7
                        I2WK1 = 8 - I
                        CLEN(I:I) = CLENWK(I2WK1:I2WK1)
 15                     CONTINUE
                        CLENWK(1:7) = CLEN(1:7)
                        L2 = LTRUE
                        J = JE + 1
                        IF(CSTMT(J:J) .EQ. CRPAR(1:1)) J = J + 1
                        GO TO 17
                     END IF
                  END IF
               END IF
C
C         LOCATE THE END OF THE NUMERICAL FIELD
C
               IF(CSTMT(JB:JB) .GE. C0(1:1) .AND. CSTMT(JB:JB) .LE.
     1            C9(1:1)) THEN
                  DO 16 I = JB,KB
                  IF(.NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE.
     1               C9)) THEN
                  IC = I - JB
                  ID = I - 1
                  IF(IC .GT. 1) THEN
                     IF(.NOT.LINCL) THEN
                        WRITE (0,101) ISN
                        IREC0 = IREC0 + 1
                     END IF
                     IC = 1
                     ID = JA
                  END IF
                  CLEN(1:IC) = CSTMT(JB:ID)
                  CLENWK(1:7) = CLEN(1:7)
C
C         DETERMINE IF THE LENGTH SPECIFICATION IS VALID FOR AN INTEGER
C
                  IF(.NOT.(CLEN(1:1) .EQ. C1 .OR. CLEN(1:1) .EQ. C2 .OR.
     1               CLEN(1:1) .EQ. C4)) THEN
                     WRITE (0,104) ISN
                     IREC0 = IREC0 + 1
                     CWORK(38:44) = C4//CBLANK(1:6)
                     CLEN(1:7) = CWORK(38:44)
                     CLENWK(1:7) = CLEN(1:7)
                  END IF
                  L2 = LTRUE
                  J = I
                  IF(CSTMT(JB-1:JB-1) .EQ. CLPAR(1:1)) J = J + 1
                  JA = J + 7
                  GO TO 17
               END IF
 16            CONTINUE
            END IF
         END IF
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
 17      IF(CSTMT(J:JA) .EQ. 'FUNCTION') THEN
            KF = J
            CALL STMT29 (CTYPED,CLEN)
            GO TO 21
         END IF
C
C         SCAN FOR SLASHES OCCURRING IN AN LOGICAL STATEMENT
C
         JC = 0
         DO 18 I = J,KB
         IF(CSTMT(I:I) .EQ. CSLASH) JC = JC + 1
C
C         DETERMINE IF AN ARITHMETIC STATEMENT
C
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            CTYPED(1:1) = CBLANK(1:1)
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 21
         END IF
 18      CONTINUE
         IF(MOD(JC,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IRET0 = IRET0 + 1
         END IF
C
C         PROCESS THE REMAINDER OF THE LOGICAL STATEMENT; THE
C         STATEMENT MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIFICATI0NS.
C         THE VALUE IN J IS THE LOCATION OF THE FIRST CHARACTER TO
C         BEGIN PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE INTEGER STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
 19      I1 = 0
         I2 = J
         I5 = 0
         I9 = 0
         I10 = 0
         DO 20 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I9 = I4
         END IF
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I10 = I4
         END IF
         IF(I1 .EQ. 0 .AND. CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS
C
         IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               I3 = I4
               IF(I5 .GT. 0) I2WK1 = I5
C
C         SET THE CORRECT LENGTH CHARACTERISTIC WHEN NO SPECIFIC VALUE
C         IS PROIVIDED FOR THE VARIABLE.
C
               IF(L2) CLEN(1:1) = CGLEN(1:1)
               LFORCE = LTRUE
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I9 .GT. 0 .AND. I10 .GT. 0) THEN
                  L5 = LTRUE
               ELSE
                  L5 = LFALSE
               END IF
               CALL TYPLST (CTYPED,CLEN,I2,I3,L5)
               IF(.NOT.L3) THEN
                  CLEN(1:7) = CGLEN(1:1)
               ELSE
                  CLEN(1:7) = CLENWK(1:7)
               END IF
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I4 .EQ. KB) GO TO 21
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                  J = I4 + 1
                  GO TO 11
               END IF
            END IF
         END IF
 20      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 21   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES NAMELIST STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBAR   - CHARACTER VARIABLE, THE CHARACTER: |
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 0
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN THE VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK;
C                  THE ISN IS NEGATIVE WHEN THE VARIABLE NAME IS THE
C                  COMMON BLOCK NAME, POSITIVE OTHERWISE
C         I1     - WORK AREA TO DETERMINE IF THE LOCATION OF THE END OF
C                  A VARIABLE NAME.
C         I2     - START LOCATION OF A VARIABLE NAME
C         I3     - SUBSCRIPT VARIABLE
C         I4     - SUBSCRIPT VARIABLE
C         I5     - LENGTH OF A VARIABLE NAME
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE END OF THE NAMELIST GROUP NAME
C         JB     - LENGTH OF THE NAMELIST GROUP NAME
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET BIT
C                  SWITCHES.
C         JC     - THE NUMBER OF NAMELIST GROUPS DEFINED IN THE CURRENT
C                  STATEMENT
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         L1       LOGICAL VARIABLE, SET TRUE WHEN THE END OF A VARIABLE
C                  NAME IS FOUND WITHIN A NAMELIST GROUP, SET FALSE
C                  OTHERWISE.
C         NA     - LOCATION OF THE ENDING SLASH OF A NAMELIST GROUP NAME
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C
C     COMMENTS
C
C         WHEN COLUMN 37 OF CWORK CONTAINS THE CHARACTER, |, THIS WILL
C         CAUSE THE PRINT ROUTINE FOR VARIABLE NAMES TO OMIT ANY LENGTH
C         AND TYPE CODES. THIS IS USED TO PREVENT THE NAMELIST GROUP
C         NAME BEING PROCESSED AS A NORMAL VARIABLE NAME.
C
C         THE NAMELIST GROUP NAME MAY NOT BE A COMPOOUND VARIABLE, BUT
C         THE VARIABLE NAMES WITHIN A GROUP MAY BE A COMPOUND VARIABLE.
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR IBSET LOCERR VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT38
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION JSTART(7), KDNUM(7), ICONTL(2,100)
      DIMENSION JMAP(20), MAPLEN(20,20)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*104 CWK104
      LOGICAL*1     L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /MUS/ JMAP, MAPLEN
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWORK(33:36),IWORK), (I2WK1,CI2WK1), (CWORK(45:48),
     1JBITS), (CWORK(49:52), IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWORK(9:12),JISN), (I4WK1,CI4WK1), (CWK8(2:2),CWK7),
     3(CSUBTB,JSUBTB)
      EQUIVALENCE (CWK104(33:36),ILEN), (CWK104(37:40),JNUM1),
     1(CWK104(41:68),KDNUM(1)), (CWK104(69:72),JSTART(1))
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NAMELIST GROUP NAME LACKS MATCHING SLASHES')
C
C         INITIALIZE WORK AREAS
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC =  LFALSE
C
C         VERIFY THE STATEMENT
C
      J = KF + 7
      IF(CSTMT(KF:J) .EQ. 'NAMELIST') THEN
C
C         SCAN FOR SLASHES OCCURRING IN A NAMELIST STATEMENT
C
         LEXEC =  LTRUE
         JC = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CSLASH) THEN
            JC = JC + 1
            GO TO 10
         END IF
C
C       SCAN FOR AN EQUAL SIGN; IF FOUND THEN THIS IS AN ARITHMETIC
C       STATEMENT.
C
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 15
         END IF
 10      CONTINUE
C
C         IF AN ODD NUMBER OF SLASHES OCCUR, A SYNTAX ERROR EXISTS
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         IF((JC .EQ. 0 .OR. MOD(JC,2) .GT. 0) .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         WRITE AN ERROR MESSAGE WHEN A NAMELIST STATEMENT OCCURS AFTER
C         THE INITIAL EXECUTABLE STATEMENT.
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
C
C         PROCESS THE NAMELIST STATEMEMT
C
         J = J + 1
C
C         COMPUTE THE NUMBER OF NAMELIST GROUPS OCCURRING IN THIS
C         STATEMENT
C
         JC = JC/2
C
C         PROCESS ALL NAMELIST GROUPS ON THIS STATEMENT
C
         DO 14 I3 = 1,JC
C
C         TEST IF THE FIRST NAME IS ENCAPSULATED IN SLASHES. WHEN
C         SLASHES EXIST, THE VARIABLE NAME IS THE GROUP NAME FOR THE
C         NAMELIST STATEMENT.
C
         IF(CSTMT(J:J) .EQ. CSLASH) THEN
C
C         FIND THE LIMIT OF THE NAMELIST GROUP NAME.
C
            J = J + 1
            DO 11 I = J,KB
            IF(CSTMT(I:I) .EQ. CSLASH) THEN
               JA = I - 1
               JB = I - J
               NA = I
               IVCNT = JB
               IWORK = ISN + 128
               CWORK(37:37) = CBAR(1:1)
               CWORK(1:JB) = CSTMT(J:JA)
               JBITS = IBSET(JBITS,12)
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C         SAVE THE NAMELIST GROUP NAME
C
               CALL CHKNME (CSTMT)
               J = JA + 1
               GO TO 12
            END IF
 11         CONTINUE
         END IF
C
C         PROCESS THE REMAINDER OF THE NAMELIST STATEMENT FOR THIS GROUP
C
C         SCAN TO FIND ALL THE VARIABLE NAMES SPECIFIED FOR THE CURRENT
C         NAMELIST GROUP NAME.  VARIABLE NAMES MAY BE COMPOUND NAMES.
C
 12      I1 = 0
C
C         RESET THE WORK AREA
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
C
C         SET THE START LOCATION OF THE FIRST VARIABLE NAME
C         NAME
C
         I2 = J
         L1 = LFALSE
         J = J + 1
C
C         LOOP FOR EACH VARIABLE NAME FOLLOWING THE NAMELIST GROUP
C         NAME OF THE CURRENT GROUP
C
         DO 13 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME PART OF A
C         THE CURRENT NAMELIST GROUP NAME DEFINITION. WHEN A COMMA
C         OCCURS, A SLASH MAY FOLLOW.
C
         IF(CSTMT(I4:I4) .EQ. COMMA .OR. CSTMT(I4:I4) .EQ. CSLASH) THEN
            I1 = I4 - 1
            I5 = I4 - I2
            L1 = LTRUE
         ELSE IF(I4 .EQ. KB) THEN
            I1 = KB
            I5 = I4 - I2 + 1
            L1 = LTRUE
         END IF
C
C         SET UP THE WORK AREA TO CATALOG THE VARIABLE NAME
C
         IF(L1) THEN
            CWORK(1:I3) = CSTMT(I2:I1)
            IWORK = ISN + 128
            IVCNT = I3
            JBITS = IBSET(JBITS,4)
            CALL VSETUP (I2,I1,I3,LFALSE,LFALSE,CSTMT)
         END IF
C
C         DETERMINE IF THE END OF A NAMELIST GROUP OF VARIABLE NAMES
C         HAS BEEN FOUND
C
         IF(CSTMT(I4:I4) .EQ. CSLASH) THEN
            J = I4 + 1
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            GO TO 14
         ELSE IF(L1) THEN
            J = I4 + 1
            GO TO 12
         END IF
 13      CONTINUE
 14      CONTINUE
C
C         ROUTINE EXIT
C
      END IF
 15   RETURN
      END
C
C    ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM PROCESSES THE OPEN STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VAARIABLE, THE LETTER: A
C         CASTER - CHARACTER VARIABLE, THE CHARACTER: *
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CF105  - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE
C                  INVALID ARGUMENT MESSAGE FOR AN OPEN STATEMENT
C         CII    - CHARACTER VAARIABLE, THE LETTER: I
C         CI2WK1 - CHARACTER VARIABLE, USED TO CONVERT INTEGER TO ASCII
C                  EQUIVALENCED TO I2WK1
C         CLPAR  - CHARACTER VARIABLE, THE CHARACTER: (
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, THE CHARACTER: )
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CUNDER - CHARACTER VAARIABLE, THE CHARACTER: _
C         CZZ    - CHARACTER VAARIABLE, THE LETTER: Z
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C         IARG   - COUNT OF THE NUMBER OF CONTROL ARGUMENTS; A MAXIMUM
C                  OF 27 ARE ALLOWED FOR AN OPEN STATEMENT.
C         ID     - INDEX VALUE OF THE ARGUMENT IN ARRAY CLIST TO BE
C                  PROCESSED IN SUBROUTINE CIOLST
C         IREC0  - THE NUMBER OF RECORDS ON UNIT 10
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IVCNT  - NUMBER OF CHARACTERS IN A VARIABLE NAME, EQUIVALENCED
C                  TO CWORK
C         I1     - COUNT OF THE NUMBER OF PARENTHESES. ONE IS ADDED WHEN
C                  A LEFT PARENTHESIS IS FOUND, ONE IS SUBTRACTED WHEN
C                  A RIGHT PARENTHESIS IS FOUND. ALSO USED AS A
C                  SUBSCRIPT.
C         I2     - START LOCATION OF AN ARGUMENT VALUE
C         I2WK1  - WORK AREA TO CONVERT INTEGER TO ASCII FOR CF105
C         I3     - END LOCATION OF AN ARGUMENT VALUE
C         I4     - WORK AREA
C         I5     - SUBSCRIPT VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JB     - LOCATION OF THE END OF AN ARGUMENT RETURNED FROM
C                  SUBPROGRAM CIOLST
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE IN SUBROUTINE CIOLST WHEN
C                  A COMMAND LIST ARGUMENT MATCH IS FOUND AND PROCESSED,
C                  SET FALSE OTHERWISE; SKIPS FURTHER PROCESSING IN THE
C                  CURRENT ARGUMENT, AND FORCES PROCESSING OF THE NEXT
C                  ARGUMENT.
C         LB     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT IS FOUND
C                  AND PROCESSED, SET FALSE OTHERWISE; PREVENTS
C                  PROCESSING OF A DUPLICATE ARGUMENT.
C         LBB    - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMSNT IS FOUND
C                  AND PROCESSED, SET FALSE OTHERWISE
C         LERR   - LOGICAL VARIABLE, SET TRUE WHEN A CONTROL LIST VALUE
C                  IS INVALID, SET FALSE OTHERWISE
C         LEXEC  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A LITERAL, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A VARIABLE, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A NUMERICAL CONSTANT, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  MAY BE A STATEMENT NUMBER, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN AN ARGUMENT VALUE
C                  IS A FILE, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN EITHER A LEFT OR
C                  RIGHT PARENTHESIS EXISTS WITHIN THE STATEMENT, SET
C                  FALSE OTHERWISE. THIS IS USED TO DETERMINE IF TEXT
C                  AT THE BEGINNING OF THE STATEMENT USES SOME FORM
C                  FORM OF OPEN AS THE FIRST FOUR CHARACTERS.
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ARGUMENT
C                  CONTAINS AN EQUAL SIGN, SET FALSE OTHERWISE.
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN A UNIT NUMBER ONLY
C                  EXISTS AND NO OTHER ARGUMENTS ARE SPECIFICED, SET
C                  FALSE OTHERWISE.
C
C     COMMENTS
C
C         THE OPEN STATEMENT MAY HAVE THE FOLLOWING CONTROL LIST
C         PARAMETERS:
C         ACCESS, ASSOCIATEVARIAB, ASSOCIATEVARIABLE, BLANK, BLOCKSIZE,
C         BUFFERCOUNT, CARIAGECONTROL, DISP, DISPOSE, ERR, EXTENDSIZE,
C         FILE, FORM, INITIALSIZE, IOSTAT, KEY, MODE, NAME,
C         ORGANIZATION, READONLY, RECL, RECORDSIZE, RECORDTYPE, SHARE,
C         SHARED, STATUS, TYPE, USEROPEN
C
C         THE KEY PARAMETER IN AN OPEN STATEMENT CONTROL LIST IS
C         ACCEPTED BUT IS NOT PROCESSED. IT PERTAINS TO INDEXED
C         SEQUENTIAL ORGANIZED FILES THAT ARE RARELY USED IN FORTRAN.
C
C         FORTRAN PROGRAMS WRITTEN FOR DEC COMPUTERS MAY USE THE
C         VARIANT OF SHARE WITHOUT ANY ARGUMENTS IN AN OPEN STATEMENT.
C         THIS WILL APPEAR AS: SHARE INSTEAD OF: SHARE=ARGUMENT. THE
C         NONSTANDARD FORM IS ACCEPTED AND WILL NOT CAUSE A MESSAGE.
C
C         A DEFAULT UNIT, i.e. AN ASTERISK, CAN NOT BE USED TO DESIGNATE
C         AN INPUT - OUTPUT UNIT
C
C     SUBROUTINES CALLED
C
C         CHKNME CIOLST CUNIT EXPR IBSET CIOLST
C
C     ******************************************************************
C
      SUBROUTINE STMT39
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION LB(30), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*50    CF105
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA, LB, LBB, LERR, L1, L2, L3, L4, L5, L6, L7, L8
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ARG/ ID, LBB, L1, L2, L3, L4, LA
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CF105/'('' ISN:'',I6,'' OPEN HAS AN INVALID ARGUMENT: '',AXX)
     1'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' USE OF UNIT ''*'' NOT ALLOWED IN OPEN')
 101  FORMAT(' ISN:',I6,' OPEN HAS INSUFFICIENT ARGUMENTS')
 102  FORMAT(' ISN:',I6,' OPEN SPECIFIES A DUPLICATE ARGUMENT')
 103  FORMAT(' ISN:',I6,' OPEN LACKS LEFT PARENTHESIS')
 104  FORMAT(' ISN:',I6,' OPEN LACKS RIGHT PARENTHESIS')
C
C         INITIALIZATION
C
      LA = LFALSE
      L5 = LFALSE
      L6 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      DO 10 I = 1,30
      LB(I) = LFALSE
 10   CONTINUE
C
C         VERIFY THIS IS AN OPEN STATEMENT
C
      J = KF + 3
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'OPEN') THEN
         J = J + 1
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION
C
C        IF(CSTMT(J:J) .EQ. CLPAR) THEN
            I1 = 0
            DO 11 I = J,KB
            IF(CSTMT(I:I) .EQ. CLPAR) THEN
               I1 = I1 + 1
               I4 = I
               L6 = LTRUE
            END IF
            IF(CSTMT(I:I) .EQ. CRPAR) THEN
               I1 = I1 - 1
               I4 = I
               L6 = LTRUE
            END IF
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               IF(L6) THEN
                  IF(I1 .EQ. 0) THEN
                     IF(I4 .EQ. 0) THEN
                        CALL EXPR (KF,KB,LFALSE,CSTMT)
                        LEXEC = LTRUE
                        GO TO 19
                     END IF
                  END IF
               ELSE
                  CALL EXPR (KF,KB,LFALSE,CSTMT)
                  LEXEC = LTRUE
                  GO TO 19
               END IF
            END IF
 11         CONTINUE
C        END IF
C
C         DETERMINE IF A LEFT PARENTHESIS FOLLOWS
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
C
C         DETERMINE IF OPEN HAS ANY ARGUMENTS
C
            J = J + 1
            IF(J .GE. KB) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               GO TO 19
            END IF
         ELSE
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS ENDS THE STATEMENT
C
         IF(CSTMT(KB:KB) .NE. CRPAR) THEN
            WRITE (0,104) ISN
            IREC0 = IREC0 + 1
            GO TO 15
         END IF
C
C         SET SWITCH TO INDICATE THE CURRENT STATEMENT IS NOT AN
C         ARITHMETIC STATEMENT
C
         LEXEC = LTRUE
         IARG = 1
C
C         BEGIN PROCESSING OPEN CONTROL OPTIONS LIST
C
 12      IA = 0
         I1 = 0
         LA = LFALSE
         L1 = LFALSE
         L2 = LFALSE
         L3 = LFALSE
         L4 = LFALSE
         IF(L5) GO TO 15
C
C     *****************************************************************
C     *                                                               *
C     *          PROCESS ALL CONTROL LIST PARAMETERS                  *
C     *                                                               *
C     *****************************************************************
C
C         WHEN THE FIRST ARGUMENT CONTAINS AN EQUAL SIGN, THE UNIT
C         SPECIFICATION WITHOUT UNIT= IS NOT PROVIDED. SEARCH FOR AN
C         EQUAL SIGN IN THE FIRST ARGUMENT.
C
         DO 13 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) L7 = LTRUE
         IF(CSTMT(I:I) .EQ. CLPAR .OR. CSTMT(I:I) .EQ. COMMA) THEN
            I3 = I
            GO TO 14
         END IF
 13      CONTINUE
C
C         WHEN AN EQUAL SIGN IS ABSENT IN THE FIRST ARGUMENT, THE
C         ARGUMENT IS A UNIT SPECIFICATION WITHOUT THE UNIT=
C         ARGUMENT, AND IT MUST BE THE FIRST ARGUMENT.
C
 14      IF(.NOT.L7) THEN
C
C         DETERMINE IF AN ASTERISK IS USED AS UNIT DESIGNATION.
C
            IF(CSTMT(J:J) .EQ. CASTER) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
               IF(CSTMT(I3:I3) .EQ. COMMA) THEN
                  J = I3 + 1
                  GO TO 15
               ELSE
                  GO TO 19
               END IF
            END IF
C
C         DETERMINE IF THE UNIT IS A NUMBER
C
            IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
C
C         DETERMINE THE END LOCATION OF THE UNIT NUMERIC FIELD
C
               DO I = J,KB
               IF(.NOT.(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9))
     1            THEN
C
C         WHEN THE FIRST CHARACTER FOLLOWING THE INITAL NUMERIC
C         CHARACTER IS A RIGHT PARENTHESIS AND IS THE FINAL CHARACTER
C         OF THE STATEMENT, NO OTHER PARAMETERS ARE SPECIFIED. SET THE
C         L8 SWITCH TO INDICATE THIS.
C
                  IF(CSTMT(I:I) .EQ. CRPAR .AND. I .EQ. KB) L8 = LTRUE
               END IF
               END DO
               CALL CUNIT
               IF(L8) GO TO 19
               J = I3 + 1
               GO TO 15
            END IF
C
C         DETERMINE IF THE UNIT IS A VARIABLE NAME
C
            IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1         CSTMT(J:J) .EQ. CUNDER) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               IVCNT = I3 - J
               CWORK(1:IVCNT) = CSTMT(J:I3-1)
               JBITS = IBSET(JBITS,7)
               CWORK(37:37) = CII(1:1)
               CALL VSETUP (J,I3-1,IVCNT,LFALSE,LFALSE,CSTMT)
               J = I3
            END IF
            L5 = LTRUE
            LB(29) = LTRUE
         END IF
C
C         PROCESS ALL REMAINING PARAMETERS
C
C
C         DETERMINE IF ANY LEFT OR RIGHT PARENTHESES, COLON, COMMA,
C         OR A LITERAL MUST BE SKIPPED OVER
C
 15      IF(CSTMT(J:J) .EQ. CLPAR .OR. CSTMT(J:J) .EQ. CRPAR .OR.
     1      CSTMT(J:J) .EQ. COLON .OR. CSTMT(J:J) .EQ. COMMA .OR.
     2      CSTMT(J:J) .EQ. CSYMCF) THEN
            J = J + 1
            IF(J .GE. KB) GO TO 19
            GO TO 15
         END IF
C
C         DETERMINE IF THE END OF THE STATEMENT HAS OCCURRED
C
         IF(J .GE. KB) GO TO 19
C
C         LOOP TO LOCATE INPUT-OUTPUT COMMANDS LIST ARGUMENTS
C
         LERR = LFALSE
         DO 18 I = J,KB
C
C         SKIP OVER ANY LITERAL ARGUMENT VALUES
C
         IF(CSTMT(I:I) .EQ. CSYMCF) GO TO 18
C
C         DETERMINE THE ARGUMENT NAME
C
         IF(CSTMT(J:J+6) .EQ. 'ACCESS=') THEN
            I2 = J + 7
            ID = 1
            IARG = 1
C           IF(CSTMT(J+7) .NE. CAPOS)
         ELSE IF(CSTMT(J:J+6) .EQ. 'ACTION=') THEN
            I2 = J + 7
            ID = 2
            IARG = 2
         ELSE IF(CSTMT(J:J+15) .EQ. 'ASSOCIATEVARIAB=') THEN
            I2 = J + 16
            ID = 3
            IARG = 3
         ELSE IF(CSTMT(J:J+17) .EQ. 'ASSOCIATEVARIABLE=') THEN
            I2 = J + 18
            ID = 3
            IARG = 4
         ELSE IF(CSTMT(J:J+5) .EQ. 'BLANK=') THEN
            I2 = J + 6
            ID = 5
            IARG = 5
         ELSE IF(CSTMT(J:J+9) .EQ. 'BLOCKSIZE=') THEN
            I2 = J + 10
            ID = 6
            IARG = 6
         ELSE IF(CSTMT(J:J+11) .EQ. 'BUFFERCOUNT=') THEN
            I2 = J + 12
            ID = 7
            IARG = 7
         ELSE IF(CSTMT(J:J+15) .EQ. 'CARRIAGECONTROL=') THEN
            I2 = J + 16
            ID = 8
            IARG = 8
         ELSE IF(CSTMT(J:J+7) .EQ. 'DISPOSE=' .OR. CSTMT(J:J+4) .EQ.
     1        'DISP=') THEN
            IF(CSTMT(J:J+4) .EQ. 'DISP=') THEN
               I2 = J + 5
            ELSE
               I2 = J + 8
            END IF
            IF(CSTMT(I2:I2) .EQ. CSYMCF) THEN
               J = I2 + 1
               GO TO 15
            END IF
            ID = 11
            IARG = 9
         ELSE IF(CSTMT(J:J+3) .EQ. 'ERR=') THEN
            I2 = J + 4
            ID = 13
            IARG = 10
         ELSE IF(CSTMT(J:J+10) .EQ. 'EXTENDSIZE=') THEN
            I2 = J + 11
            ID = 15
            IARG = 11
         ELSE IF(CSTMT(J:J+4) .EQ.'FILE=') THEN
            I2 = J + 5
            ID = 16
            IARG = 12
         ELSE IF(CSTMT(J:J+4) .EQ. 'FORM=') THEN
            I2 = J + 5
            ID = 18
            IARG = 13
         ELSE IF(CSTMT(J:J+11) .EQ. 'INITIALSIZE=') THEN
            I2 = J + 12
            ID = 20
            IARG = 14
         ELSE IF(CSTMT(J:J+6) .EQ. 'IOSTAT=') THEN
            I2 = J + 7
            ID = 21
            IARG = 15
         ELSE IF(CSTMT(J:J+3) .EQ. 'KEY=') THEN
            I2 = J + 4
            ID = 22
            IARG = 16
         ELSE IF(CSTMT(J:J+4) .EQ. 'MODE=') THEN
            I2 = J + 5
            ID = 24
            IARG = 17
         ELSE IF(CSTMT(J:J+4) .EQ. 'NAME=') THEN
            I2 = J + 5
            ID = 25
            IARG = 18
         ELSE IF(CSTMT(J:J+11) .EQ. 'NOSPANBLOCKS') THEN
            I2 = J + 12
            ID = 29
            IARG = 19
         ELSE IF(CSTMT(J:J+12) .EQ. 'ORGANIZATION=') THEN
            I2 = J + 13
            ID = 32
            IARG = 20
         ELSE IF(CSTMT(J:J+7) .EQ. 'READONLY') THEN
            I2 = J + 8
            ID = 33
            IARG = 21
            J = J + 8
            GO TO 15
         ELSE IF(CSTMT(J:J+4) .EQ. 'RECL=') THEN
            I2 = J + 5
            ID = 35
            IARG = 22
         ELSE IF(CSTMT(J:J+10) .EQ. 'RECORDSIZE=') THEN
            I2 = J + 11
            ID = 36
            IARG = 23
         ELSE IF(CSTMT(J:J+10) .EQ. 'RECORDTYPE=') THEN
            I2 = J + 11
            ID = 37
            IARG = 24
         ELSE IF(CSTMT(J:J+5) .EQ. 'SHARE=') THEN
            I2 = J + 6
            ID = 39
            IARG = 25
         ELSE IF(CSTMT(J:J+5) .EQ. 'SHARED') THEN
            I2 = J + 6
            J = I2
            ID = 40
            IARG = 26
            GO TO 15
         ELSE IF(CSTMT(J:J+6) .EQ. 'STATUS=') THEN
            I2 = J + 7
            ID = 41
            IARG = 27
         ELSE IF(CSTMT(J:J+4) .EQ. 'TYPE=') THEN
            I2 = J + 5
            ID = 42
            IARG = 28
         ELSE IF(CSTMT(J:J+4) .EQ. 'UNIT=') THEN
            I2 = J + 5
            IARG = 29
            CALL CUNIT
            L5 = LTRUE
            LB(IARG) = LTRUE
            J = J + 1
            GO TO 12
         ELSE IF(CSTMT(J:J+8) .EQ. 'USEROPEN=') THEN
            I2 = J + 9
            ID = 45
            IARG = 30
            LB(IARG) = LTRUE
            CWORK(1:52) = CBLK52(1:52)
            JBITS = 0
            DO 16 I3 = I2,KB
            IF(CSTMT(I3:I3) .EQ. COMMA .OR. CSTMT(I3:I3) .EQ. CRPAR)
     1         THEN
               IVCNT = I3 - I2
               GO TO 17
            END IF
 16         CONTINUE
 17         IWORK = ISN + 128
            CWORK(1:IVCNT) = CSTMT(I2:I3)
            JBITS = IBSET(JBITS,7)
            JBITS = IBSET(JBITS,10)
            CALL CHKNME (CSTMT)
            J = I3  + 1
            GO TO 12
         ELSE
C
C         INVALID ARGUMENT EXISTS; LOCATE THE COMMA OR RIGHT PARENTHESIS
C         THAT TERMINATES A PARAMETER FIELD.
C
            DO 170 I5 = J,KB
            IF(CSTMT(I5:I5) .EQ. COMMA .OR. CSTMT(I5:I5) .EQ. CRPAR)
     1         THEN
C
C         DO NOT TREAT A LITERAL VALUE FOR THE ARGUMENT AS AN ERROR
C
               IF(CSTMT(I5-1:I5-1) .EQ. CSYMCF) GO TO 18
C
C         WRITE THE ERROR MESSAGE
C
               I3 = I5
               IF(.NOT.L5) GO TO 171
            END IF
 170        CONTINUE
C
C         CREATE THE FORMAT STATEMENT TO WRITE AN ERROR MESSAGE
C
 171        I4 = I3 - J
            CI2WK1(1:2) = CBLANK(1:2)
            WRITE (CI2WK1,'(I2)') I4
            IF(I4 .LT. 10) THEN
               CF105(48:49) = CI2WK1(2:2)//CBLANK(1:1)
            ELSE
               CF105(48:49) = CI2WK1(1:2)
            END IF
            WRITE (0,CF105) ISN,CSTMT(J:I3)
            IREC0 = IREC0 + 1
            J = I3 + 1
            GO TO 15
         END IF
C
C         DETERMINE IF THE ARGUMENT IS A VARIABLE NAME
C
         IF(CSTMT(I2:I2) .GE. CAA .AND. CSTMT(I2:I2) .LE. CZZ .OR.
     1      CSTMT(I2:I2) .EQ. CUNDER) THEN
            IF(ID .EQ. 11 .OR. ID .EQ. 12) THEN
               L2 = LFALSE
               L4 = LTRUE
            ELSE
               L2 = LTRUE
               L4 = LFALSE
            END IF
            L1 = LFALSE
            L3 = LFALSE
            JBITS = IBSET(JBITS,7)
C
C         DETERMINE IF THE ARGUMENT IS A LITERAL
C
         ELSE IF(CSTMT(I2:I2) .EQ. CSYMCF) THEN
            L1 = LTRUE
            L2 = LFALSE
            L3 = LFALSE
            L4 = LFALSE
C
C         DETERMINE IF THE ARGUMENT IS A NUMBER
C
         ELSE IF(CSTMT(I2:I2) .GE. C0 .AND. CSTMT(I2:I2) .LE. C9) THEN
C
C     DETERMINE IF THE NUMBER IS A STATEMENT NUMBER
C
            L1 = LFALSE
            L2 = LFALSE
            IF(ID .EQ. 12) THEN
               L3 = LFALSE
               L4 = LTRUE
            ELSE
               L3 = LTRUE
               L4 = LFALSE
            END IF
         END IF
C
C         CHECK FOR DUPLICATE ARGUMENTS
C
         IF(LB(IARG)) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         SET THE LOGICAL SWITCH TO PREVENT A DUPLICATE ARGUMENT
C
         LB(IARG) = LTRUE
         LBB = LTRUE
         CALL CIOLST
C
C         ROUTINE CIOLST SETS J TO THE START LOCATION OF THE NEXT
C         ARGUMENT
C
         IF(I1 .GE. KB) THEN
            GO TO 19
         ELSE
            IF(I2. GE. J) J = I2 + 2
            IF(CSTMT(JB:JB) .EQ. COMMA) JB = JB + 1
            IF(J .LT. JB) J = JB
            IF(J .GE. KB .OR. J + 1 .GE. KB) GO TO 19
            GO TO 12
         END IF
 18      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 19   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE PARAMETER STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THESE CODES AND THEIR MEANINGS ARE:
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - M: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI2WK1 - CHARACTER VARIABLE, USED TO CONVERT THE INITIAL
C                  CHARACTER OF A VARIABLE NAME INTO AN INDEX VALUE
C                  FOR TABLE CIMPL. EQUIVALENCED WITH I2WK1.
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 CONTAINS THE FOLLOWING CODES TO INDICATE
C                  DATA TYPE
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CPARAM - CHARACTER VARIABLE, ARRAY OF PARAMETER VARIABLES
C                  TOTAL LENGTH IS 52 CHARACTERS AND A MAXIMUM OF 1000
C                  PARAMETER STATEMENTS IN A ROUTINE ARE ALLOWED
C
C                  RECORD STRUCTURE:
C                  COLS.     DESCRIPTION
C                  1  - 32   VARIABLE NAME
C                  33 - 36   ISN VALUE
C                  37 - 44   DATA TYPE & LENGTH
C                  45 - 48   NUMERIC VALUE OF INTEGER VARIABLES ONLY
C                            OTHER DATA TYPES LEAVE THIS FIELD BLANK
C                  49 - 52   LENGTH OF THE VARIABLE NAME IN COLS 1 - 32
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         CWK52  - CHARACTER VARIABLE, WORK AREA TO CREATE THE PARAMETER
C                  INTEGER TABLE ENTRY BEING ANALYZED. THE RECORD
C                  STRUCTURE IS THE SAME AS CNAME
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE, THE LOCATION OF THE FIRST CHAR-
C                  AFTER AFTER AN EQUAL SIGN
C         IARG   - THE VALUE OF THE PARAMETER VALUE TO BE SAVED IN TABLE
C                  CPARAM. IT IS EQUIVALENCED TO CWK52(45:48)
C         ICTN   - THE VALUE TO ADD TO AN ALPHABETIC NONNUMERIC
C                  CHARACTER TO CONVERT IT TO AN ALGEBRAIC NUMERIC VALUE
C         ID     - WORK VARIABLE, ONE IS ADDED WHEN A LEFT PARENTHSIS
C                  IS FOUND, ONE IS SUBTRACTED WHEN A RIGHT PARENTHESIS
C                  IS FOUND
C         IDXE   - INDEX VALUE TO PLACE THE INITIAL CHARACTER OF A
C                  VARIABLE NAME.
C         IEQ    - COUNT OF THE NUMBER OF EQUAL SIGNS IN THE STATEMENT.
C                  THIS IS USED TO DETECT A CASE WHERE NO PARENTHESES
C                  EXIST IN THE PARMAETER STATEMENT.
C         INAME  - NUMBER OF NAMES IN THE MASTER TABLE OF VARIABLE NAMES
C         IP     - COUNT OF THE NUMBER OF ENTRIES IN THE TABLE OF
C                  INTEGER PARAMETER DEFINITIONS
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IRET   - RETURN CODE OF TABLE SEARCH; >0 MATCH FOUND, CONTAINS
C                  TABLE INDEX OF MATCH, <0 NO MATCH FOUND, POSITIVE
C                  VALUE OF IRET IS WHERE THE NO MATCH COULD BE INSERTED
C         IRET1  - RETURN CODE OF TABLE SEARCH; >0 MATCH FOUND, CONTAINS
C                  TABLE INDEX OF MATCH, <0 NO MATCH FOUND, POSITIVE
C                  VALUE OF IRET1 IS WHERE THE NO MATCH COULD BE
C                  INSERTED
C         ISN    - INTERNAL STATEMENT NUMBER FOR THE CURRENT STATEMENT
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I1     - LOCATION OF THE EQUAL SIGN
C         I2     - LOCATION OF THE LAST CHARACTER BEFORE A COMMA OR A
C                  RIGHT PARENTHESIS
C         I2WK1  - USED TO CONVERT THE INITIAL CHARACTER OF A VARIABLE
C                  NAME INTO AN INDEX VALUE FOR TABLE CIMPL.
C                  EQUIVALENCED  WITH CI2WK1.
C         I3     - WORK AREA
C         I4     - LOCATION OF THE CHARACTER LEFT IF THE PARENTHESIS
C                  FOLLOWING THE PARAMETER STATEMENT
C         I5     - WORK AREA USED AS A SUBSCRIPT
C         I6     - WORK AREA USED TO COMPUTE BALANCING PARENTHESES WHEN
C                  AN EXPRESSION DEFINED THE PARAMETER VALUE
C                  SUBROUTINE PARAEV
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JARG   - THE VALUE OF THE PARAMETER VALUE RETURNED FROM
C         JB     - SAVE AREA FOR THE VALUE OF KB WHEN ROUTINE EXPR IS
C                  CALLED
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         JD     - LOCATION OF THE LAST CHARACTER BEFORE A COMMA OR A
C                  RIGHT PARENTHESIS
C         JWORK  - THE ISN FIELD IN CWK52. EQUIVALENCED TO CWK52(33:36).
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KVCNT  - LENGTH OF THE VARIABLE NAME IN CWK52. EQUIVALENCED
C                  TO CWK52
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LPARAM - LOGICAL VARIABLE, SET TRUE WHEN A PARAMETER STATEMENT
C                  IS BEING PROCESSED, SET FALSE OTHERWISE. THIS SWITCH
C                  IS USED TO SAVE THE VALUES OF ALL INTEGER PARAMETER
C                  DEFINITIONS IN CASE THE INTEGER PARAMETER VARIABLE
C                  IS USED AS A DIMENSION SIZE OR A CHARACTER LENGTH
C                  SPECIFICATION.
C         LPAREN - LOGICAL VARIABLE, SET TRUE WHEN A PARAMETER STATEMENT
C                  HAS A BALANCED NUMBER OF LEFT AND RIGHT PARENTHESES,
C                  SET FALSE OTHERWISE.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN OCCURS
C                  IN THE STATEMENT AND IT IS ENCLOSED WITHIN
C                  PARENTHESES, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         A STRUCTURE COMPOUND VARIABLE NAME CAN NOT BE USED IN A
C         PARAMETER STATEMENT, BUT AN INTRINSIC FUNCTION THAT CREATES
C         A NUMERICAL VALUE MAY BE USED TO SET A PARAMETER VARIABLE'S
C         VALUE.
C
C         THE FORM OF A VARIABLE NAME AND THE SEQUENCE OF ITS POSSIBLE
C         SPECIFICATIONS IS AS SHOWN BELOW:
C
C         [NAME] [VALUE]
C
C         THE [VALUE] SPECIFICATION MAY BE AN EXPRESSION
C
C         PARAMETER IS NOT AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR IBCLR IBSET LOCERR PARAEV SETTL TABINS TABSRH
C
C     *****************************************************************
C
      SUBROUTINE STMT41
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK, CWK52
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWK52(33:36),JWORK), (CWK52(45:48),IARG), (CNAME(1),
     2IENAME(1,1)), (CWK52(49:52),KVCNT), (CWK8(2:2),CWK7),
     3(CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' PARAMETER STATEMENT LACKS PARENTHESES')
 101  FORMAT(' ISN:',I6,' PARAMETER STATEMENT LACKS AN EQUAL SIGN')
 102  FORMAT(' ISN:',I6,' MORE THAN 4000 INTEGER PARAMETER DEFINITIONS')
 103  FORMAT(' ISN:',I6,' PARAMETER STATEMENT LACKS A LEFT PARENTHESES')
C
C         BLANK CHARACTER WORK AREA
C
      IEQ = 0
      I1 = 0
      I3 = 0
      I5 = 0
      JBITS = 0
      LEXEC = LFALSE
C
C         VERIFY THIS IS A PARAMETER STATEMENT
C
      J = KF + 8
      LPAREN = LFALSE
      IF(CSTMT(KF:J) .EQ. 'PARAMETER') THEN
         J = J + 1
         ID = 0
         LEXEC = LTRUE
C
C         AN ARITHMETIC STATEMENT EXISTS WHEN AN EQUAL SIGN IS NOT
C         ENCAPSULATED BETWEEN MATCHING PARENTHESES
C
         DO 10 I = J,KB
C
C         COUNT THE PARENTHESES
C
         IF(CSTMT(I:I) .EQ. CLPAR) THEN
            ID = ID + 1
            IF(I3 .EQ. 0) I3 = I
         END IF
         IF(CSTMT(I:I) .EQ. CRPAR) THEN
            ID = ID - 1
            I5 = I
         END IF
C
C         COUNT THE EQUAL SIGNS
C
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IEQ = IEQ + 1
            I1 = I
         END IF
 10      CONTINUE
C
C         DETERMINE IF UNBALANCED PARENTHESES EXIST
C
         IF(ID .NE. 0) THEN
            LPAREN = LFALSE
            GO TO 11
         ELSE
C
C         DETERMINE IF MORE THAN ONE EQUAL SIGN OCCURS. THIS INDICATES
C         THE STATEMENT IS A PARAMETER STATEMENT OF AN OLDER FORM WHICH
C         DID NOT USE PARENTHESES.
C
            IF(IEQ .GT. 1) THEN
C
C         DETERMINE IF THE FIRST CHARACTER AFTER PARAMETER IS A LEFT
C         PARENTHESIS AND THE FINAL CHARACTER OF THE STATEMENT IS A
C         RIGHT PARENTHESIS.
C
C              IF(CSTMT(10:10) .EQ. CRPAR .AND. CSTMT(KB:KB) .EQ. CLPAR)
C    1            GO TO 11
               IF(I3 .EQ. 0 .AND. I5 .EQ. 0) GO TO 11
               IF(I3 .GT. 0 .AND. I5 .EQ. 0) GO TO 11
               IF(I3 .EQ. 0 .AND. I5 .GT. 0) GO TO 11
            END IF
            LPAREN = LTRUE
         END IF
C
C         THIS IS AN ARITHMETIC STATEMENT WHEN THE EQUAL SIGN DOES NOT
C         OCCUR WITHIN ENCAPULATING PARENTHESES
C
         IF(.NOT.(I1 .GT. I3 .AND. I1 .LT. I5)) THEN
            IF(LPAREN) THEN
               IF(CSTMT(I1:I1) .EQ. CEQ) THEN
                  LEXEC = LTRUE
                  LSTART = LTRUE
                  CALL EXPR (KF,KB,LFALSE,CSTMT)
                  GO TO 16
               END IF
            END IF
         END IF
C
C         SET THE LPARAM SWITCH TO INDICATE A PARAMETER STATEMENT IS
C         BEING PROCESSED
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         LPARAM = LTRUE
C
C         DETERMINE IF THE LEFT PARENTHESIS IS MISSING WHEN MULTIPLE
C         EQUAL SIGNS EXISTS IN THE STATEMENT
C
 11      IF(ID .GT. 0 .AND. CSTMT(10:10) .NE. CRPAR) THEN
            IF(LPAREN) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
         END IF
C
C         TEST FOR A LEFT PARENTHESIS
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            J = J + 1
C
C         SCAN FOR A COMMA OR A BALANCED RIGHT PARENTHESIS
C
 12         L1 = LFALSE
            I4 = J
            I6 = 1
            DO 14 I = J,KB
C
C         TEST FOR AN EQUAL SIGN
C
            IF(CSTMT(I:I) .EQ. CEQ) THEN
               L1 = LTRUE
               I1 = I
            END IF
C
C         COUNT PARENTHESES
C
            IF(CSTMT(I:I) .EQ. CLPAR) I6 = I6 + 1
            IF(CSTMT(I:I) .EQ. CRPAR) I6 = I6 - 1
C
C         TEST FOR A COMMA TERMINATING THE DEFINITION OF A SINGLE
C         VARIABLE PARAMETER DEFINITION
C
            IF(CSTMT(I:I) .EQ. COMMA) THEN
               JD = I - 1
               I2 = JD
C
C         WHEN A COMMA IS FOUND, DETERMINE IF ANOTHER NUMBER FOLLOWS
C         THE COMMA. THIS MEANS IT IS PROBABLY A COMPLEX SPECIFICATION.
C
               I4WK1 = I + 1
               IF(CSTMT(I4WK1:I4WK1) .GE. C0 .AND. CSTMT(I4WK1:I4WK1)
     1            .LE. C9) THEN
                  DO 13 I3 = I4WK1,KB
                  IF(CSTMT(I3:I3) .EQ. CRPAR(1:1)) JD = I3
 13               CONTINUE
               END IF
               GO TO 15
            END IF
C
C         TEST FOR A RIGHT PARENTHESIS THAT MAY TERMINATE THE DEFINITION
C         OF A SINGLE VARIABLE PARAMETER DEFINITION
C
            IF(CSTMT(I:I) .EQ. CRPAR) THEN
C
C         WHEN THE LEFT AND RIGHT PARENTHESES MATCH, THEN THE RIGHT
C         PARENTHESIS IS THE TERMINATION OF A PARAMETER DEFINITION.
C         OTHERWISE, THE RIGHT PARENTHESIS IS PART OF AN EXPRESSION
C         DEFINING THE VALUE FOR THE PARAMETER VARIABLE, AND A COMMA
C         OR ANOTHER RIGHT PARENTHESIS MUST TERMINATE THE VARIABLE
C         DEFINITION.
C
               IF(I6 .EQ. 0) THEN
                  JD = I - 1
                  I2 = JD
                  GO TO 15
               END IF
            END IF
 14         CONTINUE
C
C         NO COMMA OR RIGHT PARENTHESIS FOUND, WRITE ERROR MESSAGE
C
            IF(.NOT.LINCL) THEN
               WRITE (0,100) ISN
               IREC0 = IREC0 + 1
            END IF
C
C         WRITE ERROR MESSAGE IF NO EQUAL SIGN FOUND FOR THIS ARGUMENT
C
 15         IF(.NOT.L1 .AND. .NOT.LINCL) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
            END IF
C
C         THE LIMITS OF THE PARAMETER EXPRESSION ARE KNOWN. PROCESS ONE
C         PARAMETER SPECIFICATION. THE CALL TO EXPR DOES NOT EVALUATE
C         THE VALUE OF AN EXPRESSION SPECIFYING THE PARAMETER VALUE.
C
            LEXEC = LTRUE
            JB = KB
            JBITS = IBSET(JBITS,14)
            IF(LSTART) THEN
               CALL EXPR(J,JD,LFALSE,CSTMT)
            ELSE
               LSTART = LTRUE
               CALL EXPR(J,JD,LFALSE,CSTMT)
               LSTART = LFALSE
            END IF
C
C         CREATE THE TABLE ENTRY FOR INTEGER DEFINED PARAMETER VARIABLES
C         ONLY. THEY MAY BE USED TO DEFINE DIMENSION AND LENGTH
C         SPECIFICATIONS.
C
C         SCAN TO DETERMINE THE PARAMETER VARIABLE NAME WHOSE VALUE IS
C         BEING DEFINED
C
            CWK52(1:52) = CBLK52(1:52)
            I3 = I1 - 1
            I5 = I3 - I4 + 1
            CWK52(1:I5) = CSTMT(I4:I3)
C
C         OBTAIN THE TYPE AND LENGTH CODE OF THE PARAMETER VARIABLE
C         WHOSE VALUE IS BEING SET
C
            IF(INAME .EQ. 1) THEN
               IRET = 1
            ELSE IF(INAME .GT. 1) THEN
               CALL TABSRH (CNAME,INAME,52,1,32,CWK52,1,32,IRET,4000)
               IF(IRET .GT. 0) THEN
                  CWORK(1:52) = CNAME(IRET)(1:52)
                  IWORK = ISN + 128
                  JBITS = IBSET(JBITS,14)
                  IENAME(12,IRET) = IBSET(IENAME(12,IRET),14)
                  WRITE (7,REC=IREC7) CWORK(1:52)
                  IREC7 = IREC7 + 1
               END IF
            END IF
C
C         TEST IF A MATCH WAS FOUND
C
            IF(IRET .GT. 0) THEN
C
C         SET THE CODE TO INDICATE THE VARIABLE NAME IS A PARAMETER
C         VARIABLE, I.E., A SYMBOLIC CONSTANT
C
               IENAME(12,IRET) = IBSET(IENAME(12,IRET),14)
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),8)
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),9)
               IENAME(12,IRET) = IBCLR(IENAME(12,IRET),10)
C
C         PLACE THE ISN, TYPE, AND LENGTH CODE IN THE WORK AREA
C
               IF(LINCL) THEN
                  IWORK = -1
               ELSE
                  CWK52(33:44) = CNAME(IRET)(33:44)
               END IF
               CWK52(49:52) = CNAME(IRET)(49:52)
C
C         DETERMINE IF A TYPE AND LENGTH DEFINITION EXISTS
C
               IF(CNAME(IRET)(37:37) .EQ. CBLANK(1:1))
     1            CALL SETTL (CNAME(IRET))
            ELSE
C
C         PARAMETER VARIABLE NAME IS IN THE TABLE OF PARAMETER
C         DEFINITIONS; SET THE TYPE AND LENGTH FROM THE MASTER NAME
C         TABLE
C
               CWK52(37:44) = CNAME(IRET)(37:44)
            END IF
C
C         TEST IF NO MATCH WAS FOUND OR IF THERE IS NO TYPE AND LENGTH
C         DEFINTION
C
            IF(IRET .LT. 0) THEN
C
C         DETERMINE THE TYPE AND LENGTH FROM THE DEFAULT IMPLICIT
C         TABLE VALUES
C
               CALL TABSRH (CIMPL,27,8,1,1,CWK52,1,1,IRET1,27)
               CWK52(37:44) = CIMPL(IRET1)(1:8)
            END IF
C
C         IF THE PARAMETER VARIABLE IS AN INTEGER, EVALUATE THE VALUE
C         OF THE VARIABLE
C
            IF(CWK52(37:37) .EQ. CII) THEN
C
C         EVALUATE THE EXPRESSION TO THE RIGHT OF THE EQUAL SIGN THAT
C         DEFINES THE PARAMETER VARIABLE VALUE
C
               CALL PARAEV (I1+1,JD,JARG)

C         PLACE THE VALUE INTO THE WORK AREA AND ENTER THE NAME INTO
C         THE TABLE FOR LATER REFERENCE
C
               IARG = JARG
               CALL TABINS (CPARAM,IP,52,1,32,CWK52,1,32,IRET,4000)
C
C         DETERMINE IF THE TABLE IS FULL
C
               IF(IRET .EQ. 0) THEN
                  WRITE (0,102) ISN
                  IREC0 = IREC0 + 1
               END IF
            END IF
C
C         DETERMINE IF ANOTHER ARGUMENT FOLLOWS THE CURRENT ONE
C
            ID = JD + 1
            IF(CSTMT(ID:ID) .EQ. COMMA(1:1)) THEN
               J = ID + 1
               KB = JB
               GO TO 12
            END IF
C
C         DETERMINE IF THE END OF THE STATEMENT HAS BEEN REACHED
C
            IF(IA .GE. KB - 1) THEN
               IF(CSTMT(IA:IA) .EQ. CRPAR(1:1) .AND. CSTMT(IA+1:IA+1)
     1            .EQ. CRPAR(1:1)) GO TO 16
            END IF
         ELSE
            WRITE (0,103) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         ROUTINE EXIT
C
 16   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE PAUSE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         I      - SUBSCRIPT VARIABLE
C         IREC10 - COUNT OF THE NUMBER OF RECORDS IN UNIT 10
C         ISN    - THE INTERNAL STATEMENT NUMBER; THIS NUMBER IS
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. WHEN TRUE, ALL ERROR
C                  MESSAGES DETECTED IN THE INCLUDE FILE FORTRAN CODE
C                  ARE SUPPRESSED AND WILL NOT BE PRINTED.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C        10      - MESSAGES, ASCII TEXT FILE, RECORD LENGTH IS 80 CHAR-
C                  ACTERS OR LESS
C
C     COMMENTS
C
C         PAUSE IS AN EXECUTABLE STATEMENT
C
C     SUNROUTINES CALLED
C
C         EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT42
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     3                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IOEF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' NOT A PAUSE STATEMENT')
C
C         BLANK CHARACTER WORK AREA
C
C     STOP 'YYYY'
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
C
C         VERIFY THIS IS A PAUSE STATEMENT
C
      J = KF + 4
      IF(CSTMT(KF:J) .NE. 'PAUSE' .AND. .NOT.LINCL) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      ELSE
         J = J + 1
C
C         DETERMINE IF THIS AN ARITHMETIC EXPRESSION
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LEXEC = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
 10      CONTINUE
         LEXEC = LTRUE
      END IF
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
 11   LEXEC = LTRUE
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE PRINT OR TYPE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CIB    - CHARACTER VARIABLE, EQUIVALENCED TO IIB
C         IREC4  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 4 (STATEMENT NUMBERS)
C         CISN   - CHARACTER VARIABLE, EQUIVALENCED TO ISN
C         CMPR   - CHARACTER STATEMENT, WILL CONTAIN EITHER PRINT OR
C                  TYPE. USED TO IDENTIFY WHICH IS BEING PROCESSED.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C         CSYMCF - CHARACTER VARIABLE, THE HEX NUMBER: CF; THIS IS USED
C                  TO REPLACE A LITERAL IN THE FORTRAN STATEMENT. IT WAS
C                  CHOSEN TO PREVENT ANY CONFLICT WITH ANY CHARACTERS
C                  USED FOR SPECIAL SYSTEM FUNCTIONS UNDER EITHER ASCII
C                  OR EBCDIC CODING SYSTEMS.
C         CWR    - CHARACTER VARIABLE, A WRITE BUFFER FOR IO STATMENT
C                  NUMBERS
C         I      - SUBSCRIPT VARIABLE
C         IIB    - EQUIVALENCED TO CIB
C         I1     - COUNT OF LEFT AND RIGHT PARENTHESES. ONE IS ADDED
C                  FOR A LEFT PARENTHESIS; ONE IS SUBTRACTED FOR A
C                  RIGHT PARENTHESIS.
C         I2     - LOCATION OF THE FIRST COMMA NOT ENCAPSULATED WITHIN
C                  PARENTHESES
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN A TYPE STATEMENT IS
C                  TO BE PROCESSED, SET FALSE WHEN A PRINT STATEMENT IS
C                  TO BE PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A COMMA OCCURS, SET
C                  FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUAL SIGN OCCURS
C                  OUTSIDE OF ENCAPULATING LEFT AND RIGHT PARENTHESES,
C                  SET FALSE OTHERWISE
C
C     COMMENTS
C
C         PRINT IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR INSERT NUMBER PIOLST VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT43 (LA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWR, CWK8
      CHARACTER*7     CWK7
      CHARACTER*5     CMPR
      CHARACTER*4     CIB, CISN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA, L1, L2
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CIB,IIB), (CISN,IISN), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         INITIALIZATION
C
      LEXEC = LFALSE
      L1 = LFALSE
      L2 = LFALSE
      CMPR(1:5) = CBLANK(1:5)
C
C         SET THE END LOCATION OF THE COMMAND STATEMENT
C
      IF(LA) THEN
         J = KF + 3
         I1 = 4
         CMPR(1:4) = 'TYPE'
      ELSE
         J = KF + 4
         I1 = 5
         CMPR(1:5) = 'PRINT'
      END IF
      IF(CSTMT(KF:J) .EQ. CMPR(1:I1)) THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS AN ARITHMETIC EXPRESSION
C
         I1 = 0
         I3 = 0
         I4 = 0
         DO 10 I = J,KB
         IF(.NOT.L1 .AND. CSTMT(I:I) .EQ. COMMA) THEN
            I2 = I
            L1 = LTRUE
         END IF
         IF(CSTMT(I:I) .EQ. CLPAR .AND. I3 .EQ. 0) THEN
            I1 = I1 + 1
            I3 = I
         END IF
         IF(CSTMT(I:I) .EQ. CRPAR .AND. I4 .EQ. 0) THEN
            I1 = I1 - 1
            I4 = I
         END IF
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(I .GT. I2 .AND. I .GT. I3 .AND. I .LT. I4) GO TO 11
            IF(I1 .EQ. 0) THEN
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 12
            END IF
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
 11      LEXEC = LTRUE
C
C         DETERMINE THE FORMAT CONTROL TYPE
C         THE FORMAT IS A LITERAL
C
         IF(CSTMT(J:J) .EQ. CSYMCF) THEN
            J = I2 + 1
C
C         THE FORMAT IS A VARIABLE NAME
C
         ELSE IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
            CALL VSETUP (J,I2-1,I2-J,LFALSE,LFALSE,CSTMT)
            J = I2 + 1
C
C         THE FORMAT IS A STATEMENT NUMBER
C
         ELSE IF(CSTMT(J:J) .GE. C0 .AND. CSTMT(J:J) .LE. C9) THEN
            IF(.NOT.LINCL) THEN
               CALL NUMBER (CSTMT,LTRUE,J,II,FP,IFP)
               CALL INSERT (II)
               IIB = II + 128
               IISN = ISN + 128
               CWR(1:4) = CIB(1:4)
               CWR(5:8) = CISN(1:4)
               IREC4 = IREC4 + 1
               WRITE (4,REC=IREC4) CWR
            END IF
            J = I2 + 1
         END IF
C
C         PROCESS THE INPUT-OUTPUT LIST
C
         CALL PIOLST
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE PROGRAM STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CPGNME - CHARACTER VARIABLE, NAME OF THE CURRENT PROGRAM
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         I      - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF THE PROGRAM NAME
C         ID     - NUMBER OF BLANKS TO BLANK THE REMAINDER OF THE
C                  PROGRAM FIELD IN CFMTH
C         IE     - LOCATION OF THE LAST CHARACTER IN THE PROGRAM NAME
C         IPGNME - LENGTH OF THE PROGRAM NAME
C         I1     - COUNT OF LEFT AND RIGHT PARENTHESES AND WORK AREA
C         I2     - WORK AREA
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - DO LOOP PARAMETER
C         JB     - DO LOOP PARAMETER
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         J1     - LOCATION OF THE INITIAL LEFT PARENTHESIS IF ONE
C                  EXISTS IN THE STATEMENT
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         K1     - VALUE OF KB PRIOR TO MODIFICATION
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LPROG  - LOGICAL VARIABLE, SET TRUE WHEN A PROGRAM STATEMENT
C                  SETS THE TITLE FORMAT FOR THE OUTPUT FILE, SET FALSE
C                  OTHERWISE. THIS PREVENTS CHANGING THE MODULE NAME
C                  WHEN A CALL STATEMENT OCCURS AFTER THE PROGRAM
C                  STATEMENT.
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 3.
C
C     COMMENTS
C
C         PROGRAM IS NOT AN EXECUTABLE STATEMENT.
C
C         SOME OLDER FORTRAN COMPILERS ALLOW ARGUMENTS FOLLOWING THE
C         SPECIFICATION OF THE PROGRAM NAME.  FXREF IGNORES ANY TEXT
C         FOLLOWING THE PROGRAM NAME.
C
C     SUBROUTINES CALLED
C
C         EXPR LOCERR
C
C     *****************************************************************
C
      SUBROUTINE STMT44
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*44    CUNION
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
      EQUIVALENCE (IDEF,CDEF)
      EQUIVALENCE (CDEF(53:56),NARGD), (CDEF(33:36),JSNU),
     1(CDEF(49:52),MVCNT)
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' A PROGRAM STATEMENT IS NOT THE FIRST STATEMENT
     1')
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      I1 = 0
      J1 = 0
      JBITS = 0
      K1 = KB
      LEXEC = LFALSE
C
C         VERIFY THIS IS A PROGRAM STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'PROGRAM') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         TEST FOR AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) THEN
            I1 = I1 + 1
            IF(I1 .EQ. 1) J1 = I
         END IF
         IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(I1 .EQ .0) THEN
               LSTART = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               LEXEC = LTRUE
               GO TO 15
            ELSE
               KB = J1 - 1
               GO TO 11
            END IF
         END IF
 10      CONTINUE
C
C         DETERMINE IF MORE THAN THE PROGRAM NAME EXISTS IN THE
C         STATEMENT, AND DELETE ALL CHARACTERS AFTER THE NAME
C
 11      IF(J1 .GT. 0) THEN
            I1 = K1 - J1 + 1
            IF(I1 .GT. 52) THEN
               I2 = I1/52
               IF(I1 - I2 * 52 .GT. 0) I2 = I2 + 1
               DO 12 I = 1,I2-1
               JA = (I - 1) * 52 + J1
               JB = JA + 51
               CSTMT(JA:JB) = CBLK52(1:52)
 12            CONTINUE
               JA = JA + 52
               JB = K1 - JA + 1
               CSTMT(JA:K1) = CBLK52(1:JB)
            ELSE
               CSTMT(J1:K1) = CBLK52(1:I1)
            END IF
            KB = J1 - 1
         END IF
C
C         FILL THE SAVE AREA FOR THE ROUTINE NAME WITH BLANKS
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         CPGNME(1:32) = CBLK52(1:32)
C
C         DETERMINE THE END OF THE PROGRAM NAME. IT IS EITHER THE FINAL
C         CHARACTER IN THE STATEMENT, OR A SPECIAL SYMBOL SUCH AS A
C         COMMA OR LEFT PARENTHESIS.
C
         DO 13 I = 8,KB
         IF(I .EQ. KB) GO TO 14
         IF(CSTMT(I:I) .GE. CAA .AND. CSTMT(I:I) .LE. CZZ) GO TO 13
         IF(CSTMT(I:I) .EQ. CUNDER) GO TO 13
         IF(CSTMT(I:I) .EQ. CDOL) GO TO 13
         IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9) GO TO 13
         J = I
         GO TO 14
 13      CONTINUE
         J = J1
C
C         SAVE THE PROGRAM NAME IN CFMTH
C
 14      IC = KB - 7
         IF(IC .GT. 32) IC = 32
         ID = 95 - IC
         IE = IC + 63
         CFMTH(64:IE) = CSTMT(J:KB)
         IPGNME = IC
         CPGNME(1:IPGNME) = CSTMT(J:J+IC-1)
         IF(IE .LT. 95) CFMTH(IE+1:95) = CBLK52(1:ID)
         LPROG = LTRUE
         LTEST = LFALSE
         NARGD = 0
      END IF
C
C          DETERMINE IF THE PROGRAM STATEMENT HAS AN ISN OF ONE
C
      IF(ISN .NE. 1) THEN
         IREC0 = IREC0 + 1
         WRITE (0,100) ISN
      END IF
C
C         ROUTINE EXIT
C
 15   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE READ OR WRITE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COUTV  - CHARACTER VARIABLE, THE ARRAY OF INPUT-OUTPUT
C                  VARIABLE NAMES USED
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C         CWK    - CHARACTER VARIABLE, USED TO COMPARE READ OR WRITE
C                  COMMANDS
C         I      - SUBSCRIPT VARIABLE
C         I1     - WORK AREA
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JA     - COUNTS THE PARENTHESES, ONE IS ADDED FOR A LEFT
C                  PARENTHESIS, ONE IS SUBTRACTED FOR A RIGHT
C                  PARENTHESIS
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN A WRITE STATEMENT
C                  IS TO BE PROCESSED, SET FALSE WHEN A READ STATEMENT
C                  IS TO BE PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     COMMENTS
C
C         READ IS AN EXECUTABLE STATEMENT. THE CONTROL LIST FOR READ
C         AND WRITE STATEMENTS MAY HAVE THE FOLLOWING PARAMETERS:
C         END, ERR, FMT, IOSTAT, KEY, NML, REC, UNIT
C
C     SUBROUTINES CALLED
C
C         EXPR PRDWR
C
C     *****************************************************************
C
      SUBROUTINE STMT45 (LA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*5     CWK
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         VERIFY THIS IS A READ OR WRITE STATEMENT
C
      CWK(1:5) = CBLANK(1:5)
      LEXEC = LFALSE
C
C         DETERMINE IF A READ OR WRITE STATEMENT IS BEING PROCESSED
C
      IF(LA) THEN
         I1 = 4
         CWK(1:5) = 'WRITE'
      ELSE
         I1 = 3
         CWK(1:4) = 'READ'
      END IF
C
C         VERIFY IF THIS IS A READ OR WRITE STATEMENT
C
      IF(CSTMT(1:I1+1) .EQ. CWK(1:I1+1)) THEN
         J = I1 + 2
         LEXEC = LTRUE
C
C         SCAN FOR AN EQUAL SIGN; IF ONE OCCURS NOT ENCAPSULATED WITHIN
C         PARENTHESES, THIS IS AN ARITHMETIC EXPRESSION
C
         JA = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) JA = JA + 1
         IF(CSTMT(I:I) .EQ. CRPAR) JA = JA - 1
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            IF(JA .EQ. 0) THEN
               LEXEC = LTRUE
               CALL EXPR (KF,KB,LFALSE,CSTMT)
               GO TO 11
            END IF
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         PROCESS THE CONTROL AND INPUT-OUTPUT LISTS
C
         CALL PRDWR (LA)
      END IF
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE REAL STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CASTER - CHARACTER VARIABLE, AN ASTERISK: *
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER STATEMENT, 52 BLANKS
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLEN   - CHARACTER VARIABLE, THE LENGTH OF A REAL DEFINITION
C         CLENWK - CHARACTER VARIABLE, WORK AREA TO SHIFT THE LENGTH
C                  SPECIFICATION DERIVED FROM A PARAMETER VARIABLE TO
C                  THE START OF CLEN AFTER CONVERSION TO TEST FORM
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CLENSA - CHARACTER VARIABLE, THE LENGTH SPECIFICATION FOR ALL
C                  VARIABLES IN A SINGLE REAL STATEMENT, UNLESS
C                  INDIVIDUAL LENGTH SPECIFICATIONS ARE MADE
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSLASH - CHARATER VARIABLE, A SLASH: /
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - THE DATA TYPE CODE. IT IS R FOR THE REAL TYPE
C         CTYPSA - CHARACTER VARIABLE, THE DATA TYPE CODE FOR THE ENTIRE
C                  STATEMENT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE, THE CHARACTER: 9
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C         IARG   - THE VALUE OF THE PARAMETER VALUE TO BE SAVED IN TABLE
C                  CPARAM. IT IS EQUIVALENCED TO CWK52(45:48)
C         II     - VALUE OF A FIXED POINT NUMER RETURNED FROM ROUTINE
C                  NUMBER
C         IPGNME - LENGTH OF A FUNCTION NAME
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         ISN    - INTERNAL STATEMENT NUMBER FOR THE CURRENT STATEMENT
C         I1     - COUNT OF THE NUMBER OF PARENTHESES
C         I2     - SAVE AREA FOR THE FIRST CHARACTER OF THE STATEMENT
C         I2WK1  - PROVIDES THE COUNT OF SLASHES NOT ENCAPSULATED WITHIN
C                  PARENTHESES TO ROUTINE TYPLST
C         I3     - LOCATION OF AN ASTERISK DESIGNATING THE FOLLOWING
C                  CHARACTERS MUST BE A LENGTH SPECIFICATION
C         I4     - END OF A VARIABLE NAME LOCATION
C         I5     - COUNT OF THE NUMBER OF SLASHES NOT ENCAPSULATED
C                  WITHIN PARENTHESES. WHEN NOT ZERO, DATA
C                  SPECIFICATIONS EXIST FOR THE CURRENT VARIABLE BEING
C                  PROCESSED.
C         I6     - LOCATION OF A LEFT PARENTHESIS FOR VARIABLE LENGTH
C                  SPECIFICATION, AND THE START OF THE EXPRESSSION.
C         I7     - LOCATION OF THE END OF THE EXPRESSION SPECIFYING
C                  THE LENGTH CHARACTERISTIC
C         I8     - NUMBER OF CHRACTERS IN THE ASCII LENGTH OF LENGTH
C                  DEFINED BY AN EXPRESSION
C         I9     - COUNTS LEFT PARENTHESIS OCCURRENCE
C         I10    - LOCATION OF THE LEFT PARENTHESIS OF THAT TERMINATES
C                  VARIABLE NAME
C         I11    - LOCATION OF THE RIGHT PARENTHESIS MATCHING THE LEFT
C                  LEFT PARENTHESIS AT LOCATION I10
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JA     - LOCATION OF THE FIRST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JB     - LOCATION OF THE LAST CHARACTER OF FUNCTION IF IT
C                  EXISTS
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LEXP   - LOGICAL VARIABLE, SET TRUE WHEN A REAL VARIABLE HAS
C                  A LENGTH DEFINITION THAT IS AN EXPRESSION. THIS IS
C                  USED TO PREVENT SUBSEQUENT CHANGING OF THE ALREADY
C                  DETERMINED LENGTH IN CLEN LATER IN THIS ROUTINE.
C                  THIS VARIABLE IS USED ONLY WHEN THE LENGTH IS
C                  SPECIFICED FOR THE ENTIRE REAL STATEMENT. IT DOES
C                  NOT APPLY WHEN INDIVIDUAL REAL VARIABLES HAVE THIER
C                  OWN LENGTH DEFINTITIONS SPECIFIED SEPARATELY.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LFORCE - LOGICAL VARIABLE, SET TRUE TO FORCE SUBROUTINE CHKNME
C                  TO REPLACE THE TYPE AND LENGTH CHARACTERISTICS OF A
C                  VARAIABLE NAME IN CNAME TO THE VALUES DEFINED BY A
C                  DATA TYPE STATEMENT. WHEN A VARIABLE OCCURS IN A
C                  STATEMENT PRIOR TO THE OCCURRENCE OF A DATA TYPE
C                  STATEMENT, THE DEFAULT STANDARD IS USED BY CHKNME
C                  WHEN THE VARIABLE NAME IS ENTERED INTO THE CNAME
C                  TABLE; THIS SWITCH FORCES A CORRECTION IN CNAME.
C                  SET FALSE OTHERWISE.
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK OCCURS
C                  IN THE FIELD OF THE INDIVIDUAL VARIABLES IN THE REAL
C                  STATEMENT, SET FALSE OTHERWISE; THIS INDICATES A
C                  LENGTH SPECIFICATION IS SUPPLED. IF NO ASTERISK
C                  WITHIN THE FIELD, THEN THE DEFAULT VALUE IS SET FOR
C                  THE VARIABLE.
C         L2     - LOGICAL VARIABLE, SET TRUE AFTER THE LENGTH FOR THE
C                  ENTIRE REAL STATEMENT IS SET, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IS
C                  DIMENSIONED, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE FORM OF A REAL VARIABLE NAME AND THE SEQUENCE OF ITS
C         POSSIBLE SPECIFICATIONS ARE:
C
C         REAL[*LENGTH] [NAME] [(DIMENSION)] [/DATA/]
C
C         WHEN A REAL VARIABLE NAME IS DEFINED WITHIN A STRUCTURE, IT
C         HAS THE FORM:
C
C         REAL[*LENGTH] [NAME] [(DIMENSION)]
C
C         THE [DIMENSION] AND [LENGTH] SPECIFICATIONS MAY BE AN
C         EXPRESSION OF CONSTANTS AND PARAMETER VARIABLES. EACH
C         SUBSCRIPT SPECIFICATION MAY BE AN EXPRESSION.
C
C     COMMENTS
C
C         REAL IS NOT AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C          EXPR INSERT LOCERR NUMBER PARAEV STMT29 TYPLST
C
C     *****************************************************************
C
      SUBROUTINE STMT46
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*7 CLEN, CLENWK, CLENSA
      CHARACTER*1 CTYPED, CTYPSA
      LOGICAL*1   LEXP, L1, L2, L4
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' TYPE STATEMENT DATA SPECIFICATIONS LACK BALANC
     1ED SLASHES')
 101  FORMAT(' ISN:',I6,' REAL VARIABLE HAS ILLEGAL LENGTH')
 102  FORMAT(I7)
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      CLEN(1:7) = CBLANK(1:7)
      CLENWK(1:7) = CBLANK(1:7)
      CLENSA(1:7) = CBLANK(1:7)
      LEXEC = LFALSE
      LEXP = LFALSE
      L1 = LFALSE
      L2 = LFALSE
      LFORCE = LFALSE
      JA = 0
C
C         VERIFY THIS IS A REAL STATEMENT
C
      J = KF + 3
      IF(CSTMT(KF:J) .EQ. 'REAL') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         SCAN FOR AN EQUAL SIGN; IF FOUND, THIS IS AN ARITHMETIC
C         STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 18
         END IF
 10      CONTINUE
C
C         THIS IS A REAL STATEMENT; PLACE DEFAULT TYPE CODE.
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         CTYPED(1:1) = CRR
         LFORCE = LTRUE
C
C         IF REAL IS FOLLOWED BY AN ASTERISK, THIS IS A REAL STATEMENT.
C         ANY LENGTH SPECIFICATION OCCURRING HERE APPLY TO THE ENTIRE
C         LIST OF ARGUMENTS UNLESS EXPLICIT LENGTHS OCCUR FOR AN
C         INDIVIDUAL VARIABLE.
C
         IF(CSTMT(J:J) .EQ. CASTER) THEN
            JA = J + 1
            I6 = JA
C
C         DETERMINE OF THE LENGTH SPECIFICATION IS AN EXPRESSION OF
C         PARAMETER VARIABLES AND CONSTANTS
C
            IF(CSTMT(I6:I6) .EQ. CLPAR(1:1)) THEN
               I6 = I6 + 1
               I9 = 0
               LEXP = LTRUE
C
C         LOCATE THE END OF THE EXPRESSION
C
               DO 12 I4 = I6,KB
               IF(CSTMT(I4:I4) .EQ. CLPAR(1:1)) I9 = I9 + 1
               IF(CSTMT(I4:I4) .EQ. CRPAR(1:1)) THEN
                  I7 = I4 + I9 - 1
                  CALL PARAEV (I6,I7,IARG)
                  IF(IARG .NE. 4 .OR. IARG .NE. 8 .OR. IARG .NE. 16
     1               .AND. .NOT.LINCL) THEN
                     WRITE (0,101) ISN
                     IREC0 = IREC0 + 1
                     IARG = 4
                  END IF
                  WRITE (CLENWK,102) IARG
                  DO 11 I7 = 1,7
                  IF(CLENWK(I7:I7) .GE. C0(1:1) .AND.
     1               CLENWK(I7:I7) .LE. C9(1:1)) THEN
                     I8 = 8 - I7
                     CLEN(1:I8) = CLENWK(I7:7)
                     CLENSA(1:I8) = CLENWK(I7:7)
                     L2 = LTRUE
                     J = I4 + 1
                     GO TO 13
                  END IF
 11               CONTINUE
               END IF
 12            CONTINUE
            ELSE
C
C         THE LENGTH SPECIFICATION IS NUMERIC
C
               IF(CSTMT(I6:I6) .GE. C0 .AND. CSTMT(I6:I6) .LE. C9) THEN
C
C         DETERMINE IF TWO DIGITS FOLLOW THE ASTERISK
C
                  IF(CSTMT(I6+1:I6+1) .GE. C0 .AND. CSTMT(I6+1:I6+1)
     1               .LE. C9) THEN
                     CLEN(1:2) = CSTMT(I6:I6+1)
                     CLENSA(1:2) = CSTMT(I6:I6+1)
                  ELSE
                     CLEN(1:1) = CSTMT(I6:I6)
                     CLENSA(1:1) = CSTMT(I6:I6)
                  END IF
               END IF
            END IF
            GO TO 13
         END IF
C
C         THE REAL STATEMENT IS NOT FOLLOWED BY AN ASTERISK AND IT IS
C         NOT AN ARITHMETIC STATEMENT
C
         IF(JA .EQ. 0) THEN
            JA = 5
            JB = 12
            CTYPED(1:1) = CRR
            CLEN(1:1) = C4(1:1)
            CLENSA(1:1) = C4(1:1)
            L2 = LTRUE
            GO TO 14
         END IF
C
C         PLACE TYPE CODE AFTER DETERMINING LENGTH
C
 13      IF(CSTMT(JA:JA) .EQ. C4(1:1)) THEN
            CTYPED(1:1) = CRR
            CLEN(1:7) = CBLANK(1:7)
            IF(.NOT.LEXP .AND. .NOT.L2) THEN
               CLEN(1:1) = C4(1:1)
               CTYPSA = CRR
               CLENSA(1:7) = CLEN(1:7)
               L2 = LTRUE
            END IF
            J = JA + 1
         ELSE IF(CSTMT(JA:JA) .EQ. C8(1:1)) THEN
            CTYPED(1:1) = CDD
            IF(.NOT.LEXP .AND. .NOT.L2) THEN
               CLEN(1:1) = C8(1:1)
               CTYPSA = CDD
               CLENSA(1:7) = CLEN(1:7)
               L2 = LTRUE
            END IF
            J = JA + 1
         ELSE IF (CSTMT(JA:JA+1) .EQ. '16') THEN
            CTYPED(1:1) = CQQ
            CTYPSA = CQQ
            CLEN(1:7) = CBLANK(1:7)
            IF(.NOT.LEXP .AND. .NOT.L2) THEN
               CLEN(1:2) = C1//C6
               CLENSA(1:7) = CLEN(1:7)
               L2 = LTRUE
            END IF
            J = JA + 2
            JA = JA + 1
         ELSE
            JA = 5
            JB = 12
            GO TO 14
         END IF
         IF(.NOT.LEXP) THEN
            CALL NUMBER (CSTMT,LTRUE,JA,II,FP,IFP)
C
C         DETERMINE IF THE LENGTH IS 4, 8, OR 16 AND WRITE A MESSAGE
C         IF NOT
C
            IF(II .NE. 4 .AND. II .NE. 8 .AND. II .NE. 16) THEN
               WRITE (0,101) ISN
               IREC0 = IREC0 + 1
               II = 4
            END IF
            IF(.NOT.LINCL) CALL INSERT (II)
         END IF
         JA = JA + 1
         JB = JA + 7
C
C         TEST IF THIS IS A FUNCTION SUBPROGRAM
C
 14      IF(CSTMT(JA:JB) .EQ. 'FUNCTION') THEN
            KF = JA
            CALL STMT29 (CTYPED,CLEN)
            GO TO 18
         END IF
C
C         PROCESS THE REMAINDER OF THE REAL STATEMENT; THE STATEMENT
C         MAY CONTAIN ALL FOUR OF THE POSSIBLE SPECIFICATI0NS. THE VALUE
C         IN J IS THE LOCATION OF THE FIRST CHARACTER TO BEGIN
C         PROCESSING.
C
C         SCAN TO FIND THE BEGINNING AND END LOCATIONS FOR ALL SPECIF-
C         ICATIONS OF EACH VARIABLE NAME IN THE REAL STATEMENT
C
C         CLEAR THE WORK AREA AND SET COUNTERS
C
         CWORK(1:52) = CBLK52(1:52)
         JBITS = 0
         I1 = 0
         I2 = J
         I5 = 0
         I10 = 0
         I11 = 0
         DO 17 I4 = J,KB
C
C         LOCATE THE END OF THE INDIVIDUAL VARIABLE NAME BLOCK
C
         IF(CSTMT(I4:I4) .EQ. CLPAR) THEN
            I1 = I1 + 1
            I10 = I4
         END IF
         IF(CSTMT(I4:I4) .EQ. CRPAR) THEN
            I1 = I1 - 1
            I11 = I4
         END IF
         IF(I1 .EQ. 0 .AND. CSTMT(I4:I4) .EQ. CSLASH) I5 = I5 + 1
C
C         WHEN BALANCED PARENTHESES AND AN EVEN NUMBER OF SLASHES EXIST,
C         A COMMA TERMINATES THE VARIABLE NAME SPECIFICATIONS. IF THE
C         FINAL CHARACTER IS REACHED, IT HAS THE SAME EFFECT AS A COMMA.
C
         IF(I1 .EQ. 0 .AND. MOD(I5,2) .EQ. 0) THEN
            IF(CSTMT(I4:I4) .EQ. COMMA .OR. I4 .EQ. KB) THEN
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               DO 15 I = I2,I4
               IF(CSTMT(I:I) .EQ. CASTER(1:1)) THEN
                  L1 = LTRUE
                  I3 = I
                  GO TO 16
               ELSE
                  I3 = 0
               END IF
 15            CONTINUE
 16            IF(L1) THEN
                  IF(L2) THEN
                     IF(CSTMT(I3+1:I3+1) .EQ. C4) THEN
                        CTYPED(1:1) = CRR
                        CLEN(1:1) = C4
                     ELSE IF(CSTMT(I3+1:I3+1) .EQ. C8) THEN
                        CTYPED(1:1) = CDD
                        CLEN(1:1) = C8
                     ELSE IF(I3 .EQ. 0) THEN
                        CTYPED = CTYPSA
                        CLEN(1:7) = CLENSA(1:7)
                     END IF
                     CWORK(37:37) = CTYPED(1:1)
                     CWORK(38:44) = CLEN(1:7)
                  END IF
               ELSE
                  IF(CLEN(1:1) .EQ. CBLANK(1:1)) THEN
                     CWORK(37:37) = CRR
                     CTYPED(1:1) = CRR
                     CWORK(38:39) = '4 '
                     CLEN(1:2) = '4 '
                  ELSE IF(CLEN(1:1) .EQ. C8) THEN
                     CWORK(37:37) = CDD
                     CTYPED(1:1) = CDD
                     CWORK(38:39) = '8 '
                     CLEN(1:2) = '8 '
                  ELSE IF(CLEN(1:1) .EQ. C4) THEN
                     CWORK(37:37) = CRR
                     CTYPED(1:1) = CRR
                     CWORK(38:39) = '4 '
                     CLEN(1:2) = '4 '
                  END IF
               END IF
               I3 = I4
               I2WK1 = I5
               LFORCE = LTRUE
               IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
C
C         DETERMINE IF THE VARIABLE IS DIMENSIONED
C
               IF(I10 .GT. 0 .AND. I11 .GT. 0) THEN
                  L4 = LTRUE
               ELSE
                  L4 = LFALSE
               END IF
               CALL TYPLST (CTYPED,CLEN,I2,I3,L4)
               LFORCE = LFALSE
               CLEN(1:7) = CLENSA(1:7)
C
C         RESET LOGICAL SWITCH FOR THE NEXT VARIABLE
C
               L1 = LFALSE
C
C         TEST FOR END OF THE STATEMENT
C
               IF(I4 .EQ. KB) GO TO 18
C
C         SET START LOCATION FOR THE NEXT VARIABLE IN THE STATEMENT
C
               IF(CSTMT(I4:I4) .EQ. COMMA) THEN
                  I1 = 0
                  I2 = I4 + 1
                  I5 = 0
                  I10 = 0
                  I11 = 0
               END IF
            END IF
         END IF
 17      CONTINUE
C
C         CHECK FOR BALANCED SLASHES
C
         IF(I5 - MOD(JA,2) .GT. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
      END IF
C
C         ROUTINE EXIT
C
 18   LFORCE = LFALSE
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE RECORD STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         ID     - COUNT OF THE NUMBER OF SLASHES
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         ISN    - INTERNAL STATEMENT NUMBER FOR THIS STATEMENT
C         I1     - LOCATION OF THE FIRST SLASH OF A STRUCTURE NAME
C         I2     - LOCATION OF THE SECOND SLASH OF A STRUCTURE NAME
C         J      - LOCATION OF THE INITIAL CHARACTER IN THE ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LREC   - LOGICAL VARIABLE, SET TRUE WHEN PROCESSING A RECORD
C                  STATEMENT, SET FALSE OTHERWISE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, SET TRUE TO CALL STMT10. INDICATES
C                  A RECORD STATEMENT IS TO BE PROCESSED IN STMT10.
C
C     COMMENTS
C
C         A RECORD STATEMENT MAY NOT BE NESTED.
C
C         RECORD STATEMENTS MUST OCCUR PRIOR TO THE FIRST EXECUTABLE
C         STATEMENT.
C
C         A RECORD STATEMENT VARIABLE MAY BE DIMENSIONED, PLACED IN A
C         COMMON BLOCK, DEFINED WITHIN A STRUCTURE, OR USED WITHIN A
C         UNION DEFINITION.
C
C         RECORD IS NOT AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR STMT10
C
C     *****************************************************************
C
      SUBROUTINE STMT47
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     3                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' STRUCTURE NAME NOT ENCAPSULATED BY SLASHES')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
      DO 10 I = 7,KB
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         LEXEC = LTRUE
         LSTART = LTRUE
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         GO TO 12
      END IF
 10   CONTINUE
C
C         VERIFY THIS IS A RECORD STATEMENT
C
      J = KF + 5
      IF(CSTMT(KF:J) .EQ. 'RECORD') THEN
C
C         TEST FOR MATCHING SLASHES
C
         ID = 0
         DO 11 I = 7,KB
         IF(CSTMT(I:I) .EQ. CSLASH) THEN
            ID = ID + 1
            IF(ID .EQ. 1) I1 = ID
            IF(ID .EQ. 2) I2 = ID - 1
         END IF
 11      CONTINUE
         IF(MOD(ID,2) .NE. 0 .AND. .NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         A RECORD STATEMENT CAN BE ANALYZED AS A COMMON STATEMENT SINCE
C         THEY HAVE IDENTICAL SYNTAX.
C

         LREC = LTRUE
         LEXEC = LTRUE
         L1 = LTRUE
         CALL STMT10 (L1)
         LREC = LFALSE
         L1 = LFALSE
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE RETURN STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         I1     - WORK AREA
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     COMMENTS
C
C         RETURN IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT48
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
C
C         VERIFY THIS IS A RETURN STATEMENT
C
      J = KF + 5
      IF(CSTMT(KF:J) .EQ. 'RETURN') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         DETERMINE IF A BLANK FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .EQ. CBLANK(1:1)) GO TO 11
C
C         TEST IF A VARIABLE NAME FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .GE. CAA .AND. CSTMT(J:J) .LE. CZZ .OR.
     1      CSTMT(J:J) .EQ. CUNDER) THEN
            CALL VSETUP (J,KB,I1,LFALSE,LFALSE,CSTMT)
         END IF
      END IF
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE REWIND STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         I      - SUBSCRIPT VARIABLE
C         I1     - COUNT OF THE NUMBER OF PARENTHESES, ADD 1 WHEN A
C                  LEFT PARENTHESIS OCCURS, SUBTRACT 1 WHEN A RIGHT
C                  PARENTHESIS OCCURS
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         L1     - LOGICAL VARIABLE, WORK SWITCH
C
C     COMMENTS
C
C         REWIND IS AN EXECUTABLE STATEMENT. THE FOLLOWING CONTROL
C         LIST PARAMETERS ARE ALLOWED:
C         ERR, IOSTAT, UNIT
C
C     SUBROUTINES CALLED
C
C         CUNIT EXPR PRDWR
C
C     *****************************************************************
C
      SUBROUTINE STMT49
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     3                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L1
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB ,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         VERIFY THIS IS A REWIND STATEMENT
C
      J = KF + 5
      L1 = LFALSE
      LEXEC = LFALSE
      IF(CSTMT(KF:J) .EQ. 'REWIND') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS ARITHMETIC STATEMENT
C
         I1 = 0
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
         IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
         IF(CSTMT(I:I) .EQ. CEQ .AND. I1 .EQ. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         PROCESS THE CONTROL LIST
C
         IF(CSTMT(J:J) .EQ. CLPAR) THEN
            CALL PRDWR (L1)
         ELSE
C
C         ONLY A DIGIT SPECIFYING THE UNIT IS SPECIFIED
C
            CALL CUNIT
         END IF
      END IF
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE SAVE OR VOLATILE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         COMMA  - CHARACTER VARIABLE, THE CHARACTER: , (COMMA)
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C                  BEING ANALYZED
C         CWK    - CHARACTER VARIABLE, USED TO COMPARE SAVE OR VOLATILE
C                  COMMANDS
C         IA     - SUBSCRIPT VARIABLE
C         IC     - LENGTH OF A VARIABLE NAME
C         ID     - SUBSCRIPT VARIABLE
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         J      - LOCATION OF THE INITIAL CHARACTER, THIS IS ALWAYS
C                  THE FIRST CHARACTER OF THE ARGUMENT
C         JB     - END OF THE VARIABLE NAME FIELD
C         JC     - WORK VARIABLE
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - THE VALUE IS THE LOCATION OF THE FINAL CHARACTER
C                  IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LA     - LOGICAL VARIABLE, SET TRUE WHEN A VOLATILE STATEMENT
C                  IS TO BE PROCESSED, SET FALSE WHEN A SAVE STATEMENT
C                  IS TO BE PROCESSED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     COMMENTS
C
C         SAVE IS NOT AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR IBSET LOCERR VSETUP
C
C     *****************************************************************
C
      SUBROUTINE STMT50 (LA)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LA
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' VARIABLE OR BLOCK COMMON NAME DOES NOT FOLLOW
     1SAVE STATEMENT')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
      IC = 0
      CWK(1:8) = CBLANK(1:8)
C
C         DETERMINE WHICH STATEMENT IS BEING PROCESSED
C
      IF(LA) THEN
         IA = 7
         CWK(1:8) = 'VOLATILE'
      ELSE
         IA = 3
         CWK(1:4) = 'SAVE'
      END IF
C
C         VERIFY THIS IS A SAVE OR VOLATILE STATEMENT
C
      J = KF + IA
      IF(CSTMT(KF:J) .EQ. CWK(1:IA+1)) THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF ANY LIST EXISTS
C
         IF(CSTMT(J:J) .EQ. CBLK52(1:1)) GO TO 14
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 14
         END IF
 10      CONTINUE
C
C         SCAN FOR ARGUMENTS
C
 11      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         IF(IC .NE. 0) J = IC
         DO 13 ID = J,KB
C
C         TEST FOR THE FIRST ALPHABETIC CHARACTER AFTER SAVE
C
         IF(CSTMT(ID:ID) .GE. CAA .AND. CSTMT(ID:ID) .LE. CZZ .OR.
     1      CSTMT(ID:ID) .EQ. CUNDER .OR. CSTMT(ID:ID) .EQ. CSLASH) THEN
C
C         PROCESS THE VARIABLE NAME OR A COMMON NAME
C         LOCATE THE END OF THE NAME
C
            DO 12 IA = ID,KB
            IF(CSTMT(IA:IA) .EQ. CSLASH .OR. CSTMT(IA:IA) .EQ. COMMA
     1         .OR. IA .EQ. KB) THEN
               IF(CSTMT(IA:IA) .EQ. CSLASH) THEN
                  CWORK(37:37) = CBAR
                  JBITS = IBSET(JBITS,11)
               END IF
C
C         SET THE END VALUE WHEN IT IS THE END OF THE STATEMENT OR NOT
C
               IF(IA .EQ. KB) THEN
C
C         WHEN THE LAST CHARACTER OF THE STATEMENT IS A SLASH, THE
C         VARIABLE NAME ENDS AT KB-1, NOT AT KB.
C
                  IF(CSTMT(KB:KB) .EQ. CSLASH) THEN
                     JB = KB - 1
                  ELSE
                     JB = KB
                  END IF
               ELSE
                  JB = IA - 1
               END IF
               CALL VSETUP (ID,JB,JC,LFALSE,LFALSE,CSTMT)
               CWORK(1:52) = CBLK52(1:52)
               JBITS = 0
               IF(IA .EQ. KB) GO TO 14
               IC = IA + 1
               GO TO 11
            END IF
 12         CONTINUE
         ELSE
C
C         AN ERROR OCCURS WHEN THE FIRST CHARACTER FOLLOWING 'SAVE' IS
C         NOT THE START OF A VARIABLE NAME OR A SLASH FOR A COMMON BLOCK
C         NAME.
C
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 14
         END IF
 13      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE STOP STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         C0     - CHARACTER VARIABLE THE CHARACTER: 0
C         C9     - CHARACTER VARIABLE THE CHARACTER: 9
C         I      - SUBSCRIPT VARIABLE
C                  ASSIGNED TO ALL STATEMENTS EXCEPT COMMENTS
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATEMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     COMMENTS
C
C         STOP IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR
C
C     *****************************************************************
C
      SUBROUTINE STMT52
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' INVALID CHARACTERS FOLLOW THE STOP STATEMENT')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
C
C         VERIFY THIS IS A STOP STATEMENT
C
      J = KF + 3
      IF(CSTMT(KF:J) .EQ. 'STOP') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC EXPRESSION
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 12
         END IF
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
         LEXEC = LTRUE
C
C         TEST IF A LITERAL FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .EQ. CSYMCF) GO TO 12
C
C         DETERMINE IF A BLANK FOLLOWS THE STATEMENT
C
         IF(CSTMT(J:J) .EQ. CBLANK(1:1)) GO TO 12
C
C         DETERMINE IF ANY NONNUMERIC CHARACTER OCCURS AFTER THE STOP
C         STATEMENT
C
         IF(.NOT.(CSTMT(J:J) .GE. C0(1:1) .AND. CSTMT(J:J) .LE. C9(1:1))
     1      ) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
      END IF
C
C         ROUTINE EXIT
C
 12   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE STRUCTURE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AND EQUAL SIGN: =
C         CSLASH - CHARACTER VARIABLE, A SLASH
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CSTR   - TABLE OF ALL STRUCTURES DEFINED IN THE MODULE BEING
C                  CURRENTLY PROCESSED. A MAXIMUM OF 1000 UNIQUE
C                  STRUCTURES MAY OCCUR. EQUIVALENCED TO ISTR.
C                  RECORD STRUCTURE
C                  COLS  1 - 32 STRUCTURE NAME, CHARACTER VARIABLE
C                  COLS 33 - 36 INTEGER VALUE OF THE STRUCTURE'S TOTAL
C                               LENGTH
C         CSTRNM - TABLE OF NESTED STRUCTURES DEFINED IN THE MODULE
C                  BEING CURRENTLY PROCESSED. A MAXIMUM OF 20 NESTED
C                  STRUCTURES MAY OCCUR. HOWEVER, FXREF LIMITS THE
C                  LEVEL TO SIX DEEP EXCLUDING THE INITIAL STRUCTURE.
C                  RECORD STRUCTURE
C                  COLS  1 - 32 STRUCTURE NAME, CHARACTER VARIABLE
C                  COLS 33 - 36 INTEGER VALUE OF THE STRUCTURE'S TOTAL
C                               LENGTH
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES
C         I      - SUBSCRIPT VARIABLE
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         ISN    - INTERNAL STATEMENT NUMBER FOR THE CURRENT STATEMENT
C         ISTR   - EQUIVLENCED TO CSTR
C         ISTRUC - COUNT OF THE NUMBER OF STRUCTURE STATEMENTS. THIS
C                  VALUE IS THE TOTAL NUMBER OF STRUCTURE STATEMENTS
C                  DEFINED IN TABLE CSTR.
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         IWORK  - THE ISN FOR A VARIABLE NAME, EQUIVALENCED TO CWORK
C         I2WK1  - WORK AREA USED IN NUMBER CONVERSION
C         J      - LOCATION OF THE INITIAL CHARACTER IN THE ARGUMENT
C         JA     - LOCATION OF THE FINAL CHARACTER IN THE ARGUMENT
C         JC     - LENGTH OF THE ARGUMENT
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUCT
C         JSTRUC - COUNT OF THE LEVELS OF STRUCTURE STATEMENTS. ONE IS
C                  ADDED WHEN A STRUCTURE STATEMENT IS PROCESSED, ONE
C                  IS SUBTRACTED WHEN AN END STRUCTURE STATEMENT IS
C                  PROCESSED.
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - LOCATION OF THE FINAL CHARACTER IN A STATEMENT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LINCL  - LOGICAL VARIABLE, SET TRUE WHEN AN INCLUDE STATEMENT
C                  OCCURS, SET FALSE OTHERWISE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT RETURNS TO ZERO.
C         NA     - LOCATION OF THE FIRST CHARACTER FOLLOWING A VARIABLE
C                  NAME IN A FORTRAN SOURCE STATEMENT.
C         NARGD  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C
C     COMMENTS
C
C         STRUCTURE STATEMENTS MAY BE NESTED.
C         STRUCTURE IS NOT AN EXECUTABLE STATEMENT.
C         NO VARIABLE DEFINED WITHIN A STRUCTURE MAY BE DIMENSIONED.
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C        10      - ASCII TEXT FILE, RECORD LENGTH IS 121 CHARACTERS
C                  CHARACTERS
C
C     SUBROUTINES CALLED
C
C         CHKNME EXPR IBSET LOCERR TABINS
C
C     *****************************************************************
C
      SUBROUTINE STMT53
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ISTRNM(9,20), ISTR(9,1000), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CZERO
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1)),
     2(CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
      EQUIVALENCE (CSTRNM,ISTRNM), (CSTR,ISTR)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CZERO/'00000000'X/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' STRUCTURE NAME LACKS CLOSING SLASH')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      LEXEC = LFALSE
C
C         VERIFY THIS IS A STRUCTURE STATEMENT
C
      J = KF + 8
      IF(CSTMT(KF:J) .EQ. 'STRUCTURE') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 13
         END IF
 10      CONTINUE
C
C         INDICATE A STRUCTURE IS BEING PROCESSED
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         LSTRUC = LTRUE
C
C         SET STRUCTURE STATEMENTS COUNT AND NESTING LEVEL
C
         JSTRUC = JSTRUC + 1
C
C         SET THE STRUCTURE LENGTH COUNTER TO ZERO
C
         JSTR(JSTRUC) = 0
C
C         VERIFY THE PRESENCE OF A SLASH
C
         IF(CSTMT(J:J) .EQ. CSLASH) THEN
            J = J + 1
C
C         TEST FOR AN ENDING SLASH
C
            DO 11 I = J,KB
            IF(CSTMT(I:I) .EQ. CSLASH) THEN
               JA = I - 1
               JC = I - J
               GO TO 12
            END IF
 11         CONTINUE
         END IF
C
C         NO CLOSING SLASH FOUND
C
         JA = KB
         JC = KB
         IF(.NOT.LINCL) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
            GO TO 13
         END IF
C
C         INSERT THE STRUCTURE NAME INTO THE STRUCTURE TABLE. THE LENGTH
C         OF THE STRUCTURE IS UNKNOWN AT THIS TIME, SO IT IS SET TO ZERO
C
 12      CWORK(1:JC) = CSTMT(J:JA)
         JBITS = 0
         JBITS = IBSET(JBITS,13)
         IF(.NOT.LINCL) JBITS = IBSET(JBITS,15)
         CSTRNM(JSTRUC)(1:32) = CWORK(1:32)
         CSTRNM(JSTRUC)(33:36) = CZERO(1:4)
         CALL TABINS (CSTR,ISTRUC,36,1,32,CSTRNM(JSTRUC),1,32,IRET,
     1                1000)
C
C         PLACE THE NAME IN THE CNAME TABLE. A STRUCTURE NAME MAY NOT
C         BE A COMPOUND VARIABLE NAME.
C
         NA = JA + 1
         IVCNT = JC
         JBITS = IBSET(JBITS,13)
         IWORK = ISN + 128
         CALL CHKNME (CSTMT)
      END IF
C
C         SET THE STRUCTURE LENGTH NESTING COUNTER ARRAY ELEMENT TO ZERO
C
      JSTR(JSTRUC) = 0
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE SUBROUTINE STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER STATEMENT, AN EQUAL SIGN: =
C         CPGNME - THE NAME OF THE PROGRAM BEING LISTED. IF A PROGRAM,
C                  SUBROUTINE, OR FUNCTION STATEMENT OCCUR, THIS IS
C                  THE NAME OF THE ROUTINE. IF NOTHING IS SPECIFIED,
C                  THE FIRST SIX CHARACTERS OF THE FILE NAME IS USED.
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPED - CHARACTER VARIABLE, CONTAINS A CODE TO DESIGNATE
C                  STATEMENT BEING PROCESSED. C - CALL, E - ENTRY,
C                  F - FUNCTION, S - SUBROUTINE, T - STRUCTURE
C         I      - SUBSCRIPT VARIABLE
C         IPGNME - PROGRAM NAME CHARACTER LENGTH
C         I1     - COUNT OF THE NUMBER OF BALANCED PARENTHESES. 0NE IS
C                  ADDED FOR A LEFT PARENTHESIS, AND ONE IS SUBTRACTED
C                  FOR A RIGHT PARENTHESIS
C         I2WK1  - COUNT OF THE NUMBER OF ARGUMENTS FOR A SUBROUTINE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         J1     - LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO ZERO.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         LCALL  - LOGICAL VARIABLE, SET TRUE WHEN A CALL STATEMENT IS
C                  BEING PROCESSED, SET FALSE WHEN AN ENTRY, FUNCTION,
C                  OF SUBROUTINE STATEMENT IS BEING PROCESSED
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF A FORTRAN ROUTINE HAS BEEN READ. SET FALSE
C                  OTHERWISE; NOT THE END OF FILE FOR UNIT 5 WHEN SET
C                  TRUE.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 3.
C         LZEND  - LOGICAL VARIABLE, SET TRUE WHEN AN END STATEMENT
C                  OCCURS, SET FALSE OTHERWISE. THE VARIABLE IS USED
C                  TO DETERMINE IF AN END STATEMENT PRECEDES A FUNCTION
C                  OR SUBROUTINE STATEMENT.
C         NARGD  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C         NARGM  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C         NARGS  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C
C     COMMENTS
C
C         SUBROUTINE IS NOT AN EXECUTABLE STATEMENT
C
C         ALL ARGUMENTS IN A SUBROUTINE STATEMENT ARE DUMMY VARIABLES.
C         DUMMY VARIABLES MAY NOT BE COMPOUND VARIABLES.
C
C     SUBROUTINES CALLED
C
C         ARGLST EXPR IBSET LOCERR
C
C     *****************************************************************
C
      SUBROUTINE STMT54
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE, CTYPED
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' A SUBROUTINE STATEMENT MUST HAVE AN ISN OF 1')
 101  FORMAT(' ISN:',I6,' UNBALANCED PARENTHESES IN SUBROUTINE STATEMENT
     1')
 102  FORMAT(' ISN:',I6,' END STATEMENT MISSING')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      IRET = 1
      I1 = 0
      LEXEC = LFALSE
      LPROG = LFALSE
      IWORK = ISN
C
C         VERIFY THIS IS A SUBROUTINE STATEMENT
C
      J = KF + 9
      IF(CSTMT(KF:J) .EQ. 'SUBROUTINE') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 14
         END IF
 10      CONTINUE
C
C         DETERMINE IF AN END STATEMENT PRECEDES A SUBROUTINE STATEMENT
C
         IF(LZEND .AND. ISN .GT. 0) THEN
            WRITE (0,102) ISN
            IREC0 = IREC0 + 1
            LZEND = LFALSE
            LENDS = LTRUE
            GO TO 14
         END IF
C
C         A SUBROUTINE STATEMENT MUST BE THE FIRST NON-COMMENT STATEMENT
C         IN THE PROGRAM MODULE. WRITE A DIAGNOSTIC IF NOT TRUE.
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         IF(ISN .GT. 1) THEN
            WRITE (0,100) ISN
            IREC0 = IREC0 + 1
         END IF
C
C         A SUBROUTINE MUST HAVE AN MATCHED LEFT AND RIGHT PARENTHESES
C         FOR AN ARGUMENT LIST TO EXIST
C
         DO 11 I = 1,KB
         IF(CSTMT(I:I) .EQ. CLPAR) I1 = I1 + 1
         IF(CSTMT(I:I) .EQ. CRPAR) I1 = I1 - 1
  11     CONTINUE
C
C         WHEN I1 IS GREATER THAN ZERO, UNMATCHED PARENTHESES OCCUR
C
         IF(I1 .GT. 0 .AND. ISN .GT. 0) THEN
            IREC0 = IREC0 + 1
            WRITE (0,101) ISN
         END IF
C
C         DETERMINE THE SUBROUTINE NAME AND PLACE IT THE WORK BUFFER
C
         DO 12 I = 11,KB
         IF(CSTMT(I:I) .EQ. CLPAR(1:1)) THEN
            IPGNME = I - 10
            CWORK(1:IPGNME) = CSTMT(11:I-1)
            CPGNME(1:IPGNME) = CSTMT(I1:I-1)
            GO TO 13
         END IF
         IF(I .EQ. KB) THEN
            IPGNME = KB - 10
            CWORK(1:IPGNME) = CSTMT(11:KB)
            CPGNME(1:IPGNME) = CSTMT(I1:I-1)
            GO TO 13
         END IF
 12      CONTINUE
C
C         NOW PROCESS THE ARGUMENT LIST
C
 13      JA = J
         CTYPED(1:1) = CSS
         LCALL = LFALSE
         LTEST = LTRUE
         NARGD = 0
         NARGS = 0
         JBITS = IBSET(JBITS,9)
         CALL ARGLST (CTYPED,CSTMT,KB)
         LFORCE = LFALSE
         NARGM = NARGS
      END IF
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM PROCESSES THE UNION STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN: =
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         I      - SUBSCRIPT VARIABLE
C         J      - LOCATION OF THE INITIAL CHARACTER IN AN ARGUMENT
C         JBITS  - EQUIVALENCED TO CWORK(45:48); USED TO SET ALL BIT
C                  SWITCHES TO FALSE STATUS.
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT.
C         JUNION - COUNT OF THE LEVELS OF UNION STATEMENTS. ONE IS ADDED
C                  WHEN A UNION STATEMENT IS PROCESSED, ONE IS
C                  SUBTRACTED WHEN AN END UNION STATEMENT IS PROCESSED.
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - LOCATION OF THE START OF THE FORTRAN STATMENT WITH
C                  THE STATEMENT NUMBER ABSENT OR REMOVED
C         KUNION - COUNT OF THE HIGHEST NESTING LEVEL OF UNION
C                  STATEMENTS
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTART - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST EXECUTABLE
C                  STATEMENT OCCURS, SET FALSE OTHERWISE. THIS IS USED
C                  TO WRITE AN ERROR MESSAGE WHEN DECLARATION STATEMENTS
C                  OCCUR AFTER THE INITIAL EXECUTABLE STATEMENT OF THE
C                  PROGRAM MODULE.
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL TRUE
C         LUNION - LOGICAL VARIABLE, SET TRUE WHEN A UNION STATEMENT IS
C
C     COMMENTS
C
C         UNION STATEMENTS HAVE NO IDENTIFIERS, BUT THEY CAN BE NESTED.
C         A UNION STATEMENT MAY ENCAPSULATE STRUCTURE, RECORD, UNION,
C         AND TYPE DESCRIPTIONS. IT MUST ENCAPSULATE AT LEAST TWO MAP
C         STATEMENT DEFINITIONS.
C
C         A UNION STATEMENT IS TERMINATED BY AN END UNION STATEMENT.
C         SUBROUTINE EUNION CONTROLS UNION TERMINATION
C
C         UNION IS NOT AN EXECUTABLE STATEMENT
C
C     SUBROUTINES CALLED
C
C         EXPR LOCERR
C
C     ******************************************************************
C
      SUBROUTINE STMT56
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION JMAP(20), MAPLEN(20,20), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /MUS/ JMAP, MAPLEN
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         VERIFY THIS IS A UNION STATEMENT
C
      J = KF + 6
      IF(CSTMT(KF:J) .EQ. 'UNION') THEN
         J = J + 1
         LEXEC = LTRUE
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
         DO 10 I = J,KB
         IF(CSTMT(I:I) .EQ. CEQ) THEN
            LSTART = LTRUE
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            GO TO 11
         END IF
 10      CONTINUE
C
C         INITIALIZATION FOR PROCESSING
C
         IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
         JUNION = JUNION + 1
         KUNION = JUNION
         JMAP(JUNION) = 0
C        LUNION = LTRUE
      END IF
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS PROGRAM PROCESSES THE WHILE ... END WHILE STATEMENT AND
C        THE WHILE (LOGIC) STATEMENT CONSTRUCT
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CEQ    - CHARACTER VARIABLE, AN EQUAL SIGN
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSTMT  - CHARACTER VARIABLE, THE CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CWORK  - CHARACTER VARIABLE, USED TO CONSTRUCT TABLE ENTRIES;
C                  IT HAS THE SAME RECORD STRUCTURE AS VARIABLE CNAME.
C         I      - SUBSCRIPT VARIABLE
C         ID     - COUNT OF THE PARENTHESES, 1 IS ADDED FOR EACH LEFT
C                  PARENTHESIS, ONE IS SUBTRACTED FOR EACH RIGHT
C                  PARENTHESIS
C         IRET   - THE RETURN CODE USED TO CHOOSE THE RETURN LOCATION
C                  FOR THE CALLING PROGRAM
C         I1     - SAVE AREA FOR THE LOCATION OF THE INITIAL LEFT
C                  PARENTHESIS
C         I2     - WORK AREA FOR THE LOCATION OF A RIGHT PARENTHESIS
C         I3     - LOCATION OF THE FINAL CHARACTER OF TEXT FOLLOWING
C                  THE LOGICAL SPECIFICATION
C         I4     - NUMBER OF CHARACTERS FOLLOWING THE LOGICAL
C                  SPECIFICATION
C         I5     - NUMBER OF BLOCKS OF 52 BLANKS
C         I6     - NUMBER OF BLANKS EXCEEDING AN INTEGER MULTIPLE OF 52
C                  BLANKS
C         I7     - LOCATION IN CSTMT TO BEGIN INSERTING BLANKS THAT
C                  EXCEED AN INTEGER MULTIPLE OF 52 BLANKS
C         I8     - SAVE AREA OF THE FINAL RIGHT PARENTHESIS
C         J      - CURRENT LOCATION IN CSTMT DURING SCANNING
C         KB     - END POINTER LOCATION OF THE NEXT CARD IMAGE IN
C                  ARRAY CSTMT. AFTER ALL RECORDS FOR A STATMENT ARE
C                  READ, THE VALUE IS THE LOCATION OF THE FINAL CHARAC-
C                  TER IN CSTMT
C         KF     - THE INITAL CHARACTER OF THE STATEMENT
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LPAREN - LOGICAL VARIABLE, SET TRUE WHEN MATCHING PARENTHESES
C                  EXIST
C         LSTMT  - LOGICAL VARIABLE, SET TRUE IF THE STATEMENT IS NOT AN
C                  ARITHMETIC STATEMENT, SET FALSE IF A STATEMENT IS
C                  AN ARITHMETIC STATEMENT
C
C     COMMENTS
C
C         WHILE ... END IS AN EXECUTABLE STATEMENT
C
C     SUBROUTINE CALLED
C
C         EXPR
C
C     ******************************************************************
C
      SUBROUTINE STMT59 (*,*)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CSREC(20)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*68    CWK68
      CHARACTER*52    CBLK52, CWORK
      CHARACTER*32    CWK32
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*7     CWK7
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FP
      INTEGER*2       I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
C
C         EQUIVALENT STATEMENTS
C
      EQUIVALENCE (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,'UNBALANCED PARENTHESES')
C
C         BLANK CHARACTER WORK AREA
C
      CWORK(1:52) = CBLK52(1:52)
      LSTMT = LFALSE
C
C         VERIFY THIS IS A WHILE STATEMENT
C
      J = KF + 4
      LPAREN = LFALSE
      IF(CSTMT(KF:J) .EQ. 'WHILE') THEN
         J = J + 1
         ID = 0
         LSTMT = LTRUE
C
C         AN ARITHMETIC STATEMENT EXISTS WHEN AN EQUAL SIGN IS NOT
C         ENCAPSULATED BETWEEN MATCHING PARENTHESES
C
         DO 10 I = J,KB
C
C         IDENTIFY A LEFT PARENTHESIS, AND SAVE THE LOCATION OF THE
C         INITIAL LEFT PARENTHESIS
C
         IF(CSTMT(I:I) .EQ. CLPAR) THEN
            ID = ID + 1
            IF(I .EQ. J) I1 = I
         END IF
C
C         IDENTIFY A RIGHT PARENTHESIS, AND SAVE THE LOCATION OF THE
C         FINAL RIGHT PARENTHESIS
C
         IF(CSTMT(I:I) .EQ. CRPAR) ID = ID - 1
         IF(ID .EQ. 0) THEN
            I2 = I
C
C         INDICATE MATCHING PARENTHESES EXIST FOR THIS STATEMENT
C
            LPAREN = LTRUE
         END IF
C
C         WHEN AN EQUAL SIGN OCCURS BEFORE ALL PARENTHESES ARE CLOSED,
C         THIS MUST BE AN ARITHMETIC STATEMENT
C
         IF(CSTMT(I:I) .EQ. CEQ .AND. ID .NE. 0) THEN
            CALL EXPR (KF,KB,LFALSE,CSTMT)
            IRET = 1
            GO TO 14
         END IF
         IF(ID .EQ. 0 .AND. I .NE. J) GO TO 11
 10      CONTINUE
C
C         SET FIRST EXECUTABLE STATEMENT SWITCH
C
 11      LEXEC = LTRUE
         I8 = I2
C
C         DETERMINE IF UNBALANCED LEFT AND RIGHT PARENTHESES EXIST
C
         IF(ID .NE. 0) THEN
            WRITE (0,100)
            IRET0 = IRET0 + 1
            IRET = 1
            GO TO 14
         END IF
C
C         THIS IS A WHILE ... END WHILE STATEMENT. PROCESS THE LOGICAL
C         CONDITION EXPRESSION TO BE SATISFIED.
C
         I1 = I1 + 1
         I2 = I8 - 1
         LEXEC = LTRUE
         CALL EXPR (I1,I2,LFALSE,CSTMT)
C
C         DETERMINE IF THE FINAL RIGHT PARENTHESIS IS ALSO THE END OF
C         STATEMENT. ANOTHER STATEMENT MUST FOLLOW THE WHILE AND ITS
C         LOGICAL CONDIITON SPECIFICATION.
C
         I2 = I8
         IF(I2+1 .EQ. KB) THEN
            IRET = 1
            GO TO 14
         ELSE
C
C         TEXT FOLLOWS THE FINAL RIGHT PARENTHESIS; CHECK FOR A DO
C         FOLLOWING THE PARENTHESIS
C
            I2 = I2 + 2
            IF(CSTMT(I2:I2+1) .EQ. 'DO' .AND. I2+1 .GE. KB) THEN
               KB = I8
               IRET = 1
               GO TO 14
            ELSE
C
C         SOME OTHER TYPE OF STATEMENT FOLLOWS THE FINAL RIGHT
C         PARENTHESIS. POSITION IT TO BE TREATED AS AN INDEPENDENT
C         STATEMENT WITHOUT A NEW ISN.
C
               DO 12 I = I2,KB
               I3 = I - I2 + 1
               CSTMT(I3:I3) = CSTMT(I:I)
 12            CONTINUE
               I4 = KB - I3
               IF(I4 .LE. 52) THEN
                  CSTMT(I3+1:KB) = CBLK52(1:I4)
               ELSE
                  I5 = I4/52
                  DO 13 I = 1,I5
                  CSTMT(I3+1:I3+52) = CBLK52(1:52)
 13               CONTINUE
                  I6 = I4 - 52 * I5
                  I7 = 52 * I5 + 1
                  IF(I6 .GT. 0) CSTMT(I7:I7+I6-1) = CBLK52(1:I6)
               END IF
               IRET = 2
            END IF
         END IF
C
C         PROCESS THE STATEMENT FOLLOWING THE WHILE LOGICAL CONDITION
C
      END IF
 14   RETURN IRET
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM PROCESSES THE MAP SPECIFICATIONS AND
C         DETERMINES THE LENGTH OF THE UNION ENCAPSULATING THE MAP
C         STATEMENTS. IT ALSO CONTIANS ENTRY STATEMENTS TO ALLOW
C         END MAP, END UNION, AND END STRUCTURE STATEMENTS PROCESSING.
C
C     MEANING OF THE VARIABLES
C
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CJSTR  - CHARACTER VARIABLE, LENGTH OF A STRUCTURE
C         CNAME  - TABLE OF ALL VARIABLE NAMES OCCURING IN THE PROGRAM
C                  CURRENTLY BEING ANALYZED
C         CSTR   - CHARACTER VARIABLE, TABLE OF ALL STRUCTURE NAMES,
C                  EQUIVALENCED TO ISTR
C                  RECORD STRUCTURE
C                  COLS  1 - 32 STRUCTURE NAME, CHARACTER VARIABLE
C                  COLS 33 - 36 INTEGER VALUE OF THE STRUCTURE'S TOTAL
C                               LENGTH
C         CSTRNM - TABLE OF ALL NESTED STRUCTURES WITHIN A SINGLE NESTED
C                  GROUP DEFINED IN THE MODULE BEING CURRENTLY PROCESSED
C                  A MAXIMUM OF 7 NESTED STRUCTURE DEFINITIONS MAY
C                  OCCUR.
C                  RECORD STRUCTURE
C                  COLS  1 - 32 STRUCTURE NAME, CHARACTER VARIABLE
C                  COLS 33 - 36 INTEGER VALUE OF THE STRUCTURE'S TOTAL
C                               LENGTH
C                  THIS TABLE IS DYNAMICALLY CREATED AND DESTROYED
C         I      - SUBSCRIPT VARIABLE
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IREC7  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 7 (VARIABLE NAMES)
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IRET   - RETURN VALUE FROM TABLE SEARCH
C         ISN    - INTERNAL STATEMENT NUMBER FOR THE CURRENT STATEMENT
C         ISTR   - EQUIVALENCED TO CSTR, INTEGER FORM USED TO PLACE
C                  THE STRING TOTAL LENGTH. EQUIVALENCED TO CSTR.
C         ISTRNM - CHARACTER VARIABLE, TABLE OF ALL NESTED STRUCTURES
C                  DEFINED IN THE MODULE BEING CURRENTLY PROCESSED. A
C                  MAXIMUM OF 7 NESTED STRUCTURE DEFINITIONS MAY OCCUR.
C                  EQUIVALENCED TO CSTRNM.
C         ISTRUC - COUNT OF THE NUMBER OF STRUCTURE NAMES IN TABLE CSTR
C         I1     - THE NUMBER OF MAP STATEMENTS OCCURRING WITHIN A
C                  SINGLE UNION DECLARATION
C         I2     - WORK VARIABLE
C         JMAP   - COUNT OF THE NUMBER OF MAP STATEMENTS OCCURRING
C                  UNDER THE A SINGLE UNION STATEMENT FOR A GIVEN NEST
C                  LEVEL OF THE UNION.
C         JSTR   - LENGTH OF A STRUCTURE STATEMENT WITH NESTING LEVEL
C                  JSTRUCT; EQUIVALENCED WITH CJSTR.
C         JSTRUC - COUNT OF THE NUMBER OF NESTED STRUCTURE NAMES IN
C                  TABLE ISTRNM
C         JUNION - COUNT OF THE NESTING LEVELS OF UNION STATEMENTS. ONE
C                  IS ADDED WHEN A UNION STATEMENT IS PROCESSED, ONE IS
C                  SUBTRACTED WHEN AN END UNION STATEMENT IS PROCESSED.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LSTRUC - LOGICAL VARIABLE, SET TRUE WHEN A STRUCTURE STATEMENT
C                  HAS BEEN FOUND, SET FALSE WHEN AN END STRUCTURE
C                  STATEMENT TERMINATES THE DEFINITION. THE END
C                  STRUCTURE WILL SET LSTRUC OFF ONLY WHEN THE LEVEL
C                  COUNT RETURNS TO ZERO.
C         LUNION - LOGICAL VARIABLE, SET TRUE WHEN UNION STATEMENTS ARE
C                  BEING PROCESSED, SET FALSE THE ALL UNION STATEMENTS
C                  WITHIN A NESTED CLUSTER HAVE COMPLETED PROCESSING.
C         MAPLEN - MAXIMUM SIZE OF A MAP DEFINITION.  SUBSCRIPT 1
C                  DESIGNATES THE UNION LEVEL, SUBSCRIPT 2 DESIGNATES
C                  THE MAP LEVEL.
C         MAXMAP - THE LARGEST MAP LENGTH OF THE MAP GROUPS OCCURRING
C                  WITHIN A SINGLE UNION RANGE
C
C     COMMENTS
C
C         A MAP STATEMENT MAY CONTAIN STRUCTURE, RECORD, MAP, AND TYPE
C         DEFINITIONS. A MAXIMUM OF 20 MAP STATEMENTS MAY OCCUR UNDER
C         A SINGLE UNION STATEMENT. A MAP STATEMENT MAY NOT OCCUR OUT-
C         SIDE OF AN ENCAPSULATING UNION STATEMENT AND MAY NOT BE
C         NESTED WITHIN A SINGLE UNION STATEMENT'S DOMAIN RANGE.
C
C     SUBROUTINES CALLED
C
C         ESTRUC EUNION EXPR ITOC LOCERR TABSRH
C
C     *****************************************************************
C
      SUBROUTINE PMAP
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
C     DIMENSION CJSTR(20), IJSTR( 9,1000), ISTR(9,1000), ISTRNM(9,20),
      DIMENSION CJSTR(20), ISTR(9,1000), ISTRNM(9,20),
     1JMAP(20), MAPLEN(20,20)
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*4     CJSTR
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      REAL*8          FCONFT, FP
C
C         COMMON STATEMENTS
C
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /MUS/ JMAP, MAPLEN
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (JSTR,CJSTR), (CSTRNM,ISTRNM), (ISTR,CSTR),
     1(CNAME(1),IENAME(1,1)), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' UNION HAS LESS THAN 2 MAP DEFINITIONS')
C
C     ******************************************************************
C     *                                                                *
C     *                     END MAP PROCESSING                         *
C     *                                                                *
C     ******************************************************************
C
C         INSURE ALL 20 MAP LENGTH WORK AREAS ARE SET TO ZERO FOR A NEW
C         NESTING LEVEL OF A UNION STATEMENT
C
C         DETERMINE IF THIS IS AN ARITHMETIC STATEMENT
C
      DO 10 I = 1,KB
      IF(CSTMT(I:I) .EQ. CEQ) THEN
         LSTART = LTRUE
         CALL EXPR (KF,KB,LFALSE,CSTMT)
         LEXEC = LTRUE
         GO TO 14
      END IF
 10   CONTINUE
      IF(JMAP(JUNION) .EQ. 0) THEN
         DO 11 I = 1,20
         MAPLEN(JUNION,I) = 0
 11      CONTINUE
      END IF
C
C         DETERMINE IF THE MAP STATEMENT OCCURS AFTER THE INITIAL
C         EXECUTABLE STATEMENT
C
      IF(LSTART) CALL LOCERR (LSTART,ISN,IREC0)
C
C         STEP THE MAP COUNTER FOR EACH MAP STATEMENT WITHIN THE RANGE
C         OF A UNION NESTING LEVEL
C
      JMAP(JUNION) = JMAP(JUNION) + 1
C     WRITE(13,701) JMAP(JUNION)
C701  FORMAT(' TRACE 701 PMAP  JMAP(JUNION) = ',I4)
      GO TO 14
C
C     ******************************************************************
C     *                   END UNION PROCESSING                         *
C     ******************************************************************
C
C         ENTRY POINT FOR END UNION PROCESSING
C
      ENTRY EUNION
C
C         DETERMINE IF AT LEAST TWO MAP STATEMENTS ARE ENCAPSULATED
C         WITHIN THIS UNION
C
      I1 = JMAP(JUNION)
      IF(I1 .LT. 2) THEN
         WRITE (0,100) ISN
         IREC0 = IREC0 + 1
      END IF
C
C         DETERMINE THE LARGEST MAP LENGTH FOR THE CURRENT UNION
C         STATEMENT
C
      MAXMAP = 0
      DO 12 I = 2,I1
      IF(MAPLEN(JUNION,I-1) .GT. MAPLEN(JUNION,I)) THEN
         MAXMAP = MAPLEN(JUNION,I-1)
      ELSE
         MAXMAP = MAPLEN(JUNION,I)
      END IF
 12   CONTINUE
C
C         ADD THE UNION SIZE TO ITS ENCAPSULATING STRUCTURE, IF ANY
C
      IF(JSTRUC .GT. 0) ISTRNM(9,JSTRUC) = ISTRNM(9,JSTRUC) + MAXMAP
C
C         IF THIS UNION BELONGS TO AN ENCAPSULATING STRUCTURE, ADD THE
C         UNION LENGTH TO THE STRUCTURE TOTAL LENGTH
C
      IF(JSTRUC .GT. 0) JSTR(JSTRUC) = JSTR(JSTRUC) + MAXMAP
C
C         RESET THE MAP COUNTER TO ZERO FOR THIS LEVEL OF THE UNION
C         STATEMENT
C
      JMAP(JUNION) = 0
      DO 13 I = 1,JUNION
      MAPLEN(JUNION,I) = 0
 13   CONTINUE
C
C         CORRECT NESTING LEVEL FOR THE UNION STATEMENTS AND EXIT
C
      JUNION = JUNION - 1
C
C         TURN OFF THE UNION SWITCH WHEN ALL UNION STATEMENTS HAVE BEEN
C         PROCESSED
C
C     IF(JUNION .LE. 0) LUNION = LFALSE
      GO TO 14
C
C     ******************************************************************
C     *                 END STRUCTURE PROCESSING                       *
C     ******************************************************************
C
C         ENTRY POINT FOR END STRUCTURE PROCESSING
C
      ENTRY ESTRUC
C
C         DETERMINE THE LOCATION OF THE STRUCTURE NAME IN THE TABLE
C
      CALL TABSRH (CSTR,ISTRUC,36,1,32,CSTRNM(JSTRUC),1,32,IRET,1000)
C
C         ADD THE LENGTH OF THE STRUCTURE TO ITS TABLE ENTRY IN INTEGER
C         FORMAT
C
      IF(IRET .GT. 0) ISTR(9,IRET) = JSTR(JSTRUC)
C
C         DETERMINE THE ENTRY FOR THE STRUCTURE NAME IN THE MASTER NAME
C         TABLE, AND ADD THE LENGTH IN CHARACTER FORM RATHER THAN IN
C         INTEGER FORM
C
      CALL TABSRH (CNAME,INAME,52,1,32,CSTRNM(JSTRUC),1,32,IRET,4000)
C
C         ADD THE LENGTH OF THE STRUCTURE TO THE MASTER NAME TABLE IN
C         ASCII TEXT FORMAT
C
      IF(IRET .GT. 0) THEN
         CALL ITOC (JSTR(JSTRUC),CNAME(IRET),38,44)
         CNAME(IRET)(37:37) = CQUES
      END IF
C
C         CREATE A RECORD ON UNIT 7 FOR THIS STRUCTURE NAME
C
      IF(.NOT.LINCL) THEN
         WRITE (7,REC=IREC7) CNAME(IRET)(1:52)
         IREC7 = IREC7 + 1
      END IF
C
C         ADD THE NESTED STRUCTURE LENGTH TO THE NEXT LOWER STRUCTURE
C         LEVEL LENGTH
C
      I2 = JSTRUC - 1
      IF(I .GT. 0) JSTR(I2) = JSTR(I2) + JSTR(JSTRUC)
C
C         BLANK THE CURRENT STRUCTURE NAME AT NESTING LEVEL JSTRUC AND
C         RESTORE THE LENGTH TO ZERO
C
      CSTRNM(JSTRUC)(1:36) = CBLK52(1:36)
      JSTR(JSTRUC) = 0
C
C         RESET STRUCTURE NESTING COUNTER
C
      JSTRUC = I2
C
C         WHEN ALL OF A NESTED STRUCTURE PROCESSING IS COMPLETE, SET
C         THE STRUCTURE PROCESSING SWITCH OFF
C
      IF(JSTRUC .LE. 0) LSTRUC = LFALSE
C
C         ROUTINE EXIT
C
 14   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL PRINT ALL OUTPUT LISTINGS
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CBUFF  - CHARACTER VARIABLE, USED TO COPY ERROR MESSAGES FROM
C                  UNIT 0 TO UNIT 6
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO CREATE THE
C                  DEFINITION RECORD OF A SUBPROGRAM. LENGTH IS
C                  1496 CHARACTERS
C         CDEF2  - CHARACTER VARIABLE, USED TO CREATE SECTION 2 OF CDEF.
C                  EQUIVALENCED TO IDEF2
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT SIZE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT SIZE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT SIZE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT SIZE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT SIZE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT SIZE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT SIZE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET, REPRESENTING THE FIRST
C                  CHARACTER OF A VARIABLE NAME.
C                  THESE CODES AND THEIR MEANINGS ARE:
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: F4; I - M: I4
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED WITH I2WK1
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CMA    - CHARACTER VARIABLE, EQUIVALENCED TO MA
C         CMB    - CHARACTER VARIABLE, EQUIVALENCED TO MB
C         CNAME  - CHARACTER VARIABLE, LIST OF ALL VARIABLE NAMES
C                  FOUND IN A PROGRAM OR SUBPROGRAM
C         COUTC  - CHARACTER VARIABLE, ARRAY OF INPUT-OUTPUT UNITS,
C                  EQUIVALENCED TO IOUTC
C         COUTV  - CHARACTER VARIABLE, ARRAY OF INPUT-OUTPUT UNITS
C                  DEFINED AS A VARIABLE
C         CPGNME - THE NAME OF THE PROGRAM BEING LISTED. IF A PROGRAM,
C                  SUBROUTINE, OR FUNCTION STATEMENT OCCUR, THIS IS
C                  THE NAME OF THE ROUTINE. IF NOTHING IS SPECIFIED,
C                  THE FIRST SIX CHARACTERS OF THE FILE NAME IS USED.
C         CPRINT - CHARACTER VARIABLE, FOR PRINTING A LIST OF SUB-
C                  PROGRAMS USED BY A ROUTINE
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CRECTB - TABLE OF RECORD VARIABLE NAMES AND THEIR LENGTH.
C                  A MAXIMUM OF 1000 RECORD VARIABLE NAME DEFINITIONS
C                  ARE ALLOWED.
C                  RECORD STRUCTURE:
C                  COLS.  1 - 32 STRUCTURE VARIABLE NAME
C                  COLS. 33 - 64 RECORD VARIABLE NAME
C                  COLS. 65 - 68 INTEGER VALUE OF THE LENGTH OF THE
C                                RECORD
C         CREC1M - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA
C         CREC1  - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA, FIRST 80 BYTES OF CREC1M
C         CREC14 - CHARACTER VARIABLE, DEFINES THE FIRST FOUR BYTES OF
C                  CREC1
C         CREC18 - CHARACTER VARIABLE, DEFINES THE FIRST EIGHT BYTES OF
C                  CREC1
C         CREC2M - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA, EQUIVALENCED TO CREC2
C         CREC2  - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA, FIRST 80 BYTES OF CREC2M
C         CREC24 - CHARACTER VARIABLE, DEFINES THE FIRST FOUR BYTES OF
C                  CREC2
C         CREC28 - CHARACTER VARIABLE, DEFINES THE FIRST EIGHT BYTES OF
C                  CREC2
C         CREC3M - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA
C         CREC3  - CHARACTER VARIABLE, A SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA
C         CREC34 - CHARACTER VARIABLE, DEFINES THE FIRST FOUR BYTES OF
C                  CREC3
C         CREC38 - CHARACTER VARIABLE, DEFINES THE FIRST EIGHT BYTES OF
C                  CREC3
C         CSTR   - TABLE OF ALL STRUCTURES DEFINED IN THE MODULE BEING
C                  CURRENTLY PROCESSED. A MAXIMUM OF 1000 UNIQUE
C                  STRUCTURES MAY OCCUR.
C                  RECORD STRUCTURE
C                  COLS  1 - 32 STRUCTURE NAME, CHARACTER VARIABLE
C                  COLS 33 - 36 INTEGER VALUE OF THE STRUCTURE'S TOTAL
C                               LENGTH
C         CSTMT  - CHARACTER VARIABLE, A CURRENT FORTRAN STATEMENT
C                  BEING ANALYZED
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   A - BYTE
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C         CVARND - CHARACTER VARIABLE, TABLE OF VARIABLE NAMES THAT
C                  ARE ARGUMENTS OF A CALL STATEMENT
C         CWK7   - CHARACTER VARIABLE, WORK AREA TO CREATE THE ASCII
C                  FORM OF THE LENGTH OF RECORD AND STRUCTURE VARIABLE
C                  NAMES
C         CWORK  - CHARACTER VARIABLE, SAVE AREA FOR THE SORT ROUTINE
C         CWK32  - CHARACTER VARIABLE, WORK AREA FOR A VARIABLE NAME
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         C1WK1  - CHARACTER VARIABLE, WORK AREA FOR CARRIAGE CONTROL
C         FCONFT - ARRAY OF ALL REAL CONSTANTS OCCURING IN THE PROGRAM
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - WORK AREA TO SORT THE STATEMENT NUMBERS INTO SEQUENCE
C         IC     - WORK AREA TO SORT THE ISNS OF STATEMENT NUMBERS
C         ICALKT - WORK AREA USED TO DETERMINE THE START LOCATION OF A
C                  SUBPROGRAM NAME IN THE PRINT LINE
C         ICONF  - COUNT OF THE NUMBER IF REAL CONSTANTS IN FCONFT
C         ICONI  - COUNT OF THE NUMBER OF INTEGER CONSTANTS IN ICONIT
C         ICONIT - TABLE OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM. WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C                  IT TO AN ALGEBRAIC NUMERIC VALUE
C         ICTN   - THE VALUE TO ADD TO AN ALPHABETIC NONNUMERIC
C                  CHARACTER TO CONVERT IT TO AN ALGEBRAIC NUMERIC VALUE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C                  IT IS 2 IF A TWO BYTE WORD IS BEING USED
C         IEOF   - RETURN VALUE IF THE IOSTAT PARAMETER FOR A READ
C                  STATEMENT, SET TO -1 ON END OF FILE CONDITION
C         IFLEN  - THE LENGTH OF A FIELD WITHIN THE RECORD TO BE SORTED;
C                  THIS VALUE MUST BE IN BYTES
C         IFNUM  - THE NUMBER OF DIFFERENT FLOATING POINT NUMBERS LISTED
C                  IN ROUTINE PRINTF
C         ILINE  - COUNT OF THE NUMBER OF LINES WRITTEN ON A PAGE
C         ILIT   - COUNT OF THE NUMBER OF LITERALS ON UNIT 9
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         INAMEP - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME THAT
C                  ARE PRINTED IN TABLE 1, THE LIST OF USED VARIABLES
C         INUM   - NUMBER OF UNIQUE LITERALS PRINTED IN PRINTL
C         IOUTC  - ARRAY OF INPUT-OUTPUT UNITS DEFINED AS AN INTEGER,
C                  EQUIVALENCED TO COUTC
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN CIOUTC
C         IOUTNV - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN COUTV
C         IPAGE  - PAGE COUNT
C         IPGNME - NUMBER OF CHARACTERS IN CPGNME, THE PROGRAM NAME
C         IREC   - ASSOCIATE VARIABLE TO POSITION THE DISK FILE FOR
C                  READING THE RECORDS TO BE SORTED
C         IRECD  - COUNT OF THE NUMBER OF RECORD DEFINITIONS
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IREC00 - COUNT OF ERROR MESSAGES NOT PRINTED
C         IREC3  - RECORD COUNT FOR UNIT 3
C         IREC4  - THE NUMBER OF RECORDS ON UNIT 4 (STATEMENT NUMBERS)
C         IREC7  - THE NUMBER OF RECORDS ON UNIT 7 (VARIABLE NAMES)
C         IREC8  - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 8 (INPUT-OUTPUT VARIABLE
C                  NAMES
C         IREC10 - THE NUMBER OF RECORDS ON UNIT 10
C         IREC11 - ASSOCIATE VARIABLE FOR READING AND WRITING DIRECT
C                  ADDRESS FILES ON UNIT 11 (COMMON DEFINITIONS)
C         IRET   - RETURN CODE OF TABLE SEARCH; >0 MATCH FOUND, CONTAINS
C                  TABLE INDEX OF MATCH, <0 NO MATCH FOUND, POSITIVE
C                  VALUE OF IRET IS WHERE THE NON MATCHING RECORD COULD
C                  BE INSERTED
C         IRET1  - RETURN CODE OF TABLE SEARCH; >0 MATCH FOUND, CONTAINS
C                  TABLE INDEX OF MATCH, <0 NO MATCH FOUND, POSITIVE
C                  VALUE OF IRET1 IS WHERE THE NON MATCHING RECORD COULD
C                  BE INSERTED
C         IRET2  - RETURN CODE OF TABLE SEARCH; >0 MATCH FOUND, CONTAINS
C                  TABLE INDEX OF MATCH, <0 NO MATCH FOUND, POSITIVE
C                  VALUE OF IRET2 IS WHERE THE NON MATCHING RECORD COULD
C                  BE INSERTED
C         ISNUM  - TABLE OF DEFINED STATEMENT NUMBERS FOUND IN THE
C                  PROGRAM; WORD 1 CONTAINS THE STATEMENT
C                  NUMBER VALUE, WORD 2 CONTAINS THE ISN DEFINING
C                  THE STATMENT NUMBER
C         ISNW   - LIST OF ALL ISNS WHERE A VARIABLE, STATEMENT NUMBER,
C                  ETC. OCCUR
C         ISTART - THE START LOCATION OF A FIELD WITHIN THE RECORD TO
C                  BE SORTED; THIS VALUE MUST BE IN BYTES
C         ISTRUC - COUNT OF THE NUMBER OF STRUCTURE STATEMENTS. THIS
C                  VALUE IS THE TOTAL NUMBER OF STRUCTURE STATEMENTS
C                  DEFINED IN TABLE CSTR.
C         ISUBKT - COUNT OF THE NUMBER OF SUBPROGRAM NAMES LISTED
C         IVARND - COUNT OF THE NUMBER OF ENTRIES IN TABLE CVARND
C         I2WK2  - WORK VARIABLE USED TO CONVERT ALPHABETIC CHARACTERS
C                  INTO A SUBSCRIPT VARIABLE VALUE
C         I4WK1  - WORK VARIABLE USED TO MOVE THE ISN FOR SORTS
C         J      - DO LOOP INDEX VARIABLE
C         JA     - SUBSCRIPT VARIABLE, USE TO WRITE A LIST OF SUBPROGRAM
C                  NAMES USED BY THE CURRENT PROGRAM MODULE
C         JB     - LOCATION IN THE PRINT LINE WHERE THE INITIAL
C                  CHARACTER OF A SUBPROGRAM NAME IS TO BE PLACED
C         JC     - LOCATION IN THE PRINT LINE WHERE THE FINAL CHARACTER
C                  OF A SUBPROGRAM NAME IS TO BE PLACED
C         JDIM   - NUMBER OF BYTES DEFINING THE SORT KEYS FOR MSORT
C         JE     - THE INPUT OUTPUT NUMERICAL UNIT FIELD IN CREC18(1:4)
C         JG     - THE ISN FIELD IN CREC18(5l8)
C         JLEN   - LOCATION OF THE END OF VARIABLE NAME IN AN ERROR
C                  MESSAGE
C         JLOC1  - COLS. 81 - 84 OF CREC1M
C         JLOC2  - COLS. 81 - 84 OF CREC2M
C         JUNIT  - THE INPUT UNIT TO BE USED IN PRINTING
C         KISN   - THE ISN OF THE VARIABLE CONTIANING THE 201st
C                  SUBROUTINE CALLED BY A SINGLE PROGRAM MODULE
C         LASC   - LOGICAL VARIABLE, SET TRUE IF A DESCENDING ORDER FOR
C                  A SORT FIELD IS DESIRED, SET FALSE FOR AN ASCENDING
C                  ORDER
C         LENDS  - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL END STATE-
C                  MENT OF A FORTRAN ROUTINE HAS BEEN READ. SET FALSE
C                  OTHERWISE; NOT THE END OF FILE FOR UNIT 5 OR AN
C                  INCLUDED FILE WHEN SET TRUE.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IS
C                  TO BE PERFORMED, SET FALSE OTHERWISE
C         LTEST  - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM
C                  STATEMENT (ENTRY, FUNCTION, OR SUBROUTINE) IS BEING
C                  PROCESSED, SET FALSE WHEN THE MAIN ROUTINE IS BEING
C                  PROCESSED. THIS ALLOWS OR PREVENTS WRITING GLOBAL
C                  ANALYSIS RECORDS ON UNIT 3.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A SINGLE VARIABLE
C                  NAME EXIST, BUT UNIT 7 HAS MORE THAN 2 RECORDS, SET
C                  FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE HEADER FOR A LIST
C                  OF SUBPROGRAM NAMES USED IN A FORTRAN MODULE HAS BEEN
C                  WRITTEN, SET FALSE OTHERWISE. THIS PREVENTS THE
C                  HEADER FROM BEING WRITTEN MORE THAN ONCE IN A LISTING
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A MESSAGE LIST EXISTS
C                  AND THE MESSAGES HEADER IS TO BE PRINTED AT THE START
C                  OF THE MESSAGES, SET FALSE OTHERWISE.
C         MA     - COMPARE FIELD FOR STATEMENT NUMBERS ON UNIT 4 WHEN
C                  ONLY TWO RECORDS EXIST
C         MB     - COMPARE FIELD FOR STATEMENT NUMBERS ON UNIT 4 WHEN
C                  ONLY TWO RECORDS EXIST
C         MVCNT  - NUMBER OF CHARACTERS IN CDEF(1:32), EQUIVALENCED TO
C                  CDEF(49:52)
C         NARGS  - NUMBER OF ARGUMENTS IN A SUBPROGRAM DEFINITION
C         NARGD  - NUMBER OF ARGUMENTS IN A SUBPROGRAM STATEMENT
C         NARGM  - NUMBER OF ARGUMENTS IN A SUBPROGRAM STATEMENT
C         MNUM   - COUNT OF THE NUMBER OF ENTRIES INTO TABLE OF STATE-
C                  MENT NUMBERS, ISNUM
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C         NREC   - THE NUMBER OF RECORDS IN A WORK FILE
C
C     INPUT-OUTPUT UNITS USED
C
C         3      - LIST OF ALL DEFINED SUBPROGRAMS THAT CAN BE CALLED.
C                  EVERY SUBROUTINE, ENTRY, AND DEFINED FUNCTION
C                  SUBPROGRAM HAS A SINGLE RECORD ON THIS FILE. THE
C                  RECORD CONTAINS A LIST AND DEFINITION OF UP TO 30
C                  ARGUMENTS OF THE SUBPROGRAM. INTRINISIC FUNCTIONS
C                  USED ARE NOT IN THIS FILE. EACH RECORD IS 1496
C                  CHARACTERS. THIS IS A GLOBAL RECORD AND EXTENDS
C                  BEYOND A SINGLE SUBPROGRAM.
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C         6      - THE LISTING FILE TO BE PRINTED
C         7      - THE VARIABLE NAMES AND THE ISNS WHERE THEY OCCUR,
C                  RECORD LENGTH IS 52 CHARACTERS
C         8      - VARIABLE INPUT-OUTPUT UNIT NAMES, RECORD LENGTH IS 8
C                  CHARACTERS
C         9      - LITERALS AND THE ISNS WHERE THEY OCCUR, RECORD LENGTH
C                  IS 88 CHARACTERS
C        11      - COMMON DEFINITIONS FOR NAMED AND BLANK COMMON,
C                  RECORD LENGTH IS 36 CHARACTERS
C
C     COMMENTS
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE.
C
C         THE LISTINGS PRODUCED BY THIS PROGRAM ARE DESIGNED FOR
C         VERTICAL PAPER ORIENTATION, 8.5 X 11 INCHES, USING 8 POINT
C         SIZED TYPE.  THIS PROVIDES 15 CHARACTERS PER INCH AND 90
C         LINES PER PRINTED PAGE. A MAXIMUM OF 120 CHARACTERS PER LINE
C         ARE ALLOWED.
C
C         EXCEPT WHEN A POSTSCRIPT OUTPUT LISTING IS CHOSEN, EACH
C         PRINT LINE CONTAINS A CARRIAGE CONTROL CHARACTER IN
C         COLUMN ONE OF THE OUTPUT LISTING RECORD.  STANDARD FORTRAN
C         CARRIAGE CONTROL CHARACTERS ARE USED.
C
C     SUBROUTINES CALLED
C
C         BTEST DSORT ITOC MFSORT MISORT MSORT PCOMM PRINTC PRINTF
C         PRINTI PRINTL PRINTS PRINTV PRTVIO TABINS TABSRH TBLSRH
C
C     ******************************************************************
C
      SUBROUTINE LIST
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CDEF2(30), IDEF2(12,30), IDEF(374)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION IPARAM(13,4000)
C
C         DIMENSION STATEMENTS FOR THIS ROUTINE ONLY
C
      DIMENSION CREC14(2), CREC24(2), CREC34(2)
      DIMENSION COUTC(100), CVARND(1000)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST, CBUFF
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*72    CVARST
      CHARACTER*80    CIFILE
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*48    CDEF2
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CVARND, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*4     COUTC
      CHARACTER*2     CI2WK1, CI2WK2
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1, I2WK2
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
      LOGICAL*1       L1, L2, L3
C
C         TYPE STATEMENTS FOR THIS ROUTINE ONLY
C
      CHARACTER*121 CPRINT
      CHARACTER*92  CREC1M, CREC2M, CREC3M
      CHARACTER*80  CLIT
      CHARACTER*52  CREC1, CREC2, CREC3
      CHARACTER*8   CREC18, CREC28, CREC38
      CHARACTER*4   CREC14, CREC24, CREC34
      CHARACTER*4   CWRKX, CMA, CMB
      CHARACTER*4   CI4WK1
      CHARACTER*1   C1WK1, CTYPE
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (CWORK(45:48),
     1JBITS), (CNAME,IENAME), (CREC3,CWORK), (CI4WK1,I4WK1),
     2(CDEF(1:1),IDEF(1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         EQUIVALENCE STATEMENTS FOR THIS ROUTINE ONLY
C
      EQUIVALENCE (CREC1M,CREC1,CREC18,CREC14), (CREC2M,CREC2,CREC28,
     1            CREC24), (CREC3M,CREC3,CREC38,CREC34)
      EQUIVALENCE (CLITWK(81:84),ILOC1), (CLITWK(85:88),ILOC2),
     1            (CLITWK(1:80),CLIT(1:80))
      EQUIVALENCE (CREC1M(81:84),JLOC1), (CREC2M(81:84),JLOC2)
      EQUIVALENCE (JWORK,CWRKX), (NLINE,ILINE), (CMA,MA), (CMB,MB)
      EQUIVALENCE (CREC1(33:36),J1ISN), (CREC1(33:36),J2ISN)
      EQUIVALENCE (COUTC(1),IOUTC(1))
      EQUIVALENCE (CREC18(1:4),JE), (CREC18(5:8),JG), (CREC28(1:4),JH),
     1            (CREC28(5:8),JI)
      EQUIVALENCE (CDEF(53:56),NARGD), (CDEF(33:36),JSNU),
     1            (CDEF(49:52),MVCNT)
      EQUIVALENCE (CDEF(57:57),CDEF2,IDEF2)
      EQUIVALENCE (CPARAM,IPARAM)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(A1,'STATISTICS FOR ROUTINE:',1X,A32/'0COUNTS;    VARIABLE N
     1AMES:',I5,'; STATEMENT NUMBERS:',I5,'; INPUT-OUTPUT UNITS, CONSTAN
     2T:',I5,'; VARIABLE:',I5,/5X,' INTEGER CONSTANTS:',I5,'; REAL CONST
     3ANTS:',I5,'; CHARACTER CONSTANTS:',I5,'; SUBPROGRAMS CALLED:',I5)
 101  FORMAT('0MESSAGES')
 102  FORMAT(121A1)
 104  FORMAT(A1,'SUBPROGRAMS USED BY THIS ROUTINE'/)
 105  FORMAT(1X,A121)
 106  FORMAT(' ISN:',I6,' UNDEFINED TYPE FOR VARIABLE: ',A32)
C
C     *****************************************************************
C     *                                                               *
C     *        INSURE ALL VARIABLE NAMES IN ARRAY CNAME HAVE          *
C     *        DEFINED TYPE AND LENGTH CHARACTERISTICS                *
C     *                                                               *
C     *****************************************************************
C
C
C         WHEN THE TYPE AND LENGTH CHARACTERISTICS ARE BLANK, THEY ARE
C         EITHER DIMENSIONED VARIABLES NOT USED IN A SUBPROGRAM, OR A
C         SUBPROGRAM NAMED DEFINED BY AN EXTERNAL STATEMENT AND IS NOT
C         PART OF INPUT FROM UNIT 5.
C
      J = 1
      DO WHILE (J .LE. INAME)
      IF(CNAME(J)(38:44) .EQ. CBLANK(1:7)) THEN
C
C         DETERMINE IF THE VARIABLE IN CNAME IS DIMENSIONED OR A
C         FUNCTION
C
         IF(BTEST(IENAME(12,J),17) .OR. BTEST(IENAME(12,J),10)) THEN
            CWORK(1:52) = CBLK52(1:52)
            CWORK(1:32) = CNAME(J)(1:32)
            CALL SETTL (CWORK)
            CNAME(J)(37:44) = CWORK(37:44)
         END IF
      END IF
      J = J + 1
      END DO
C
C         SET THE LISTING PROGRAM NAME IF NOT ALREADY CREATED
C
      CFMTH(64:95) = CPGNME(1:32)
      IVARND = 0
C
C         CORRECT RECORD COUNTS
C
      IF(IREC7 .GT. 1) IREC7 = IREC7 - 1
      IF(IREC8 .GT. 1) IREC8 = IREC8 - 1
      IF(IREC11 .GT. 0) IREC11 = IREC11 - 1
C
C         VERIFY ALL INTRINSIC FUNCTIONS USED HAVE THE CORRECT TYPE
C         AND LENGTH CHARACTERISTICS WHEN THEY ARE NOT SET CORRECTLY
C         BY THE PROCESSING ROUTINES.
C
C
C     *****************************************************************
C     *                                                               *
C     *         UNIT 7 VARIABLE CHARACTERISTICS VERIFICATION          *
C     *                                                               *
C     *****************************************************************
C
C         SCAN ALL VARIABLE NAMES ON FORTRAN UNIT 7 TO INSURE THE
C         CORRECT TYPE AND LENGTH CHARACTERISTIC ARE SET FOR UNIT 7
C         RECORDS. THIS INSURES THE SORT OF UNIT 7 RECORDS WILL BE
C         CORRECT FOR SUBROUTINE PRINTV. VARIABLE CNAME CONTAINS THE
C         CORRECT CHARACTERISTICS.
C
      IF(IREC7 .GT. 1) THEN
         DO 10 I = 1,IREC7
         READ (7,REC=I) CWORK
      JWORK = IWORK - 128
C
C         DETERMINE IF THE VARIABLE IS DEFINED WITHIN A STRUCTURE
C
         IF(BTEST(JBITS,6)) THEN
            CALL TBLSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         ELSE
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
         END IF
         IF(IRET .LT. 0 .OR. CWORK(37:44) .EQ. CBLANK(1:8)) THEN
            CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET,4000)
C
C         WHEN IRET IS GREATER THAN ZERO, THEN THERE IS A SINGLE ENTRY
C         IN CNAME. IF THE TYPE AND LENGTH CHARACTERISTICS IN CWORK
C         ARE DIFFERENT FROM THAT IN CNAME, FORCE CWORK TO MATCH THE
C         DEFINITIONS IN CNAME.
C
            IF(IRET .GT. 0) THEN
               IF(CNAME(IRET)(37:37) .NE. CBAR)  CWORK(37:44) =
     1            CNAME(IRET)(37:44)
               WRITE (7,REC=I) CWORK
            ELSE
               GO TO 10
            END IF
         ELSE IF(IRET .GT. 0) THEN
            CWORK(37:44) = CNAME(IRET)(37:44)
            WRITE (7,REC=I) CWORK
         END IF
C
C         DETERMINE IF THE UNIT 7 RECORD IS A STRUCTURE DEFINITION
C
         IF(BTEST(JBITS,13)) THEN
            IF(IRET .LT. 0) THEN
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
               IF(IRET1 .GT. 0) CWORK(37:44) = CNAME(IRET1)(37:44)
            ELSE
               IF(CNAME(IRET)(37:44) .NE. CWORK(37:44)) THEN
C
C         INSURE ANY VARIABLE NAME WITH TYPE AND LENGTH CHARACTERISTICS
C         FROM UNIT 7 DIFFERING FROM THAT IN CNAME ARE SET TO THE CNAME
C         VALUES. VARIABLES OCCURRING IN THE SOURCE FORTAN CODE PRIOR
C         TO TYPE STATEMENTS WILL REQUIRE THIS CORRECTION IF THEY ARE
C         NOT USED IN A MAP OR STRUCTURE STATEMENT. ONLY VARIABLES USED
C         OR DEFINED IN A MAP OR STRUCTURE DEFINITION MAY HAVE DIFFERENT
C         TYPE AND LENGTH CHARACTERISTICS FOR A VARIABLE NAME.
C
                  IF(BTEST(IENAME(12,IRET),5) .OR.
     1               BTEST(IENAME(12,IRET),6)) THEN
                     CWORK(37:44) = CNAME(IRET)(37:44)
                     WRITE (7,REC=I) CWORK
                     GO TO 10
                  END IF
               END IF
            END IF
         END IF
C
C         THE VARIABLE IS NOT IN A STRUCTURE; DETERMINE IF THE
C         VARIABLE NAMES ARE THE SAME.
C
         IF(CNAME(IRET)(1:32) .EQ. CWORK(1:32) .AND.
     1      .NOT.BTEST(JBITS,13)) THEN
C
C         DETERMINE IF THE VARIABLE NAME FROM UNIT 7 MATCHING THE
C         MASTER TABLE NAME HAS IDENTICAL BIT SWITCH SETTINGS WHEN
C         IT IS AN ENTRY, FUNCTION, OR SUBROUTINE DEFINITION.
C
            IF(CWORK(37:37) .EQ. CBAR .AND. CNAME(IRET)(37:37) .EQ.
     1         CBAR .AND. CWORK(45:48) .EQ. CNAME(IRET)(45:48))
     2         GO TO 10
C
C         DETERMINE IF THE VARIABLE NAME FROM UNIT 7 DEFINES A
C         FUNCTION
C
            IF(CWORK(37:37) .EQ. CBAR .OR. CWORK(37:37) .EQ.
     1         CBLANK(1:1)) THEN
               CWORK(37:44) = CNAME(IRET)(37:44)
C              IF(BTEST(IENAME(12,IRET),9)) THEN
C                 JBITS = IBSET(JBITS,10)
C                 JBITS = IBCLR(JBITS,9)
C                 IENAME(12,IRET) = JBITS
C              END IF
               WRITE (7,REC=I) CWORK
            END IF
C
C         DETERMINE IF THE BIT SWITCHES ARE SET CORRECTLY
C
            IF(CWORK(45:48) .NE. CNAME(IRET)(45:48)) THEN
C
C         WHEN THE VARIABLE NAME IS AN ARGUMENT IN A CALL STATEMENT AND
C         IT IS USED ELSEWHERE WHITHIN THE SUBPROGRAM MODULE, PLACE ITS
C         NAME IN THE CVARND TABLE. THIS TABLE IS USED TO DETERMINE IF
C         ANY CALL ARGUMENT VARIABLE NOT FOUND MESSAGE NEEDS TO BE
C         SUPPRESSED.
C
               IF(BTEST(IENAME(12,IRET),20) .AND. .NOT.BTEST(JBITS,20))
     1            THEN
                  CALL TABINS (CVARND,IVARND,32,1,32,CWORK,1,32,IRETA,
     1                         1000)
               END IF
               CWORK(45:48) = CNAME(IRET)(45:48)
               WRITE (7,REC=I) CWORK
            END IF
         END IF
 10      CONTINUE
      END IF
C
C         INSURE ALL ARGUMENTS OF A SUBPROGRAM DEFINITION IN CDEF HAVE
C         THE CORRECT TYPE AND LENGTH CHARACTERISTICS SPECIFIED FOR THE
C         CURRENT ENTRY, FUNCTION, OR SUBROUTINE. THIS IS NECESSARY,
C         BECAUSE AN ENTRY, FUNCTION, OR SUBROUTINE IDENTIFIES ONLY THE
C         DUMMY VARIABLE NAMES, AND NO TYPE OR LENGTH CHARACTERISTICS
C         ARE KNOWN WHEN THE SUBPROGRAM STATEMENT IS PROCESSED. THE MAIN
C         PROGRAM WILL NOT BE ENTERED ON UNIT 3, SINCE IT CAN HAVE NO
C         ARGUMENTS AND CAN NEVER BE CALLED BY A CALL STATEMENT.
C
      IF(LGLOBL .AND. LTEST) THEN
C
C         WHEN THE CURRENT SUBPROGRAM IS BLOCK COMMON, DO NOT CREATE A
C         A RECORD ON UNIT 3.
C
         IF(CFMTH(64:73) .EQ. 'BLOCK DATA') THEN
            IDEF(13) = 10
            GO TO 13
         END IF
C
C         SET THE LOOP TO PROCESS ALL DEFINED ARGUMENTS
C         SET THE NUMBER OF ARGUMENTS OF THE DEFINED SUBPROGRAM
C
C         IF ARGUMENTS EXIST FOR THE SUBROUTINE OR FUNCTION STATEMENT,
C         SET THE DATA TYPE AND LENGTH AND THE BIT SWITCHES FOR ALL
C         ARGUMENTS
C
         IF(NARGM .GT. 0) THEN
            DO 11 I = 1,NARGM
            CALL TABSRH (CNAME,INAME,52,1,32,CDEF2(I),1,32,IRET,4000)
            IF(IRET .GT. 0) THEN
C
C         WHEN AN ARGUMENT OF THE CURRENT SUBPROGRAM IS A COMMON BLOCK
C         NAME, DETERMINE IF THE PRECEDING ENTRY IN TABLE CNAME HAS THE
C         SAME VARIABLE NAME THAT IS NOT A COMMON BLOCK NAME.
C
               IF(CNAME(IRET)(37:37) .EQ. CBAR) THEN
                  IF(CNAME(IRET-1)(1:32) .EQ. CNAME(IRET)(1:32)) THEN
                     CDEF2(I)(33:40) = CNAME(IRET-1)(37:44)
                     CDEF2(I)(41:44) = CNAME(IRET-1)(45:48)
                     IDEF2(12,I) = IENAME(13,IRET-1)
                  ELSE
                     CDEF2(I)(33:40) = CNAME(IRET)(37:44)
                     CDEF2(I)(41:44) = CNAME(IRET)(45:48)
                     IDEF2(12,I) = IENAME(13,IRET)
                  END IF
               ELSE
C
C         WHEN THE LENGTH CHARACTERISTIC IS (*), THE DEFINITION LENGTH
C         OF A SUBPROGRAM'S ARGUMENT IN INHERITED AND IS NOT KNOW
C         UNTIL EXECUTION.
C
                  IF(CNAME(IRET)(38:40) .EQ. '(*)') CDEF2(I)(33:40) =
     1               CNAME(IRET)(37:44)
C
C         WHEN THE LENGTH CHARACTERISTIC DEFINED IS DIFFERENT THAN
C         THAT IN CNAME, CORRECT THE LENGTH IN CDEF2 TO MATCH THE
C         VALUE IN CNAME
C
                  IF(CNAME(IRET)(38:44) .NE. CDEF2(I)(34:40))
     1               CDEF2(I)(34:40) = CNAME(IRET)(38:44)
C
C         DETERMINE IF THE TYPE CODE OF THE DEFINITION FILE IS
C         DIFFERENT FROM THAT IN CNAME
C
                  IF(CNAME(IRET)(37:37) .NE. CDEF2(I)(33:33)) THEN
                     IF(CNAME(IRET)(37:37) .NE. CBLANK(1:1))
     1                  CDEF2(I)(33:33) = CNAME(IRET)(37:37)
                  END IF
               END IF
            ELSE
               I2WK1 = 0
               IF(CDEF2(I)(1:1) .EQ. CUNDER) THEN
                  I2WK1 = 27
               ELSE
                  CI2WK1(1:1) = CDEF2(I)(1:1)
                 I2WK1 = I2WK1 - ICTN
               END IF
               CDEF2(I)(33:40) = CIMPL(I2WK1)(1:8)
            END IF
 11         CONTINUE
            IDEF(14) = NARGM
         ELSE
            IDEF(14) = 0
         END IF
C
C         INSURE THE VARIABLE LENGTH NAME IS CORRECT
C
         DO IA = 32,1,-1
         IF(CDEF(IA:IA) .NE. CBLANK(1:1)) THEN
            MVCNT = IA
            GO TO 12
         END IF
         END DO
C
C         SAVE THE SUBPROGRAM NAME DEFINITION RECORD ON UNIT 3 FOR
C         ARGUMENT CHECKING AND DIAGNOSIS ONLY IF THE ISN IS 1.
C
 12      IF(CDEF(1:1) .NE. CBLANK(1:1)) THEN
            IREC3 = IREC3 + 1
            WRITE (3,REC=IREC3) CDEF(1:1496)
         END IF
      END IF
C
C         SCAN THE LIST OF ALL VARIABLE NAMES AND SET THEIR TYPE AND
C         LENGTH CHARACTERISTICS FROM THE IMPLICIT STATEMENT DEFINITIONS
C         IF THEY ARE NOT ALREADY SPECIFIED.
C
 13   L1 = LFALSE
      L2 = LFALSE
      I4WK1 = 0
      DO 14 I = 1,INAME
      I2WK2 = 0
C
C         DETERMINE IF THE VARIABLE NAME IS A RECORD VARIABLE AND NO
C         LENGTH HAS BEEN DEFINED
C
      IF(BTEST(IENAME(12,I),2) .AND. CNAME(I)(38:44) .EQ. CBLANK(1:7))
     1   THEN
C
C         DETERMINE THE LOCATION IN THE RECORD TABLE
C
         CALL TABSRH (CRECTB,IRECD,68,33,64,CNAME(I),1,32,IRET,1000)
         IF(IRET .GT. 0) THEN
C
C         DETERMINE IF A LENGTH IS DEFINED FOR THE VARIABLE IN THE
C         RECORD TABLE
C
            IF(CRECTB(IRET)(65:68) .EQ. CBLANK(1:4)) THEN
C
C         IF NO LENGTH IS DEFINED, OBTAIN IT FROM THE STRUCTURE DEFINING
C         THE RECORD VARIABLE
C
               CALL TABSRH (CSTR,ISTRUC,36,1,32,CNAME(I),1,32,IRET1,
     1                      1000)
               IF(IRET1 .GT. 0) THEN
                  CI4WK1(1:4) = CSTR(IRET1)(33:36)
                  CWK7(1:7) = CBLANK(1:7)
                  CALL ITOC (I4WK1,CWK7,1,7)
                  CNAME(IRET)(38:44) = CWK7(1:7)
                  CALL TABSRH (CSTR,ISTRUC,36,1,32,CNAME(I),1,32,IRET2,
     1                         1000)
                  IF(IRET2 .GT. 0) CNAME(IRET2)(38:44) = CWK7(1:7)
               END IF
            ELSE
C
C         WHEN A LENGTH EXISTS IN THE RECORD TABLE FOR THE VARIABLE,
C         PLACE IT IN THE VARIABLE NAME AND VARIABLE PRINT TABLES
C
               CI4WK1(1:4) = CRECTB(IRET)(65:68)
               CWK7(1:7) = CBLANK(1:7)
               CALL ITOC (I4WK1,CWK7,1,7)
               CNAME(IRET)(38:44) = CWK7(1:7)
               CALL TABSRH (CSTR,ISTRUC,36,1,32,CNAME(I),1,32,IRET2,
     1                         1000)
               IF(IRET2 .GT. 0) CNAME(IRET2)(38:44) = CWK7(1:7)
            END IF
         END IF
      END IF
C
C         DETERMINE IF A VARIABLE NAME IS NOT A SUBPROGRAM NAME, AN
C         ENTRY NAME, BUT IS A FUNCTION NAME
C
      IF(.NOT.BTEST(IENAME(12,I),8) .AND. .NOT.BTEST(IENAME(12,I),9)
     1.AND. BTEST(IENAME(12,I),10)) THEN
C
C         DETERMINE IF A VARIABLE NAME MATCHES AN IMPLICIT SPECIFIC-
C         ATION AND HAS NOT HAD ITS TYPE SET YET
C
         IF(CNAME(I)(37:37) .EQ. CBLK52(1:1)) THEN
            CI2WK2(IDXE:IDXE) = CNAME(I)(1:1)
            IF(CNAME(I)(1:1) .EQ. CUNDER) THEN
               I2WK2 = 27
            ELSE
               I2WK2 = I2WK2 + ICTN
            END IF
            CNAME(I)(37:44) = CIMPL(I2WK2)(1:8)
C
C         DETERMINE IF AN IMPLICIT DEFINITION EXISTS FOR THIS VARIABLE
C
            IF(CIMPL(I2WK2)(1:8) .EQ. CBLANK(1:8)) THEN
               CI4WK1(1:4) = CNAME(I)(33:36)
               I4WK1 = I4WK1 - 128
               WRITE (0,106) I4WK1,CNAME(I)(1:32)
               IREC0 = IREC0 + 1
            END IF
         END IF
      END IF
C
C         DETERMINE IF A VARIABLE NAME IS NOT A SUBPROGRAM NAME, AN
C         ENTRY NAME, OR A FUNCTION NAME
C
 14   CONTINUE
C
C         TEST IF ANY VARIABLE NAMES EXIST THAT ARE TO BE PRINTED
C
      IF(INAME .EQ. 0) GO TO 17
C
C         TEST IF THERE IS A SINGLE VARIABLE NAME
C
      IF(INAME .EQ. 1 .AND. IREC7 .EQ. 1) GO TO 16
C
C         TEST IF THERE ARE TWO VARIABLES ONLY
C
      IF(INAME .EQ. 2) THEN
         IF(IREC7 .EQ. 2) THEN
            READ (7,REC=1) CREC1
            READ (7,REC=2) CREC2
            IF(CREC1(1:32) .GT. CREC2(1:32)) THEN
               WRITE (7,REC=1) CREC2
               WRITE (7,REC=2) CREC1
               GO TO 16
            ELSE
               IF(IREC7 .LE. 2) GO TO 16
            END IF
         END IF
      END IF
C
C         SET SORT PARAMETERS FOR THE VARIABLE NAMES ARRAY USAGE LIST
C         ON UNIT 7
C
      IF(INAME .GT. 2 .OR. IREC7 .GT. 2) THEN
C
C         DETERMINE IF ONLY UNIT 7 IS TO BE SORTED
C
         IF(L1) THEN
            L1 = LFALSE
            GO TO 16
         END IF
C
C         TEST IF TWO VARIABLE NAMES OCCUR ON UNIT 7
C
         IF(IREC7 .EQ. 2) THEN
            READ (7,REC=1) CREC1
            READ (7,REC=2) CREC2
            IF(CREC1(1:32) .GT. CREC2(1:32)) THEN
               WRITE (7,REC=1) CREC2
               WRITE (7,REC=2) CREC1
               GO TO 16
            ELSE
               GO TO 16
            END IF
         END IF
C
C         SET UP SORT FOR UNIT 7 FOR MORE THAN 3 VARIABLES NAMES
C
         DO 15 I = 1,5
         ISTART(I) = 0
         IFLEN(I) = 0
         LASC(I) = LFALSE
         CTYPE(I) = CBLANK(1:1)
 15      CONTINUE
C
C         SET SORT PARAMETERS FOR THE VARIABLE NAMES REFERENCED WHICH
C         ARE LOCATED ON UNIT 7. MAJOR FIELD IS THE VARIABLE NAME;
C         FIRST MINOR FIELD IS ISN; SECOND MINOR FIELD IS FIELD LENGTH.
C
         JUNIT = 7
         IRECL = 52
         NREC = IREC7
         ISTART(1) = 1
         IFLEN(1) = 32
         CTYPE(1) = CCC
         LASC(1) = LFALSE
         ISTART(3) = 33
         IFLEN(3) = 4
         CTYPE(3) = CII
         LASC(3) = LFALSE
         ISTART(2) = 37
         IFLEN(2) = 8
         CTYPE(2) = CCC
         LASC(2) = LFALSE
C
C         SORT THE VARIABLE NAMES ON FORTRAN UNIT 7 INTO ASCENDING
C         SEQUENCE; ISN WITHIN VARIABLE NAME
C
         IF(NREC .GT. 2) CALL DSORT (JUNIT,IRECL,NREC,3)
      END IF
C
C         PRINT THE VARIABLE NAME CROSS REFERENCE LISTING
C
 16   CALL PRINTV
C
C         TEST IF ANY STATEMENTS NUMBERS EXIST
C
 17   IF(MNUM .EQ. 0) GO TO 18
C
C         SORT THE STATEMENT NUMBERS IN ARRAY ISNUM INTO NUMERICAL
C         ASCENDING SEQUENCE; THIS IS A LIST OF ALL STATEMENT NUMBERS
C         OCCURING IN THE PROGRAM OR SUBPROGRAM.
C
      IF(MNUM .GT. 2) THEN
         CALL MISORT (ISNUM,MNUM,2,1000)
      ELSE
         IF(MNUM .EQ. 2) THEN
            IF(ISNUM(1,1) .GT. ISNUM(1,2)) THEN
               IA = ISNUM(1,2)
               IB = ISNUM(2,2)
               ISNUM(1,2) = ISNUM(1,1)
               ISNUM(2,2) = ISNUM(2,1)
               ISNUM(1,1) = IA
               ISNUM(2,1) = IB
            END IF
            IF(ISNUM(1,1) .EQ. ISNUM(1,2)) THEN
               IF(ISNUM(2,1) .GT. ISNUM(2,2)) THEN
                  IB = ISNUM(2,2)
                  ISNUM(2,2) = ISNUM(2,1)
                  ISNUM(2,2) = IB
               END IF
            END IF
            GO TO 18
         END IF
      END IF
C
C         SET SORT PARAMETERS FOR STATEMENT NUMBERS LOCATED ON UNIT 4
C
 18   IF(IREC4 .EQ. 1) GO TO 20
C
C         TWO RECORD CASE
C
      IF(IREC4 .EQ. 2) THEN
         READ (4,REC=1) CREC18
         READ (4,REC=2) CREC28
         CMA(1:4) = CREC18(1:4)
         CMB(1:4) = CREC28(1:4)
         IF(MB .LT. MA) THEN
            WRITE (4,REC=1) CREC28
            WRITE (4,REC=2) CREC18
         END IF
         GO TO 20
      END IF
C
C         MORE THAN TWO RECORDS EXIST ON UNIT 4
C
      DO 19 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 19   CTYPE(I) = CBLANK(1:1)
      JUNIT = 4
      IRECL = 8
      NREC = IREC4
      ISTART(1) = 1
      IFLEN(1) = 4
      CTYPE(1) = CII
      LASC(1) = LFALSE
      ISTART(2) = 5
      IFLEN(2) = 4
      CTYPE(2) = CII
      LASC(2) = LFALSE
C
C         SORT THE STATEMENT NUMBER CROSS REFERENCES ON FORTRAN UNIT 4
C         INTO ASCENDING SEQUENCE; ISN WITHIN STATEMENT NUMBER
C
      IF(IREC4 .GT. 1) CALL DSORT (JUNIT,IRECL,NREC,2)
C
C         PRINT THE STATEMENT NUMBER CROSS REFERENCE LISTING
C
 20   IF(IREC4 .EQ. 0 .AND. MNUM .EQ. 0) GO TO 21
      CALL PRINTS
C
C         TEST IF ANY NUMERIC INPUT-OUTPUT UNITS EXIST
C
 21   IF(IOUTNC .EQ. 0) GO TO 25
C
C         A SINGLE INPUT-OUTPUT UNIT EXITS IN IOUTC
C
      IF(IOUTNC .EQ. 1) THEN
C
C         DETERMINE IF ONLY A SINGLE RECORD EXISTS ON UNIT 8
C
         IF(IREC8 .EQ. 1) GO TO 24
C
C         DETERMINE IF TWO RECORDS EXIST ON UNIT 8
C
         IF(IREC8 .EQ. 2) THEN
            READ (8,REC = 1) CREC18(1:10)
            READ (8,REC = 2) CREC28(1:10)
            IF(JE .GT. JH) THEN
               WRITE (8,REC = 1) CREC2(1:10)
               WRITE (8,REC = 2) CREC1(1:10)
            END IF
            GO TO 24
         END IF
         GO TO 24
      END IF
C
C         TWO INPUT-OUTPUT UNITS IN IOUTC EXIST
C
      IF(IOUTNC .EQ. 2) THEN
         IF(IOUTC(1) .GT. IOUTC(2)) THEN
            I2WK1 = IOUTC(1)
            IOUTC(1) = IOUTC(2)
            IOUTC(2) = I2WK1
         END IF
         IF(IREC8 .EQ. 1) GO TO 24  ! ERROR
         IF(IREC8 .EQ. 2) THEN
            READ (8,REC = 1) CREC18(1:10)
            READ (8,REC = 2) CREC28(1:10)
            IF(JE .GT. JH) THEN
               WRITE (8,REC = 1) CREC2(1:10)
               WRITE (8,REC = 2) CREC1(1:10)
            END IF
            GO TO 24
         END IF
      END IF
C
C         SET SORT PARAMETERS FOR THE NUMERIC INPUT-OUTPUT UNITS LIST
C         IN IOUTC
C
      DO 22 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 22   CTYPE(I) = CBLANK(1:1)
      ISTART(1) = 1
      IFLEN(1) = 1
      CTYPE(1) = CII
C
C         SORT THE NUMERIC INPUT-OUTPUT UNITS ARRAY COUTC INTO NUMERIC
C         ASCENDING SEQUENCE; THIS IS A LIST OF ALL INPUT-OUTPUT NUMERIC
C         UNITS OCCURING IN THE PROGRAM OR SUBPROGRAM.
C
      IF(IOUTNC .GT. 2) CALL MSORT (COUTC,IOUTNC,4,100,1)
C
C         SET SORT PARAMETERS FOR THE NUMERIC INPUT-OUTPUT UNITS USAGE
C         SAVED ON UNIT 8
C
      DO 23 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 23   CTYPE(I) = CBLANK(1:1)
      JUNIT = 8
      IRECL = 10
      NREC = IREC8
      ISTART(1) = 1
      IFLEN(1) = 4
      CTYPE(1) = CII
      LASC(1) = LFALSE
      ISTART(2) = 5
      IFLEN(2) = 4
      CTYPE(2) = CII
      LASC(2) = LFALSE
      CI2WK1(1:2) = CBLANK(1:2)
C
C         SORT THE VARIABLE NAME INPUT-OUTPUT UNITS ON FORTRAN UNIT 8
C         INTO ASCENDING SEQUENCE; ISN WITHIN UNIT
C
      IF(IREC8 .GT. 2) CALL DSORT (JUNIT,10,NREC,2)
C
C         PRINT THE NUMERIC INPUT-OUTPUT UNITS CROSS REFERENCE LISTING
C
 24   CALL PRINTI
C
C         AT THIS POINT THE NUMERIC INPUT-OUTPUT UNIT PROCESSING IS
C         COMPLETE
C
C         TEST IF ANY VARIABLE INPUT-OUTPUT UNITS EXIST
C
 25   IF(IOUTNV .EQ. 0) GO TO 30
C
C         PROCESS VARIABLE INPUT-OUTPUT UNITS
C
      IF(IOUTNV .EQ. 1) THEN
         IF(IREC1 .EQ. 1) THEN
            GO TO 29
         ELSE IF(IREC2 .EQ. 2) THEN
            READ (2,REC = 1) CREC1(1:40)
            READ (2,REC = 2) CREC2(1:40)
            IF(J1ISN .GT. J2ISN) THEN
               WRITE (2,REC = 1) CREC2(1:40)
               WRITE (2,REC = 2) CREC1(1:40)
            END IF
            GO TO 29
         ELSE IF(IREC2 .GT. 2) THEN
            GO TO 27
         END IF
      END IF
      IF(IOUTNV .EQ. 2) THEN
         IF(COUTV(1)(1:32) .GT. COUTV(2)(1:32)) THEN
            CREC1(1:32) = COUTV(1)(1:32)
            COUTV(1)(1:32) = COUTV(2)(1:32)
            COUTV(2)(1:32) = CREC1(1:32)
         END IF
         IF(IREC1 .EQ. 1) THEN
            GO TO 29
         ELSE IF(IREC1 .EQ. 2) THEN
            READ (2,REC = 1) CREC1(1:40)
            READ (2,REC = 2) CREC2(1:40)
            IF(CREC1(1:32) .GT. CREC2(1:32)) THEN
               IF(J1ISN .GT. J2ISN) THEN
                  WRITE (2,REC = 1) CREC2(1:40)
                  WRITE (2,REC = 2) CREC1(1:40)
               END IF
            END IF
            GO TO 29
         ELSE IF(IREC2 .GT. 2) THEN
            GO TO 27
         END IF
      END IF
C
C         SET SORT PARAMETERS FOR THE VARIABLE INPUT-OUTPUT UNITS LIST
C         IN COUTV
C
      DO 26 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 26   CTYPE(I) = CBLANK(1:1)
      ISTART(1) = 1
      IFLEN(1) = 32
      CTYPE(1) = CCC
C
C         SORT THE VARIABLE INPUT-OUTPUT UNITS ARRAY COUTV INTO ALPHA-
C         BETIC ASCENDING SEQUENCE; THIS IS A LIST OF ALL INPUT-OUTPUT
C         VARIABLE UNITS OCCURING IN THE PROGRAM OR SUBPROGRAM.
C
      IF(IOUTNV .GT. 2) CALL MSORT (COUTV,IOUTNV,32,3200,1)
C
C         TEST IF ANY VARIABLE INPUT-OUTPUT UNITS EXIST ON UNIT 2
C
 27   IF(IREC2 .EQ. 0) GO TO 30
C
C         TEST FOR A SINGLE VARIABLE INPUT-OUTPUT UNIT RECORD ON UNIT 2
C
      IF(IREC2 .EQ. 1) GO TO 29
C
C         TEST FOR TWO VARIABLE INPUT-OUTPUT UNIT RECORDS ON UNIT 2
C
      IF(IREC2 .EQ. 2) THEN
         READ (2,REC=1) CREC1M(1:40)
         READ (2,REC=2) CREC2M(1:40)
         IF(CREC1M(1:32) .GT. CREC2M(1:32)) THEN
            WRITE (2,REC=1) CREC2M(1:40)
            WRITE (2,REC=2) CREC1M(1:40)
         END IF
         GO TO 29
      END IF
C
C         SET SORT PARAMETERS FOR THE VARIABLE INPUT-OUTPUT UNITS USAGE
C         SAVED ON UNIT 15
C
      DO 28 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 28   CTYPE(I) = CBLANK(1:1)
      JUNIT = 2
      IRECL = 40
      NREC = IREC2
      ISTART(1) = 1
      IFLEN(1) = 32
      CTYPE(1) = CCC
      ISTART(2) = 33
      IFLEN(2) = 4
      CTYPE(2) = CII
C
C         SORT THE VARIABLE NAME INPUT-OUTPUT UNITS ON FORTRAN UNIT 15
C         INTO ASCENDING SEQUENCE; ISN WITHIN UNIT
C
      IF(IREC2 .GT. 2) CALL DSORT (JUNIT,40,NREC,2)
C
C         PRINT THE VARIABLE NAME INPUT-OUTPUT UNITS CROSS REFERENCE
C         LISTING
C
 29   CALL PRTVIO
C
C         TEST IF ANY INTEGER CONSTANTS EXIST
C
 30   IF(ICONI .EQ. 0) GO TO 33
C
C         TEST FOR A SINGLE CONSTANT
C
      IF(ICONI .EQ. 1) GO TO 32
C
C         TEST FOR TWO CONSTANTS ONLY
C
      IF(ICONI .EQ. 2) THEN
         IF(ICONIT(1,1) .LT. ICONIT(1,2)) THEN
            IB = ICONIT(1,1)
            IC = ICONIT(2,1)
            ICONIT(1,1) = ICONIT(1,2)
            ICONIT(2,1) = ICONIT(2,2)
            ICONIT(1,2) = IB
            ICONIT(2,2) = IC
            GO TO 32
         END IF
      END IF
C
C         SET SORT PARAMETERS FOR THE INTEGER CONSTANTS LISTING
C
      DO 31 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 31   CTYPE(I) = CBLANK(1:1)
      ISTART(1) = 1
      IFLEN(1) = 8
      CTYPE(1) = CII
      ISTART(2) = 5
      IFLEN(2) = 8
      CTYPE(2) = CII
C
C         ONLY 2000 INTEGERS MAY EXIST IN TABLE ICONIT. WHEN ICONI IS
C         GREATER THAN 2000, SET ITS VALUE TO 2000.
C
      IF(ICONI .GT. 2000) ICONI = 2000
C
C         SORT THE INTEGER CONSTANTS INTO ASCENDING SEQUENCE; ISN
C         WITHIN THE CONSTANT VALUE
C
      IF(ICONI .GT. 2) CALL MISORT (ICONIT,ICONI,2,1000)
C
C         PRINT THE INTEGER CONSTANT CROSS REFERENCE LISTING
C
 32   CALL PRINTC
C
C         TEST IF ANY REAL CONSTANTS EXIST
C
 33   IFNUM = ICONF
      IF(ICONF .EQ. 0) GO TO 36
      IF(ICONF .EQ. 1) GO TO 35
      IF(ICONF .EQ. 2) THEN
         IF(FCONFT(1) .GT. FCONFT(2)) THEN
            FP = FCONFT(1)
            FCONFT(1) = FCONFT(2)
            FCONFT(2) = FP
            I4WK1 = JCONFT(1)
            JCONFT(1) = JCONFT(2)
            JCONFT(2) = I4WK1
            GO TO 35
         END IF
         GO TO 35
      END IF
C
C         SORT FOR MORE THAN TWO FLOATING NUMBERS
C
      IF(ICONF .GT. 2) THEN

C
C         SET SORT PARAMETERS FOR THE REAL CONSTANTS LISTING
C
         DO 34 I = 1,5
         ISTART(I) = 0
         IFLEN(I) = 0
         LASC(I) = LFALSE
 34      CTYPE(I) = CBLANK(1:1)
         ISTART(1) = 1
         IFLEN(1) = 8
         CTYPE(1) = CFF
C
C         SORT THE REAL CONSTANTS INTO ASCENDING SEQUENCE; ISN
C         WITHIN THE CONSTANT VALUE
C
         CALL MFSORT (FCONFT,JCONFT,ICONF,4000)
      END IF
C
C         PRINT THE REAL CONSTANT CROSS REFERENCE LISTING
C
 35   CALL PRINTF (IFNUM)
C
C         TEST IF ANY CHARACTER CONSTANTS EXIST
C
 36   IF(ILIT .EQ. 0) THEN
         INUM = 0
         GO TO 40
      END IF
      IF(ILIT .EQ. 1) GO TO 39
      IF(ILIT .EQ. 2) THEN
         READ (9,REC = 1) CREC1M
         READ (9,REC = 2) CREC2M
         IF(JLOC1 .LT. JLOC2) GO TO 39
         IF(JLOC1 .GT. JLOC2) THEN
            WRITE (9,REC = 1) CREC2M
            WRITE (9,REC = 2) CREC1M
            GO TO 39
         END IF
         IF(JLOC1 .EQ. JLOC2) THEN
            IA = JLOC1
            DO 37 I = 1,IA
            IF(CREC1M(I:I) .GT. CREC2M(I:I)) THEN
               WRITE (9,REC = 1) CREC2M
               WRITE (9,REC = 2) CREC1M
               GO TO 39
            END IF
 37         CONTINUE
         END IF
         GO TO 39
      END IF
C
C         SET SORT PARAMETERS FOR THE LITERALS LISTING
C
      DO 38 I = 1,5
      ISTART(I) = 0
      IFLEN(I) = 0
      LASC(I) = LFALSE
 38   CTYPE(I) = CBLANK(1:1)
      JUNIT = 9
      IRECL = 88
      ISTART(1) = 81
      IFLEN(1) = 4
      CTYPE(1) = CII
      ISTART(2) = 1
      IFLEN(2) = 80
      CTYPE(2) = CCC
      ISTART(3) = 85
      IFLEN(3) = 4
      CTYPE(3) = CII
C
C         SORT THE LITERALS INTO ASCENDING SEQUENCE; ISN WITHIN THE
C         LITERAL VALUE WITHIN ITS LENGTH
C
      IF(ILIT .GT. 1) CALL DSORT (JUNIT,IRECL,ILIT,3)
C
C         PRINT THE LITERAL CROSS REFERENCE LISTING
C
 39   CALL PRINTL (INUM)
C
C         TEST IF ANY COMMON BLOCKS EXIST
C
 40   IF(IREC11 .EQ. 0) GO TO 41
C
C         PRINT THE COMMON BLOCK ANALYSIS
C
      CALL PCOMM
C
C         DETERMINE IF ANY SUBPRGRAMS WERE USED IN THE CURRENT PROGRAM
C         MODULE
C
 41   ISUBKT = 0
      JA = 0
      JB = 0
      L2 = LFALSE
      INAMEP = 0
      DO 43 I = 1,INAME
C
C         DO NOT ADD THE CURRENT SUBROUTINE NAME TO THE LIST OF
C         SUBROGRAMS CALLED
C
      IF(CPGNME(1:IPGNME) .EQ. CNAME(I)(1:IPGNME)) GO TO 43
C
C         DETERMINE IF THIS NAME IS TO BE PRINTED IN THE SUBPROGRAM
C         LIST TABLE
C
      IF(.NOT.BTEST(IENAME(12,I),15)) GO TO 43
C
C         COUNT THE NUMBER OF VARIABLES TO BE PRINTED IN THE LISTING.
C         THIS COUNT WILL EXCLUDE ALL VARIABLES FROM INCLUDE FILES.
C
      IF(BTEST(IENAME(12,I),15)) INAMEP = INAMEP + 1
      JC = I
C
C         DETERMINE IF THE CURRENT CNAME ENTRY IS FROM AN INCLUDE
C         STATEMENT.  THE ISN IS A NEGATIVE VALUE WHEN THE VARIABLE
C         NAME IS IN AN INCLUDE STATEMENT.
C
      IF(IENAME(9,I) .GT. 0) THEN
C
C         DETERMINE IF THE CURRENT VARIABLE NAME IS AN ENTRY, FUNCTION,
C         OR SUBROUTINE SUBPROGRAM
C
         IF(BTEST(IENAME(12,I),8) .OR. BTEST(IENAME(12,I),9) .OR.
     1      BTEST(IENAME(12,I),10)) THEN
C
C         DETERMINE IF THE SUBPROGRAM NAME IS THE SAME AS THE SUBPROGRAM
C         MODULE BEING PROCESSED. THIS WILL EXCLUDE THAT NAME FROM THE
C         LIST APPEARING IN THE OUTPUT LISTING.
C
            IF(IPGNME .EQ. IENAME(13,I) .AND. CPGNME(1:IPGNME) .EQ.
     1         CNAME(I)(1:IPGNME)) GO TO 43
C
C         THE Ith CNAME VARIABLE IS A SUBPROGRAM NAME
C
            ISUBKT = ISUBKT + 1
            ICALKT = IENAME(13,I)
 42         JA = JA + 1
            JB = JA + ICALKT - 1
C
C         WRITE THE TABLE TITLE
C
            IF(.NOT.L2) THEN
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  ILINE = 5
                  CFMTH(3:3) = C1(1:1)
                  IF(.NOT.LENDS) THEN
                     IPAGE = IPAGE + 1
                     WRITE (6,CFMTH) IPAGE
                  END IF
                  C1WK1(1:1) = CBLANK(1:1)
               ELSE
                  C1WK1(1:1) = C0(1:1)
                  ILINE = ILINE + 2
                  CFMTH(3:3) = C0(1:1)
               END IF
               WRITE (6,104) C1WK1
               L2 = LTRUE
            END IF
C
C         BLANK THE PRINT LINE BUFFER FOR A NEW LINE OF PRINT
C
            IF(JA .EQ. 1) THEN
               CPRINT(2:52) = CBLK52(2:52)
               CPRINT(53:104) = CBLK52(1:52)
               CPRINT(105:121) = CBLK52(1:17)
            END IF
C
C         DETERMINE IF THE VARIABLE NAME WILL FIT WITHIN THE 121
C         CHARACTER LIMIT OF THE PRINT LINE
C
            IF(JB .LE. 121) THEN
               CPRINT(JA:JB) = CNAME(I)(1:ICALKT)
               JA = JB + 1
               GO TO 43
            ELSE
C
C         THE CURRENT LINE OF PRINT IS FULL; PRINT IT
C
               IF(JA .EQ. 1) THEN
                  IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                     ILINE = 5
                     IF(.NOT.LENDS) THEN
                        CFMTH(3:3) = C1(1:1)
                        IPAGE = IPAGE + 1
                        WRITE (6,CFMTH) IPAGE
                     END IF
                     C1WK1(1:1) = CBLANK(1:1)
                  ELSE
                     C1WK1(1:1) = C0(1:1)
                     ILINE = ILINE + 2
                     CFMTH(3:3) = C0(1:1)
                  END IF
                  WRITE (6,104) C1WK1
               END IF
               WRITE (6,105) CPRINT(1:121)
               ILINE = ILINE + 1
               JA = 0
               GO TO 42
            END IF
         END IF
      END IF
 43   CONTINUE
C
C         WHEN ALL THE VARIABLE NAMES IN CNAME HAVE BEEN PROCESSED,
C         DETERMINE IF A FINAL, PARTIAL LINE OF PRINT REMAINS TO BE
C         PRINTED
C
      IF(JA .GT. 0 .AND. JC .EQ. INAME .OR. ISUBKT .GT. 0) THEN
         WRITE (6,105) CPRINT(1:121)
         ILINE = ILINE + 1
      END IF
C
C         WRITE ROUTINE STATISTICS
C
      IF(ILINE .GE. NLINES) THEN
         C1WK1(1:1) = C1(1:1)
         ILINE = 5
         IPAGE = IPAGE + 1
      ELSE
         C1WK1(1:1) = C0(1:1)
         ILINE = ILINE + 5
      END IF
      WRITE (6,100,IOSTAT=IERR) C1WK1, CFMTH(64:94), INAMEP, MNUM,
     1IOUTNC, IOUTNV, ICONI, IFNUM, INUM, ISUBKT
C
C         REWIND THE MESSAGES FILE AND COPY THE DIAGNOSTICS ONTO THE
C         PRINT FILE
C
      IF(IREC0 .EQ. 0) GO TO 45
      ENDFILE (0)
      REWIND (0)
C
C         SET THE CARRIAGE CONTROL CHARACTER
C
      IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES .OR. ILINE .GE.
     1   NLINES - 3) THEN
         IF(.NOT.LENDS) THEN
            CFMTH(3:3) = C1(1:1)
            ILINE = 5
            IPAGE = IPAGE + 1
         END IF
      ELSE
         CFMTH(3:3) = C0(1:1)
      END IF
      IF(.NOT.LENDS) THEN
         WRITE (6,CFMTH) IPAGE
         WRITE (6,101)
         ILINE = ILINE + 2
      END IF
C
C         COPY THE ERROR MESSAGES FROM UNIT 0 TO UNIT 6
C
C
C         DETERMINE IF THE MESSAGES HEADER IS TO BE WRITTEN BEFORE THE
C         FIRST MESSAGE IS PRINTED.
C
      IF(IREC0 .GT. 0) L3 = LTRUE
      IREC00 = 0
      CBUFF(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      DO 44 IA = 1,IREC0
      READ (0,102,IOSTAT=IEND) (CBUFF(I:I),I = 1,121)
C
C         DETERMINE IF A SUBSCRIPT FOR AN EQUIVALENCED VARIABLE THAT
C         IS DIMENSIONED EXISTS, BUT AN ERROR MESSAGE HAS BEEN WRITTEN.
C         DELETE THE ERROR MESSAGE FOR THIS CASE. THIS IS CAUSED BY A
C         DIMENSION STATEMENT THAT FOLLOWS THE EQUIVALENCE STATEMENT.
C
      IF(CBUFF(13:24) .EQ. 'EQUIVALENCED') THEN
         JLEN = 0
         DO I2WK2 = 35,66
         IF(CBUFF(I2WK2:I2WK2) .EQ. COMMA) JLEN = I2WK2 - 1
         END DO
         CWK32(1:32) = CBLK52(1:32)
         CWK32(1:JLEN-34) = CBUFF(35:JLEN)
         CALL TABSRH (CNAME,INAME,52,1,32,CWK32,1,32,IRET,4000)
         IF(BTEST(IENAME(12,IRET),3) .AND. BTEST(IENAME(12,IRET),17))
     1      THEN
            IREC00 = IREC00 + 1
            GO TO 44
         END IF
      END IF
C
C         DETERMINE IF A CALL ARGUMENT VARIABLE IS NOT DEFINED MESSAGE
C         WAS WRITTEN, AND DETERMINE IF IT IS A RETURN VALUE FROM THE
C         CALLED SUBPROGRAM. WHEN THE VARIABLE NAME EXISTS IN THE
C         MASTER NAME TABLE, OMIT THE MESSAGE RECORD.
C
      IF(CBUFF(13:50) .EQ. 'CALL ARGUMENT VARIABLE IS NOT DEFINED:')
     1   THEN
         JLEN = 0
         DO I2WK2 = 83,52,-1
         IF(CBUFF(I2WK2:I2WK2) .NE. CBLANK) THEN
            JLEN = I2WK2
            GO TO 430
         END IF
         END DO
 430     CWK32(1:32) = CBLK52(1:32)
         CWK32(1:JLEN-51) = CBUFF(52:JLEN)
         CALL TABSRH (CVARND,IVARND,32,1,32,CWK32,1,32,IRET,1000)
         CALL TABSRH (CNAME,INAME,52,1,32,CWK32,1,32,IRET1,1000)
         IF(IRET1 .GT. 0 .AND. CNAME(IRET1)(1:32) .EQ. CWK32(1:32)) THEN
            IREC00 = IREC00 + 1
            GO TO 44
         END IF
      END IF
C
C         DETERMINE IF A PARAMETER EVALUATION VARIABLE ERROR EXISTS,
C         AND DETERMINE IF THE VARIABLE IS DEFINED IN COMMON AFTER IT
C         HAS BEEN USED AS A PARAMETER PRIOR TO THE DEFINITION. WHEN
C         THIS CONDITION EXISTS, DELETE THE ERROR MESSAGE.
C
      IF(CBUFF(13:34) .EQ. 'PARAMETER EVALUATION A') THEN
         CALL TABSRH (CNAME,INAME,52,1,32,CBUFF,54,85,IRET,4000)
         IF(IRET .GT. 0) THEN
            IF(BTEST(IENAME(12,IRET),1)) THEN
               IREC00 = IREC00 + 1
               GO TO 44
            END IF
         END IF
      END IF
C
C         DETERMINE WHEN THE END OF THE FILE HAS BEEN REACHED
C
      IF(IEND .EQ. -1) GO TO 45
      IF(ILINE .GE. NLINES .OR. ILINE + 3 .GE. NLINES) THEN
         IF(.NOT.LENDS) THEN
            CFMTH(3:3) = C1(1:1)
            ILINE = 4
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,101)
            L3 = LFALSE
         END IF
      END IF
      IF(L3) THEN
         WRITE (6,101)
         WRITE (6,'(A2)') CBLANK(1:2)
         L3 = LFALSE
      END IF
      WRITE (6,102) (CBUFF(I:I),I = 1,121)
      ILINE = ILINE + 1
 44   CONTINUE
C
C         DETERMINE IF ALL THE MESSAGES ARE SUPPRESSED
C
      IF(IREC00 .GE. IREC0) BACKSPACE (6)
C
C         REWIND THE MESSAGES FILE
C
 45   IF(IREC0 .GT. 0) REWIND (0)
C
C         WHEN LZEND IS TRUE, INDICATING AN END STATEMENT EXISTS, SET
C         IT TO FALSE
C
      IF(LZEND) LZEND = LFALSE
C
C         ALL TABLES ARE COMPLETE, RESET THE PAGE COUNT FOR THE NEXT
C         ROUTINE TO BE PROCESSED.
C
      IPAGE = 1
C
C         RESET THE LSTART SWITCH. THIS SWITCH IS SET WHEN THE FIRST
C         EXECUTABLE FORTRAN STATEMENT OCCURS IN A ROUTINE
C
      LSTART = LFALSE
C
C         RESET THE DEFINED ARGUMENT COUNT TO ZERO FOR THE NEXT ROUTINE
C
      NARGD = 0
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ********************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL SORT ELEMENTS WITHIN A SINGLE MEMORY ARRAY
C        TO EITHER ASCENDING OR DESCENDING ORDER FOR UP TO FIVE FIELDS.
C        EACH FIELD MAY BE OF THE INTEGER, SINGLE & DOUBLE PRECISION
C        REAL OR COMPLEX, AND CHARACTER TYPE. THE FIVE FIELDS MAY BE
C        FROM ONE TO 80 CHARACTERS IN LENGTH.
C
C     MEANING OF THE VARIABLES
C
C         CBLK80 - CHARACTER VARIABLE, 80 BLANKS
C         CIWK   - CHARACTER VARIABLE, WORK ARRAY OF VARIABLE BYTES IN
C                  LENGTH, THIS VARIABLE CONTAINS A COPY OF ONE OF THE
C                  ELEMENTS FROM VARIABLE VC
C         CJWK   - CHARACTER VARIABLE, WORK ARRAY OF 80 BYTES
C         CKWK   - CHARACTER VARIABLE, WORK ARRAY OF 80 BYTES
C                  EQUIVALENCED TO CKWK1 THROUGH CKWK5
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   A - BYTE
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C         CV     - CHARACTER ARRAY, THE ARRAY TO BE SORTED
C         I      - INDEX VARIABLE
C         IDIMV  - THE SIZE OF THE DIMENSION OF CV THE ARRAY ENTRY;
C                  I.E., ITS SUBSCRIPT SIZE. JDIM*IDIMV = # 0F BYTES IN
C                  CV.
C         IFLEN  - THE LENGTH IN BYTES OF EACH TEST FIELD IN AN ELEMENT
C                  IN ARRAY CV. THIS VALUE MUST BE IN BYTES.
C         II     - SUBSCRIPT VARIABLE
C         IIB    - END LOCATION OF A SUBFIELD
C         IL     - INDEX VARIABLE
C         INAME  - NUMBER OF ENTRIES IN ARRAY CV, I. E. THE MAXIMUM
C                  SUBSCRIPT VALUE
C         IR     - INDEX VARIABLE
C         ISTART - THE START LOCATION OF A FIELD BE TESTED WITHIN AN
C                  ELEMENT OF ARRAY CV. THIS VALUE MUST BE IN BYTES FROM
C                  START OF THE ELEMENT
C         IV     - THE ARRAY TO BE SORTED AS AN INTEGER.  THIS MUST BE
C                  THE SAME ARRAY AS CV IN THE CALL STATEMENT OF THIS
C                  ROUTINE. THIS INDIRECT EQUIVALENCE PERMITS USE OF
C                  NUMERICAL FIELDS AS SORT KEYS
C         J      - SUBSCRIPT VARIABLE
C         JDIM   - THE NUMBER OF BYTES IN EACH CV ARRAY ENTRY; I.E.,
C                  ITS LENGTH IN BYTES
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE TEST CONDITIONS
C                  ARE SATISFIED, SET FALSE IF NOT SATISFIED
C         LASC   - LOGICAL VARIABLE, SET TRUE IF A DESCENDING ORDER FOR
C                  A FIELD IS DESIRED, SET FALSE FOR AN ASCENDING ORDER
C         LL     - LOGICAL VARIABLE, SET TRUE WHEN EQUAL VALUE ARGUMENTS
C                  EXIST IN A TEST OF MULTIPLE ARGUMENTS
C         NARG   - NUMBER OF FIELDS TO BE SORTED; VALUE 5 OR LESS
C
C     COMMENTS
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE
C
C         SINCE COMPLEX VARIABLES HAVE NO ORDER, THE SORT IS PERFORMED
C         ONLY ON THE REAL PART. WHEN A SORT OF BOTH REAL AND THE
C         IMAGINARY PARTS ARE WANTED, USE SEPARATE FIELD DEFINITIONS
C         FOR EACH PART.
C
C     SUBROUTINES USED
C
C         CFIELD CMFLD
C
C     ******************************************************************
C
      SUBROUTINE MSORT (CV,INAME,JDIM,IDIMV,NARG)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), CV(IDIMV), IFLEN(5), ISNW(1000), ISTART(5),
     1LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CV
      CHARACTER*1   CTYPE
      CHARACTER*80  CBLK80, CIWK, CJWK, CKWK
      CHARACTER*111 CFMTH
      CHARACTER*32  CPGNME
      LOGICAL*1     L, LASC, LL
C
C         COMMON STATEMENTS
C
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         DATA STATEMENT
C
      DATA CBLK80 /'
     1                            '/
      EQUIVALENCE (CIWK(1:4),IWK1), (CIWK(5:8),IWK2), (CJWK(1:4),JWK1),
     1(CJWK(5:8),JWK2), (CKWK(1:4),KWK1), (CKWK(5:8),KWK2)
C
C         SAVE STATEMENT
C
      SAVE
C
C         COMPUTE THE MIDPOINT AND INITIALIZE COUNTS
C
      IL = INAME/2 + 1
      IR = INAME
C
C         SET UP SAVE WORK AREA
C
 10   IF(IL .GT. 1) THEN
         IL = IL - 1
         CIWK(1:JDIM) = CV(IL)(1:JDIM)
      ELSE
         CIWK(1:JDIM) = CV(IR)(1:JDIM)
         CV(IR)(1:JDIM) = CV(1)(1:JDIM)
         IR = IR - 1
         IF(IR .EQ. 1) THEN
            CV(1)(1:JDIM) = CIWK(1:JDIM)
            GO TO 16
         END IF
      END IF
C
C         SET UP SHIFT OF ONE ITEM TO ANOTHER
C
      I = IL
      J = IL + IL
C
C         COMPARE THE FIELDS FOR SHIFTING
C
 11   IF(J .LE. IR) THEN
         IF(J .LT. IR) THEN
C
C         SET UP COMPARE FIELDS AND TEST
C
            DO 12 II = 1,NARG
            IF(ISTART(1) .NE. 0) THEN
               IIB = ISTART(II) + IFLEN(II) - 1
               CJWK(1:80) = CBLK80(1:80)
               CKWK(1:80) = CBLK80(1:80)
               CJWK(1:IFLEN(II)) = CV(J)(ISTART(II):IIB)
               CKWK(1:IFLEN(II)) = CV(J+1)(ISTART(II):IIB)
               IF(NARG .EQ. 1) THEN
                  CALL CMFLD (CJWK,CKWK,ISTART(II),IFLEN(II),CTYPE(II),
     1               LASC(II),L,LL)
               ELSE
                  CALL CFIELD (CJWK,CKWK,ISTART(II),IFLEN(II),CTYPE(II),
     1               LASC(II),L,NARG)
               END IF
               IF(.NOT.L) GO TO 13
            END IF
 12         CONTINUE
            J = J + 1
         END IF
C
C         MOVE RECORDS IF TESTS SUCCEEDED
C
 13      DO 14 II = 1,NARG
         IIB = ISTART(II) + IFLEN(II) - 1
         CJWK(1:80) = CBLK80(1:80)
         CKWK(1:80) = CBLK80(1:80)
         CJWK(1:IFLEN(II)) = CIWK(ISTART(II):IIB)
         CKWK(1:IFLEN(II)) = CV(J)(ISTART(II):IIB)
         IF(NARG .EQ. 1) THEN
            CALL CMFLD (CJWK,CKWK,ISTART(II),IFLEN(II),CTYPE(II),
     1         LASC(II),L,LL)
         ELSE
            CALL CFIELD (CJWK,CKWK,ISTART(II),IFLEN(II),CTYPE(II),
     1         LASC(II),L,NARG)
         END IF
         IF(.NOT.L) GO TO 15
         CV(I)(1:JDIM) = CV(J)(1:JDIM)
         I = J
         J = J + J
 14      CONTINUE
         GO TO 11
 15      J = IR + 1
         GO TO 11
      END IF
      CV(I)(1:JDIM) = CIWK(1:JDIM)
      GO TO 10
 16   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL SORT ELEMENTS WITHIN A SINGLE MEMORY ARRAY
C        TO EITHER ASCENDING OR DESCENDING ORDER FOR ONE FIELD OF
C        INTEGER NUMBERS. THE ARRAY HAS ONE DIMENSION.
C
C     MEANING OF THE VARIABLES
C
C         I      - INDEX VARIABLE
C         IDIMV  - THE SIZE OF THE DIMENSION OF IV THE ENTIRE ARRAY;
C                  I.E., ITS LENGTH IN WORDS
C         IL     - INDEX VARIABLE
C         INAME  - NUMBER OF ENTRIES IN ARRAY IV, I. E. THE MAXIMUM
C                  SUBSCRIPT VALUE
C         IR     - INDEX VARIABLE
C         IV     - THE INTEGER ARRAY TO BE SORTED.
C         IWK1   - WORK ARRAY OF FOUR BYTES. THIS VARIABLE CONTAINS A
C                  COPY OF THE FIRST ELEMENT FROM VARIABLE IV, THE
C                  SORT FIELD VALUE
C         J      - SUBSCRIPT VARIABLE
C
C     COMMENTS
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE
C
C     ******************************************************************
C
      SUBROUTINE MISRT1 (IV,INAME,IDIMV)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), IV(IDIMV),
     1 LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*111   CFMTH
      CHARACTER*32    CPGNME
      CHARACTER*1     CTYPE
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         SAVE STATEMENT
C
      SAVE
C
C         COMPUTE THE MIDPOINT AND INITIALIZE COUNTS
C
      IL = INAME/2 + 1
      IR = INAME
C
C         RETURN WHEN ONLY ONE ENTRY EXISTS
C
      IF(INAME .LT. 2) GO TO 13
C
C         SET UP SAVE WORK AREA
C
 10   IF(IL .GT. 1) THEN
         IL = IL - 1
         IWK1 = IV(IL)
      ELSE
         IWK1 = IV(IR)
         IV(IR) = IV(1)
         IR = IR - 1
         IF(IR .EQ. 1) THEN
            IV(1) = IWK1
            GO TO 13
         END IF
      END IF
C
C         SET UP SHIFT OF ONE ITEM TO ANOTHER
C
      I = IL
      J = IL + IL
C
C         COMPARE THE FIELDS FOR INCREMENTING TO THE NEXT RECORD
C
 11   IF(J .LE. IR) THEN
         IF(J .LT. IR) THEN
C
C           TEST THE FIELD
C
            IF(IV(J) .LT. IV(J+1)) J = J + 1
         END IF
C
C         MOVE RECORDS IF TESTS SUCCEEDED
C
         IF(IWK1 .LT. IV(J)) THEN
            IV(I) = IV(J)
            I = J
            J = J + J
            GO TO 11
         ELSE
            J = IR + 1
            GO TO 11
         END IF
      END IF
      IV(I) = IWK1
      GO TO 10
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL SORT ELEMENTS WITHIN A SINGLE MEMORY ARRAY
C        TO EITHER ASCENDING OR DESCENDING ORDER FOR TWO FIELDS OF
C        INTEGER NUMBERS. THE ARRAY HAS TWO DIMENSIONS.
C
C     MEANING OF THE VARIABLES
C
C         I      - INDEX VARIABLE
C         IDIMV  - THE SIZE OF THE DIMENSION OF IV THE ENTIRE ARRAY;
C                  I.E., ITS LENGTH IN WORDS
C         IL     - INDEX VARIABLE
C         INAME  - NUMBER OF ENTRIES IN ARRAY IV, I. E. THE MAXIMUM
C                  SUBSCRIPT VALUE
C         IR     - INDEX VARIABLE
C         IV     - THE INTEGER ARRAY TO BE SORTED.
C         IWK1   - WORK ARRAY OF FOUR BYTES. THIS VARIABLE CONTAINS A
C                  COPY OF THE FIRST ELEMENT FROM VARIABLE IV, THE
C                  FIRST SORT FIELD VALUE
C         IWK2   - WORK ARRAY OF FOUR BYTES. THIS VARIABLE CONTAINS A
C                  COPY OF THE SECOND ELEMENT FROM VARIABLE IV, THE
C                  SECOND SORT FIELD VALUE
C         J      - SUBSCRIPT VARIABLE
C         JDIM   - THE VALUE OF THE FIRST DIMENSION OF ARRAY IV IN
C                  WORDS
C
C     COMMENTS
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE
C
C     ******************************************************************
C
      SUBROUTINE MISORT (IV,INAME,JDIM,IDIMV)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5),
     1 IV(JDIM,IDIMV), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*111   CFMTH
      CHARACTER*32    CPGNME
      CHARACTER*1     CTYPE
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         SAVE STATEMENT
C
      SAVE
C
C         COMPUTE THE MIDPOINT AND INITIALIZE COUNTS
C
      IL = INAME/2 + 1
      IR = INAME
C
C         SET UP SAVE WORK AREA
C
 10   IF(IL .GT. 1) THEN
         IL = IL - 1
         IWK1 = IV(1,IL)
         IWK2 = IV(2,IL)
      ELSE
         IWK1 = IV(1,IR)
         IWK2 = IV(2,IR)
         IV(1,IR) = IV(1,1)
         IV(2,IR) = IV(2,1)
         IR = IR - 1
         IF(IR .EQ. 1) THEN
            IV(1,1) = IWK1
            IV(2,1) = IWK2
            GO TO 12
         END IF
      END IF
C
C         SET UP SHIFT OF ONE ITEM TO ANOTHER
C
      I = IL
      J = IL + IL
C
C         COMPARE THE FIELDS FOR INCREMENTING TO THE NEXT RECORD
C
 11   IF(J .LE. IR) THEN
         IF(J .LT. IR) THEN
C
C           TEST THE TWO FIELDS
C
            IF(IV(1,J) .EQ. IV(1,J+1)) THEN
               IF(IV(2,J) .LT. IV(2,J+1)) J = J + 1
            ELSE
               IF(IV(1,J) .LT. IV(1,J+1)) J = J + 1
            END IF
         END IF
C
C         MOVE RECORDS IF TESTS SUCCEEDED
C
         IF(IWK1 .EQ. IV(1,J)) THEN
            IF(IWK2 .LT. IV(2,J)) THEN
               IV(1,I) = IV(1,J)
               IV(2,I) = IV(2,J)
               I = J
               J = J + J
               GO TO 11
            ELSE
               J = IR + 1
               GO TO 11
            END IF
         ELSE
            IF(IWK1 .LT. IV(1,J)) THEN
               IV(1,I) = IV(1,J)
               IV(2,I) = IV(2,J)
               I = J
               J = J + J
               GO TO 11
            ELSE
               J = IR + 1
               GO TO 11
            END IF
         END IF
      END IF
      IV(1,I) = IWK1
      IV(2,I) = IWK2
      GO TO 10
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL SORT ELEMENTS WITHIN A SINGLE MEMORY ARRAY
C        TO EITHER ASCENDING OR DESCENDING ORDER FOR TWO DIFFERENT
C        ARRAYS. THE FIRST ARRAY IS DOUBLE PRECISION REAL; THE SECOND
C        ARRAY IS INTEGER. BOTH ARRAYS ARE SINGLE DIMENSIONED.
C
C     MEANING OF THE VARIABLES
C
C         FV     - THE REAL ARRAY TO BE SORTED, FLOATING FORM
C         FWK1   - WORK VARIABLE OF FOUR BYTES. THIS VARIABLE CONTAINS A
C                  COPY OF THE FIRST ELEMENT FROM VARIABLE FV, THE
C                  FIRST SORT FIELD VALUE
C         I      - INDEX VARIABLE
C         IL     - INDEX VARIABLE
C         INAME  - NUMBER OF ENTRIES IN ARRAY IV, I. E. THE MAXIMUM
C                  SUBSCRIPT VALUE
C         IR     - INDEX VARIABLE
C         IV     - THE INTEGER ARRAY BE SORTED THAT IS COUPLED WITH
C                  VARIABLE FV.
C         IWK2   - WORK VARIABLE OF FOUR BYTES. THIS VARIABLE CONTAINS A
C                  COPY OF ISN FROM VARIABLE IV
C         J      - SUBSCRIPT VARIABLE
C         JDIM   - THE VALUE OF THE DIMENSION OF ARRAY IV IN WORDS
C
C     COMMENTS
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE
C
C     ******************************************************************
C
      SUBROUTINE MFSORT (FV,IV,INAME,JDIM)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), FV(JDIM),
     1IV(JDIM), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*111   CFMTH
      CHARACTER*32    CPGNME
      CHARACTER*1     CTYPE
      REAL*8          FV, FWK1
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         SAVE STATEMENT
C
      SAVE
C
C         COMPUTE THE MIDPOINT AND INITIALIZE COUNTS
C
      IL = INAME/2 + 1
      IR = INAME
C
C         SET UP SAVE WORK AREA
C
 10   IF(IL .GT. 1) THEN
         IL = IL - 1
         FWK1 = FV(IL)
         IWK2 = IV(IL)
      ELSE
         FWK1 = FV(IR)
         IWK2 = IV(IR)
         FV(IR) = FV(1)
         IV(IR) = IV(1)
         IR = IR - 1
         IF(IR .EQ. 1) THEN
            FV(1) = FWK1
            IV(1) = IWK2
            GO TO 12
         END IF
      END IF
C
C         SET UP SHIFT OF ONE ITEM TO ANOTHER
C
      I = IL
      J = IL + IL
C
C         COMPARE THE FIELDS FOR INCREMENTING TO THE NEXT RECORD
C
 11   IF(J .LE. IR) THEN
         IF(J .LT. IR) THEN
C
C           TEST THE TWO FIELDS
C
            IF(FV(J) .EQ. FV(J+1)) THEN
               IF(IV(J) .LT. IV(J+1)) J = J + 1
            ELSE
               IF(FV(J) .LT. FV(J+1)) J = J + 1
            END IF
         END IF
C
C         MOVE RECORDS IF TESTS SUCCEEDED
C
         IF(FWK1 .EQ. FV(J)) THEN
            IF(IWK2 .LT. IV(J)) THEN
               FV(I) = FV(J)
               IV(I) = IV(J)
               I = J
               J = J + J
               GO TO 11
            ELSE
               J = IR + 1
               GO TO 11
            END IF
         ELSE
            IF(FWK1 .LT. FV(J)) THEN
               FV(I) = FV(J)
               IV(I) = IV(J)
               I = J
               J = J + J
               GO TO 11
            ELSE
               J = IR + 1
               GO TO 11
            END IF
         END IF
      END IF
      FV(I) = FWK1
      IV(I) = IWK2
      GO TO 10
 12   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM WILL SORT FIELDS WITHIN A DISK FILE RECORD TO
C        EITHER ASCENDING OR DESCENDING ORDER FOR UP TO FIVE FIELDS.
C        EACH FIELD MAY BE OF THE INTEGER, SINGLE & DOUBLE PRECISION
C        REAL OR COMPLEX, AND CHARACTER TYPE.
C
C     MEANING OF THE VARIABLES
C
C         CREC1  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CREC2  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CREC3  - CHARACTER VARIABLE, TEMPORARY SAVE AREA FOR A RECORD
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   A - BYTE
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C         I      - INDEX VALUE AND ASSOCIATE VARIABLE FOR A READ OR
C                  WRITE OF A RECORD BACK ONTO DISK
C         IFLEN  - THE LENGTH OF A FIELD WITHIN THE RECORD TO BE SORTED;
C                  THIS VALUE MUST BE IN BYTES
C         IL     - INDEX VARIABLE
C         IR     - INDEX VARIABLE
C         IRECL  - THE LENGTH OF THE RECORDS IN THE INPUT FILE TO BE
C                  SORTED
C         ISTART - THE START LOCATION OF A FIELD WITHIN THE RECORD TO
C                  BE SORTED; THIS VALUE MUST BE IN BYTES
C         J      - INDEX VALUE AND ASSOCIATE VARIABLE FOR A READ OR
C                  WRITE
C         JP1    - ALWAYS THE VALUE OF J + 1, AND ASSOCIATE VARIABLE FOR
C                  A READ
C         JUNIT  - THE INPUT UNIT WHERE THE FILE IS STORED
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE TEST CONDITIONS
C                  ARE SATISFIED, SET FALSE IF NOT SATISFIED
C         LASC   - LOGICAL VARIABLE, SET TRUE IF A DESCENDING ORDER FOR
C                  A FIELD IS DESIRED, SET FALSE FOR AN ASCENDING ORDER
C         NARG   - NUMBER OF FIELDS TO BE TESTED
C         NREC   - NUMBER OF RECORDS IN THE DISK FILE
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         JUNIT - THE INPUT UNIT OF DATA TO BE SORTED. THE FILE MUST BE
C                 AN UNFORMATTED DIRECT ACCESS FILE.
C
C     COMMENTS
C
C         THE FILE STRUCTURE USED BY THIS ROUTINE IS UNFORMATTED
C         DIRECT ACCESS.
C
C         THE INPUT RECORD IS SPECIFIED AS A SINGLE DIMENSION.
C         ALL VALUES MUST BE IN BYTES SINCE SUBSCRIPTING IS DETERMINED
C         BY THIS ROUTINE.  THE WORK ARRAYS ARE DEFINED AS CHARACTER
C         VARIABLES OF LENGTH ONE.
C
C         SINCE COMPLEX VARIABLES HAVE NO ORDER, THE SORT IS PERFORMED
C         ONLY ON THE REAL PART. WHEN A SORT OF BOTH REAL AND THE
C         IMAGINARY PARTS ARE WANTED, USE SEPARATE FIELD DEFINITIONS
C         FOR EACH PART.
C
C         THE CONTROL FIELDS FOR THE SORT ARE THE VARIABLES IFLEN,
C         ISTART, LASC, & CTYPE
C
C     SUBROUTINES USED
C
C         CFIELD
C
C     ******************************************************************
C
      SUBROUTINE DSORT (JUNIT,IRECL,NREC,NARG)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*1532  CREC1, CREC2, CREC3
      CHARACTER*111   CFMTH
      CHARACTER*32    CPGNME
      CHARACTER*1     CTYPE
      LOGICAL*1       L, LASC
C
C         COMMON STATEMENTS
C
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         SAVE STATEMENT
C
      SAVE
C
C         TEST IF THREE OR MORE ENTRIES ON JUNIT
C
      IF(NREC .LE. 2) THEN
         IF(NREC .EQ. 2) THEN
            READ (JUNIT,REC=1) CREC1(1:IRECL)
            READ (JUNIT,REC=2) CREC2(1:IRECL)
C
C         TEST FOR EACH FIELD CRITERION SPECIFICATION
C
            CALL CFIELD (CREC1,CREC2,ISTART,IFLEN,CTYPE,LASC,L,NARG)
            IF(.NOT.L) THEN
               WRITE (JUNIT,REC=1) CREC2(1:IRECL)
               WRITE (JUNIT,REC=2) CREC1(1:IRECL)
            END IF
         END IF
         RETURN
      END IF
C
C         COMPUTE THE MIDPOINT AND INITIALIZE COUNTS
C
      IL = NREC/2 + 1
      IR = NREC
C
C         TEST IF MORE PROCESSING IS REQUIRED
C
 10   IF(IL .GT. 1) THEN
         IL = IL - 1
         READ (JUNIT,REC=IL) CREC3(1:IRECL)
      ELSE
         READ (JUNIT,REC=IR) CREC3(1:IRECL)
         READ (JUNIT,REC=1) CREC1(1:IRECL)
         WRITE (JUNIT,REC=IR) CREC1(1:IRECL)
         IR = IR - 1
         IF(IR .EQ. 1) THEN
            WRITE (JUNIT,REC=1) CREC3(1:IRECL)
            GO TO 14
         END IF
      END IF
C
C         SET UP SHIFT OF ONE RECORD TO ANOTHER
C
      I = IL
      J = IL + IL
C
C         COMPARE THE FIELDS FOR SHIFTING
C
 12   IF(J .LE. IR) THEN
         IF(J .LT. IR) THEN
            JP1 = J + 1
            READ (JUNIT,REC=J) CREC1(1:IRECL)
            READ (JUNIT,REC=JP1) CREC2(1:IRECL)
C
C         TEST FOR EACH FIELD CRITERION SPECIFICATION
C
            CALL CFIELD (CREC1,CREC2,ISTART,IFLEN,CTYPE,LASC,L,NARG)
            IF(L) J = J + 1
         END IF
C
C         READ THE RECORD FOR COMPARES
C
         READ (JUNIT,REC=J) CREC2(1:IRECL)
C
C         TEST FOR EACH FIELD CRITERION SPECIFICATION
C
      IF(CREC2(1:6) .EQ. 'CTYPED') THEN
      END IF
      CALL CFIELD (CREC3,CREC2,ISTART,IFLEN,CTYPE,LASC,L,NARG)
      IF(CREC2(1:6) .EQ. 'CTYPED') THEN
      END IF
         IF(.NOT.L) GO TO 13
C
C         INTERCHANGE THE RECORDS BECAUSE OF DETECTED ORDER
C
         WRITE (JUNIT,REC=I) CREC2(1:IRECL)
         I = J
         J = J + J
         GO TO 12
C
C         NO INTERCHANGE, ORDER IS CORRECT
C
 13      J = IR + 1
         GO TO 12
      END IF
      WRITE (JUNIT,REC=I) CREC3(1:IRECL)
      GO TO 10
 14   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM SETS LOGICAL VARIABLES TO DETERMINE THE ORDER
C        OF A RECORD IN EITHER ASCENDING OR DESCENDING ORDER. EACH
C        FIELD MAY BE OF THE INTEGER, SINGLE & DOUBLE PRECISION REAL
C        OR COMPLEX, AND CHARACTER TYPES.
C
C     MEANING OF THE VARIABLES
C
C         CREC1  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CREC2  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C         IFLEN  - THE LENGTH OF A FIELD WITHIN THE RECORD TO BE SORTED;
C                  THIS VALUE MUST BE IN BYTES
C         II     - SUBSCRIPT VARIABLE
C         IRECL  - THE LENGTH OF THE RECORDS IN THE INPUT FILE TO BE
C                  SORTED
C         ISTART - THE START LOCATION OF A FIELD WITHIN THE RECORD TO
C                  BE SORTED; THIS VALUE MUST BE IN BYTES
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE TEST CONDITIONS
C                  ARE SATISFIED, SET FALSE IF NOT SATISFIED
C         LA     - LOGICAL VARIABLE, AN ARRAY OF DIMENSION 5, ONE FOR
C                  EACH FIELD TEST TO BE MADE. THIS SAVES THE INDIVIDUAL
C                  TEST RESULTS USED TO DETERMINE THE RETURN VALUE OF L.
C         LASC   - LOGICAL VARIABLE, SET TRUE IF A DESCENDING ORDER FOR
C                  A FIELD IS DESIRED, SET FALSE FOR AN ASCENDING ORDER
C         LL     - LOGICAL VARIABLE, SET TRUE IF EQUAL ARGUMENTS EXIST
C                  WHEN FIELDS ARE TESTED.  USED FOR MULTIPLE FIELD
C                  TESTS.
C         NARG   - NUMBER OF FIELDS TO BE TESTED
C
C     COMMENTS
C
C         SINCE COMPLEX VARIABLES HAVE NO ORDER, THE TEST IS PERFORMED
C         ONLY ON THE REAL PART. WHEN A SORT OF BOTH REAL AND THE
C         IMAGINARY PARTS ARE WANTED, USE SEPARATE FIELD DEFINITIONS
C         FOR EACH PART.
C
C     SUBROUTINES CALLED
C
C         CMFLD
C
C     ******************************************************************
C
      SUBROUTINE CFIELD (CREC1,CREC2,ISTART,IFLEN,CTYPE,LASC,L,
     1NARG)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENT
C
      DIMENSION CTYPE(5), IFLEN(5), ISTART(5), LA(5), LASC(5), LL(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*) CREC1, CREC2
      CHARACTER*8   CWKA, CWKB
      CHARACTER*1   CTYPE
      LOGICAL*1     L, LA, LASC, LL
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CWKA(1:4),IWKA,FWKA), (CWKB(1:4),IWKB,FWKB),
     1(CWKA(1:8),DWKA),(CWKB(1:8),DWKB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         SCAN FOR EACH FIELD CRITERION SPECIFICATION
C
      DO 10 II = 1,NARG
 10   CALL CMFLD (CREC1,CREC2,ISTART(II),IFLEN(II),CTYPE(II),LASC(II),
     1   LA(II),LL(II))
C
C         TEST IF ALL CRITERIA HAVE BEEN MET
C         DETERMINE THE NUMBER OF FIELDS BEING TESTED
C
      IF(NARG .GT. 1) THEN
         IF(NARG .GT. 2) THEN
            IF(NARG .GT. 3) THEN
               IF(NARG .GT. 4) THEN
C
C         FIVE FIELDS ARE BEING USED
C
                  IF(LL(1)) THEN
                     IF(LL(2)) THEN
                        IF(LL(3)) THEN
                           IF(LL(4)) THEN
                              L = LA(5)
                              GO TO 11
                           ELSE
                              L = LA(4)
                              GO TO 11
                           END IF
                        ELSE
                           L = LA(3)
                           GO TO 11
                        END IF
                     ELSE
                        L = LA(2)
                        GO TO 11
                     END IF
                  ELSE
                     L = LA(1)
                     GO TO 11
                  END IF
C
C         FOUR FIELDS ARE BEING USED
C
               ELSE
                  IF(LL(1)) THEN
                     IF(LL(2)) THEN
                        IF(LL(3)) THEN
                           L = LA(4)
                           GO TO 11
                        ELSE
                           L = LA(3)
                           GO TO 11
                        END IF
                     ELSE
                        L = LA(2)
                        GO TO 11
                     END IF
                  ELSE
                     L = LA(1)
                     GO TO 11
                  END IF
               END IF
C
C         THREE FIELDS ARE BEING USED
C
            ELSE
               IF(LL(1)) THEN
                  IF(LL(2)) THEN
                     L = LA(3)
                     GO TO 11
                  ELSE
                     L = LA(2)
                     GO TO 11
                  END IF
               ELSE
                  L = LA(1)
                  GO TO 11
               END IF
            END IF
C
C         TWO FIELDS ARE BEING USED
C
         ELSE
            IF(LL(1)) THEN
               L = LA(2)
               GO TO 11
            ELSE
               L = LA(1)
               GO TO 11
            END IF
         END IF
C
C         ONE FIELD IS BEING USED
C
      ELSE
         L = LA(1)
      END IF
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS SUBPROGRAM COMPARES UP TO FIVE CONDITION FIELDS FROM A
C        RECORD TO DETERMINE EITHER ASCENDING OR DESCENDING ORDER.
C        EACH FIELD MAY BE OF THE INTEGER, SINGLE & DOUBLE PRECISION
C        REAL OR COMPLEX, AND CHARACTER TYPES.
C
C     MEANING OF THE VARIABLES
C
C         CBLK88 - CHARACTER VARIABLE, 88 BLANKS
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CREC1  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CREC2  - CHARACTER VARIABLE, THE SINGLE DIMENSIONED CHARACTER
C                  VARIABLE WORK AREA TO READ IN A DISK RECORD
C         CSNW   - CHARACTER VARIABLE, EQUIVALENCED TO ISNW
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   A - BYTE
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C                  WHEN THIS FIELD IS BLANK, THE CODE IS ASSUMED TO BE C
C         CWKA   - CHARACTER VARIABLE, WORK AREA OF 8 BYTES, EQUIVAL-
C                  ENCED TO IWKA AND FWKA, ALWAYS ASSOCIATED WITH CREC1
C         CWKB   - CHARACTER VARIABLE, WORK AREA OF 8 BYTES, EQUIVAL-
C                  ENCED TO IWKB AND FWKB, ALWAYS ASSOCIATED WITH CREC2
C         CWKD   - CHARACTER VARIABLE, WORK AREA OF UP TO 80 BYTES,
C                  USED FOR CHARACTER FIELD COMPARE
C         CWKE   - CHARACTER VARIABLE, WORK AREA OF UP TO 80 BYTES,
C                  USED FOR CHARACTER FIELD COMPARE
C         DWKA   - DOUBLE PRECISION VALUE FOR A FIELD FROM CREC1
C         DWKB   - DOUBLE PRECISION VALUE FOR A FIELD FROM CREC2
C         FWKA   - SINGLE PRECISION VALUE FOR A FIELD FROM CREC1
C         FWKB   - SINGLE PRECISION VALUE FOR A FIELD FROM CREC2
C         IFLEN  - THE LENGTH OF A FIELD WITHIN THE RECORD TO BE SORTED;
C                  THIS VALUE MUST BE IN BYTES
C         II     - SUBSCRIPT VARIABLE
C         INAME  - NUMBER OF ENTRIES IN ARRAY CV, I. E. THE MAXIMUM
C                  SUBSCRIPT VALUE
C         IRECL  - THE LENGTH OF THE RECORDS IN THE INPUT FILE TO BE
C                  SORTED
C         ISTART - THE START LOCATION OF A FIELD WITHIN THE RECORD TO
C                  BE SORTED; THIS VALUE MUST BE IN BYTES
C         IWKA   - INTEGER WORK AREA FOR A FIELD OF CREC1
C         IWKB   - INTEGER WORK AREA FOR A FIELD OF CREC2
C         I1     - START LOCATION OF A FIELD IN A RECORD
C         I2     - END LOCATION OF A FIELD IN A RECORD
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE TEST CONDITIONS
C                  ARE SATISFIED, SET FALSE IF NOT SATISFIED
C         LASC   - LOGICAL VARIABLE, SET TRUE IF A DESCENDING ORDER FOR
C                  A FIELD IS DESIRED, SET FALSE FOR AN ASCENDING ORDER
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LL     - LOGICAL VARIABLE, SET TRUE IF THE TWO FIELDS TO BE
C                  TESTED ARE EQUAL, SET FALSE OTHERWISE
C
C     COMMENTS
C
C         THE WORK ARRAYS ARE DEFINED AS CHARACTER VARIABLES OF LENGTH
C         ONE.
C
C         THE MAXIMUM LENGTH OF A SORT FIELD IS 80 CHARACTERS.
C
C         SINCE COMPLEX VARIABLES HAVE NO ORDER, THE TEST IS PERFORMED
C         ONLY ON THE REAL PART. WHEN A SORT OF BOTH REAL AND THE
C         IMAGINARY PARTS ARE WANTED, USE SEPARATE FIELD DEFINITIONS
C         FOR EACH PART.
C
C     ******************************************************************
C
      SUBROUTINE CMFLD (CREC1,CREC2,ISTART,IFLEN,CTYPE,LASC,L,LL)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CREC1, CREC2
      CHARACTER*80    CBLK80, CWKD, CWKE
      CHARACTER*8     CWKA, CWKB
      CHARACTER*1     CTYPE
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      LOGICAL*1       L, LASC, LL, LTRUE, LFALSE
C
C        COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
C
C         PARAMETER STATEMENTS
C
      PARAMETER (LFALSE=.FALSE., LTRUE=.TRUE.)
C
C         EQUIVALENCE STATEMENT
C
      EQUIVALENCE (CWKA(1:4),IWKA,FWKA), (CWKB(1:4),IWKB,FWKB),
     1(CWKA(1:8),DWKA),(CWKB(1:8),DWKB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CBLK80 /'
     1                            '/
C
C         SET EQUAL SWITCH TO FALSE
C
      LL = LFALSE
C
C         TEST FOR AN INTEGER TYPE FIELD
C
      IF(CTYPE .EQ. CII) THEN
         I1 = ISTART
         I2 = I1 + IFLEN - 1
         CWKA(1:4) = CREC1(I1:I2)
         CWKB(1:4) = CREC2(I1:I2)
C
C         TEST IF THE ARGUMENTS ARE EQUAL
C
         IF(IWKA .EQ. IWKB) LL = LTRUE
C
C         TEST IF ARGUMENTS ARE .LT. OR .GT.
C
      IF(CREC1(1:6) .EQ. 'CTYPED') THEN
      END IF
         IF(LASC) THEN
            IF(IWKA .LE. IWKB) GO TO 10
         ELSE
            IF(IWKA .GE. IWKB) GO TO 10
         END IF
      END IF
C
C         TEST FOR A REAL*4 OR A COMPLEX*8 TYPE FIELD
C
      IF(CTYPE .EQ. CRR .OR. CTYPE .EQ. CBB) THEN
         I1 = ISTART
         I2 = I1 + 3
         CWKA(1:4) = CREC1(I1:I2)
         CWKB(1:4) = CREC2(I1:I2)
C
C         TEST IF THE ARGUMENTS ARE EQUAL
C
         IF(FWKA .EQ. FWKB) LL = LTRUE
C
C         TEST IF ARGUMENTS ARE LT OR GT
C
          IF(LASC) THEN
            IF(FWKA .LE. FWKB) GO TO 10
         ELSE
            IF(FWKA .GE. FWKB) GO TO 10
         END IF
      END IF
C
C         TEST FOR A REAL*8 OR A COMPLEX*16 TYPE FIELD
C
      IF(CTYPE .EQ. CDD .OR. CTYPE .EQ. CEE) THEN
         I1 = ISTART
         I2 = I1 + 7
         CWKA(1:8) = CREC1(I1:I2)
         CWKB(1:8) = CREC2(I1:I2)
C
C         TEST IF THE ARGUMENTS ARE EQUAL
C
         IF(DWKA .EQ. DWKB) LL = LTRUE
C
C         TEST IF ARGUMENTS ARE LT OR GT
C
         IF(LASC) THEN
            IF(DWKA .LE. DWKB) GO TO 10
         ELSE
            IF(DWKA .GE. DWKB) GO TO 10
         END IF
      END IF
C
C         TEST FOR A CHARACTER TYPE FIELD
C
      IF(CTYPE .EQ. CCC .OR. CTYPE .EQ. CBLK80(1:1)) THEN
         CWKD(1:80) = CBLK80(1:80)
         CWKE(1:80) = CBLK80(1:80)
         I1 = ISTART
         I2 = I1 + IFLEN - 1
         CWKD(I1:I2) = CREC1(I1:I2)
         CWKE(I1:I2) = CREC2(I1:I2)
C
C         TEST IF THE ARGUMENTS ARE EQUAL
C
         IF(CWKD(I1:I2) .EQ. CWKE(I1:I2)) LL = LTRUE
C
C         TEST IF ARGUMENTS ARE LT OR GT
C
         IF(LASC) THEN
            IF(CWKD(I1:I2) .LE. CWKE(I1:I2)) GO TO 10
         ELSE
            IF(CWKD(I1:I2) .GE. CWKE(I1:I2)) GO TO 10
         END IF
      END IF
C
C         IF THE CONDIITON IS SATISFIED FOR THE FIELD, SET THE LOGICAL
C         SWITCH TO TRUE
C
      L = LTRUE
      GO TO 11
C
C         IF THE CONDIITON IS NOT SATISFIED FOR THE FIELD, SET THE
C         LOGICAL SWITCH TO FALSE
C
 10   L = LFALSE
C
C         ROUTINE EXIT
C
 11   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE, PRINTV, CREATES THE VARIABLE NAMES CROSS
C        REFERENCE LISTING FOR EACH PROGRAM MODULE. THIS IS TABLE 2.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CFMT1  - CHARACTER VARIABLE, FORMAT STATEMENT FOR THE INITIAL
C                  LINE OF PRINT FOR A VARIABLE NAME. THIS WILL CAUSE
C                  THE USAGE AND TYPE CODES TO BE PRINTED.
C         CFMT2  - CHARACTER VARIABLE, FORMAT STATEMENT FOR OTHER LINES
C                  OF PRINT AFTER THE FIRST LINE OF A VARIABLE NAME.
C                  THIS WILL CAUSE THE USAGE AND TYPE CODES TO BE
C                  OMITTED FROM THE LINE OF PRINT.
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C
C                  COLUMN 37 CONTAINS THE FOLLOWING CODES TO INDICATE
C                  DATA TYPE
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C         CSTR   - TABLE OF ALL STRUCTURES DEFINED IN THE MODULE BEING
C                  CURRENTLY PROCESSED. A MAXIMUM OF 1000 UNIQUE
C                  STRUCTURES MAY OCCUR.
C                  RECORD STRUCTURE
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32   8  STRUCTURE NAME, CHARACTER VARIABLE
C                 33 - 36 I*4    9  INTEGER VALUE OF THE STRUCTURE'S
C                                   TOTAL LENGTH
C         CTYPL  - CHARACTER VARIABLE, THE TYPE AND LENGTH
C                  CHARACTERISTICS OF THE CURRENT VARIABLE
C         CUSE   - CHARACTER VARIABLE, USAGE SYMBOLS FOR PRINTING
C                    A - SUBROUTINE ARGUMENT VARIABLE
C                    B - ENTRY SUBPROGRAM NAME
C                    C - COMMON VARIABLE
C                    D - DIMENSIONED VARIABLE
C                    E - EQUIVALENCED VARIABLE
C                    F - FUNCTION SUBPROGRAM NAME
C                    N - NAMELIST NAME
C                    P - PARAMETER VARIABLE
C                    R - RECORD NAME
C                    S - SUBROUTINE SUBPROGRAM NAME
C                    T - STRUCTURE NAME
C                    U - UNION VARIABLE NAME
C         CWK7   - CHARACTER VARIABLE, THE LENGTH OF A STRUCTURE
C         CWORK  - CHARACTER VARIABLE, READ IN AREA FOR A RECORD ON
C                  UNIT 7
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         C100   - CHARACTER VARIABLE, FORMAT TO WRITE THE HEADER FOR
C                  THE VARIABLE NAME TABLE
C         I      - SUBSCRIPT VARIABLE, CHOOSES THE VARIABLE BEING
C                  CURRENTLY LISTED
C         IA     - SUBSCRIPT VARIABLE, START INDEX FOR PRINTING A LINE;
C                  ALSO USED AS A SUBSCRIPT VARIABLE
C         IB     - END INDEX VALUE FOR PRINTING A LINE OF PRINT; ALSO
C                  USED AS A SUBSCRIPT VARIABLE
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IEND   - RESULTS OF IOSTAT TEST IN READ FROM UNIT 7
C         IERR   - RETURN CODE FROM THE IOSTAT PARAMETER IN A WRITE
C                  STATEMENT, SET -1 WHEN AN END OF FILE OCCURS.
C         II     - THE NUMBER OF LINES OF PRINT WHEN A VARIABLE LENGTH
C                  IS GREATER THAN EIGHT CHARACTERS
C         ILINE  - NUMBER OF LINES PRINTED ON A PAGE
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IPAGE  - PAGE COUNT
C         IREC7  - COUNT OF THE NUMBER OF VARIABLE NAMES WRITTEN ON
C                  UNIT 7
C         IRET   - RETURN CODE FROM TABSRH, USED TO DETERMINE THE TABLE
C                  LOCATION OF A STRUCTURE DEFINITION NAME
C         IRET1  - RETURN CODE FROM TABSRH, USED TO OBTAIN BIT SWITCHES
C                  FROM CNAME WHEN A VARIABLE NOT DEFINED MESSAGE IS TO
C                  BE WRITTEN. THE BIT SWITCHES DETERMINE IF THE
C                  NAME IS A COMMON BLOCK NAME. THE MESSAGE IS NOT
C                  WRITTEN FOR THIS CASE.
C         ISNW   - LIST OF ALL ISNS WHERE A VARIABLE IN CNAME OCCURS
C                  THAT ARE TO BE PRINTED FROM UNIT 7
C         ISTR   - EQUIVALENCED TO CSTR
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         I2WK1  - NUMBER OF ISNS TO BE PRINTED ON A LINE OF PRINT
C         I4WK1  - TEMPORARY WORK AREA TO CONTAIN A NEW INS FOR A
C                  VARIABLE
C         JBITS  - THE BIT SWITCHES IN CWORK(45:48)
C         JISN   - THE ISN WHERE A VARIABLE NAME WAS USED IN THE MODULE
C         J      - COUNT OF THE NUMBER OF ISNS IN ISNW (SUBSCRIPT)
C         JD     - COUNT OF THE NUMBER OF ISNS IN ISNW (TABINS)
C         JJ     - LOCATION FOR PLACEMENT OF USAGE CHARACTERS
C         K      - LOCATION COUNT OF THE CURRENT RECORD ON UNIT 7
C         K      - LOCATION COUNT OF THE CURRENT RECORD ON UNIT 7
C         KISN   - THE ISN OF THE VARIABLE NAME WHICH HAS NOT BEEN
C                  USED WITHIN THE CURRENT MODULE
C         KK     - LOCATION COUNT OF THE PREVIOUS RECORD ON UNIT 7
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME DOES
C                  NOT HAVE TYPE AND LENGTH CHARACTERISTICS, SET FALSE
C                  OTHERWISE. THIS PREVENTS CHARACTERISTICS BEING SHOWN
C                  ON THE LISTING. ENTRY  AND SUBROUTINE NAMES FIT THIS
C                  CONDITION.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME HAS A
C                  LENGTH CHARACTERISTIC, BUT NO TYPE CODE. STRUCTURE
C                  AND RECORD STATEMENTS FIT THIS CONDITION. SET FALSE
C                  OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE AFTER A T CODE FOR A
C                  STRUCTURE USAGE HAS BE SET, SET FALSE OTHERWISE. THIS
C                  PREVENTS MULTIPLE T CODES UNDER CERTAIN CONDITIONS.
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE NAME FROM
C                  UNIT 7 MATCHES A MASTER VARIABLE NAME TABLE ENTRY,
C                  SET FALSE OTHERWISE.
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C
C     SUBRUTINES CALLED
C
C         BTEST IBTANIN NUPAGE TABSRH VFMTC
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         6 - OUTPUT LISTING OF VARIABLE CROSS REFERENCES
C         7 - INPUT UNIT FOR THE VARIABLE ISN REFERENCES
C
C     *****************************************************************
C
      SUBROUTINE PRINTV
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ISTR(9,1000), ICONTL(2,100)
      DIMENSION CSNW(1000)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606 CSTMT
      CHARACTER*293  C100
      CHARACTER*132  CREC, CSREC, CSAVST
      CHARACTER*111  CFMTH
      CHARACTER*104  CDIM
      CHARACTER*92   CLITWK
      CHARACTER*82   CFMTL
      CHARACTER*80   CIFILE
      CHARACTER*72   CVARST
      CHARACTER*69   C101
      CHARACTER*68   CRECTB, CWK68
      CHARACTER*56   CSUBTB
      CHARACTER*52   CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44   CUNION
      CHARACTER*42   CFMT1, CFMT2
      CHARACTER*40   COMTBL
      CHARACTER*36   CSTR, CSTRNM
      CHARACTER*32   CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*10   C103
      CHARACTER*8    CBLANK, CIMPL, CTYPL, CWK8
      CHARACTER*7    CWK7
      CHARACTER*6    CUSE
      CHARACTER*4    CI4WK1, CSNW
      CHARACTER*1    CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1               CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2               CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1    C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1    CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1               CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2               CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3               CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4               CUNDER
      CHARACTER*1    CTYPE
      INTEGER*2      ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
      INTEGER*2      ISRECL, I2WK1
      REAL*8         FCONFT, FP
      LOGICAL*1      L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2               LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3               LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4               LZEND
      LOGICAL*1      LASC
      LOGICAL*1      L1, L2, L3, L4
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CNAME(1),IENAME(1,1)), (CWORK(33:36),JISN),
     1(CWORK(45:48),JBITS), (CSTR(1),ISTR(1,1)), (CWK8(2:2),CWK7),
     2(ISNW(1),CSNW(1)), (CI4WK1,I4WK1), (NLINE,ILINE), (CSUBTB,JSUBTB)
      EQUIVALENCE (CWORK(33:36),IWORK)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS FOR FORMAT STATEMENTS
C
      DATA C100 /'('' USAGE: A - ARGUMENT, B - ENTRY, C - COMMON, D - DI
     1MENSIONED, E - EQUIVALENCED, F - FUNCTION,''/''        N - NAMELIS
     2T, P - PARAMETER, R - RECORD, S - SUBROUTINE, T - STRUCTURE, U - U
     3NION''/''  TYPE: A-BYTE, B-COMPLEX, C-CHARACTER, D-DBL PRECISION,
     4E-DBL COMPLEX, I-INTEGER, L-LOGICAL, R-REAL'')'/
      DATA C101 /'(''0USAGE  TYPE '',3X,''VAR NAME'',4X,''INTERNAL STATE
     1MENT NUMBERS (ISN)'')'/
      DATA C103 /'(T26,16I6)'/
      DATA CFMT1/'(1X,A6,1X,A1,''*'',A7,T19,AXX,TXX,XXI6)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' VARIABLE NOT REFERENCED: ',A32)
 101  FORMAT(' ISN:',I6,' VARIABLE NOT DEFINED: ',A32)
 102  FORMAT(' MORE THAN 1000 ISNS FOR A VARIABLE: ',A32)
C
C         WRITE THE INITIAL PAGE HEADER FOR THE OUTPUT LISTING
C
      CALL NUPAGE (7)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,C100)
      WRITE (6,C101)
C
C         INITIALIZATION
C
      K = 0
      CWORK(1:52) = CBLK52(1:52)
C
C         READ THE FIRST RECORD ON UNIT 7
C
      K = 1
      READ (7,REC=K,IOSTAT=IEND) CWORK
C
C         DO LOOP TO PROCESS EACH VARIABLE NAME LOCATED IN CNAME, THE
C         MASTER LIST OF VARIABLE NAMES.
C
      DO 18 I = 1,INAME
C
C         PREVENT A SYNTHETIC VARIABLE FROM BEING PRINTED
C
      IF(CNAME(I)(2:3) .EQ. '##') GO TO 18
      JD = 0
      L4 = LFALSE
C
C         DETERMINE IF THE VARIABLE NAME IN CWORK IS LESS THAN THE ONE
C         IN CNAME.
C
C         DO LOOP INITIALIZATION TO SAVE ALL ISNS FOR A PARTICULAR
C         VARIABLE
C
      DO 10 IA = 1,1000
      ISNW(IA) = 0
 10   CONTINUE
      J = 0
      JJ = 0
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      CUSE(1:6) = CBLANK(1:6)
      CTYPL(1:8) = CBLANK(1:6)
C
C         DETERMINE IF THIS VARIABLE NAME IS TO APPEAR IN THE LISTINGS
C
      IF(.NOT.BTEST(IENAME(12,I),15)) GO TO 18
C
C         WHEN THE TABLE VARIABLE NAME AND THE UNIT 7 VARIABLE NAME
C         ARE THE SAME, DO NOT READ A RECORD FROM UNIT 7 EXCEPT WHEN K
C         IS GREATER THAN KK
C
      I4WK1 = JISN - 128
      IF(CNAME(I)(1:32) .EQ. CWORK(1:32)) CALL ITABIN (ISNW,JD,4,1,4,
     1   I4WK1,1,4,IRET,1000)
C
C         READ A CURRENT VARIABLE NAME'S ISN FROM UNIT 7 AND PUT
C         IT IN ARRAY ISNW WHEN THE NAMES FROM THE TWO RECORDS MATCH
C
 11   READ (7,REC=K,IOSTAT=IEND) CWORK
C
C         SAVE THE PREVIOUS VALUE OF K
C
      KK = K
C
C         DETERMINE IF THE VARIABLE NAME FROM UNIT 7 MATCHES THE NAME
C         IN THE MASTER NAME TABLE
C
      IF(CNAME(I)(1:32) .EQ. CWORK(1:32)) THEN
         L4 = LTRUE
C
C         DETERMINE IF THE VARIABLE NAMES MATCH BUT THE TYPE AND LENGTH
C         DEFINITIONS DO NOT
C
         IF(CNAME(I)(37:44) .NE. CWORK(37:44) .AND.
     1      .NOT.BTEST(IENAME(12,I),6) .AND. .NOT.BTEST(IENAME(12,I),13)
     2      .AND. .NOT.BTEST(IENAME(12,I),8) .AND.
     3      .NOT.BTEST(IENAME(12,I),9) .AND. .NOT.BTEST(IENAME(12,I),10)
     4      ) THEN
            GO TO 16
         ELSE IF(CNAME(I)(37:44) .NE. CWORK(37:44)) THEN
C
C         DETERMINE IF THE VARIABLE NAME IS A FUNCTION DEFINITION
C
            IF(BTEST(IENAME(12,I),10)) THEN
               CONTINUE
            ELSE
               GO TO 16
            END IF
         END IF
C
C         WHEN THE VARIABLE NAME FROM UNIT 7 AND FROM TABLE CNAME ARE
C         NOT EQUAL, PRINT THE ISN'S IN TABLE ISNW
C
         IF(CNAME(I)(37:44) .EQ. CWORK(33:44)) THEN
C
C         THE TYPE AND LENGTH OF CWORK MATCHES THAT OF CNAME
C
            ISNW(JD) = IWORK - 128
            J = JD
            GO TO 16
         END IF
      END IF
C
C         DETERMINE IF THE CURRENT VARIABLE NAME OCCURS IN A STRUCTURE
C
      IF(BTEST(IENAME(12,I),6) .OR. BTEST(IENAME(12,I),13)) THEN
C
C         DETERMINE IF THE TWO RECORDS NAMES' MATCH. VARIABLE NAMES MAY
C         BE UNIQUE. DISTINCTIONS DEPEND ON TYPE AND LENGTH DEFINITIONS.
C
         IF(CNAME(I)(1:32) .EQ. CWORK(1:32)) THEN
C
C         DETERMINE IF THE TYPE AND LENGTH CODES MATCH
C
            IF(CNAME(I)(37:44) .EQ. CWORK(37:44) .OR.
     1         BTEST(IENAME(12,I),13) .OR. BTEST(IENAME(12,I),6)) THEN
               IF(CNAME(I)(37:44) .EQ. CWORK(37:44)) J = J + 1
               IF(J .GT. 1000) THEN
                  WRITE (0,102) CWORK(1:32)
                  IREC0 = IREC0 + 1
               END IF
               IF(J .GT. 1) THEN
                  I4WK1 = JISN - 128
                  IF(I4WK1 .NE. ISNW(J-1)) THEN
                     IF(J .LE. 1000 .AND. CNAME(I)(37:44) .EQ.
     1                  CWORK(37:44)) CALL ITABIN (ISNW,JD,4,1,4,
     2                  I4WK1,1,4,IRET,1000)
                  ELSE
                     J = J - 1
                  END IF
               ELSE
                  I4WK1 = JISN - 128
                  CALL ITABIN (ISNW,JD,4,1,4,I4WK1,1,4,IRET,1000)
               END IF
C
C         DETERMINE IF THE NAME IS A STRUCTURE DEFINITION VARIABLE NAME.
C         IT MUST BE PRINTED WHEN NOT IN AN INCLUDE FILE.
C
               IF(BTEST(IENAME(12,I),13)) THEN
                  J = JD
                  K = K + 1
                  IF(K .LE. IREC7) THEN
                     GO TO 11
                  ELSE
                     GO TO 16
                  END IF
               END IF
C
C         DETERMINE IF THIS IS THE FINAL RECORD ON UNIT 7
C
               IF(K .EQ. IREC7) GO TO 16
               K = K + 1
               IF(K .LT. IREC7) GO TO 11
               IF(K .LE. IREC7) GO TO 11
C
C         DETERMINE IF ALL RECORDS FOR THE CURRENT NAME, TYPE, AND
C         LENGTH CHARACTERISTICS HAVE BEEN READ
C
            ELSE IF(CNAME(I)(37:44) .LT. CWORK(37:44)) THEN
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT REFERENCED WHEN NO
C         MATCHING RECORD EXISTS ON UNIT 7.
C
               IF(.NOT.BTEST(IENAME(12,I),15)) GO TO 18
               IF(J .EQ. 0 .AND. .NOT.BTEST(IENAME(12,I),8) .AND.
     1            .NOT.BTEST(IENAME(12,I),9) .AND.
     2            .NOT.BTEST(IENAME(12,I),10)) THEN
                  KISN = IENAME(9,I) - 128
                  IF(KISN .GT. 0)THEN
                     WRITE (0,100) KISN, CNAME(I)(1:32)
                     IREC0 = IREC0 + 1
                     GO TO 18
                  END IF
               ELSE
C
C         ALL THE ISNS FOR THE CURRENT VARIABLE NAME ARE NOW IN ISNW.
C
                  GO TO 16
               END IF
            ELSE IF(CNAME(I)(37:44) .GT. CWORK(37:44)) THEN
C
C         WHEN THE VARIABLE NAME IS C##NNN, DO NOT WRITE THE ERROR
C         MESSAGE
C
               IF(CWORK(1:3) .NE. 'C##') THEN
C
C         ALLOW PRINTING FOR VALID DATA TYPE CODES
C
                  IF(CWORK(37:37) .EQ. CAA) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CBB) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CCC) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CDD) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CEE) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CII) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CLL) THEN
                     GO TO 13
                  ELSE IF(CWORK(37:37) .EQ. CRR) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,2)) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,6)) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,13)) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,8)) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,9)) THEN
                     GO TO 13
                  ELSE IF(BTEST(JBITS,10)) THEN
                     GO TO 13
                  ELSE IF(L4) THEN
                     GO TO 13
                  END IF
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT DEFINED
C
                  KISN = JISN - 128
                  WRITE (0,101) KISN, CWORK(1:32)
                  IREC0 = IREC0 + 1
 13               K = K + 1
                  IF(K .LT. IREC7) GO TO 11
               END IF
            END IF
         ELSE IF(CNAME(I)(1:32) .LT. CWORK(1:32)) THEN
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT REFERENCED WHEN NO
C         MATCHING RECORD EXISTS ON UNIT 7.
C
            IF(.NOT.BTEST(IENAME(12,I),15)) GO TO 18
            IF(J .EQ. 0 .AND. .NOT.BTEST(IENAME(12,I),8) .AND.
     1         .NOT.BTEST(IENAME(12,I),9) .AND.
     2         .NOT.BTEST(IENAME(12,I),10) .AND.
     3         BTEST(IENAME(12,I),15) .AND.
     4         CWORK(37:44) .EQ. CNAME(I)(37:44)) THEN
               KISN = IENAME(9,I) - 128
               IF(KISN .GT. 0) THEN
                  WRITE (0,100) KISN, CNAME(I)(1:32)
                  IREC0 = IREC0 + 1
                  GO TO 18
               END IF
            ELSE
C
C         ALL THE ISNS FOR THE CURRENT VARIABLE NAME ARE NOW IN ISNW
C
               I4WK1 = JISN - 128
               IF(CWORK(1:32) .EQ. CNAME(I)(1:32))
     1            CALL ITABIN (ISNW,JD,4,1,4,I4WK1,1,4,IRET,1000)
            END IF
         ELSE IF(CNAME(I)(1:32) .GT. CWORK(1:32)) THEN
C
C         WHEN THE VARIABLE NAME ON UNIT 7 DOES NOT MATCH THE MASTER
C         TABLE NAME AND THE VARIABLE NAME IS A STRUCTURE VARIABLE,
C         DO NOT WRITE THE ERROR MESSAGE.
C
C         WHEN THE VARIABLE NAME IS C##NNN, DO NOT WRITE THE ERROR
C         MESSAGE
C
            IF(CWORK(1:3) .NE. 'C##') THEN
               IF(CWORK(37:37) .EQ. CAA) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CBB) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CCC) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CDD) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CEE) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CII) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CLL) THEN
                  GO TO 14
               ELSE IF(CWORK(37:37) .EQ. CRR) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,2)) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,6)) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,13)) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,8)) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,9)) THEN
                  GO TO 14
               ELSE IF(BTEST(JBITS,10)) THEN
                  GO TO 14
               ELSE IF(L4) THEN
                  GO TO 14
               END IF
C
C         OBTAIN THE BIT SWICHES FOR THIS VARIABLE NAME
C
               CALL TABSRH (CNAME,INAME,52,1,32,CWORK,1,32,IRET1,4000)
               IF(IRET1 .GT. 0) THEN
                  IF(BTEST(IENAME(12,IRET1),11)) GO TO 14
               END IF
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT DEFINED
C
               KISN = JISN - 128
               WRITE (0,101) KISN, CWORK(1:32)
               IREC0 = IREC0 + 1
 14            K = K + 1
               IF(K .LE. IREC7) GO TO 11
            END IF
         END IF
C
C         THE VARIABLE NAME DOES NOT OCCUR IN A STRUCTURE
C
      ELSE
C
C         WHEN THE VARIABLE NAME DOES NOT OCCUR WITHIN A STRUCTURE,
C         DETERMINE IF THE TWO RECORDS NAMES MATCH; THEREFORE, ONLY
C         NORMAL MATCHING IS NECESSARY BECAUSE THE VARIABLE IS UNIQUE.
C
         IF(CNAME(I)(1:32) .EQ. CWORK(1:32)) THEN
C
C         DETERMINE IF THE TYPE AND LENGTH CHARACTERISTICS FOR THE
C         MASTER VARIABLE NAME MATCHED BY THE RECORD ON UNIT 7
C
C         WHEN THIS IS THE FIRST ENTRY FOR ISNW, PLACE THE ISN IN THE
C         TABLE
C
            J = J + 1
            IF(J .GT. 1000) THEN
               WRITE (0,102) CWORK(1:32)
               IREC0 = IREC0 + 1
            END IF
            IF(J .GE. 1) THEN
               IF(J .LE. 1000) I4WK1 = JISN - 128
               IF(I4WK1 .NE. ISNW(J-1)) THEN
                  CALL ITABIN (ISNW,JD,4,1,4,I4WK1,1,4,IRET,1000)
               ELSE IF(I4WK1 .EQ. ISNW(J-1)) THEN
                  J = J - 1
               END IF
            ELSE
               I4WK1 = JISN - 128
               CALL ITABIN (ISNW,JD,4,1,4,I4WK1,1,4,IRET,1000)
            END IF
            K = K + 1
            IF(K .LE. IREC7) GO TO 11
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT REFERENCED WHEN NO
C         MATCHING RECORD EXISTS ON UNIT 7.
C
            IF(CNAME(I)(1:32) .LT. CWORK(1:32)) THEN
               IF(.NOT.BTEST(IENAME(12,I),15)) GO TO 18
               IF(J .EQ. 0 .AND. .NOT.BTEST(IENAME(12,I),8) .AND.
     1            .NOT.BTEST(IENAME(12,I),9) .AND.
     2            .NOT.BTEST(IENAME(12,I),10)) THEN
                  KISN = IENAME(9,I) - 128
                  WRITE (0,100) KISN, CNAME(I)(1:32)
                  IREC0 = IREC0 + 1
                  GO TO 18
               ELSE
C
C         ALL THE ISNS FOR THE CURRENT VARIABLE NAME ARE NOW IN ISNW
C
                  GO TO 16
               END IF
C
C         WRITE A MESSAGE THAT THE VARIABLE IS NOT DEFINED
C
            ELSE IF(CNAME(I)(1:32) .GT. CWORK(1:32)) THEN
C
C         WHEN THE VARIABLE NAME IS C##NNN, DO NOT WRITE THE ERROR
C         MESSAGE
C
               IF(CWORK(1:3) .NE. 'C##') THEN
                  IF(CWORK(37:37) .EQ. CAA) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CBB) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CCC) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CDD) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CEE) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CII) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CLL) THEN
                     GO TO 15
                  ELSE IF(CWORK(37:37) .EQ. CRR) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,2)) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,6)) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,13)) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,8)) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,9)) THEN
                     GO TO 15
                  ELSE IF(BTEST(JBITS,10)) THEN
                     GO TO 15
                  ELSE IF(L4) THEN
                     GO TO 15
                  END IF
                  KISN = JISN - 128
                  WRITE (0,101) KISN, CWORK(1:32)
                  IREC0 = IREC0 + 1
 15               K = K + 1
                  IF(K .LT. IREC7) GO TO 11
               END IF
            END IF
C
C         THE NEW CNAME VARIABLE IS NOT EQUAL TO THE ONE IN CWORK.
C         DETERMINE IF THE CWORK VARIABLE NAME IS LESS THAN THE ONE
C         IN CNAME.
C
         ELSE IF(CNAME(I)(1:32) .GT. CWORK(1:32)) THEN
            K = K + 1
            GO TO 11
         END IF
      END IF
C
C         SKIP PRINTING WHEN NO ISNS EXIST FOR A VARIABLE. THIS CAN
C         OCCUR WHEN A VARIABLE NAME IN A STRUCTURE OCCURRING IN AN
C         INCLUDE FILE IS IDENTICAL TO A NORMAL VARIABLE NAME.
C
 16   IF(BTEST(IENAME(12,I),7)) THEN      ! ARGUMENT
         JJ = JJ + 1
         CUSE(JJ:JJ) = CAA
      END IF
      IF(BTEST(IENAME(12,I),8)) THEN      ! ENTRY DEFINITION
         JJ = JJ + 1
         CUSE(JJ:JJ) = CBB
         L1 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
      IF(BTEST(IENAME(12,I),11)) THEN     ! COMMON DEFINITION
         IF(.NOT.L1) THEN
            JJ = JJ + 1
            CUSE(JJ:JJ) = CCC
         END IF
         L1 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
      IF(BTEST(IENAME(12,I),1)) THEN      ! COMMON VARIABLE
         IF(.NOT.L1) THEN
            JJ = JJ + 1
            CUSE(JJ:JJ) = CCC
         END IF
      END IF
      IF(BTEST(IENAME(12,I),17)) THEN     ! DIMENSIONED
         JJ = JJ + 1
         CUSE(JJ:JJ) = CDD
      END IF
      IF(BTEST(IENAME(12,I),3)) THEN      ! EQUIVALENCED
         JJ = JJ + 1
         CUSE(JJ:JJ) = CEE
      END IF
      IF(BTEST(IENAME(12,I),10)) THEN     ! FUNCTION DEFINITION
         JJ = JJ + 1
         CUSE(JJ:JJ) = CFF
         CALL TABSRH (CSUBTB,ISUBTB,56,1,32,CNAME(I),1,32,IRET,1000)
         IF(IRET .GT. 0) THEN
            CNAME(I)(37:44) = CSUBTB(IRET)(37:44)
            CTYPL(1:8) = CNAME(I)(37:37)//CASTER//CNAME(I)(38:43)
         ELSE
            IF(CNAME(I)(37:37) .NE. CBLANK(1:1)) THEN
               CTYPL(1:8) = CNAME(I)(37:37)//CASTER//CNAME(I)(38:43)
            ELSE
               CTYPL(1:8) = CBLANK(1:8)
               L1 = LTRUE
            END IF
         END IF
      END IF
      IF(BTEST(IENAME(12,I),12)) THEN     ! NAMELIST DEFINITION
         JJ = JJ + 1
         CUSE(JJ:JJ) = CNN
         L1 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)         ! NAMELIST USAGE
      END IF
      IF(BTEST(IENAME(12,I),4)) THEN
         JJ = JJ + 1
         CUSE(JJ:JJ) = CNN
         L1 = LFALSE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
      IF(BTEST(IENAME(12,I),14)) THEN     ! PARAMETER
         JJ = JJ + 1
         CUSE(JJ:JJ) = CPP
      END IF
      IF(BTEST(IENAME(12,I),2)) THEN      ! RECORD DEFINITION
         JJ = JJ + 1
         CUSE(JJ:JJ) = CRR
         IF(L1) L1 = LFALSE
         L2 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
      IF(BTEST(IENAME(12,I),9)) THEN      ! SUBROUTINE DEFINITION
         JJ = JJ + 1
         CUSE(JJ:JJ) = CSS
         L1 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
C
C         DETERMINE IF THIS IS A STRUCTURE DEFINITION OR VARIABLE
C         NAME
C
      IF(BTEST(IENAME(12,I),13) .OR. BTEST(IENAME(12,I),6)) THEN
         IF(.NOT.L3) THEN
            JJ = JJ + 1
            CUSE(JJ:JJ) = CTT
         END IF
         L2 = LTRUE
         L3 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
         IF(.NOT.L3) THEN
            JJ = JJ + 1
            CUSE(JJ:JJ) = CTT
            L3 = LTRUE
         END IF
      END IF
      IF(BTEST(IENAME(12,I),5)) THEN      ! UNION VARIABLE
         JJ = JJ + 1
         CUSE(JJ:JJ) = CUU
         L2 = LTRUE
         CTYPL(1:8) = CBLANK(1:8)
      END IF
C
C         CREATE THE TYPE AND LENGTH CHARACTERISTICS FOR THE CURRENT
C         VARIABLE WHEN NO ADJUSTMENTS ARE REQUIRED
C
      IF(.NOT.L1 .AND. .NOT.L2) THEN
         IF(CTYPL(1:2) .NE. '??') THEN
            CTYPL(1:8) = CNAME(I)(37:44)
         ELSE
         END IF
      END IF
C
C         SET THE TYPE AND LENGTH CHARACTERISTICS WHEN LENGTH EXISTS
C         BUT NO TYPE EXISTS
C
      IF(L2) THEN
         IF(BTEST(IENAME(12,I),6)) THEN
            CTYPL(1:1) = CNAME(I)(37:37)
         ELSE
            IF(BTEST(IENAME(12,I),0)) THEN
               CTYPL(1:1) = CNAME(I)(37:37)
            ELSE
               CTYPL(1:1) = CQUES(1:1)
            END IF
         END IF
         CTYPL(2:8) = CNAME(I)(38:44)
      END IF
C
C         DETERMINE THE NUMBER OF LINES OF PRINT REQUIRED TO LIST ALL
C         THE ISNS FOR THE CURRENT VARIABLE
C
      IF(J .NE. JD) J = JD
      IVCNT = IENAME(13,I)
      CALL VFMTC (II,IVCNT,CFMT1,J,I2WK1)
C
C         WRITE THE DATA FOR THE CURRENT VARIABLE
C
C         CASE 1: A SINGLE LINE LISTS ALL ISNS
C
      IF(II .EQ. 1) THEN
         IF(L1) THEN
            CFMT2(1:42) = CFMT1(1:42)
            CFMT2(14:17) = CBLANK(1:4)
            WRITE (6,CFMT2) CUSE(1:6),CTYPL(1:1),CTYPL(2:8),
     1      CNAME(I)(1:IVCNT),(ISNW(JC),JC = 1,J)
         ELSE
            WRITE (6,CFMT1) CUSE(1:6),CTYPL(1:1),CTYPL(2:8),
     1      CNAME(I)(1:IVCNT),(ISNW(JC),JC = 1,J)
         END IF
         ILINE = ILINE + 1
C
C         DETERMINE IF A NEW PAGE HEADER IS REQUIRED
C
         IF(K .LT. IREC7 .AND. (ILINE .GE. NLINES .OR. ILINE + 7 .GE.
     1      NLINES)) THEN
            IF(CFMTH(3:3) .EQ. C0(1:1)) CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,C100)
            WRITE (6,C101)
            ILINE = 7
         END IF
C
C         CASE 2: MULTIPLE LINES ARE REQUIRED TO LIST ALL ISNS
C
      ELSE IF(II .GT. 1) THEN
         IF(L1) THEN
            CFMT2(1:42) = CFMT1(1:42)
            CFMT2(8:20) = CBLK52(1:13)
            WRITE (6,CFMT2) CUSE(1:6),
     1      CNAME(I)(1:IVCNT),(ISNW(JC),JC = 1,I2WK1)
         ELSE
            WRITE (6,CFMT1) CUSE(1:6),CTYPL(1:1),CTYPL(2:8),
     1      CNAME(I)(1:IVCNT),(ISNW(JC),JC = 1,I2WK1)
         END IF
         ILINE = ILINE + 1
         DO 17 IA = 17,J,16
         IB = IA + 15
         IF(IB .GT. J) IB = J
         IF(K .LT. IREC7 .AND. (ILINE .GE. NLINES .OR. ILINE + 7 .GE.
     1      NLINES)) THEN
            IF(CFMTH(3:3) .EQ. C0(1:1)) CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,C100)
            WRITE (6,C101)
            ILINE = 7
         END IF
         WRITE (6,C103) (ISNW(JC),JC = IA,IB)
 17      CONTINUE
      END IF
C
C         SET THE VALUE OF JD TO ZERO AFTER ISNW IS COMPLETLY WRITTEN
C
      JD = 0
C
C         INCREASE THE VALUE OF K BY ONE IF A STRUCTURE DEFINITION
C         VARIABLE HAS BEEN PRINTED
C
      IF(BTEST(IENAME(12,I),13)) K = K + 1
C
C         DETERMINE IF THE NEXT RECORD IS THE END OF THE CNAME TABLE
C
      IF(I+1 .GT. INAME) GO TO 19
C
C         DETERMINE IF ALL RECORDS ON UNIT 7 ARE PROCESSED
C
      IF(K .GT. IREC7) GO TO 19
 18   CONTINUE
C
C         ROUTINE EXIT
C
 19   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE, CHKSWS, SETS BIT SWITCHES IN CNAME THAT ARE
C        SET IN MATCHING VARIABLE NAME RECORDS FROM UNIT 7 WHEN THOSE
C        SWITCHES ARE NOT SET IN CNAME
C
C        REFERENCE LISTING
C
C     MEANING OF THE VARIABLES
C
C         JBITS  - THE BIT SWITCHES IN CNAME
C         KBITS  - THE BIT SWITCHES IN THE RECORDS FORM UNIT 7
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         IBSET
C
C     *****************************************************************
C
      SUBROUTINE CHKSWS (JBITS,KBITS)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         SET BITS WHEN THE RECORD FROM UNIT 7 HAS SWITCHES SET THAT
C         WERE NOT YET SET IN CNAME.
C
      IF(BTEST(KBITS,1)) JBITS = IBSET(JBITS,1)
      IF(BTEST(KBITS,2)) JBITS = IBSET(JBITS,2)
      IF(BTEST(KBITS,3)) JBITS = IBSET(JBITS,3)
      IF(BTEST(KBITS,4)) JBITS = IBSET(JBITS,4)
      IF(BTEST(KBITS,5)) JBITS = IBSET(JBITS,5)
      IF(BTEST(KBITS,6)) JBITS = IBSET(JBITS,6)
      IF(BTEST(KBITS,7)) JBITS = IBSET(JBITS,7)
      IF(BTEST(KBITS,8)) JBITS = IBSET(JBITS,8)
      IF(BTEST(KBITS,9)) JBITS = IBSET(JBITS,9)
      IF(BTEST(KBITS,10)) JBITS = IBSET(JBITS,10)
      IF(BTEST(KBITS,11)) JBITS = IBSET(JBITS,11)
      IF(BTEST(KBITS,12)) JBITS = IBSET(JBITS,12)
      IF(BTEST(KBITS,13)) JBITS = IBSET(JBITS,13)
      IF(BTEST(KBITS,14)) JBITS = IBSET(JBITS,14)
      IF(BTEST(KBITS,15)) JBITS = IBSET(JBITS,15)
      IF(BTEST(KBITS,16)) JBITS = IBSET(JBITS,16)
      IF(BTEST(KBITS,17)) JBITS = IBSET(JBITS,17)
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE WILL PRINT THE NUMERICAL INTEGER CONSTANTS
C        LISTING. THIS IS TABLE 5.
C
C     MEANING OF THE VARIABLES
C
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         I      - SUBSCRIPT VARIABLE, CHOOSES THE INTEGER NUMBER BEING
C                  CURRENTLY LISTED
C         II     - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IB     - WORK AREA FOR DO LIMITS
C         IC     - COUNT OF THE NUMBER OF INTEGER CONSTANTS TO BE
C                  PRINTED
C         ICONI  - COUNT OF THE NUMBER OF INTEGER NUMBERS IN ICONIT
C         ICONIT - ARRAY OF ALL INTEGER CONSTANTS OCCURING IN THE
C                  PROGRAM, WORD 1 IS THE VALUE, WORD 2 IS THE ISN.
C         ID     - THE VALUE OF ICONIT(2,I) - 128, THE ISN VALUE
C         II     - SUBSCRIPT VARIABLE
C         ILINE  - PAGE LINE COUNT
C         IPAGE  - PAGE COUNT
C         ISNW   - LIST OF ALL ISNS OF AN INTEGER NUMBER IN ICONIT
C         IWORK  - THE WORK AREA FOR THE VALUE OF AN INTEGER NUMBER
C         I2WK1  - SUBSCRIPT VALUE OF THE FIRST ISN THAT IS NOT -1
C         J      - COUNT OF THE ISNS PLACED IN ISNW
C         JWORK  - THE PRINT AREA FOR AN INTEGER NUMBER
C         L      - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL ENTRY
C                  IS BEING PROCESSED, SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE SEARCH FOR
C                  DUPLICATE ISNS ARE COMPLETE, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN A NUMBER PRINT
C                  LINE IS COMPLETE, SET FALSE OTHERWISE
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         6 - OUTPUT LISTING OF CONSTANTS CROSS REFERENCES
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         NUPAGE
C
C     *****************************************************************
C
      SUBROUTINE PRINTC
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         DIMENSION STATEMENTS FOR THIS ROUTINE ONLY
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
      LOGICAL*1       L1, L2
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (NLINE,ILINE),
     1(CNAME(1),IENAME(1,1)), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 101  FORMAT('0  VALUE',8X,' INTERNAL STATEMENT NUMBERS')
 102  FORMAT(' ',I10,1X,18I6)
 103  FORMAT(12X,18I6)
 104  FORMAT(' INTEGER CONSTANTS  (EXCLUDES CONSTANTS IN FORMAT STATEMEN
     1TS)')
 105  FORMAT(' ',I10,1X,I6)
C
C         DETERMINE IF A NEW PAGE HEADER IS REQUIRED
C
      CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,104)
      WRITE (6,101)
C
C         SET DO LOOP FOR EACH INTEGER CONSTANT IN ICONIT
C
      IC = 0
      J = 0
      L = LFALSE
      L1 = LFALSE
      L2 = LFALSE
C
C         OBTAIN THE FIRST ISN FOR THE INITIAL NUMBER IN ICONIT
C
      DO 10 I = 1,ICONI
      ID = ICONIT(2,I) - 128
      IF(ID .NE. -1) THEN
         ISNW(1) = ID
         J = J + 1
         I2WK1 = I + 1
         IWORK = ICONIT(1,1)
         GO TO 11
      END IF
 10   CONTINUE
C
C         WHEN THE INITIAL TABLE CONSTANT HAS A VALUE OF ZERO, MAKE
C         JWORK NON-ZER0 TO INSURE CORRECT PROCESSING
C
 11   IF(IWORK .EQ. 0) JWORK = -1
C
C         CHECK IF ONLY A SINGLE CONSTANT EXISTS
C
      IF(ICONI .EQ. 1) THEN
         IF(J .NE. 0) THEN
            WRITE (6,105) ICONIT(1,1),ISNW(1)
            ILINE = ILINE + 1
         END IF
         GO TO 19
      END IF
C
C         CHECK FOR DUPLICATE ISNS WHEN ONLY TWO ENTRIES EXIST IN
C         ICONFT
C
      IF(ICONI .EQ. 2) THEN
C
C         DETERMINE IF ANY ISNS EXIST FOR THE CURRENT ROUTINE
C
         IF(J .EQ. 0) GO TO 19
C
C         OBTAIN THE ISN OF THE SECOND TABLE ENTRY
C
         ISNW(2) = ICONIT(2,2) - 128
C
C         DETERMINE IF THE TWO NUMBERS ARE EQUAL
C
         IF(ICONIT(1,1) .EQ. ICONIT(1,2)) THEN
C
C         DETERMINE IF THE THE TWO ISNS ARE EQUAL
C
            IF(ICONIT(2,1) .EQ. ICONIT(2,2)) THEN
C
C         DO NOT WRITE THE ISN IF THE VALUE IS -1; THIS INDICATES THE
C         NUMBER OCCURS IN AN INCLUDE FILE.
C
               IF(ISNW(1) .NE. -1) THEN
                  WRITE (6,105) ICONIT(1,1),ISNW(1)
                  ILINE = ILINE + 1
               END IF
               GO TO 19
            ELSE
C
C         THE TWO ISNS ARE NOT EQUAL
C         CASE 1: BOTH ISNS ARE NOT -1
C
               IF(ISNW(1) .NE. -1 .AND. ISNW(2) .NE. -1) THEN
                  WRITE (6,102) ICONIT(1,1),ISNW(1),ISNW(2)
                  ILINE = ILINE + 1
               END IF
C
C         CASE 2: THE SECOND ISN IS NOT -1
C
               IF(ISNW(1) .NE. -1 .AND. ISNW(2) .EQ. -1) THEN
                  WRITE (6,105) ICONIT(1,1),ISNW(1)
                  ILINE = ILINE + 1
               END IF
C
C         CASE 3: THE FIRST ISN IS NOT -1
C
               IF(ISNW(1) .EQ. -1 .AND. ISNW(2) .NE. -1) THEN
                  WRITE (6,105) ICONIT(1,1),ISNW(2)
                  ILINE = ILINE + 1
               END IF
               GO TO 19
            END IF
         ELSE
C
C         THE TWO NUMBERS ARE NOT EQUAL; PLACE THEM IN NUMERICAL ORDER.
C
            IF(ICONIT(1,1) .GT. ICONIT(1,2)) THEN
               ICONIT(1,1) = ICONIT(1,2)
               ICONIT(1,2) = IWORK
               ISNW(2) = ISNW(1)
               ISNW(1) = ICONIT(2,2) - 128
            END IF
C
C         WHEN THE TWO ISNS ARE NOT -1; PRINT EACH NUMBER ON A SEPARATE
C         LINE OF OUTPUT
C
            IF(ISNW(1) .NE. -1 .AND. ISNW(2) .NE. -1) THEN
               WRITE (6,102) ICONIT(1,1),ISNW(1)
               WRITE (6,102) ICONIT(1,2),ISNW(2)
               ILINE = ILINE + 2
            END IF
C
C         CASE 1: ISN 1 IS NOT -1; PRINT NUMBER 1.
C
            IF(ISNW(1) .NE. -1 .AND. ISNW(2) .EQ. -1) THEN
               WRITE (6,105) ICONIT(1,1),ISNW(1)
               ILINE = ILINE + 1
            END IF
C
C         CASE 2: ISN 2 IS NOT -1; PRINT NUMBER 2
C
            IF(ISNW(1) .EQ. -1 .AND. ISNW(2) .NE. -1) THEN
               WRITE (6,105) ICONIT(1,1),ISNW(2)
               ILINE = ILINE + 1
            END IF
            GO TO 19
         END IF
      END IF
C
C       MORE THAN TWO ENTRIES EXIST IN ICONIT. THE DO LOOP BEGINS WITH
C       SUBSCRIPT VALUE OF THE FIRST ISN GREATER THAN ZER0.
C
      DO 18 I = I2WK1,ICONI
C
C         PROCESS ALL THE ISNS FOR A NUMBER TO BE LISTED IN THE LISTING.
C         DETERMINE IF THE WORK AREA AND THE CURRENT INDEX NUMBER VALUES
C         ARE EQUAL
C
 12   IF(IWORK .EQ. ICONIT(1,I)) THEN
C
C         CHECK FOR DUPLICATE ISNS
C
         ID = ICONIT(2,I) - 128
         IF(ID .EQ. ISNW(J)) THEN
            IF(I .EQ. ICONI) THEN
               L = LTRUE
               L1 = LTRUE
               GO TO 13
            ELSE
               GO TO 13
            END IF
            GO TO 18
         END IF
C
C         DETERMINE IF THE ISN OF A NUMBER IS FROM AN INCLUDE FILE
C         BEFORE INSERTING IT INTO THE LIST TO BE PRINTED
C
 13      ID = ICONIT(2,I) - 128
         IF(ID .NE. -1) THEN
            IF(.NOT.L) THEN
               IF(.NOT. L2) J = J + 1
               L2 = LFALSE
            END IF
            IF(ISNW(J-1) .NE. ID) THEN
               ISNW(J) = ID
            ELSE
               J = J - 1
               GO TO 18
            END IF
         ELSE
            IF(J .NE. 0) J = J - 1
            GO TO 18
         END IF
C
C         DETERMINE IF THIS IS THE FINAL NUMBER TO BE PROCESSED
C
         IF(I .EQ. ICONI) THEN
            L1 = LTRUE
            GO TO 14
         END IF
         GO TO 18
      END IF
C
C         ALL ISNS ARE TABULATED FOR A GIVEN INTEGER
C         DETERMINE IF ANY ISNS EXIST FOR THIS NUMBER
C
      IF(J .EQ. 0) THEN
         L2 = LFALSE
         IWORK = ICONIT(1,I)
         ISNW(1) = ICONIT(2,I) - 128
         IF(ISNW(1) .NE. -1) J = 1
         GO TO 18
      END IF
C
C         TEST IF THE INTEGER ISNS HAVE ALREADY BEEN WRITTEN
C
 14   IF(IWORK .NE. ICONIT(1,I) .OR. L1) THEN
C
C        TEST IF THE END OF DUPLICATE ISNS WAS REACHED
C
         IF(L1) L1 = LFALSE
         IF(IWORK .EQ. JWORK) THEN
            L = LTRUE
            GO TO 16
         END IF
C
C         WRITE THE INTEGER'S CROSS REFERENCES
C
         JWORK = IWORK
         IC = IC + 1
         IF(J .LE. 18) THEN
            WRITE (6,102) JWORK,(ISNW(II),II = 1,J)
            ILINE = ILINE + 1
            IF(ILINE .GE. NLINES. OR. ILINE + 4 .GE. NLINES .AND. I .LT.
     1         ICONI) THEN
               CFMTH(3:3) = C1(1:1)
               IPAGE = IPAGE + 1
               WRITE (6,CFMTH) IPAGE
               WRITE (6,104)
               WRITE (6,101)
               ILINE = 4
            END IF
            IF(I .EQ. ICONI) THEN
               IF(ICONI .EQ. 1) GO TO 19
               IF(JWORK .LT. ICONIT(1,I)) GO TO 16
            END IF
         ELSE
            WRITE (6,102) JWORK,(ISNW(II),II = 1,18)
            ILINE = ILINE + 1
            IF(ILINE .GE. NLINES .OR. ILINE + 4 .GE. NLINES .AND. I .LT.
     1         ICONI) THEN
               CFMTH(3:3) = C1(1:1)
               IPAGE = IPAGE + 1
               WRITE (6,CFMTH) IPAGE
               WRITE (6,104)
               WRITE (6,101)
               ILINE = 4
            END IF
C
C         PRINT ADDITIONAL LINES WHEN MORE THAN 17 ISNS FOR A SINGLE
C         NUMBER
C
            DO 15 IA = 19,J,18
            IF(IA + 17 .GE. J) THEN
               IB = J
            ELSE
               IB = IA + 17
            END IF
            WRITE (6,103) (ISNW(II),II = IA,IB)
            ILINE = ILINE + 1
            IF(ILINE .GT. NLINES .OR. ILINE + 4 .GE. NLINES .AND. I .LT.
     1         ICONI) THEN
               CFMTH(3:3) = C1(1:1)
               IPAGE = IPAGE + 1
               WRITE (6,CFMTH) IPAGE
               WRITE (6,104)
               WRITE (6,101)
               ILINE = 4
            END IF
 15         CONTINUE
         END IF
C
C         RESET WORK VARIABLES
C
 16      DO 17 II = 1,J
 17      ISNW(II) = 0
         IWORK = ICONIT(1,I)
         ISNW(1) = ICONIT(2,I) - 128
C
C         TEST FOR AN END OF DATA IN ICONIT
C
         IF(L) GO TO 18
         IF(I .EQ. ICONI) THEN
            L = LTRUE
            IF(ISNW(1) .EQ. -1) GO TO 18
            J = 1
            GO TO 12
         END IF
         IF(J + IC .GT. ICONI .OR. ICONI .EQ. 1 .OR. L) GO TO 18
         J = 1
         IF(IC .EQ. ICONI) THEN
            GO TO 19
         ELSE
            IF(L) GO TO 19
            ISNW(J) = ICONIT(2,I) - 128
            IF(ISNW(1) .EQ. -1) GO TO 18
            L2 = LTRUE
            GO TO 12
         END IF
      END IF
 18   CONTINUE
C
C         SET NUMBER OF INTEGER CONSTANTS IN THE MODULE BEING ANALYZED
C
 19   IF(IC .GT. 0) ICONI = IC
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE MODIFIES THE FORMAT STATEMENTS CFMT1 TO WRITE
C        THE VARIABLE NAME LISTING, TABLE 2.
C
C     MEANING OF THE VARIABLES
C
C         CFMT1  - CHARACTER VARIABLE, CONTAINS THE FORMAT TO PRINT A
C                  LINE OF PRINT OF A VARIABLE NAME WHEN THE VARIABLE
C                  NAME IS NOT A SUBPROGRAM, COMMON, OR STRUCTURE NAME.
C                  IT ALLOWS PRINTING OF THE TYPE AND LENGTH
C                  CHARACTERISTIC OF A VARIABLE.
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1. USED TO
C                  CONVERT AN INTEGER TO CHARACTER FORM
C         II     - THE NUMBER OF LINES OF PRINT WHEN A VARIABLE LENGTH
C                  IS GREATER THAN EIGHT CHARACTERS
C         IVCNT  - COUNT OF THE NUMBER OF CHARACTERS IN A VARIABLE NAME
C         I1     - NUMBER OF ISN VALUES TO BE PRINTED IN A LINE OF PRINT
C         I2WK1  - NUMBER OF ISNS TO BE PRINTED ON A LINE OF PRINT
C         I4WK1  - WORK AREA TO CONVERT FROM INTEGER TO CHARACTER FORM
C         J      - COUNT OF THE ISNS PLACED IN ISNW IN ROUTINE PRINTV
C
C     COMMENTS
C
C         EACH LINE OF PRINT IS 121 CHARACTERS
C
C     *****************************************************************
C
      SUBROUTINE VFMTC (II,IVCNT,CFMT1,J,I2WK1)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         TYPE STATEMENTS
C
      CHARACTER*42  CFMT1
      CHARACTER*4   CI4WK1
      CHARACTER*1   CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1              CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2              CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3              CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4              CUNDER
      INTEGER*2     I2WK1
C
C        COMMON STATEMENTS
C
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CI4WK1,I4WK1)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT MODEL TO BE USED
C
C     DATA CFMT1/'(1X,A6,1X,A1,''*'',A7,T19,AXX,TXX,XXI6)'/
C
C         CONVERT THE LENGTH OF THE VARIABLE NAME TO CHARACTER FORM
C
      WRITE (CI4WK1,'(I4)') IVCNT
C
C         SET THE VALUE OF THE AXX FORMAT PARAMETER IN CFMT1
C
      IF(IVCNT .LT. 8) THEN
         CFMT1(26:28) = CI4WK1(4:4)//COMMA//' '
         CFMT1(30:31) = '26'
         CFMT1(33:34) = '16'
         I1 = 16
      ELSE IF(IVCNT .GE. 8 .AND. IVCNT .LT. 14) THEN
         CFMT1(30:31) = '32'
         IF(IVCNT .LT. 10) THEN
            CFMT1(26:28) = CI4WK1(4:4)//COMMA//' '
         ELSE
            CFMT1(26:28) = CI4WK1(3:4)//COMMA
         END IF
         CFMT1(33:34) = '15'
         I1 = 15
      ELSE IF(IVCNT .GE. 14 .AND. IVCNT .LE. 20) THEN
         CFMT1(30:31) = '38'
         CFMT1(26:28) = CI4WK1(3:4)//COMMA
         CFMT1(33:34) = '14'
         I1 = 14
      ELSE IF(IVCNT .GT. 20 .AND. IVCNT .LE. 26) THEN
         CFMT1(30:31) = '43'
         CFMT1(26:28) = CI4WK1(3:4)//COMMA
         CFMT1(33:34) = '13'
         I1 = 13
      ELSE IF(IVCNT .GT. 26 .AND. IVCNT .LE. 32) THEN
         CFMT1(30:31) = '49'
         CFMT1(26:28) = CI4WK1(3:4)//COMMA
         CFMT1(33:34) = '12'
         I1 = 12
      END IF
C
C         SET THE NUMBER OF LINES OF PRINT REQUIRED TO PRINT ALL THE
C         ISN VALUES FOR A SINGLE VARIABLE NAME
C
      I3 = J - I1
      IF(I3 .LT. 0) I3 = 0
      I2 = MOD(I3,16)
      II = I3/16 + 1
      IF(I2 .GT. 0) II = II + 1
C
C         SET THE NUMBER OF ISNS THAT CAN BE PRINTED ON A LINE OF PRINT
C         WHEN THE LENGTH OF THE VARIABLE NAME IS ADJUSTED FOR
C
      I2WK1 = I1
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE WILL PRINT THE STATEMENT NUMBERS CROSS
C         REFERENCE LISTING FOR EACH PROGRAM MODULE. THIS IS TABLE 3.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CII    - CHARCTER VARIABLE, THE CHARACTER I
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CSNUM  - CHARACTER VARIABLE, EQUIVALENCED TO ISNUM
C         CTYPE  - CHARACTER VARIBBLE, SORT CONTROL PARAMETER
C         CWRK   - CHARACTER VARIABLE, WORK VARIABLE
C         C0     - CHARACTER VARIABLE, THE DIGIT 0 (ZERO)
C         C1     - CHARACTER VARIABLE, THE DIGIT 1
C         C101   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE THE
C                  INITIAL LINE OF OUTPUT FOR THE STATEMENT NUMBER TABLE
C         C102   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE A
C                  PARTIAL FINAL LINE OF OUTPUT FOR THE STATEMENT NUMBER
C                  TABLE
C         C103   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE ALL
C                  FULL 16 ISN LINES OF OUTPUT ADTER THE FIRST LINE FOR
C                  THE STATEMENT NUMBER TABLE
C         C6     - CHARACTER VARIABLE, THE DIGIT 6
C         I      - SUBSCRIPT VARIABLE
C         IA     - THE START INDEX VALUE TO PRINT ISNS
C         IB     - THE END INDEX VALUE TO PRINT ISNS
C         IEND   - WHEN EQUAL TO -1, THE END OF FILE HAS BEEN REACHED
C                  ON UNIT 4
C         II     - WORK AREA
C         ILINE  - NUMBER OF LINES PRINTED ON A PAGE
C         IPAGE  - PAGE COUNT
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IREC4  - COUNT OF THE NUMBER OF RECORDS ON UNIT 4
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IRET   - A VALUE RETURNED FROM SUBROUTINE TABSRH; WHEN IRET
C                  IS GREATER THAN 0, A MATCH WAS FOUND. AND IRET IS
C                  THE INDEX WHERE THE MATCHING ARGUMENT WAS FOUND.
C                  WHEN IRET IS LESS THAN 0, NO MATCH WAS FOUND, AND
C                  IRET IS WHERE THAT NON-MATCHING FIELD MAY BE PLACED
C                  IN THE TABLE.
C         ISN    - INTERNAL STATEMENT NUMBER FOR THE CURRENT STATEMENT
C         ISNW   - SAVE ARRAY OF ALL ISNS REFERRING TO A SINGLE
C                  STATEMENT NUMBER; A MAXIMUM OF 1000 VALUES PER
C                  STATEMENT NUMBER ARE ALLOWED.
C         ISNUM  - TABLE OF DEFINED STATEMENT NUMBERS FOUND IN THE
C                  PROGRAM; WORD 1 CONTAINS THE STATEMENT
C                  NUMBER VALUE, WORD 2 CONTAINS THE ISN DEFINING
C                  THE STATMENT NUMBER (128 IS NOT ADDED TO THIS VALUE)
C         ISTART - START LOCATION WITHIN A RECORD FOR A SORT
C         IWRK   - INPUT BUFFER FOR THE RECORDS ON UNIT 4
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         I3     - SUBSCRIPT VARIABLE
C         I2WK1  - WORK AREA, USED TO CREATE THE ISN VALUE FOR AN ERROR
C                  MESSAGE, AND THE COMPUTED NUMBER OF LINES OF PRINT
C                  CONTAINING 16 ISNS.
C         I2WK2  - WORK AREA, CONTAINS THE LIMIT COUNT OF THE NUMBER OF
C                  ISNS OF FULL 16 LINES OF PRINT FOR A STATEMENT NUMBER
C                  WHEN MORE THAN A SINGLE LINE OF PRINT IS REQUIRED.
C         I4WK1  - WORK AREA USED TO CONVERT AN INTEGER TO TEXT;
C                  EQUIVALENCED TO CI4WK1
C         J      - SUBSCRIPT VARIABLE, INDEX VALUE TO PLACE STATEMENT
C                  NUMBERS READ FROM UNIT 7. THIS IS THE NUMBER OF ISNS
C                  TO BE PRINTED FOR A SINGLE STATEMENT NUMBER.
C         JA     - SUBSCRIPT VARIABLE
C         K      - ASSOCIATE VARIABLE TO READ RECORDS FROM UNIT 4
C         LASC   - LOGICAL VARIABLE, USED TO DETERMINE IF AN ASCENDING
C                  OR DECENDING SORT IS TO BE PERFORMED
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN AN ISN IS NOT
C                  REFERENCED AND AN ERROR MESSAGE HAS BEEN WRITTEN,
C                  SET FALSE OTHERWISE. THIS PRVENTS MULTIPLE ERROR
C                  MESSAGES FOR THE SAME ISN.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN ISN IS NOT
C                  DEFINED AND AN ERROR MESSAGE HAS BEEN WRITTEN,
C                  SET FALSE OTHERWISE. THIS PRVENTS MULTIPLE ERROR
C                  MESSGES FOR THE SAME ISN.
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN AN ISN IS ENTERED
C                  INTO ISNW (THE TABLE OF ISNS TO BE PRINTED), SET
C                  FALSE OTHERWISE
C         MNUM   - COUNT OF THE NUMBER OF ENTRIES IN TABLE ISNUM; THIS
C                  IS A LIST OF DEFINED STATEMENT NUMBERS.
C         NLINE  - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON A
C                  SINGLE PAGE IN THE OUTPUT LISTINGS
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C
C     INPUT - OUTPUT UNITS USED
C
C         4      - THE LIST OF PROGRAM STATEMENT NUMBERS AND THEIR ISNS
C                  REFERENCED BY STATEMENTS OTHER THAN THE DEFINING ONE
C                  IN THE PROGRAM, RECORD LENGTH IS 8 CHARACTERS
C
C                  RECORD STRUCTURE
C
C                  COLUMNS   DESCRIPTION
C                    1 - 4   INTEGER VALUE OF A STATEMENT NUMBER + 128
C                    5 - 8   INTEGER VALUE OF THE ISN + 128
C
C         6      - THE OUTPUT LISTING FILE TO BE PRINTED
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         MISRT1 NUPAGE TABSRH
C
C     *****************************************************************
C
      SUBROUTINE PRINTS
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION IWRK(2), ISNWS(1,1000), CSNUM(1000), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*24    C101
      CHARACTER*14    C102, C103
      CHARACTER*8     CBLANK, CIMPL, CWRK, CWK8, CSNUM
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1, I2WK2
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
      LOGICAL*1       L1, L2, L3
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK),  (CWORK(45:48),
     1JBITS), (CNAME(1),IENAME(1,1)), (CI4WK1,I4WK1), (CWRK,IWRK),
     2(NLINE,ILINE), (CWK8(2:2),CWK7), (ISNW(1),ISNWS(1,1)),
     3(CSNUM,ISNUM), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA C101 /'('' '',I6,T10,I6,T18,XXI6)'/
      DATA C102 /'('' '',T18,XXI6)'/
      DATA C103 /'('' '',T18,16I6)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' STATEMENT NUMBERS'//2X,'LABEL',3X,'DEFINED',1X,
     1'REFERENCED ISNS')
 101  FORMAT(' ',I6,T10,I6)
 102  FORMAT(' ISN:',I6,' STATEMENT NUMBER NOT REFERENCED: ',I5)
 103  FORMAT(' ISN:',I6,' STATEMENT NUMBER NOT DEFINED: ',I5)
 104  FORMAT(' ISN:',I6,' STATEMENT NUMBER IS DEFINED MORE THAN ONCE: ',
     1I5)
C
C         WHEN A SINGLE STATEMENT NUMBER OCCURS ON UNIT 4, BUT NO
C         STATEMENT NUMBER OCCURS IN ISNUM, ISSUE A DIAGNOSTIC MESSAGE
C
      IF(IREC4 .GT. 0 .AND. MNUM .EQ. 0) THEN
         DO 10 K = 1,IREC4
         READ (4,REC=K) IWRK
         I2WK1 = IWRK(1) - 128
         II = IWRK(2) - 128
         WRITE (0,103) II,I2WK1
         IREC0 = IREC0 + 1
10       CONTINUE
         GO TO 18
      ELSE IF(IREC4 .EQ. 0 .AND. MNUM .GT. 0) THEN
         DO 11 I = 1,MNUM
         WRITE (0,102) ISNUM(2,I),ISNUM(1,I)
         IREC0 = IREC0 + 1
 11      CONTINUE
         GO TO 18
      END IF
C
C         WRITE THE PAGE HEADER FOR THE STATEMENT NUMBERS TABLE
C
      CALL NUPAGE (4)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,100)
C
C         INITIALIZATION
C
      K = 0
      L2 = LFALSE
      CI4WK1(1:4) = CBLANK(1:4)
C
C         PROCESS EACH DEFINED STATEMENT NUMBER IN ISNUM
C
      DO 17 I = 1,MNUM
      L1 = LFALSE
      J = 0
C
C         SET STATEMENT NUMBER OCCURRENCE LIST ARRAY TO ZEROS
C
      DO 12 I1 = 1,1000
      ISNW(I1) = 0
 12   CONTINUE
C
C         WHEN A DEFINED STATEMENT NUMBER OCCURS MORE THAN ONCE, WRITE
C         A DIAGNOSTIC MESSAGE, AND SKIP PROCESSING FOR THE DUPLICATE
C         STATEMENT NUMBER.
C
      IF(I .GT. 1 .AND. I .LT. MNUM) THEN
         IF(ISNUM(1,I) .EQ. ISNUM(1,I+1)) THEN
            I2WK1 = ISNUM(2,I)
            WRITE (0,104) I2WK1,ISNUM(1,I)
            IREC0 = IREC0 + 1
            GO TO 17
         END IF
      END IF
C
C         READ THE LIST OF STATEMENT NUMBERS REFERRED TO WITHIN THE
C         PROGRAM MODULE
C
 13   K = K + 1
      L3 = LFALSE
      READ (4,REC=K,IOSTAT=IEND) IWRK
C
C         WHEN IREC4 IS EQUAL TO ONE, PRINT THE SINGLE STATEMENT NUMBER
C
      IF(IREC4 .GE. 1 .AND. IREC4 .LE. 2) THEN
         J = 1
C        I1 = IWRK(1)
         I1 = IWRK(1) - 128
         IF(ISNUM(1,I) .EQ. I1) ISNW(J) = IWRK(2)
         IF(ISNUM(1,I) .EQ. I1) ISNW(J) = IWRK(2) - 128
         IF(IREC4 .EQ. 2) THEN
            K = K + 1
            READ (4,REC=K,IOSTAT=IEND) IWRK
            I1 = IWRK(1) - 128
            IF(I1 .EQ. ISNUM(1,1)) THEN
               J = 2
               ISNW(J) = IWRK(1) - 128
               GO TO 14
            ELSE
               K = K - 1
               GO TO 14
            END IF
         END IF
         GO TO 14
      END IF
C
C         DETERMINE IF THE NEW CWRK(1) MATCHES THE FORMER IRET TABLE
C         MATCH. THIS INDICATES ALL REFERENCES TO THE FORMER IRET
C         TABLE STATEMENT NUMBER HAVE BEEN READ. WRITE THE OUTPUT FOR
C         THIS TABLE.
C
      IF(IRET .GT. 0) THEN
         IF(ISNUM(1,I) .LT. IWRK(1)-128) GO TO 14
      ELSE IF(IRET .LT. 0) THEN
         IF(ISNUM(1,I) .NE. IWRK(1)-128) GO TO 14
      END IF
C
C         DETERMINE IF THE END OF FILE HAS BEEN REACHED
C
      IF(K .GT. IREC4 .AND. IEND .EQ. -1) THEN
         IF(I .LE. MNUM) THEN
            I2WK1 = ISNUM(2,I) - 128
            II = ISNUM(1,I) - 128
            WRITE (0,102) I2WK1,II
            IREC0 = IREC0 + 1
            GO TO 17
         END IF
         GO TO 18
      END IF
C
C         DETERMINE IF THE STATEMENT NUMBER MATCHES THE TABLE ENTRY
C
C     CALL TABSRH (CSNUM,MNUM,8,1,4,CWRK,1,4,IRET,1000)
      DO 130 IRET = 1,MNUM
      IF(IWRK(1)-128 .EQ. ISNUM(1,IRET)) GO TO 131
 130  CONTINUE
      IRET = -1
C
C         WHEN THE CURRENT ISN FROM UNIT 4 HAS NOT BEEN PLACED IN
C         VARIABLE ISNW, INSERT THE VALUE.
C
 131  IF(IRET .LT. 0 .AND. ISNUM(1,I) .EQ. IWRK(1)-128) THEN
         L3 = LTRUE
         J = J + 1
         ISNW(J) = IWRK(2) - 128
         K = K + 1
         GO TO 13
      END IF
      IF(IRET .GT. 0 .AND. ISNUM(1,IRET) .EQ. IWRK(1)-128 .OR. J .EQ. 0)
     1   THEN
C
C         MOVE THE USAGE ISN TO THE SAVE ARRAY, ISNW
C
         J = J + 1
         ISNW(J) = IWRK(2) - 128
         IF(K .GT. IREC4) GO TO 14
C
C         DETERMINE IF THE END OF FILE HAS BEEN REACHED
C
         IF(K .LT. IREC4) GO TO 13
C
C         WHEN THE FINAL RECORD ON UNIT FOUR IS BEING PROCESSED, MAKE
C         SURE THE OUTPUT RECORD IS WRITTEN
C
         IF(K .EQ. IREC4 .AND. J .GT. 0) GO TO 14
C
C         WHEN NO MATCH OCCURS, DETERMINE IF THE UNIT 4 RECORD STATEMENT
C         NUMBER IS GREATER THAN THE TABLE VALUE. THIS CASE TERMINATES
C         THE USAGE DATA FOR THE STATEMENT NUMBER IN ARRAY ISNUM.
C
      ELSE IF(.NOT.L1 .AND. IRET .GT. 0 .AND. ISNUM(1,IRET) .LT.
     1   IWRK(1)-128) THEN
C
C         WRITE A DIAGNOSTIC MESSAGE THAT THE STATEMENT NUMBER IS NOT
C         REFERENCED, AND CONTINUE LOOP FOR ANOTHER TABLE ISN.
C
         IF(J .LE. 0 .AND. IRET .LT. 0) THEN
            I2WK1 = IWRK(2) - 128
            II = IWRK(1) - 128
            WRITE (0,102) I2WK1,II
            IREC0 = IREC0 + 1
            L1 = LTRUE
C
C         WHEN THE STATEMENT NUMBER FOR THE ERROR MESSAGE IS LESS THAN
C         THE ONE READ FROM UNIT 4, DECREMENT K BY ONE TO PREVENT
C         SKIPPING OVER THAT RECORD.
C
            IF(IWRK(1)-128 .GT. ISNUM(2,I)) K = K - 1
C
C         DETERMINE IF THE END OF FILE HAS BEEN REACHED
C
            IF(K .LT. IREC4) GO TO 13
         ELSE
C
C         ALL THE STATEMENT VALUES MATCHING THE ISNUM VALUE ARE NOW
C         IN ISNW
C
            GO TO 14
         END IF
C
C         WHEN NO MATCH OCCURS, DETERMINE IF THE UNIT 4 RECORD ISN IS
C         LESS THAN THE TABLE VALUE
C
      ELSE IF(IRET .LT. 0 .AND. K .LT. IREC4 .AND. .NOT.L3) THEN
         IRET = -IRET
C        IF(ISNUM(1,IRET) .GT. IWRK(1)) THEN
         IF(ISNUM(1,IRET) .GT. IWRK(1)-128) THEN
C
C         WRITE A DIAGNOSTIC MESSAGE THAT THE STATEMENT NUMBER IS NOT
C         DEFINED
C
            I2WK1 = IWRK(2) - 128
            II = IWRK(1) - 128
            WRITE (0,103) I2WK1,II
            IREC0 = IREC0 + 1
            IF(K .LT. IRET) K = K + 1
            GO TO 13
         END IF
      END IF
C
C         SORT THE ISNS INTO ASCENDING ORDER FOR PRINTING
C
 14   IF(J .GT. 1) THEN
         DO I3 = 1,5
         ISTART(I3) = 0
         IFLEN(I3) = 0
         LASC(I3) = LFALSE
         CTYPE(I3) = CBLANK(1:1)
         END DO
         ISTART(1) = 1
         IFLEN(1) = 4
         CTYPE(1) = CII
         CALL MISRT1 (ISNWS,J,1000)
      END IF
C
C         WHEN ALL THE SAVED STATEMENT NUMBER RECORDS ON UNIT 4 MATCHING
C         THE TABLE ARE PROCESSED, INITIALIZE SET UP FOR PRINTING A
C         STATEMENT NUMBER TABLE OUTPUT LINE.
C
C         CREATE THE FORMAT STATEMENT TO WRITE THE LISTING OF ISNS FOR
C         THE CURRENT VARIABLE NAME
C
      WRITE (CI4WK1,'(I4)') J
C
C         DETERMINE IF A SINGLE LINE OF PRINT CAN LIST ALL ISNS
C
      IF(J .LE. 16) THEN
C
C         MODIFY C101 TO WRITE THE SINGLE LINE OF PRINT FOR THE
C         STATEMENT NUMBER
C
         IF(J .LT. 10) THEN
            C101(20:20) = CBLANK(1:1)
            C101(21:21) = CI4WK1(4:4)
         ELSE
            C101(20:21) = CI4WK1(3:4)
         END IF
C
C         DETERMINE IF A NEW PAGE HEADER MUST BE PRINTED
C
         IF(ILINE .LT. NLINES) GO TO 15
C
C         DETERMINE IF THE LINE WILL FIT ON THE CURRENT PAGE OF THE
C         LISTING
C
         CALL NUPAGE (7)
         WRITE (6,CFMTH) IPAGE
         WRITE (6,100)
         ILINE = ILINE + 5
C
C         WRITE THE LISTING LINE
C
 15      IF(J .GT. 0) THEN
            WRITE (6,C101) ISNUM(1,I),ISNUM(2,I),(ISNW(JA),JA = 1,J)
         ELSE
            WRITE (6,101) ISNUM(1,I),ISNUM(2,I)
         END IF
         ILINE = ILINE + 1
         IF(ILINE .GE. NLINES .AND. I .LT. MNUM) THEN
            CALL NUPAGE (7)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = 5
         END IF
         K = K - 1
         GO TO 17
      END IF
C
C         DETERMINE IF MORE THAN A SINGLE LINE OF PRINT IS NECESSARY TO
C         LIST ALL ISNS
C
      IF(J .GT. 16) THEN
C
C         COMPUTE THE NUMBER OF LINES OF PRINT NECESSARY TO LIST ALL THE
C         THE REFERRALS OF THE STATEMENT NUMBER WITH 16 ISNS.
C
         I2WK1 = J/16
         I2WK2 = 16 * (I2WK1 - 1)
C
C         MODIFY C101 TO WRITE THE FIRST LINE OF PRINT
C
         C101(20:21) = C1//C6
C
C         WRITE THE INITIAL LINE OF THE LISTING FOR THIS STATEMENT
C         NUMBER
C
         WRITE (6,C101) ISNUM(1,I),ISNUM(2,I),(ISNW(JA),JA = 1,16)
         ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE STATEMENT NUMBERS TABLE
C
         IF(ILINE .GE. NLINES .AND. I .LT. MNUM) THEN
            CALL NUPAGE (7)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = ILINE + 5
         END IF
C
C         WRITE ALL OF THE REMAINING FULL 16 ISN LINES OF THE STATEMENT
C         NUMBER
C
         IF(I2WK1 - 1 .NE. 0) THEN
            DO 16 I1 = 2,I2WK1
            IA = 16 * (I1 - 1) + 1
            IB = IA + 15
            WRITE (6,C103) (ISNW(I2),I2 = IA,IB)
            ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE STATEMENT NUMBERS TABLE
C
            IF(NLINE .GE. NLINES .AND. I .LT. MNUM) THEN
               CALL NUPAGE (7)
               WRITE (6,CFMTH) IPAGE
               WRITE (6,100)
               ILINE = 5
            END IF
 16         CONTINUE
         END IF
C
C         MODIFY C102 TO WRITE THE FINAL OUTPUT LINE OF PRINT FOR THE
C         STATEMENT NUMBER
C
         IA = J - 16 * I2WK1
         IF(IA .GT. 0) THEN
            WRITE (CI4WK1,'(I4)') IA
            IF(IA .LT. 10) THEN
               C102(10:10) = CBLANK(1:1)
               C102(11:11) = CI4WK1(4:4)
            ELSE
               C102(10:11) = CI4WK1(3:4)
            END IF
C
C         SET THE STARTING INDEX FOR THE IMPLIED DO LOOP
C
            IA = 16 * I2WK1 + 1
C
C         WRITE THE FINAL PARTIAL LINE OF ISNS FOR THE STATEMENT NUMBER
C
               WRITE (6,C102) (ISNW(I2),I2 = IA,J)
               ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE STATEMENT NUMBERS TABLE
C
               IF(ILINE .GE. NLINES .AND. I .LT. MNUM) THEN
                  CALL NUPAGE (7)
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,100)
                  ILINE = 5
               END IF
            END IF
         END IF
      IF(IWRK(1) .GT. ISNUM(1,I)) K = K - 1
 17   CONTINUE
C
C         ROUTINE EXIT
C
 18   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE WILL PRINT THE INPUT-OUTPUT UNIT NUMBERS CROSS
C         REFERENCE LISTING FOR EACH PROGRAM MODULE. THIS IS TABLE 4,
C         PART 1.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CNEWUN - CHARACTER VARIABLE, SAVE AREA FOR THE UNIT
C         CUNIT  - CHARACTER VARIABLE, THE TEXT FORM OF THE CURRENT
C                  NUMERICAL UNIT
C         C0     - CHARACTER VARIABLE, THE DIGIT 0 (ZERO)
C         C1     - CHARACTER VARIABLE, THE DIGIT 1
C         C101   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE THE
C                  INITIAL LINE OF OUTPUT FOR THE NUMERICAL UNIT ISNS
C         C102   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE ALL
C                  FOLLOWING LINES OF OUTPUT FOR THE NUMERICAL UNIT ISNS
C                  TABLE
C         I      - SUBSCRIPT VARIABLE, THE INDEX VALUE TO DETERMINE
C                  THE UNIT NUMBER IN IOUTC
C         IA     - THE START INDEX VALUE TO PRINT ISNS
C         IB     - THE END INDEX VALUE TO PRINT ISNS
C         IEND   - WHEN EQUAL TO -1, THE END OF FILE HAS BEEN REACHED
C                  ON UNIT 84
C         ILINE  - NUMBER OF LINES PRINTED ON A PAGE
C         IOUTC  - ARRAY OF INPUT-OUTPUT UNITS DEFINED AS AN INTEGER
C         IOUTNC - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN IOUTC
C         IPAGE  - PAGE COUNT
C         IPGNME - NUMBER OF CHARACTERS IN CPGNME, THE PROGRAM NAME
C         IREC8  - NUMBER OF RECORDS ON UNIT 8
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         ISNW   - SAVE ARRAY OF ALL ISNS REFERRING TO A SINGLE
C                  STATEMENT NUMBER; A MAXIMUM OF 1000 VALUES PER
C                  STATEMENT NUMBER ARE ALLOWED.
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE
C         I2WK1  - WORK AREA, USED TO CREATE THE ISN VALUE FOR AN ERROR
C                  MESSAGE
C         I3     - THE NUMBER OF ISNS REMAINING AFTER THE FIRST LINE OF
C                  PRINT
C         I4     - START LOCATION IN ISNW FOR THE FINAL PARTIAL LINE OF
C                  PRINT FOR A UNIT NUMBER
C         I4WK1  - WORK AREA USED TO CONVERT AN INTEGER TO TEXT;
C                  EQUIVALENCED TO CI4WK1
C         J      - SUBSCRIPT VARIABLE, INDEX VALUE TO PLACE STATEMENT
C                  NUMBERS READ FROM UNIT 8. THIS IS THE NUMBER OF ISNS.
C                  TO BE PRINTED FOR A SINGLE STATEMENT NUMBER.
C         J1     - THE ISN OF A NUMERICAL UNIT NUMBER + 128;
C         J2     - THE NUMERICAL UNIT NUMBER AS AN INTEGER + 128;
C         K      - ASSOCIATE VARIABLE TO READ UNIT 8
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         L1     - LOGICAL VARIABLE, SET TRUE TO PREVENT READING ANOTHER
C                  RECORD FROM UNIT 8, SET FALSE TO READ UNIT8. THIS IS
C                  USED TO PREVENT SKIPPING AN ISN RECORD.
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C
C     INPUT - OUTPUT UNITS USED
C
C         6      - THE OUTPUT LISTING FILE TO BE PRINTED
C         8      - THE LIST OF NUMERIC INPUT-OUTPUT UNITS AND THEIR
C                  ISNS, RECORD LENGTH IS 10 CHARACTERS
C
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1  - 4 I*4     1 THE UNIT NUMBER AS AN INTEGER + 128.
C                  5  - 8 I*4     2 THE ISN + 128 WHERE THE UNIT IS USED
C                  9 - 10 A*2       THE UNIT NUMBER IN TEXT FORM
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         NUPAGE
C
C     *****************************************************************
C
      SUBROUTINE PRINTI
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION IWRK(3), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*20    C101
      CHARACTER*14    C102
      CHARACTER*8     CBLANK, CIMPL, CWRK, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1, CI2WK2, CNEWUN, CUNIT
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1, I2WK2
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (I2WK2,CI2WK2), (CWORK(33:36),IWORK),
     1(CWORK(45:48),JBITS), (CNAME(1),IENAME(1,1)), (CI4WK1,I4WK1),
     2(CWRK,IWRK), (NLINE,ILINE), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA C101 /'('' '',3X,A2,T10,XXI6)'/
      DATA C102 /'('' '',T10,XXI6)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' NUMERICAL INPUT-OUTPUT UNITS'//2X,'UNIT',T10,'INTERNAL ST
     1ATEMENT NUMBERS (ISN)')
 102  FORMAT(1X,T10,17I6)
C
C         WRITE THE PAGE HEADER FOR THE NUMERIC UNIT NUMBERS TABLE
C
      CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,100)
C
C         INITIALIZATION
C
      L1 = LFALSE
      K = 0
      CI4WK1(1:4) = CBLANK(1:4)
      CI2WK1(1:2) = CBLANK(1:2)
      CUNIT(1:2) = CBLANK(1:2)
C
C         PROCESS EACH INPUT-OUTPUT NUMERIC UNIT NUMBER IN IOUTC
C
      DO 16 I = 1,IOUTNC
      WRITE (CUNIT,'(I2)') IOUTC(I)
C
C         SET THE ISNS TO BE PRINTED COUNTER AND SET THE ARRAY ISNW
C         TO ZEROS
C
      J = 0
      DO 10 JA = 1,1000
      ISNW(JA) = 0
 10   CONTINUE
C
C         READ THE LIST OF STATEMENT NUMBERS REFERRED TO WITHIN THE
C         PROGRAM MODULE
C
 11   IF(.NOT.L1) THEN
         K = K + 1
         READ (8,REC=K,IOSTAT=IEND) I1,I2,CI2WK1(1:2)
         J1 = I1 - 128
         J2 = I2 - 128
      ELSE
         L1 = LFALSE
      END IF
C
C         DETERMINE IF THE END OF FILE HAS BEEN REACHED
C
      IF(K .GT. IREC8 .AND. IEND .EQ. -1) GO TO 17
C
C         DETERMINE IF THE UNIT NUMBER MATCHES THE TABLE
C
      IF(IOUTC(I) .EQ. J1) THEN
C
C         MOVE THE USAGE ISN TO THE SAVE ARRAY, ISNW
C
         J = J + 1
         ISNW(J) = J2
C
C         DETERMINE IF THE END OF DATA ON UNIT 8
C
         IF(K .GE. IREC8) GO TO 12
         GO TO 11
C
C         WHEN NO MATCH OCCURS, DETERMINE IF THE UNIT 8 RECORD UNIT
C         NUMBER IS GREATER THAN THE TABLE VALUE. THIS CASE TERMINATES
C         THE USAGE DATA FOR THE UNIT NUMBER IN ARRAY IOUTC.
C
      ELSE IF(IOUTC(I) .LT. J1) THEN
C
C         ALL THE STATEMENT VALUES MATCHING THE ISNUM VALUE ARE NOW
C         IN ISNW
C
C        CNEWUN = CI2WK1(1:2)
         CNEWUN = CUNIT(1:2)
         GO TO 12
      END IF
C
C         WHEN ALL THE SAVED UNIT NUMBER RECORDS ON UNIT 8 MATCHING
C         THE TABLE ARE PROCESSED, INITIALIZE SET UP FOR PRINTING A
C         UNIT NUMBER TABLE OUTPUT LINE.
C
C         CREATE THE FORMAT STATEMENT TO WRITE THE LISTING OF ISNS FOR
C         THE CURRENT VARIABLE NAME. J IS THE NUMBER ISNS TO BE PRINTED.
C
 12   WRITE (CI2WK2,'(I2)') J
C
C         DETERMINE IF A SINGLE LINE OF PRINT CAN LIST ALL ISNS
C
      IF(J .LE. 17 .AND. J .GT. 0) THEN
C
C         MODIFY C101 TO WRITE THE SINGLE LINE OF PRINT FOR THE UNIT
C         NUMBER
C
         C101(16:17) = CBLANK(1:2)
         IF(J .LT. 10) THEN
            IF(CI2WK2(2:2) .NE. C1) C101(17:17) = CI2WK2(2:2)
         ELSE
            C101(16:17) = CI2WK2(1:2)
         END IF
C
C         DETERMINE IF A NEW PAGE HEADER MUST BE PRINTED
C
         IF(ILINE .LT. NLINES) GO TO 13
C
C         DETERMINE IF THE LINE WILL FIT ON THE CURRENT PAGE OF THE
C         LISTING
C
         IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
            CALL NUPAGE (5)
            CFMTH(3:3) = C1(1:1)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = 5
         END IF
C
C         WRITE THE LISTING LINE
C
 13      WRITE (6,C101) CUNIT(1:2),(ISNW(JA),JA = 1,J)
         ILINE = ILINE + 1
         L1 = LTRUE
         IF(K .LT. IREC8 .AND. (ILINE .GE. NLINES .OR. ILINE + 5 .GE.
     1      NLINES)) THEN
            CALL NUPAGE (5)
            CFMTH(3:3) = C1(1:1)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = 5
         END IF
         GO TO 16
      END IF
C
C         DETERMINE IF MORE THAN A SINGLE LINE OF PRINT IS NECESARY TO
C         LIST ALL ISNS FOR A UNIT
C
      IF(J .GT. 17) THEN
C
C         MODIFY C101 TO WRITE A SINGLE FULL LINE OF PRINT FOR THE UNIT
C         NUMBER
C
         C101(16:16) = C1(1:1)
         C101(17:17) = C7(1:1)
C
C         WRITE THE INITIAL LINE OF THE LISTING FOR THIS UNIT NUMBER
C
         WRITE (6,C101) CUNIT(1:2),(ISNW(JA),JA = 1,17)
         ILINE = ILINE + 1
         L1 = LTRUE
         IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE.
     1      NLINES) THEN
            CALL NUPAGE (5)
            CFMTH(3:3) = C1(1:1)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = 5
         END IF
C
C         COMPUTE THE NUMBER OF FULL LINES OF PRINT NECESSARY TO LIST
C         THE ISNS FOR THE UNIT NUMBER
C
         I2WK1 = J/17
         I4 = 17 * I2WK1 + 1
         IF(I2WK1 .GT. 0) THEN
            I3 = J - I2WK1 * 17
          ELSE
            I3 = 0
         END IF
C
C         WRITE THE PAGE HEADER FOR THE UNIT NUMBERS TABLE WHEN
C         NECESSARY
C
         IF(ILINE .GE. NLINES .OR. ILINE + 7 .GE. NLINES) THEN
            CALL NUPAGE (5)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = 5
         END IF
C
C         WRITE ALL OF THE REMAINING FULL 17 ISNS LINES OF THE UNIT
C         NUMBER
C
         IF(J .GT. 17 .AND. I2WK1 .GT. 1) THEN
            DO 14 I1 = 2,J,17
            IF(I1 .EQ. 2) THEN
               IA = 17 * (I1 - 1) + 1
            ELSE
               IA = IB + 1
            END IF
            IB = IA + 16
            IF(IB .GT. J) GO TO 15
            WRITE (6,102) (ISNW(I2),I2 = IA,IB)
            ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE UNIT NUMBERS TABLE
C
            IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
               CALL NUPAGE (7)
               WRITE (6,CFMTH) IPAGE
               WRITE (6,100)
               ILINE = 5
            END IF
 14         CONTINUE
         END IF
C
C         MODIFY C102 TO WRITE THE FINAL OUTPUT LINE OF PRINT FOR THE
C         UNIT NUMBER
C
 15      IF(I2WK1 .GT. 1 .AND. I3 .GT. 17) THEN
            IA = J - (17 * I2WK1) - I3 * 17
         ELSE
            IA = I3
         END IF
         IF(IA .GT. 0) THEN
            WRITE (CI2WK2,'(I2)') IA
            IF(IA .LT. 10) THEN
               C102(10:10) = CBLANK(1:1)
               C102(11:11) = CI2WK2(2:2)
            ELSE
               C102(10:11) = CI2WK2(1:2)
            END IF
C
C         WRITE THE FINAL PARTIAL LINE OF ISNS FOR THE UNIT NUMBER
C
            WRITE (6,C102) (ISNW(I2),I2 = I4,J)
            ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE UNIT NUMBERS TABLE
C
            IF(K .LT. IREC8 .AND. (ILINE .GE. NLINES .OR. ILINE + 7 .GE.
     1         NLINES)) THEN
               CALL NUPAGE (5)
               WRITE (6,CFMTH) IPAGE
               WRITE (6,100)
               ILINE = 5
            END IF
         END IF
      END IF
      CI2WK1(1:2) = CBLANK(1:2)
 16   CONTINUE
C
C         ROUTINE EXIT
C
 17   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE WILL PRINT THE INPUT-OUTPUT UNIT VARIABLE
C         NAMES CROSS REFERENCE LISTING FOR EACH PROGRAM MODULE. THIS
C         IS TABLE 4, PART 2.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         COUTV  - CHARACTER VARIABLE, ARRAY OF INPUT-OUTPUT UNITS
C                  DEFINED AS A VARIABLE
C         CI2WK1 - WORK AREA, EQUIVALENCED TO I2WK1
C         CI2WK2 - WORK AREA, EQUIVALENCED TO I2WK2
C         CI2WK3 - WORK AREA, EQUIVALENCED TO I2WK3
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         C0     - CHARACTER VARIABLE, THE DIGIT 0 (ZERO)
C         C1     - CHARACTER VARIABLE, THE DIGIT 1
C         C101   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE THE
C                  INITIAL LINE OF OUTPUT FOR THE VARIABLE NAME UNIT
C                  ISNS
C         C102   - CHARACTER VARIABLE, THE FORMAT STATEMENT TO WRITE ALL
C                  FOLLOWING LINES OF OUTPUT FOR THE VARIABLE NAME UNIT
C                  ISNS TABLE
C         C40    - CHARACTER VARIABLE, INPUT BUFFER FROM UNIT 2
C         CWK40  - CHARACTER VARIABLE, INPUT BUFFER FROM UNIT 2; THIS
C                  BUFFER CONTAINS THE NEXT RECORD ON UNIT 2.
C         I      - SUBSCRIPT VARIABLE, THE INDEX VALUE TO DETERMINE
C                  THE UNIT VARIABLE NAME IN IOUTV
C         IA     - THE START INDEX VALUE TO PRINT ISNS
C         IB     - THE END INDEX VALUE TO PRINT ISNS
C         IC     - LOCATION OF A VARIABLE NAME IN ARRAY COUTV THAT
C                  MATCHES THE CARIABEL NAME ON UNIT 2.
C         IEND   - WHEN EQUAL TO -1, THE END OF FILE HAS BEEN REACHED
C                  ON UNIT 2
C         ILINE  - NUMBER OF LINES PRINTED ON A PAGE
C         IOUTNV - COUNT OF THE NUMBER OF INPUT-OUTPUT UNITS IN COUTV
C         IPAGE  - PAGE COUNT
C         IPGNME - NUMBER OF CHARACTERS IN CPGNME, THE PROGRAM NAME
C         IREC2  - NUMBER OF RECORDS ON UNIT 2
C         IREC10 - COUNT OF THE NUMBER OF RECORDS ON UNIT 10
C         IRET   - RETURN CODE FROM ROUTINE TABSRH
C         ISNW   - SAVE ARRAY OF ALL ISNS REFERRING TO A SINGLE
C                  STATEMENT NUMBER; A MAXIMUM OF 1000 VALUES PER
C                  STATEMENT NUMBER ARE ALLOWED.
C         I1     - ISN + 128 OF THE VARIABLE NAME UNIT
C         I2     - LENGTH + 128 OF THE VARIABLE NAME UNIT
C         I2WK1  - WORK AREA, USED TO CREATE THE ISN VALUE FOR AN ERROR
C                  MESSAGE
C         I2WK2  - WORK AREA, USED TO CONVERT THE NUMBER OF ISNS COUNT
C                  FOR A SINGLE VARIABLE NAME UNIT TO TEXT FORMAT.
C                  EQUIVALENCED TO CI2WK1; IT IS USED TO MODIFY THE
C                  FORMAT STATEMENTS C101, AND C102.
C         I2WK3  - WORK AREA, USED TO CONVERT THE LENGTH OF THE VARIABLE
C                  NAME UNIT TO TEST FORMAT. EQUIVALENCED TO CI2WK3;
C                  USED TO MODIFY THE FORMAT STATEMENTSW C101 AND C102.
C         I4WK1  - WORK AREA USED TO CONVERT AN INTEGER TO TEXT;
C                  EQUIVALENCED TO CI4WK1
C         J      - SUBSCRIPT VARIABLE, INDEX VALUE TO PLACE STATEMENT
C                  NUMBERS READ FROM UNIT 1. THIS IS THE NUMBER OF ISNS
C                  TO BE PRINTED FOR A SINGLE VARIABLE NAME UNIT
C         JA     - SUBSCRIPT VARIABLE
C         JB     - THE MAXIMUM NUMBER OF ISNS THAT CAN BE PRINTED ON A
C                  SINGLE LINE OF OUTPUT LISTING
C         JPGNME - WORK AREA USED TO DETERMINE VARIABLE NAME LENGTHS
C         J1     - THE ISN OF A VARIABLE NAME UNIT NUMBER
C         J2     - THE LENGTH OF A VARIABLE NAME UNIT NUMBER
C         J3     - THE MAXIMUM NUMBER OF ISNS PERMITTED ON A SINGLE LINE
C                  OF PRINT AFTER ADJUSTING FOR THE UNIT VARIABLE NAME
C                  LENGTH
C         K      - ASSOCIATE VARIABLE TO READ UNIT 2
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         L1     - LOGICAL VARIABLE, SET TRUE TO PREVENT READING ANOTHER
C                  RECORD FROM UNIT 2, SET FALSE TO READ UNIT 2. THIS IS
C                  USED TO PREVENT SKIPPING AN ISN RECORD.
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C
C     INPUT - OUTPUT UNITS USED
C
C          2     - THE LIST OF NUMERIC INPUT-OUTPUT UNITS AND THEIR
C                  ISNS, RECORD LENGTH IS 40 CHARACTERS
C
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                  1 - 32 A*32    8 THE UNIT AS A VARIABLE NAME
C                 33 - 36 I*4     9 THE ISN + 128 WHERE THE UNIT IS USED
C                 37 - 40 I*4    10 THE LENGTH + 128 OF THE VARIABLE
C                                   NAME IN COLS 1 - 32
C         6      - THE OUTPUT LISTING FILE TO BE PRINTED
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         NUPAGE TABSRH
C
C     ******************************************************************
C
      SUBROUTINE PRTVIO
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION IWRK(3), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL, C40, CWK40
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*18    C101
      CHARACTER*14    C102
      CHARACTER*8     CBLANK, CIMPL, CWRK, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1, CI2WK2, CI2WK3
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1, I2WK2
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC
      LOGICAL*1       L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (I2WK2,CI2WK2), (I2WK3,CI2WK3),
     1(CWORK(33:36),IWORK), (CWORK(45:48),JBITS), (NLINE,ILINE),
     2(CNAME(1),IENAME(1,1)), (CI4WK1,I4WK1), (CWRK,IWRK),
     3(C40(33:36),I1), (C40(37:40),I2), (CWK8(2:2),CWK7),
     4(CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA C101 /'('' '',AXX,TXX,XXI6)'/
      DATA C102 /'('' '',T10,XXI6)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' VARIABLE INPUT-OUTPUT UNITS'//2X,'UNIT',T10,'INTERNAL STA
     1TEMENT NUMBERS (ISN)')
 101  FORMAT(' ',T10,17I6)
C
C         WRITE THE PAGE HEADER FOR THE VARIABLE UNIT TABLE
C
      CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,100)
C
C         INITIALIZATION
C
      L1 = LFALSE
      K = 0
      CI4WK1(1:4) = CBLANK(1:4)
C
C         PROCESS EACH INPUT-OUTPUT VARIABLE UNIT IN IOUTC
C
      DO 16 I = 1,IOUTNV
C
C         SET THE ISNS TO BE PRINTED COUNTER AND SET THE ARRAY ISNW
C         TO ZEROS
C
      J = 0
      DO 10 JA = 1,1000
      ISNW(JA) = 0
 10   CONTINUE
C
C         READ THE LIST OF STATEMENT NUMBERS REFERRED TO WITHIN THE
C         PROGRAM MODULE
C
 11   IF(.NOT.L1) THEN
         K = K + 1
         READ (2,REC=K,IOSTAT=IEND) C40(1:40)
         J1 = I1 - 128
      ELSE
         L1 = LFALSE
      END IF
C
C         DETERMINE IF THE END OF FILE HAS BEEN REACHED
C
      IF(K .GT. IREC2 .AND. IEND .EQ. -1) GO TO 17
C
C         DETERMINE IF THE UNIT NAME MATCHES THE TABLE NAME
C
C
C         DETERMINE THE LOCATION OF THE VARIABLE IN COUTV(I) THAT
C         MATCHES THE VARIABLE NAME IN THE UNIT 2 RECORD
C
      CALL TABSRH (COUTV,IOUTNV,32,1,32,C40,1,32,IRET,100)
      IF(IRET .GT. 0) THEN
C
C         MOVE THE USAGE ISN TO THE SAVE ARRAY, ISNW
C
         J = J + 1
         ISNW(J) = J1
C
C         DETERMINE IF THE END OF DATA ON UNIT 15
C
         IF(K .GT. IREC2) GO TO 12
C
C         DETERMINE IF THE NEXT RECORD ON UNIT 2 MATCHES THE CURRENT
C         VARIABLE FROM COUTV
C
         I2WK3 = K + 1
         IF(I2WK3 .GT. IREC2) GO TO 12
         READ (2,REC=I2WK3) CWK40(1:40)
         IF(CWK40(1:32) .EQ. C40(1:32)) THEN
            GO TO 11
         ELSE
            GO TO 12
         END IF
      END IF
C
C         WHEN ALL THE SAVED UNIT NAME RECORDS ON UNIT 1 MATCHING
C         THE TABLE ARE PROCESSED, INITIALIZE SET UP FOR PRINTING A
C         UNIT NAME TABLE OUTPUT LINE.
C
C         CREATE THE FORMAT STATEMENT TO WRITE THE LISTING OF ISNS FOR
C         THE CURRENT VARIABLE NAME. J IS THE NUMBER ISNS TO BE PRINTED.
C
 12   WRITE (CI2WK2,'(I2)') J
      J2 = I2 - 128
      WRITE (CI2WK3,'(I2)') J2
C
C         SET THE TAB LOCATION WHERE ISNS ARE TO BEGIN IN THE OUTPUT
C         PRINT LINE, AND THEN SET THE NUMBER OF ISNS THAT MAY BE
C         PRINTED ON THE FIRST LINE.
C
      IF(J2 .LE. 8) THEN
         C101(11:12) = C1//C0
         JB = J
         J3 = 17
         GO TO 13
      ELSE IF(J2 .LE. 14) THEN
         C101(11:12) = C1//C6
         JB = J - 1
         J3 = 16
         GO TO 13
      ELSE IF(J2 .LE. 20) THEN
         C101(11:12) = C2//C2
         JB = J - 2
         J3 = 15
         GO TO 13
      ELSE IF(J2 .LE. 26) THEN
         C101(11:12) = C2//C8
         JB = J - 3
         J3 = 14
         GO TO 13
      ELSE
         C101(11:12) = C3//C2
         JB = J - 4
         J3 = 13
         GO TO 13
      END IF
C
C         MODIFY C101 FOR THE NUMBER OF ISNS ON THE LINE OF PRINT
C
 13   IF(J3 .LE. J) THEN
         WRITE (CI2WK2,'(I2)') J3
         IF(CI2WK2(1:1) .EQ. CBLANK(1:1)) THEN
            C101(14:15) = CBLANK(1:1)//CI2WK2(2:2)
         ELSE
            C101(14:15) = CI2WK2(1:2)
         END IF
      ELSE
         IF(CI2WK2(1:1) .EQ. CBLANK(1:1)) THEN
            C101(14:15) = CBLANK(1:1)//CI2WK2(2:2)
         ELSE
            C101(14:15) = CI2WK2(1:2)
         END IF
      END IF
C
C         MODIFY C101 FOR THE LENGTH OF THE VARIABLE NAME; FIRST, SET
C         THE VARIABLE NAME LENGTH.
C
      IF(CI2WK3(1:1) .EQ. CBLANK(1:1)) THEN
         C101(7:8) = CI2WK3(2:2)//CBLANK(1:1)
      ELSE
         C101(7:8) = CI2WK3(1:2)
      END IF
C
C         DETERMINE IF A SINGLE LINE OF PRINT CAN LIST ALL ISNS
C
      IF(J .LE. J3) THEN
C
C         SET THE NUMBER OF ISNS TO BE PRINTED WHEN NOT A FULL LIST OF
C         ISNS
C
         IF(J3 .GT. J) J3 = J
C
C         DETERMINE IF A NEW PAGE HEADER MUST BE PRINTED
C
         IF(ILINE .LT. NLINES) GO TO 14
C
C         DETERMINE IF THE LINE WILL FIT ON THE CURRENT PAGE OF THE
C         LISTING
C
         CALL NUPAGE (5)
         WRITE (6,CFMTH) IPAGE
         WRITE (6,100)
         ILINE = ILINE + 3
C
C         WRITE THE LISTING LINE
C
 14      WRITE (6,C101) COUTV(I)(1:J2),(ISNW(JA),JA = 1,J3)
         ILINE = ILINE + 1
      END IF
C
C         DETERMINE IF MORE THAN A SINGLE LINE OF PRINT IS NECESSARY TO
C         LIST ALL ISNS FOR A UNIT
C
      IF(JB .GT. J3) THEN
C
C         WRITE THE INITIAL LINE OF THE LISTING FOR THIS UNIT NUMBER
C
         WRITE (6,C101) COUTV(I)(1:J2),(ISNW(JA),JA = 1,J3)
         ILINE = ILINE + 1
         L1 = LTRUE
C
C         COMPUTE THE NUMBER OF FULL LINES OF PRINT NECESSARY TO LIST
C         THE ISNS FOR THE UNIT VARIABLE AFTER THE FIRST LINE OF PRINT.
C         THIS VALUE DOES NOT INCLUDE A FINAL LINE OF PRINT LISTING
C         AN INCOMPLETE LINE OF ISNS.
C
         I2WK1 = (J - J3)/17 + 1
C
C         WRITE THE PAGE HEADER FOR THE UNIT NUMBERS TABLE WHEN
C         NECESSARY
C
         CALL NUPAGE (5)
         IF(ILINE .GE. NLINES .OR. ILINE + 7 .GE. NLINES) THEN
            WRITE (6,CFMTH) IPAGE
            WRITE (6,100)
            ILINE = ILINE + 3
         END IF
C
C         WRITE ALL OF THE REMAINING FULL 17 ISNS LINES OF THE UNIT
C         VARIABLE
C
         IF(I2WK1 .GT. 0) THEN
            DO 15 I1 = 2,I2WK1
            IA = 17 * (I1 - 1) + 1
            IB = IA + 16
            WRITE (6,101) (ISNW(JA),JA = IA,IB)
            ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE VARIABLE UNIT TABLE
C
            CALL NUPAGE (5)
            IF(ILINE .GE. NLINES .OR. ILINE + 7 .GE. NLINES) THEN
               WRITE (6,CFMTH) IPAGE
               WRITE (6,100)
               ILINE = ILINE + 3
            END IF
 15         CONTINUE
         END IF
C
C         MODIFY C102 TO WRITE THE FINAL OUTPUT LINE OF PRINT FOR THE
C         UNIT NUMBER
C
         IA = J - J3 - (17 * (I2WK1 - 1))
         IF(IA .GT. 0) THEN
            WRITE (CI2WK2,'(I2)') IA
            C102(10:11) = CI2WK2(1:2)
            C102(7:8) = C101(11:12)
            IA = J3 + (17 * (I2WK1 - 1)) + 1
C
C         WRITE THE FINAL PARTIAL LINE OF ISNS FOR THE UNIT NUMBER
C
            WRITE (6,C102) (ISNW(I3),I3 = IA,J)
            ILINE = ILINE + 1
C
C         WRITE THE PAGE HEADER FOR THE UNIT NUMBERS TABLE
C
            CALL NUPAGE (5)
            IF(ILINE .GE. NLINES .OR. ILINE + 7 .GE. NLINES) THEN
               WRITE (6,CFMTH) IPAGE
               WRITE (6,100)
               ILINE = ILINE + 3
            END IF
         END IF
      END IF
 16   CONTINUE
C
C         ROUTINE EXIT
C
 17   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE WILL PRINT THE NUMERICAL REAL CONSTANTS LISTING
C        THIS IS TABLE 6.
C
C     MEANING OF THE VARIABLES
C
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         FCONFT - ARRAY OF ALL REAL CONSTANTS OCCURING IN THE PROGRAM.
C                  THE ARRAY IS DEFINED AS A DOUBLE PRECISION.
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE, CHOOSES THE INTEGER NUMBER BEING
C                  CURRENTLY LISTED
C         IA     - SUBSCRIPT VARIABLE
C         IB     - WORK AREA FOR DO LIMITS
C         IC     - WORK AREA FOR DO LIMITS
C         ICONF  - COUNT OF THE NUMBER OF REAL NUMBERS IN FCONFT
C         ID     - THE VALUE OF JCONFT(I) - 128, THE ISN VALUE
C         IE     - LOCATION OF THE NEXT REAL NUMBER IN FCONFT TO BE
C                  PROCESSED
C         II     - SUBSCRIPT VARIABLE
C         IJ     - SUBSCRIPT VARIABLE
C         ILINE  - PAGE LINE COUNT
C         IPAGE  - PAGE COUNT
C         ISNW   - LIST OF ALL ISNS OF A REAL NUMBER IN FCONFT
C         I2WK1  - SUBSCRIPT VALUE OF THE FIRST ISN THAT IS NOT -1
C         I2WK2  - NUMBER OF ISNS TO BE WRITTEN IN A PARTIAL FINAL LINE
C                  OF PRINT
C         J      - COUNT OF THE ISNS PLACED IN ISNW
C         JA     - SUBSCRIPT VARIABLE
C         JCONFT - ARRAY OF ISNS OF AN ENTRY IN FCONFT
C         JEND   - THE INDEX VALUE OF THE LAST ISN FOR A NUMBER
C         L1     - LOGICAL VARIABLE, SET TRUE FOR THE INITIAL NUMBER IN
C                  FCONFT PROCESSING, SET FALSE OTHERWISE
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         6 - OUTPUT LISTING OF CONSTANTS CROSS REFERENCES
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         NUPAGE
C
C     *****************************************************************
C
      SUBROUTINE PRINTF (IFNUM)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         DIMENSION STATEMENTS FOR THIS ROUTINE ONLY
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1, I2WK2
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (NLINE,ILINE), (CNAME(1),IENAME(1,1)),
     1            (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 101  FORMAT('0  VALUE',8X,' INTERNAL STATEMENT NUMBERS')
 102  FORMAT(' ',E16.7E3,1X,17I6)
 103  FORMAT(18X,17I6)
 104  FORMAT(' REAL CONSTANTS  (DOUBLE PRECISION IS SHOWN AS SINGLE PREC
     1ISION)')
 105  FORMAT(' ',E16.7E3,1X,I6)
C
C         DETERMINE IF A NEW PAGE HEADER IS REQUIRED
C
      CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,104)
      WRITE (6,101)
C
C         INITIALIZATION
C
      IC = 0
      J = 0
      L1 = LTRUE
      FP = 0.D0
      IFNUM = 0
C
C         DETERMINE IF SINGLE REAL NUMBER IS IN FCONFT
C
      IF(ICONF .EQ. 1) THEN
C
C         WHEN THE SINGLE NUMBER IS FROM AN INCLUDE FILE, DO NOT PRINT
C
         IF(JCONFT(1) .NE. -1) THEN
            WRITE (6,105) FCONFT(1),JCONFT(1)
            IFNUM = IFNUM + 1
            ILINE = ILINE + 1
         END IF
         WRITE (6,101)
         GO TO 15
      END IF
C
C         DETERMINE IF TWO REAL NUMBERS ARE IN FCONFT
C
      IF(ICONF .EQ. 2) THEN
C
C         DETERMINE IF THEY ARE EQUAL
C
         IF(FCONFT(1) .EQ. FCONFT(2)) THEN
C
C         INSURE THE ISNS ARE IN ASCENDING VALUE
C
            IF(JCONFT(1) .LT. JCONFT(2))THEN
               II = JCONFT(1)
               JCONFT(1) = JCONFT(2)
               JCONFT(2) = II
            END IF
C
C         DETECT IF THE ISNS ARE FROM AN INCLUDED FILE AND PRINT THE
C         LINE OF PRINT
C
            IF(JCONFT(1) .EQ. -1 .AND. JCONFT(2) .GT. 0) THEN
               WRITE (6,105) FCONFT(1),JCONFT(2)
               ILINE = ILINE + 1
               IFNUM = IFNUM + 1
            ELSE IF(JCONFT(1) .GT. 0 .AND. JCONFT(2) .EQ. -1) THEN
               WRITE (6,105) FCONFT(1),JCONFT(1)
               ILINE = ILINE + 1
               IFNUM = IFNUM + 1
            ELSE IF(JCONFT(1) .GT. 0 .AND. JCONFT(2) .GT. 0) THEN
               WRITE (6,102) FCONFT(1),(JCONFT(IA),IA = 1,2)
               ILINE = ILINE + 1
               IFNUM = IFNUM + 1
            END IF
            IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
               CALL NUPAGE (5)
               WRITE (6,CFMTH) IPAGE
               WRITE (6,104)
               WRITE (6,101)
            END IF
            GO TO 15
         ELSE
C
C         THE TWO NUMBERS ARE NOT EQUAL; INSURE THE NUMBER'S VALUES ARE
C         ARE IN ASCENDING VALUE
C
            IF(FCONFT(1) .GT. FCONFT(2)) THEN
               II = FCONFT(1)
               ID = JCONFT(1)
               FCONFT(1) = FCONFT(2)
               JCONFT(1) = JCONFT(2)
               FCONFT(2) = II
               JCONFT(2) = ID
            END IF
C
C         PRINT EACH LINE OF PRINT FOR BOTH NUMBERS IF THEY ARE NOT FROM
C         AN INCLUDE FILE
C
            IF(JCONFT(1) .NE. -1) THEN
               WRITE (6,105) FCONFT(1),JCONFT(1)
               ILINE = ILINE + 1
               IFNUM = IFNUM + 1
            END IF
            IF(JCONFT(2) .NE. -1) THEN
               WRITE (6,105) FCONFT(2),JCONFT(2)
               ILINE = ILINE + 1
               IFNUM = IFNUM + 1
            END IF
         END IF
         IF((ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) .AND.
     1       IFNUM .LT. 2) THEN
            CALL NUPAGE (5)
            WRITE (6,CFMTH) IPAGE
            WRITE (6,104)
            WRITE (6,101)
         END IF
         GO TO 15
      END IF
C
C         WHEN THREE OR MORE NUMBERS EXIST IN FCONFT, PROCESS THEM
C         HERE
C
C         MOVE ISNS FOR THE CURRENT NUMBER INTO ISNW
C
      ID = 1
      J = 1
 10   DO 14 I = ID,ICONF
C
C         MOVE THE INITIAL ISN FOR THE CURRENT NUMBER
C
      ISNW(J) = JCONFT(I)
      IA = I + 1
C
C         LOOP TO SEARCH FOR ADDITIONAL MATCHING NUMBERS MATCHING THE
C         INITIAL NUMBER
C
      DO 11 II = IA,ICONF
C
C         DETERMINE IF THE NUMBERS FOLLOWING THE Ith NUMBER EQUAL IT
C
      IF(FCONFT(I) .EQ. FCONFT(II)) THEN
C
C         BUILD A LIST OF ALL ISNS FOR THIS NUMBER
C
         IF(.NOT.LINCL) THEN
            J = J + 1
            ISNW(J) = JCONFT(II)
            GO TO 11
         END IF
      END IF
C
C         TERMINATE THE LOOP WHEN FCONFT(II) > FCONFT(I) OR ALL NUMBERS
C         HAVE BEEN PROCESSED
C
      IF(FCONFT(II) .GT. FCONFT(I)) THEN
         IE = II
         IF(.NOT.LINCL) THEN
            GO TO 12
         END IF
      END IF
      IF(II .EQ. ICONF) THEN
         IE = ICONF + 1
         GO TO 12
      END IF
 11   CONTINUE
C
C         ALL ISNS FOR THE CURRENT NUMBER ARE NOW IN ISNW.
C
C         WHEN A NUMBER FOLLOWING THE Ith ONE IS GREATER THAN IT, WRITE
C         OUT THE LISTING LINE OF PRINT OF THE ISNS
C
 12   JEND = II
      IFNUM = IFNUM + 1
      IF(II .GT. ICONF) II = ICONF
      IF(FCONFT(II) .GE. FCONFT(I) .OR. II .EQ. I) THEN
C
C         DETERMINE THE NUMBER OF LINES OF PRINT NECESSARY TO PRINT ALL
C         ISNS FOR THIS NUMBER
C
         IF(J .LE. 17) THEN
C
C         A SINGLE LINE OF PRINT IS REQUIRED TO LIST ALL ISNS
C
            WRITE (6,102) FCONFT(I),(ISNW(IJ),IJ = 1,J)
            ILINE = ILINE + 1
            FP = FCONFT(I)
         ELSE IF(J .GT. 17) THEN
C
C         MULTIPLE LINES OF PRINT ARE REQUIRED TO LIST ALL ISNS
C
C         WRITE THE INITIAL LINE OF PRINT FOR THE CURRENT NUMBER
C
            WRITE (6,102) FCONFT(I),(ISNW(IJ),IJ = 1,17)
            ILINE = ILINE + 1
            IFNUM = IFNUM + 1
            I2WK1 = J/17 - 1
            I2WK2 = J - (I2WK1 + 1) * 17
C
C         I2WK1 NOW CONTAINS THE NUMBER OF FULL 17 LINE ISNS TO BE
C         PRINTED FOR THIS NUMBER AFTER THE INITIAL LINE OF PRINT
C
            IF(I2WK1 .GT. 0) THEN
               DO 13 JA = 1,I2WK1
               IB = 18 + (JA - 1) * 17
               IC = IB + 16
               WRITE (6,103) (ISNW(IJ),IJ = IB,IC)
               ILINE = ILINE + 1
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  CALL NUPAGE (5)
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,104)
                  WRITE (6,101)
               END IF
 13            CONTINUE
            END IF
C
C         DETERMINE IF A FINAL PARTIAL LINE OF PRINT IS REQUIRED
C
            IF(I2WK2 .GT. 0) THEN
               IF(I2WK1 .GT. 0) THEN
                  IB = 18 + I2WK1 * 17
               ELSE
                  IB = 18
               END IF
               WRITE (6,103) (ISNW(IJ),IJ = IB,J)
               ILINE = ILINE + 1
               CALL NUPAGE (5)
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,104)
                  WRITE (6,101)
               END IF
            END IF
            IF(J .EQ. 1) THEN
               ID = IE
            ELSE
               ID = IE + 1
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE END OF THE FCONFT TABLE HAS BEEN REACHED
C
      IF(JEND .GE. ICONF .AND. I .GE. ICONF) GO TO 15
      IF(IA .GT. ICONF .OR. FP .EQ. FCONFT(ICONF)) GO TO 15
      ID = I + J
      J = 1
      GO TO 10
 14   CONTINUE
C
C         ROUTINE EXIT
C
 15   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE WILL PRINT THE CHARACTER CONSTANTS LISTING OF
C        LITERALS, HOLLERITH FIELDS; AND HEXIDECIMAL, OCTAL, AND BINARY
C        NUMERIC CONSTANTS. THIS IS TABLE 7.
C
C     MEANING OF THE VARIABLES
C
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1; USED TO
C                  CONVERT FROM INTEGER TO CHARACTER FORM
C         CI2WK3 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK3; USED TO
C                  CONVERT FROM INTEGER TO CHARACTER FORM
C         CLITWK - CHARACTER VARIABLE, WORK AREA FOR READING THE
C                  LITERALS AND THEIR ISNS ON UNIT 9
C                   COLS TYPE WORD CONTENT
C                    1-80 A*80  10 THE LITERAL VALUE
C                   81-84 I*4   11 LENGTH OF THE LITERAL IN COLS. 1-80
C                                  + 128 (MAY NOT BE NOT THE TRUE
C                                  LENGTH). DOES NOT EXCEED 80.
C                   85-88 I*4   12 THE ISN OF THE STATEMENT CONTAINING
C                                  THE LITERAL IN COLS. 1 - 80
C                   89-92 I*4   13 THE ARGUMENT NUMBER WHEN THE LITERAL
C                                  IS THE ARGUMENT OF A CALL STATEMENT
C         CLITBU - CHARACTER VARIBLE, THE INPUT BUFFER TO READ UNIT 9.
C                  THIS VARIABLE HAS THE SAME RECORD STRUCTURE AS CLITWK
C         CLIT1  - EQUIVALENCED TO CLITWK. THE LITERAL FIELD IN CLITWK.
C         CLIT2  - EQUIVALENCED TO CLITBU. THE LITERAL FIELD IN CLITBU.
C         CLIT3  - SAVE AREA FOR THE LITERAL TO BE PRINTED
C
C         C0     - CHARACTER VARIABLE, THE CHARACTER: 0
C         C1     - CHARACTER VARIABLE, THE CHARACTER: 1
C         C102   - CHARACTER VARIABLE, FORMAT TO WRITE A LINE OF THE
C                  LISTING
C         C105   - CHARACTER VARIABLE, FORMAT TO WRITE ALL LINES AFTER
C                  THE FIRST KINE OF ISNS FOR A SINGLE LITERAL
C         FP     - FLOATING POINT WORK AREA
C         I      - SUBSCRIPT VARIABLE, CHOOSES THE INTEGER NUMBER BEING
C                  CURRENTLY LISTED
C         IA     - SUBSCRIPT VARIABLE
C         IARG1  - EQUIVALENCED TO CLITWK(89:92)
C         IB     - WORK AREA FOR DO LIMITS
C         IC     - WORK AREA FOR DO LIMITS
C         IEND   - HAS THE VALUE -1 WHEN AN END OF FILE EXISTS ON UNIT 1
C         II     - SUBSCRIPT VARIABLE AND WORK AREA
C         ILEN1  - EQUIVALENCED TO CLITWK(81:84)
C         ILINE  - PAGE LINE COUNT
C         ILIT   - COUNT OF THE NUMBER OF LITERALS ON UNIT 9
C         INUM   - NUMBER OF UNIQUE LITERALS PRINTED BY THIS ROUTINE
C         IPAGE  - PAGE COUNT
C         IREC9  - COUNT OF THE NUMBER OF LITERAL RECORDS WRITTE ON
C                  UNIT 9
C         ISNW   - LIST OF ALL ISNS OF A LITERAL
C         ISN1   - EQUIVALENCED TO CLITWK(85:88)
C         I1     - SUBSCRIPT VARIABLE
C         I2     - WORK AREA
C         I3     - WORK AREA
C         I2WK1  - SUBSCRIPT VALUE OF THE FIRST ISN THAT IS NOT -1
C         J      - COUNT OF THE ISNS PLACED IN ISNW
C         JA     - SUBSCRIPT VARIABLE
C         JARG2  - EQUIVALNCED T0 CLITBU(89:92)
C         JCONFT - ARRAY OF ISNS OF AN ENTRY IN FCONFT
C         JLEN2  - LENGTH OF THE LITERAL TO BE LISTED, EQUIVALENCED TO
C                  CLITBU(81:84)
C         JSN2   - EQUIVALENCED TO CLITBU(85:88)
C         K      - THE ASSOCIATE VARIABLE TO READ UNIT 9
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FINAL LITERAL
C                  ON UNIT 9 NEEDS TO BE PRINTED, SET FALSE OTHERWISE
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     COMMENTS
C
C         UNIT 9 DOES NOT CONTAIN ANY LITERALS FROM INCLUDE FILES AND
C         IS SORTED BY LENGTH, LITERAL, AND ISN.
C
C     FORTRAN INPUT-OUTPUT UNITS USED
C
C         6 - OUTPUT LISTING OF LITERALS CROSS REFERENCES
C         9 - LITERALS AND THE ISNS WHERE THEY OCCUR, RECORD LENGTH IS
C             92 CHARACTERS
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         NUPAGE
C
C     *****************************************************************
C
      SUBROUTINE PRINTL (INUM)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION ICONTL(2,100)
C
C         DIMENSION STATEMENTS FOR THIS ROUTINE ONLY
C
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITBU, CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CLIT1, CLIT2, CLIT3, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*20    C102
      CHARACTER*13    C105
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (NLINE,ILINE), (CNAME(1),IENAME(1,1)),
     1(CSUBTB,JSUBTB)
      EQUIVALENCE (CLITWK(1:80),CLIT1(1:80)), (CLITWK(81:84),ILEN1),
     1(CLITWK(85:88),ISN1), (CLITWK(89:92),IARG1), (CWK8(2:2),CWK7)
      EQUIVALENCE (CLITBU(1:80),CLIT2(1:80)), (CLITBU(81:84),JLEN2),
     1(CLITBU(85:88),JSN2), (CLITBU(89:92),JARG2)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA C102 /'(1X,AXX,1X,TXX,XXI6)'/
      DATA C105 /'(1X,T12,XXI6)'/
C
C         FORMAT STATEMENTS
C
 101  FORMAT('0  LITERAL',8X,' INTERNAL STATEMENT NUMBERS')
 103  FORMAT(T12,18I6)
 104  FORMAT(' CHARACTER CONSTANTS')
C
C         DETERMINE IF A NEW PAGE HEADER IS REQUIRED
C
      CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,104)
      WRITE (6,101)
C
C         INITIALIZATION
C
      L1 = LFALSE
      IC = 0
      J = 0
      K = 1
      INUM = 0
      IEND = 0
      IREC9 = 0
      CLITWK(1:92) = CBLK52(1:50)//CBLK52(1:42)
      CLITBU(1:92) = CBLK52(1:50)//CBLK52(1:42)
C
C         DETERMINE IF SINGLE LITERAL RECORD IS ON UNIT 9
C
 10   IF(ILIT .EQ. 1 .OR. J .EQ. 1) THEN
C
C         READ THE SINGLE RECORD INTO THE WORK AREA
C
         IF((ILIT .EQ. 1 .OR. J .EQ. 1) .AND. IEND .NE. -1) THEN
            IREC9 = IREC9 + 1
            READ (9,REC=IREC9,IOSTAT=IEND) CLITWK(1:92)
         ELSE
            GO TO 11
         END IF
C
C         DETERMINE IF END OF FILE ON UNIT 9
C
         IF(IEND .EQ. -1) GO TO 16
C
C         CREATE THE FORMAT STATEMENT C102 TO WRITE THE LINE OF PRINT
C
         IF(IEND .NE. -1) ILEN1 = ILEN1 - 128
         WRITE (CI2WK1,'(I2)') ILEN1    ! LITERAL LENGTH
         C102(16:17) = CBLANK(1:2)      ! XXI6
         IF(ILEN1 .LT. 10) THEN
            C102(6:6) = CBLANK(1:1)     ! AXX
            C102(7:7) = CI2WK1(2:2)
            C102(13:14) = C1//C2        ! TXX
         ELSE
            C102(6:6) = CI2WK1(1:1)     ! AXX
            C102(7:7) = CI2WK1(2:2)
            I = (ILEN1 - 11)/6 + 1
            I = I * 6 + 12
            WRITE (CI2WK1,'(I2)') I
            C102(13:14) = CI2WK1(1:2)   ! TXX
         END IF
         ISNW(1) = ISN1 - 128
         J = 1
         WRITE (6,C102) CLIT1(1:ILEN1),(ISNW(I1),I1 = 1,J)
         INUM = INUM + 1
         ILINE = ILINE + 1
         IF(IEND .EQ. -1) GO TO 16
      END IF
C
C         DETERMINE IF TWO RECORDS ARE ON UNIT 9
C
 11   IF(ILIT .EQ. 2 .OR. J .EQ. 2) THEN
C
C         READ THE TWO RECORDS FROM UNIT 9
C
         IF(ILIT .EQ. 2) THEN
            READ (9,REC=1) CLITWK(1:92)
            READ (9,REC=2) CLITBU(1:92)
            ILEN1 = ILEN1 - 128
            JLEN2 = JLEN2 - 128
         END IF
C
C         DETERMINE IF THE LITERALS ARE OF EQUAL LENGTH
C
         IF(ILEN1 .EQ. JLEN2) THEN
C
C         SAVE THE LITERAL TO BE PRINTED
C
            CLIT3(1:80) = CLITWK(1:80)
C
C         CREATE THE FORMAT STATEMENT C102 TO WRITE THE LINE OF PRINT
C
            WRITE (CI2WK1,'(I2)') ILEN1    ! LITERAL LENGTH
            IF(ILEN1 .LT. 10) THEN
               C102(6:6) = CBLANK(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               C102(13:14) = C1//C2        ! TXX
            ELSE
               C102(6:6) = CI2WK1(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               I = (ILEN1 - 11)/6 + 1
               I = I * 6 + 11
               WRITE (CI2WK1,'(I2)') I
               C102(13:14) = CI2WK1(1:2)   ! TXX
            END IF
            C102(16:17) = CBLANK(1:1)//C2  ! XXI6
C
C         DETERMINE IF THE LITERALS ARE IDENTICAL
C
            IF(CLIT1(1:ILEN1) .EQ. CLIT2(1:JLEN2)) THEN
               ISNW(1) = ISN1 - 128
               ISNW(2) = JSN2 - 128
               WRITE (6,C102) CLIT1(1:ILEN1),(ISNW(I1),I1 = 1,2)
               ILINE = ILINE + 1
               INUM = INUM + 1
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  CFMTH(3:3) = C1(1:1)
                  IPAGE = IPAGE + 1
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,104)
                  WRITE (6,101)
                  ILINE = 5
               END IF
               GO TO 16
C
C         THE TWO LITERALS ARE NOT IDENTICAL
C
            ELSE
               ISNW(1) = ISN1 - 128
               WRITE (6,C102) CLIT1(1:ILEN1),ISNW(1)
               INUM = INUM + 1
               ILINE = ILINE + 1
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  CALL NUPAGE (5)
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,101)
               END IF
               ISNW(1) = JSN2 - 128
               WRITE (6,C102) CLIT2(1:JLEN2),ISNW(1)
               ILINE = ILINE + 1
               INUM = INUM + 1
               GO TO 16
            END IF
         END IF
C
C         THE TWO LITERALS ARE OF UNEQUAL LENGTH
C
         IF(ILEN1 .NE. JLEN2) THEN
C
C         CREATE THE FORMAT STATEMENT C102 TO WRITE THE LINE OF PRINT OF
C         THE FIRST RECORD ON UNIT 9
C
            WRITE (CI2WK1,'(I2)') ILEN1    ! LITERAL LENGTH
            IF(ILEN1 .LT. 10) THEN
               C102(6:6) = CBLANK(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               C102(13:14) = C1//C2        ! TXX
            ELSE
               C102(6:6) = CI2WK1(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               I = (ILEN1 - 11)/6 + 1
               I = I * 6 + 11
               WRITE (CI2WK1,'(I2)') I
               C102(13:14) = CI2WK1(1:2)   ! TXX
            END IF
            ISNW(1) = ISN1 - 128
            C102(16:17) = CBLANK(1:1)//C2  ! XXI6
            WRITE (6,C102) CLIT1(1:ILEN1),ISNW(1)
            INUM = INUM + 1
            ILINE = ILINE + 1
C
C         CREATE THE FORMAT STATEMENT C102 TO WRITE THE LINE OF PRINT OF
C         THE SECOND RECORD ON UNIT 9
C
            WRITE (CI2WK1,'(I2)') JLEN2    ! LITERAL LENGTH
            IF(JLEN2 .LT.10) THEN
               C102(6:6) = CBLANK(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               C102(13:14) = C1//C2        ! TXX
            ELSE
               C102(6:6) = CI2WK1(1:1)     ! AXX
               C102(7:7) = CI2WK1(2:2)
               I = (JLEN2 - 11)/6 + 1
               I = I * 6 + 11
               WRITE (CI2WK1,'(I2)') I
               C102(13:14) = CI2WK1(1:2)   ! TXX
            END IF
            ISNW(1) = JSN2 - 128
            C102(16:17) = CBLANK(1:1)//C2  ! XXI6
            IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
               CALL NUPAGE (5)
               WRITE (6,CFMTH) IPAGE
               WRITE (6,104)
               WRITE (6,101)
            END IF
            WRITE (6,C102) CLIT2(1:JLEN2),ISNW(1)
            INUM = INUM + 1
            ILINE = ILINE + 1
            GO TO 16
         END IF
      END IF
C
C         MORE THAN TWO LITERAL RECORDS EXIST ON UNIT 9
C
      IF(ILIT .GT. 2) THEN
C
C         THE LITERAL TO BE WRITTEN AFTER ALL ISNS FROM UNIT 9 FOR THIS
C         LITERAL ARE MOVED TO ISNW
C
         K = 1
         READ (9,REC=K) CLITWK(1:92)
         ILEN1 = ILEN1 - 128
         ISNW(1) = ISN1 - 128
         K = K + 1
         J = 1
C
C         SAVE THE LITERAL TO BE PRINTED
C
         CLIT3(1:80) = CLITWK(1:80)
C
C         READ SUBSEQUENT RECORDS FOR THE SAME LITERAL IN CLITWK
C
 12      IF(K .LE. ILIT) READ (9,REC=K,IOSTAT=IEND) CLITBU(1:92)
C
C         DETERMINE IF A SINGLE ISN EXISTS FOR FINAL LITERAL RECORD
C
         IF(IEND .EQ. -1 .AND. J .EQ. 1) THEN
C
C         WHEN THE FINAL LITERAL FOR THE CURRENT ROUTINE HAS ALREADY
C         BEEN PROCESSED, AN END OF FILE CONDITION WILL EXIT THIS
C         ROUTINE. OTHERWISE, PROCESS THE FINAL LITERAL.
C
            GO TO 10
         END IF
C
C         DETERMINE IF TWO ISNS EXIST FOR FINAL LITERAL RECORD
C
         IF(IEND .EQ. -1 .AND. J .EQ. 2) GO TO 11
C
C         TEST FOR AN END OF FILE
C
         IF(K .GT. ILIT .AND. .NOT.L1) GO TO 16
C
C         CORRECT LITERAL LENGTH FOR SUBSEQUENT RECORDS
C
         JLEN2 = JLEN2 - 128
C
C         DETERMINE IF THE LITERALS ARE OF EQUAL LENGTH
C
         IF(ILEN1 .EQ. JLEN2) THEN
C
C         WHEN THE LITERALS ARE IDENTICAL, PLACE THE ISN IN ISNW
C
            IF(CLIT1(1:ILEN1) .EQ. CLIT2(1:JLEN2)) THEN
C
C         DETERMINE IF THE ISN IS A DUPLICATE OF ONE IN THE TABLE
C
               IF(ISNW(J) .NE. JSN2-128) THEN
                  J = J + 1
                  ISNW(J) = JSN2 - 128
               END IF
C
C         TEST FOR AN END OF FILE
C
               IF(K .GE. ILIT) GO TO 13
               K = K + 1
               GO TO 12
            ELSE
C
C         WHEN THE END OF THE ALL LITERALS HAS BEEN REACHED, PROCESS
C         THE FINAL LITERAL WHEN ONLY ON USAGE OCCURS
C
               IF(J .EQ. 1 .AND. K .LT. ILIT) THEN
                  IF(ILEN1 .EQ. JLEN2) THEN
                     IF(CLIT3(1:ILEN1) .EQ. CLITBU(1:JLEN2)) THEN
                        ISNW(J) = JSN2 - 128
                     END IF
                  END IF
                  GO TO 13
               END IF
            END IF
         END IF
C
C         WHEN ILEN1 IS LESS THAN JLEN2, SET ILEN1 TO JLEN2
C
         IF(J .GT. 1 .AND. CLIT3(1:JLEN2) .EQ. CLITBU(1:JLEN2)) THEN
            ILEN1 = JLEN2
            I2WK1 = JLEN2
         END IF
C
C         WHEN THE LITERALS IN CLITWK AND CLITBU ARE NOT EQUAL, PRINT
C         THE ISNS FOR CLITWK.
C
C         CREATE THE FORMAT C102 TO PRINT THE FIRST LINE OF PRINT;
C         DETERMINE IF MORE THAN A SINGLE LINE OF PRINT IS REQUIRED.
C
 13      IF(ILEN1 .GT. 80) ILEN1 = 80
         WRITE (CI2WK1,'(I2)') ILEN1    ! LITERAL LENGTH
         II = (118 - ILEN1)/6           ! NUMBER OF ISNS IN 1ST LINE
         IF(ILEN1 .LT. 10) THEN
            C102(7:7) = CBLANK(1:1)     ! AXX
            C102(6:6) = CI2WK1(2:2)
            C102(13:14) = C1//C2        ! TXX
         ELSE IF(ILEN1 .GE. 10) THEN
            C102(6:6) = CI2WK1(1:1)     ! AXX
            C102(7:7) = CI2WK1(2:2)
            I2WK1 = (ILEN1 - 11)/6
            IF(MOD(I2WK1,6) .GT. 0) THEN
               I = (6 * (I2WK1 + 1)) + 12
            ELSE IF(I2WK1 .EQ. 0) THEN
               I = 18
            ELSE
               I2WK1 = ILEN1/6
               I = (6 * I2WK1)
               IF(ILEN1 .GT. I) I2WK1 = I2WK1 + 1
               I = 6 * I2WK1
               II = (120 - I)/6
            END IF
            WRITE (CI2WK1,'(I2)') I
            C102(13:14) = CI2WK1(1:2)   ! TXX
         END IF
C
C         SET THE XXI6 FIELD VALUE
C
         IF(J .LT. II) II = J
         WRITE (CI2WK1,'(I2)') II
         IF(II .EQ. 0) THEN
            C102(16:17) = CBLANK(1:2)   ! XXI6, 1ST LINE
         ELSE
            C102(16:17) = CI2WK1(1:2)   ! XXI6, 1ST LINE
         END IF
         WRITE (6,C102) CLIT3(1:ILEN1),(ISNW(I1),I1 = 1,II)
         ILINE = ILINE + 1
         INUM = INUM + 1
         IF(K .GT. ILIT) GO TO 16
         IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
            CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,104)
            WRITE (6,101)
            ILINE = 5
         END IF
C
C         DETERMINE IF MULTIPLE LINES OF PRINT ARE REQUIRED TO LIST ALL
C         THE ISNS FOR THE LITERAL
C
         IF(J .GT. II) THEN
C
C       SECOND AND SUBSQUENT LINES
C
            IA = II + 1
            II = J - II
            IF(II .LE. 17) THEN
C
C         A SINGLE LINE OF PRINT LISTS ALL THE REMAINING ISNS
C
               IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                  CALL NUPAGE (5)
                  WRITE (6,CFMTH) IPAGE
                  WRITE (6,104)
                  WRITE (6,101)
               END IF
               WRITE (CI2WK1,'(I2)') II
               C105(9:10) = CI2WK1(1:2)      ! XXI6
               WRITE (6,C105) (ISNW(I1),I1 = IA,J)
               ILINE = ILINE + 1
               GO TO 15
C
C         MULTIPLE FULL LINES OF ISNS MUST BE PRINTED; DETERMINE HOW
C         MANY ARE NECESSARY.
C
            ELSE IF(II .GT. 17) THEN
C
C         FULL LINES OF ISNS MUST BE PRINTED
C
               I2 = II/18
               IF(I2 .GT. 0) THEN
                  DO 14 I3 = 1,I2
                  IB = IA + 17
                  II = II - 17
                  IF(ILINE .GE. NLINES .OR. ILINE + 5 .GE. NLINES) THEN
                     CALL NUPAGE (5)
                     WRITE (6,CFMTH) IPAGE
                     WRITE (6,104)
                     WRITE (6,101)
                  END IF
                  WRITE (6,103) (ISNW(I1),I1 = IA,IB)
                  ILINE = ILINE + 1
                  IA = IA + 17
 14               CONTINUE
               END IF
            END IF
         END IF
C
C         THE LIST OF ISNS FOR THE LITERAL IN CLITWK HAVE BEEN WRITTEN;
C         SET UP FOR THE NEXT LITERAL
C
C         DETERMINE IF THE END OF THE FILE HAS BEEN REACHED
C
 15      IF(K .GE. ILIT) THEN
            IF(CLITBU(1:10) .EQ. CLIT3(1:10)) THEN
               GO TO 16
            ELSE
               GO TO 150
            END IF
C           IF(J .EQ. 1) THEN  CLIT3
C              GO TO 150
C           ELSE
C              GO TO 16
C           END IF
         END IF
C        IF(K .EQ. ILIT .AND. J .GT. 1) GO TO 16
C
C         DETERMINE IF THE LAST LITERAL WRITTEN ON UNIT 6 IS DIFFERENT
C         FROM THE LITERAL IN CLITBU. WHEN TRUE AND IT IS THE FINAL
C         LITERAL ON UNIT 9, SET SWITCH TO PROCESS THE FINAL LITERAL.
C
 150     IF(ILEN1 .EQ. JLEN2 .AND. K .EQ. ILIT) THEN
            IF(CLIT3(1:ILEN1) .EQ. CLITBU(1:JLEN2))THEN
               L1 = LFALSE
            ELSE
               L1 = LTRUE
            END IF
         ELSE
            L1 = LTRUE
         END IF
C
C         MOVE THE LITERAL RECORD IN CLITBU TO CLITWK
C
         CLITWK(1:92) = CLITBU(1:92)
         ISNW(1) = ISN1 - 128
         CLIT3(1:80) = CLITBU(1:80)
         ILEN1 = JLEN2
         J = 1
         K = K + 1
         IF(K .GT. ILIT .AND. IEND .EQ. -1) GO TO 16
         GO TO 12
         END IF
C
C         ROUTINE EXIT
C
 16   RETURN
      END
C
C    *******************************************************************
C
C     PURPOSE
C
C        THIS ROUTINE PRODUCES A LISTING OF ALL COMMON BLOCK DEFINITIONS
C
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES.
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  LENGTH OF THE VARIABLE NAME IN COLS
C                                  1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT SIZE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT SIZE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT SIZE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT SIZE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT SIZE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT SIZE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT SIZE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CFCLEN - CHARACTER VARIABLE, THE FILE NAME TO BE OPENED ON
C                  UNIT 1 FOR COMMON BLOCK GLOBAL ANALYSIS
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         CF110  - CHARACTER VARIABLE, FORMAT TO WRITE THE ERROR
C                  MESSAGE THAT A VARIABLE IS NOT IN A COMMON BLOCK,
C                  BUT IT IS EXPECTED TO BE IN A COMMON BLOCK
C         CF111  - CHARACTER VARIABLE, FORMAT TO WRITE THE ERROR
C                  MESSAGE THAT A VARIABLE IS DEFINED IN MORE THAN ONE
C                  COMMON BLOCK
C         CGCOMM - CHARACTER VAARIABLE, THE RECORD OF A COMMON BLOCK FOR
C                  COMMON GLOBAL ANALYSIS. EQUIVALENCED TO IGCOMM.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1; USED TO
C                  CONVERT FROM INTEGER TO TEXT.
C         CL8    - CHARACTER VARIABLE, CREATION AREA FOR THE TOTAL
C                  LENGTH OF THE COMMON BLOCK
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM, INCLUDING ALL VARIABLE NAMES
C                  BROUGHT INTO A PROGRAM MODULE BY USING AN INCLUDE
C                  STATEMENT.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         COMPRT - CHARACTER VARIABLE, DATA TO BE PRINTED FOR VARIABLES
C                  IN A COMMON BLOCK. EQUIVALENCED TO ICOMPR.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  RELATIVE ADDRESS IN BYTES
C                  37-44  A*8   11  TYPE AND LENGTH CHARACTERISTICS
C                  45-48  I*4   12  LENGTH OF THE VARIABLE NAME
C                  49-52  I*4   13  NUMBER OF SUBSCRIPTS DEFINED FOR THE
C                                   VARIABLE NAME IN COLS 1-32
C         COMTBL - CHARACTER VARIABLE, THE TABLE OF ALL COMMON BLOCK
C                  NAMES. DOES NOT CONTAIN ANY VARIABLE NAMES WITHIN A
C                  COMMON BLOCK.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                                   NAME IN COLS. 1 - 32
C                  37-40  I*4   10  THE LOCATION OF EACH COMMON BLOCK
C                                   NAME RECORD ON UNIT 11
C                  THIS TABLE CONTAINS ONLY THE COMMON BLOCK NAME
C                  VARIABLES. THE VALUE IN COLS. 33 - 36 WILL BE SET
C                  TO NEGATIVE AFTER THAT COMMON BLOCK IS PROCESSED.
C                  THIS PREVENTS MULTIPLE PROCESSING OF THE SAME BLOCK.
C         CPGNME - CHARACTER VARIABLE, PROGRAM OR SUBPROGRAM NAME
C                  CURRENTLY BEING PROCESSED
C         CWKBUF - THE SAVE AREA FOR THE RECORD OF UNIT 11 THAT DEFINES
C                  THE COMMON BLOCK NAME TO BE PROCESSED
C         CWK44  - CHARACTER VARIABLE, 44 BYTE BUFFER TO READ RECORDS
C                  FROM UNIT 11. EQUIVALENCED TO IWK44.
C                  RECORD STRUCTURE IS:
C                  COLS TYPE WORD DESCRIPTION
C                  1-32 C*32   8  VARIABLE NAME
C                 33-36 I*4    9  LENGTH OF THE VARIABLE NAME IN COLS
C                                 1-32; SET NEGATIVE FOR THE COMMON
C                                 BLOCK NAME; SET POSITIVE FOR VARIABLE
C                                 NAMES BELONGING TO THE BLOCK.
C                    37 C*1       THE VARIABLE DATA TYPE IN COLS. 1-32
C                 38-44 C*7   11  THE VARIABLE'S LENGTH CHARACTERISTIC
C         CWK68  - CHARACTER VARIABLE, USED TO SORT THE ARRAY COMPRT
C                  WHEN ONLY TWO ENTRIES EXIST
C         CWK80  - CHARACTER VARIABLE, THE BUFFER USED TO READ THE
C                  RECORDS ON UNIT 12.
C         C0     - CHARACTER VARIABLE, THE CHARACTER ZERO
C         C1     - CHARACTER VARIABLE, THE CHARACTER ONE
C         C103   - CHARACTER VARIABLE, TITLE FOR COMMON INFORMATION ON
C                  THE LISTING
C         I      - SUBSCRIPT VARIABLE, THE INDEX VALUE TO PLACE A
C                  VARIABLE NAME IN ARRAY COMTBL
C         IA     - DO LOOP PARAMETER, START VALUE
C         IADDR  - THE RELATIVE ADDRESS OF EACH VARIABLE; WHEN ALL
C                  VARIABLES FOR A COMMON BLOCK ARE PROCESSED, THIS WILL
C                  CONTAIN THE TOTAL LENGTH OF THE COMMON BLOCK
C         IB     - DO LOOP PARAMETER AND WORK AREA
C         ICOMKT - THE NUMBER OF COMMON BLOCK DEFINITIONS IN COMTBL
C         ICOMPR - EQUIVALENCED TO COMPRT
C         ICOMTB - EQUIVALENCED TO COMTBL
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IEND   - RETURN VALUE FROM IOSTAT IN READ AND WRITE STATEMENTS
C         IFMT   - FORMAT TO BE USED IN WRITING THE OUTPUT LISTING
C                  VARIABLE NAMES IN THE COMMON BLOCK
C         IGCOMM - THE RECORD OF A COMMON BLOCK FOR COMMON GLOBAL
C                  ANALYSIS. EQUIVALENCED TO CGCOMM.
C             RECORD STRUCTURE
C             COLUMN TYPE WORD DESCRIPTION
C             1 - 32 C*32   8  ROUTINE NAME WHERE THE COMMON BLOCK
C                              OCCURS
C            33 - 64 C*32  16  THE COMMON BLOCK NAME
C         #  65 - 68 I*4   17  LENGTH OF VARIABLE NAME IN COLS 1-32
C         #  69 - 72 I*4   18  LENGTH OF VARIABLE NAME IN COLS 33-64
C         #  73 - 76 I*4   19  THE LENGTH OF THE COMMON BLOCK
C         III    - THE DEINED LENGTH CHARCTERISTIC OF A VARIABLE
C         ILINE  - COUNT OF THE NUMBER OF LINES WRITTEN ON A PAGE
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IPAGE  - PAGE COUNT
C         IREC1  - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 1
C         IREC10 - COUNT OF RECORDS WRITTEN ON UNIT 10
C         IREC11 - COUNT OF RECORDS WRITTEN ON UNIT 11
C         IREC12 - COUNT OF RECORDS WRITTEN ON UNIT 12
C         IRET   - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET1  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         IRET2  - RETURN VALUE OF A TABLE SEARCH, .GT. 0 A MATCH WAS
C                  FOUND, .LT. 0 NO MATCH FOUND
C         ISN    - THE INTERNAL STATEMENT NUMBER
C         IWK44  - EQUIVALENCED TO CWK44
C         IWK80  - EQUIVALENCED TO CWK80
C         I1     - DO LOOP PARAMETER, START VALUE
C         I2     - DO LOOP PARAMETER, END VALUE
C         I2WK1  - WORK AREA, EQUIVALENCED TO CI2WK1
C         I3     - WORK AREA
C         I4     - NUMBER OF VARIABLES IN A COMMON BLOCK
C         I5     - THE LENGTH OF THE COMMON BLOCK NAME
C         I6     - THE NUMBER OF COMMON VARIABLES TO BE PRINTED IN THE
C                  FINAL PARTIAL LINE
C         I7     - WORK AREA
C         I8     - WORK AREA
C         J      - SUBSCRIPT VARIABLE
C         JDIM   - NUMBER OF ENTRIES IN TABLE CDIM
C         JEQGRP - LOCATION OF THE FIRST VARIABLE OF AN EQUIVALENCE
C                  GROUP ON UNIT 12.
C                  SUBSCRIPT 1 VALUE  MEANING
C                  1 - THE ASSOCIATE VARIABLE VALUE OF THE RECORD ON
C                      UNIT 12.
C                  2 - COUNT OF THE NUMBER OF VARIABLES BELONGING TO
C                      THE EQUIVALENCE GROUP
C                  3 - THE MASTER ADDRESS OF ALL EQUIVALENCE VARIABLES
C                      BELONGING TO THE EQUIVALENCE GROUP WHEN ONE OF
C                      THE EQUIVALENCE GROUP VARIABLES MATCH A VARIABLE
C                      IN THE CURRENT COMMON BLOCK (PROVIDED BY ROUTINE
C                      PEQUIV).
C                  SUBSCRIPT 2 DETERMINES THE GROUP CHOICE
C         JFMT   - FORMAT TO BE USED IN WRITING THE OUTPUT LISTING TITLE
C         JGRPKT - COUNT OF THE NUMBER OF EQUIVALENCE GROUPS ON UNIT 12
C         J1     - SUBSCRIPT VARIABLE
C         J2     - SUBSCRIPT VARIABLE
C         K      - ASSOCIATE VARIABLE INDEX USED TO READ UNIT 11
C         KDIM   - EQUIVALENCED TO CDIM
C         K7     - COUNT OF THE NUMBER OF EQUIVALENCED VARIABLES ALREADY
C                  PROCESSED BY ROUTINE PEQUIV.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LGLOBL - LOGICAL VARIABLE, SET TRUE WHEN GLOBAL ANALYSIS IS
C                  TO BE PERFORMED, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, USED TO SAVE RESULTS OF BTEST
C         L2     - LOGICAL VARIABLE, USED TO COUNT LENGTH OF A VARIABLE
C                  NAME
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A COMMON BLOCK FROM
C                  A BLOCK DATA SUBOUTINE IS BEING PROCESSED
C         M      - THE MAXIMUM LENGTH OF A VARIABLE NAME TO BE PRINTED
C                  ON AN OUTPUT LISTING LINE
C         N      - THE NUMBER OF ISNS THAT CAN BE PRINTED ON A SINGLE
C                  LINE OF THE OUTPUT LISTING
C         N1     - THE VALUE OF N + 1
C         NLINES - THE MAXIMUM NUMBER OF LINES THAT CAN BE PRINTED ON
C                  A PAGE OF THE OUTPUT LISTING
C
C         INPUT - OUTPUT UNITS USED
C
C          0 - ERROR MESSAGES FILE
C          1 - THE COMMON BLOCK NAME AND LENGTH RECORD IN ALL ROUTINES
C              WITHIN THE ENTIRE PROGRAM FOR GLOBAL ANALYSIS
C              RECORD STRUCTURE
C              COLUMN TYPE WORD DESCRIPTION
C              1 - 32 A*32   8  ROUTINE NAME WHERE THE COMMON BLOCK
C                               OCCURS
C             33 - 64 A*32  16  THE COMMON BLOCK NAME
C           # 65 - 68 I*4   17  LENGTH OF VARIABLE NAME IN COLS 1-32
C           # 69 - 72 I*4   18  LENGTH OF VARIABLE NAME IN COLS 33-64
C           # 73 - 76 I*4   19  THE LENGTH OF THE COMMON BLOCK
C             NOTE: FIELDS MARKED WITH # HAVE 128 ADDED TO THEIR VALUE
C          6 - THE OUTPUT LISTING FILE
C         11 - LIST OF ALL COMMON BLOCKS AND THEIR VARIABLES RECORD
C              STRUCTURE. THIS IS FOR A SINGLE ROUTINE ONLY.
C              COLUMN TYPE WORD DESCRIPTION
C              1 - 32 A*32   8  VARIABLE NAME
C             33 - 36 I*4    9  NUMBER OF CHARACTERS IN THE VARIABLE
C                               NAME IN COLUMNS 1 - 32. THIS VALUE IS
C                               NEGATIVE WHEN THE VARIABLE NAME IN
C                               COLUMNS 1-32 IS THE COMMON BLOCK NAME;
C                               IT IS POSITIVE FOR THE VARIABLE NAMES
C                               THAT ARE PLACED IN THE COMMON BLOCK.
C             37 - 44 A*8   11  VARIABLE TYPE AND LENGTH DEFINITIONS
C
C     COMMENTS
C
C         DIMENSIONED VARIABLES THAT ARE NOT USED IN A SUBPROGRAM WILL
C         NOT HAVE A TYPE AND LENGTH CHARACTERISTIC DEFINED WHEN THAT
C         VARIABLE HAS NOT BEEN USED WITHIN THE SUBPROGRAM. THIS
C         SUBPROGRAM WILL ASSIGN TYPE AND LENGTH CHARACTERISTICS USING
C         THE DEFAULTS DEFINED IN ARRAY CIMPL BEFORE PROCESSING COMMON
C         AND EQUIVALENT STATEMENTS.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         BTEST MSORT NUPAGE PEQUIV TABSRH TBLSRH
C
C     ******************************************************************
C
      SUBROUTINE PCOMM
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ICOMTB(10,200), COMPRT(500),ICOMPR(13,500),IGCOMM(19),
     1IWK44(11), KDIM(26,1000), JEQGRP(3,200), IWK80(20)
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION IWKBUF(11), ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*104   CDIM
      CHARACTER*111   CFMTH
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE, CWK80
      CHARACTER*76    CGCOMM
      CHARACTER*73    C103
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*60    CF111
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, COMPRT, CPARAM, CWORK
      CHARACTER*47    CF110
      CHARACTER*44    CUNION, CWKBUF, CWK44
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CL8, CWK8
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     ISRECL, CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CTYPE
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FCONFT, FP
      INTEGER*2       I2WK1
      LOGICAL*1       LASC, L1, L2, L3
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CWORK(33:36),IWORK), (NLINE,ILINE),
     1(CWORK(45:48),JBITS), (CWORK(49:52),IVCNT), (CNAME(1),IENAME(1,1))
     2, (I4WK1,CI4WK1), (CWK8(2:2),CWK7), (CSUBTB,JSUBTB)
      EQUIVALENCE (COMTBL,ICOMTB), (COMPRT,ICOMPR), (CDIM,KDIM),
     1(CWK44,IWK44), (CGCOMM(1:1),IGCOMM(1)), (CWK80,IWK80)
      EQUIVALENCE (CWKBUF,IWKBUF)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA C103 /'(A1,T3,''NAME OF COMMON BLOCK  *'',AXX,''*'',5X,''BLOC
     1K SIZE: '',A8,1X,''BYTES'')'/
      DATA CF110 /'('' ISN:'',I6,'' NOT A COMMON VARIABLE: '',AXX)'/
      DATA CF111 /'('' VARIABLE IS DEFINED IN MORE THAN ONE COMMON BLOCK
     1: '',AXX)'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' BLOCK COMMON NAME NOT DEFINED: ',A32)
 101  FORMAT(' ISN:',I6,' COMMON VARIABLE NOT FOUND: ',A32)
 102  FORMAT(A1,T46,'***  COMMON INFORMATION  ***')
 104  FORMAT(A1,4('VAR. NAME  TYPE   REL. ADDR. '))
 105  FORMAT(A1,3('VAR. NAME            TYPE   REL. ADDR. '))
 106  FORMAT(A1,2('VAR. NAME                        TYPE  REL. ADDR.   '
     1))
 107  FORMAT(A1,4(A10,1X,A1,'*',A6,1X,I8,1X))
 108  FORMAT(A1,3(A20,1X,A1,'*',A6,1X,I8,1X))
 109  FORMAT(A1,2(A32,1X,A1,'*',A6,1X,I8,1X))
C
C         INITIALIZATION
C
      K = 1
      K7 = 0
      JGRPKT = 0
C
C        DETERMINE IF ANY EQUIVALENCE GROUPS EXIST FOR THIS ROUTINE
C
      IF(IREC12 .EQ. 0) GO TO 18
C
C         CREATE THE TABLE OF EQUIVALENCE GROUPS DEFINED FOR THE CURRENT
C         ROUTINE BEING PROCESSED WHEN ANY EXIST
C
      DO 11 J = 1,200
      DO 10 J1 = 1,3
      JEQGRP(J1,J) = 0
 10   CONTINUE
 11   CONTINUE
      DO 12 J1 = 1,IREC12
      READ (12,REC=J1) CWK80(1:80)
C
C         DETERMINE IF THE VARIABLE IS THE START OF AN EQUIVALENCE
C         GROUP
C
      IF(IWK80(9) .LT. 0) THEN
         JGRPKT = JGRPKT + 1
         JEQGRP(1,JGRPKT) = J1
      END IF
 12   CONTINUE
C
C         DETERMINE THE NUMBER OF VARIABLES IN EACH EQUIVALENCE GROUP
C
C         SET THE SINGLE EQUIVALENCE GROUP CASE END OF GROUP COUNT
C
      IF(JGRPKT .EQ. 1) THEN
         JEQGRP(2,1) = IREC12
         GO TO 14
      END IF
C
C         WHEN MORE THAN A SINGLE EQUIVALENCE GROUP OCCURS, SET THE
C         END OF GROUP COUNT
C
      DO 13 J = 1,JGRPKT
      IF(J .EQ. JGRPKT) THEN
         IF(JGRPKT .EQ. 1) THEN
            JEQGRP(2,JGRPKT) =  IREC12
         ELSE
            JEQGRP(2,JGRPKT) = IREC12 - JEQGRP(1,JGRPKT-1) - 1
         END IF
         GO TO 14
      ELSE
         JEQGRP(2,J) = JEQGRP(1,J+1) - JEQGRP(1,J)
      END IF
 13   CONTINUE
C
C         DETERMINE IF ANY VARIABLE IS DEFINED IN MORE THAN ONE COMMON
C         BLOCK. A COMMON BLOCK NAME MAY OCCUR MORE THAN ONCE SINCE A
C         COMMON BLOCK MAY BE CONTINUED WITH MULTIPLE STATEMENTS.
C
 14   DO 17 J = 1,ICOMKT-1
C
C         SET DO LOOP PARAMETERS TO READ ALL VARIABLES IN THE JTH
C         COMMON BLOCK
C
C        SET THE START INDEX FOR THE VARIABLE NAMES IN THE CURRENT
C        BLOCK ON UNIT 11
C
      I7 = ICOMTB(10,J) + 1
C
C        SET THE ENDING INDEX FOR THE VARIABLE NAMES IN THE CURRENT
C        BLOCK ON UNIT 11
C
      IF(J .EQ. ICOMKT) THEN
         I8 = IREC11
      ELSE
         I8 = ICOMTB(10,J+1) - 1
      END IF
C
C         PROCESS ALL VARIABLES IN THE JTH COMMON BLOCK
C
      DO 16 J2 = I7,I8
C
C         READ EACH VARIABLE NAME IN THE JTH COMMON BLOCK
C
      READ (11,REC=J2) CWKBUF
C
C         SET DO LOOP STARTING PARAMETER TO SEARCH ALL REMAINING
C         RECORDS ON UNIT 11
C
      IF(J .EQ. ICOMKT) THEN
         I3 = ICOMTB(10,J) + 1
      ELSE
         I3 = ICOMTB(10,J+1)
      END IF
C
C         PROCESS ALL VARIABLE NAMES IN COMMON BLOCKS AFTER THE JTH
C         COMMON BLOCK
C
      DO 15 J1 = I3,IREC11
C
C         READ ALL SUBSEQUENT VARIABLE NAME RECORDS
C
      READ (11,REC=J1) CWK44
C
C         DETERMINE IF ANY VARIABLE NAME IN OTHER COMMON BLOCKS MATCH
C         THE VARIABLE NAME IN THE JTH COMMON BLOCK
C
      IF(CWKBUF(1:32) .EQ. CWK44(1:32)) THEN
C
C         SKIP OVER THE COMMON BLOCK NAME
C
         IF(IWK44(9) .LT. 0) GO TO 15
C
C       CREATE AND WRITE THE ERROR MESSAGE
C
         I4WK1 = IABS(IWK44(9))
         WRITE (CI2WK1,'(I2)') I4WK1
         IF(CI2WK1(1:1) .EQ. CBLANK(1:1)) THEN
            CF111(58:60) =  CI2WK1(2:2)//CBLANK(1:1)//CRPAR(1:1)
         ELSE
            CF111(58:60) =  CI2WK1(1:2)//CRPAR(1:1)//CBLANK(1:1)
         END IF
         WRITE (0,CF111) CWK44(1:I4WK1)
         IREC0 = IREC0 + 1
      END IF
 15   CONTINUE
 16   CONTINUE
 17   CONTINUE
C
C         PRINT THE COMMON TABLE HEADER
C
 18   CALL NUPAGE (5)
      WRITE (6,CFMTH) IPAGE
      WRITE (6,102) C0
C
C         OPEN UNIT 1 TO SAVE THE LENGTH OF EACH COMMON BLOCK FOR GLOBAL
C         ANALYSIS
C
      IF(LGLOBL) OPEN (UNIT=1,FILE=CFCLEN,FORM='UNFORMATTED',
     1RECL=76,STATUS='UNKNOWN',ACCESS='DIRECT')
C
C         SET THE LOOP TO PROCESS ALL DEFINED COMMON BLOCKS IN THE
C         CURRENT ROUTINE BEING PROCESSED
C
      DO 28 I = 1,ICOMKT
      IADDR = 0
C
C         DETERMINE IF THE CURRENT BLOCK NAME HAS ALREADY BEEN PROCESSED
C         BECAUSE IT IS A CONTINUATION BLOCK
C
      IF(ICOMTB(9,I) .LT. 0) GO TO 28
C
C         SET THE STARTING VALUE FOR THE ASSOCIATE VARIABLE OF UNIT 11
C         FOR EACH COMMON BLOCK
C
      K = ICOMTB(10,I)
C
C         READ THE BLOCK COMMON RECORDS ON UNIT 11
C
      READ (11,REC=K,IOSTAT=IEND) CWK44
C
C         VERIFY THE INITIAL RECORD IS A COMMON BLOCK NAME
C
      IF(COMTBL(I)(1:32) .EQ. CWK44(1:32)) THEN
C
C     DETERMINE IF THE BLOCK COMMON NAME IS BLANK COMMON
C
         IF(COMTBL(I)(1:32) .EQ. CBLK52(1:32)) THEN
            I5 = 6
         ELSE
            I5 = ICOMTB(9,I)
         END IF
C
C         SET THE BLOCK COMMON VARIABLE NAME LENGTH TO A NEGATIVE VALUE
C         TO PREVENT ANY PROCESSING AFTER ITS DATA HAS BEEN PROCESSED
C
         ICOMTB(9,I) = -ICOMTB(9,I)
C
C         MOVE THE COMMON BLOCK NAME TO A SAVE AREA
C
         CWKBUF(1:44) = CWK44(1:44)
      ELSE
         WRITE (0,100) ISN,COMTBL(I)(1:32)
         IREC0 = IREC0 + 1
         GO TO 28
      END IF
C
C       SET THE DO LOOP LIMITS TO READ AND PROCESS THE VARIABLE NAMES
C       IN THE COMMON BLOCK
C
      I1 = K + 1
      IF(I .EQ. ICOMKT) THEN
         I2 = IREC11
      ELSE
         I2 = ICOMTB(10,I+1) - 1
      END IF
C
C         PROCESS ALL THE VARIABLES BELONGING TO THE CURRENT COMMON
C         BLOCK; THIS EXCLUDES THE COMMON BLOCK NAME.
C
      I4 = 0
      IY = 0
      DO 19 J = I1,I2
      IY = IY + 1
C
C         READ THE RECORD OF EACH VARIABLE WITHIN THE COMMON BLOCK
C
      READ (11,REC=J) CWK44(1:44)
C
C       BEGIN SETUP OF THE DATA TO BE PRINTED
C
      CALL TABSRH (CNAME,INAME,52,1,32,CWK44,1,32,IRET,4000)
      CALL TBLSRH (CNAME,INAME,52,1,32,CWK44,1,32,IRET1,4000)
C
C         DETERMINE THE CORRECT INDEX VALUE TO BE USED
C
      IF(CWK44(1:32) .EQ. CNAME(IRET)(1:32)) IRET1 = IRET
      IF(CWK44(37:44) .EQ. CNAME(IRET)(37:44)) IRET = IRET1
C
C         WHEN THE TYPE DEFINITION IS A BAR, THE IRET VALUE DOES NOT
C         PROVIDE THE CORRECT RECORD FOR A NORMAL VARIABLE. DETERMINE
C         IF THE PRECEDING VARIABLE ENTRY IN CNAME IS THE NORMAL
C         VARIABLE ENTRY.
C
      IF(CNAME(IRET)(37:37) .EQ. CBAR) THEN
         IF(CWK44(1:32) .EQ. CNAME(IRET-1)(1:32)) THEN
            IF(CWK44(37:44) .EQ. CNAME(IRET-1)(37:44)) IRET = IRET -1
            IF(CWK44(37:44) .EQ. CBLANK(1:8)) IRET = IRET -1
         END IF
      END IF
C
C         SET THE VARIABLE NAME OF A COMMON BLOCK TO THE CORRECT TYPE
C         AND LENGTH WHEN THE RECORD ON UNIT 11 DISAGREES WITH THAT IN
C         CNAME. THIS CORRECTION IS REQUIRED, BECAUSE COMMON AND TYPE
C         DEFINITIONS OCCUR IN THE SAME SEQUENCE ORDER; WHEN THE DATA
C         TYPE DEFINITION FOLLOWS A COMMON DEFINITION, THE TYPE AND
C         LENGTH CHARACTERISTICS MAY BE INCORRECT IN THE COMMON RECORD
C         ON UNIT 11, SINCE DEFAULT VALUES MAY BE ASSIGNED TO THE TYPE
C         AND LENGTH CHARACTERISTICS. THIS CORRECTION MUST NOT BE USED
C         FOR STRUCTURE AND UNION VARIABLES.
C
      IF(CWK44(37:44) .NE. CNAME(IRET)(37:44)) THEN
C
C         DETERMINE IF THE VARIABLE OCCURS IN A STRUCTURE OR RECORD
C
         IF(.NOT.BTEST(IENAME(12,IRET),5) .OR.
     1      .NOT.BTEST(IENAME(12,IRET),6)) CWK44(37:44) =
     2       CNAME(IRET)(37:44)
      END IF
      IF(IRET .GT. 0) THEN
C
C         DETERMINE IF THIS VARIABLE NAME IS TO BE PRINTED
C
         IF(BTEST(IENAME(12,IRET),15) .AND. BTEST(IENAME(12,IRET),1))
     1      THEN
            I4 = I4 + 1
            COMPRT(I4)(37:44) = CNAME(IRET)(37:44)  ! TYPE & LENGTH
            COMPRT(I4)(1:32) = CNAME(IRET)(1:32)    ! VARIABLE NAME
            ICOMPR(12,I4) = IENAME(13,IRET)         ! VAR. NAME LENGTH
            ICOMPR(9,I4) = IADDR                    ! RELATIVE ADDRESS
C
C         OBTAIN THE NUMBER OF SUBSCRIPTS OF THE DIMENSIONED VARIABLE
C
            CALL TABSRH (CDIM,JDIM,104,1,32,CNAME(IRET),1,32,IRET1,1000)
            IF(IRET1 .GT. 0) THEN
               ICOMPR(13,I4) = IDIM(10,IRET1)
            ELSE
               ICOMPR(13,I4) = 0
            END IF
         END IF
C
C         WHEN BOTH CWK44(37:37) AND CNAME(IRET)(37:37) ARE CBAR, DO
C         NOT WRITE THE ERROR MESSAGE
C
         IF(CWK44(37:37) .NE. CBAR .AND. CNAME(IRET)(37:37) .NE. CBAR)
     1      THEN
C
C         WHEN CW44(37:37) AND CNAME(IRET)(37:37) ARE IDENTICAL, DO
C         NOT WRITE THE ERROR MESSAGE
C
            IF(CWK44(37:37) .NE. CNAME(IRET)(37:37)) THEN
C
C         WHEN NOT A NAMELIST VARIABLE OR A NAMELIST DEFINITION, WRITE
C         AN ERROR MESSAGE
C
               IF(.NOT.BTEST(IENAME(12,IRET),1) .AND.
     1            BTEST(IENAME(12,IRET),15)) THEN
                  I3 = IWK44(9)
                  I2WK1 = 0
                  WRITE (CI2WK1,'(I2)') I3
                  IF(I3 .GT. 9) THEN
                     CF110(41:42) = CI2WK1(1:2)
                  ELSE
                     CF110(41:42) = CI2WK1(2:2)//CBLANK(1:1)
                  END IF
                  WRITE (0,CF110) ISN,CWK44(1:I3)
                  IREC0 = IREC0 + 1
               END IF
            END IF
         END IF
      ELSE
C
C         WRITE THE COMMON VARIABLE NOT IN CNAME MESSAGE
C
         I3 = IENAME(13,IRET)
         WRITE (0,101) ISN,CNAME(IRET)(1:I3)
         IREC0 = IREC0 + 1
         GO TO 19
      END IF
C
C         DETERMINE THE LENGTH CHARACTERISTIC OF THE VARIABLE WITHIN
C         COMMON
C
      READ (CNAME(IRET)(38:44),'(I4)') III
C
C         CREATE THE NEXT VARIABLE'S ADDRESS; DETERMINE IF THE VARIABLE
C         IS DIMENSIONED.
C
      L1 = BTEST(IENAME(12,IRET),17)
      IF(L1) THEN
         CALL TABSRH (CDIM,JDIM,104,1,32,CNAME(IRET),1,32,IRET1,1000)
         IF(IRET1 .GT. 0) IADDR = IADDR + III * KDIM(25,IRET1)
      ELSE
         IADDR = IADDR + III
      END IF
C
C         THE VALUE OF IADDR JUST COMPUTED IS THE NEXT VARIABLE'S
C         ADDRESS, OR THE TOTAL LENGTH OF THE COMMON BLOCK
C
 19   CONTINUE
C
C         SEARCH FOR A CONTINUATION OF THE BLOCK COMMON IN THE REMAINING
C         BLOCK COMMON DEFINITIONS
C
      IA = I + 1
C
C         DETERMINE IF THE FINAL COMMON GROUP IS BEING PROCESSED. THERE
C         CAN NOT BE A CONTINUATION OF THE COMMON BLOCK AT THIS TIME.
C
      IF(IA .GT. ICOMKT) GO TO 22
C
C         LOOP TO SEARCH FOR A CONTINUATION OF THE CURRENT COMMON BLOCK
C
      DO 21 J = IA,ICOMKT
      IF(COMTBL(I)(1:32) .EQ. COMTBL(J)(1:32)) THEN
C
C         INDICATE THE CONTINUATION COMMON BLOCK HAS BEEN PROCESSED
C
         ICOMTB(9,J) = -ICOMTB(9,J)
C
C         PROCESS THE CONTINUATION COMMON BLOCK
C
         I1 = ICOMTB(10,J) + 1
         IF(J .EQ. ICOMKT) THEN
            I2 = IREC11
         ELSE
            I2 = ICOMTB(10,J+1) - 1
         END IF
         DO 20 J1 = I1,I2
         READ (11,REC=J1) CWK44
C
C       BEGIN SETUP OF THE DATA TO BE PRINTED
C
         CALL TABSRH (CNAME,INAME,52,1,32,CWK44,1,32,IRET,4000)
         IF(IRET .GT. 0) THEN
C
C         DETERMINE IF THIS VARIABLE NAME IS TO BE PRINTED
C
            IF(BTEST(IENAME(12,IRET),15) .AND. BTEST(IENAME(12,IRET),1))
     1         THEN
               I4 = I4 + 1
               COMPRT(I4)(1:32) = CNAME(IRET)(1:32)    ! VARIABLE NAME
               COMPRT(I4)(37:44) = CNAME(IRET)(37:44)  ! TYPE & LENGTH
               ICOMPR(12,I4) = IENAME(13,IRET)         ! VAR. NAME LENGTH
               ICOMPR(9,I4) = IADDR                    ! RELATIVE ADDRESS
               CALL TABSRH (CDIM,JDIM,104,1,32,CNAME(IRET),1,32,IRET1,
     1                      1000)
               IF(IRET1 .GT. 0) THEN
                  ICOMPR(13,I4) = IDIM(10,IRET1)
               ELSE
                  ICOMPR(13,I4) = 0
               END IF
            ELSE
               IF(.NOT.BTEST(IENAME(12,IRET),1)) THEN
                  I3 = IWK44(9)
                  I2WK1 = 0
                  WRITE (CI2WK1,'(I2)') I3
                  IF(I3 .GT. 9) THEN
                     CF110(41:42) = CI2WK1(1:2)
                  ELSE
                     CF110(41:42) = CI2WK1(2:2)//CBLANK(1:1)
                  END IF
                  WRITE (0,CF110) ISN,CWK44(1:I3)
                  IREC0 = IREC0 + 1
               END IF
            END IF
         ELSE
            I3 = IENAME(13,IRET)
            WRITE (0,101) ISN,CNAME(IRET)(1:I3)
            IREC0 = IREC0 + 1
            GO TO 20
         END IF
C
C         DETERMINE THE LENGTH CHARACTERISTIC OF THE VARIABLE WITHIN
C         COMMON
C
         READ (CNAME(IRET)(38:44),'(I7)') III
C
C         CREATE THE NEXT VARIABLE'S ADDRESS; DETERMINE IF THE VARIABLE
C         IS DIMENSIONED.
C
         IF(BTEST(IENAME(12,IRET),17)) THEN
            CALL TABSRH (CDIM,JDIM,104,1,32,CNAME,1,32,IRET1,1000)
            IF(IRET1 .GT. 0) IADDR = IADDR + KDIM(25,IRET1)
         ELSE
            IADDR = IADDR + III
         END IF
 20      CONTINUE
C
C         THE VALUE OF IADDR JUST COMPUTED IS THE NEXT VARIABLE'S
C         ADDRESS, OR THE TOTAL LENGTH OF THE COMMON BLOCK
C
      END IF
 21   CONTINUE
C
C         ALL VARIABLES BELONGING TO THE CURRENT COMMON BLOCK ARE READY
C         TO PRINT. THIS INCLUDES ALL CONTINUATIONS OF THE COMMON BLOCK.
C         DETERMINE THE VARIABLE NAME WITH THE GREATEST LENGTH IN THE
C         COMMON BLOCK.
C
 22   I3 = 0
      DO 23 J = 1,I4
      IF(ICOMPR(12,J) .GT. I3) THEN
         I3 = ICOMPR(12,J)
         IA = J
      END IF
 23   CONTINUE
C
C         WHEN A SINGLE VARIABLE EXISTS IN A COMMON BLOCK AND THE TOTAL
C         LENGTH OF THE COMMON BLOCK IS ZERO, SET THE BLOCK TOTAL LENGTH
C         TO THE MEMORY SIZE OF THE SINGLE VARIABLE.
C
      IF(I .EQ. 1 .AND. IADDR .EQ. 0) THEN
         IF(IRET1 .GT. 0) THEN
            IADDR = KDIM(25,IRET1)
         END IF
      END IF
C
C         CONVERT THE COMMON BLOCK TOTAL LENGTH TO TEXT FORMAT
C
      WRITE (CL8,'(I8)') IADDR
      WRITE (CI2WK1,'(I2)') I5
      IF(CI2WK1(1:1) .EQ. CBLANK(1:1)) THEN
         C103(35:36) = CI2WK1(2:2)//CBLANK(1:1)
      ELSE
         C103(35:36) = CI2WK1(1:2)
      END IF
      WRITE (6,C103) C0,COMTBL(I)(1:I5),CL8(1:8)
      IF(ILINE .GE. NLINES .OR. ILINE + 7 .GE. NLINES) THEN
         CFMTH(3:3) = C1(1:1)
         IPAGE = IPAGE + 1
         WRITE (6,CFMTH) IPAGE
         WRITE (6,102)
         ILINE = 4
      END IF
C
C         WHEN GLOBAL ANALYSIS OF COMMON IS REQUESTED, WRITE THE COMMON
C         RECORD FOR THIS COMMON BLOCK ON UNIT 1.
C
      IF(LGLOBL) THEN
         IREC1 = IREC1 + 1
         CGCOMM(1:76) = CBLK52(1:52)//CBLK52(1:24)
C
C         PLACE SUBPOGRAM NAME WHERE THE COMMON BLOCK OCCURS
C
         L3 = LFALSE
         IF(CPGNME(1:10) .EQ. 'BLOCK DATA') THEN
            CGCOMM(1:10) = CPGNME(1:10)
            L3 = LTRUE
            I4WK1 = 138
         ELSE
            CGCOMM(1:IPGNME) = CPGNME(1:IPGNME)
         END IF
C
C         DETERMINE THE LENGTH OF THE VARIABLE IN CGCOMM(1:32)
C
         IF(.NOT.L3) THEN
            L2 = LFALSE
            DO 24 J = 1,32
            IF(CGCOMM(J:J) .EQ. CBLANK(1:1) .AND. .NOT.L2) THEN
               JPGNME = J - 1
               L2 = LTRUE
            END IF
 24         CONTINUE
C
C         LENGTH OF THE SUBPROGRAM NAME
C
            I4WK1 = JPGNME + 128
         END IF
         CGCOMM(65:68) = CI4WK1(1:4)
C
C         PLACE COMMON BLOCK NAME
C
         CGCOMM(33:I5+32) = COMTBL(I)(1:I5)
C
C         DETERMINE THE LENGTH OF THE VARIABLE IN CGCOMM(33:64)
C
         L2 = LFALSE
         DO 25 J = 33,64
         IF(CGCOMM(J:J) .EQ. CBLANK(1:1) .AND. .NOT.L2) THEN
            JPGNME = J - 33
            L2 = LTRUE
            GO TO 26
         END IF
 25      CONTINUE
C
C         LENGTH OF THE COMMON BLOCK NAME IN BYTES
C
 26      I4WK1 = JPGNME + 128
         CGCOMM(69:72) = CI4WK1(1:4)
         WRITE (1,REC=IREC1) CGCOMM(1:76)
      END IF
C
C         SET THE NUMBER OF ISNS PER LINE OF PRINT VALUE AND THE NUMBER
C         OF LINES OF PRINT NECESSARY TO PRINT ALL THE VARIABLE NAMES
C         IN THE CURRENT COMMON BLOCK
C
      IF(I3 .LE. 10) THEN
         M = 10
         N = 4
         N1 = 5
         ASSIGN 107 TO IFMT
         ASSIGN 104 TO JFMT
      ELSE IF(I3 .GT. 10 .AND. I3 .LE. 20) THEN
         M = 20
         N = 3
         N1 = 4
         ASSIGN 108 TO IFMT
         ASSIGN 105 TO JFMT
      ELSE IF(I3 .GT. 20 .AND. I3 .LE. 32) THEN
         M = 32
         N = 2
         N1 = 3
         ASSIGN 109 TO IFMT
         ASSIGN 106 TO JFMT
      END IF
      I2 = I4/N
      I6 = I4 - N * I2
C
C         PRINT THE HEADER AND THEN THE DATA FOR THE COMMON BLOCK
C
      IF(ILINE .GE. NLINES .OR. ILINE + I2 + 1 .GT. NLINES) THEN
         ILINE = 4
         CFMTH(3:3) = C1(1:1)
         IPAGE = IPAGE + 1
         WRITE (6,CFMTH) IPAGE
         WRITE (6,C103)
      END IF
      WRITE (6,JFMT) C0
      ILINE = ILINE + 1
      IF(I4 .LE. N) THEN
C
C         ALL VARIABLES FOR A COMMON BLOCK CAN BE PRINTED ON A SINGLE
C         LINE IN THE LISTING
C
         WRITE (6,IFMT) CBLANK(1:1),(COMPRT(J)(1:M),COMPRT(J)(37:37),
     1   COMPRT(J)(38:44),ICOMPR(9,J),J = 1,I4)
         ILINE = ILINE + 1
         IF(ILINE .GE. NLINES .OR. ILINE + I2 + 1 .GT. NLINES) THEN
            ILINE = 4
            CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,C103)
         END IF
      ELSE
C
C         VARIABLES FOR A COMMON BLOCK REQUIRE MULTIPLE LINES OF PRINT
C         IN THE LISTING. PRINT THE FULL LINES FIRST.
C
         DO 27 J1 = 1,I2
         IA = N * (J1 - 1) + 1
         IB = IA + N - 1
         WRITE (6,IFMT) CBLANK(1:1),(COMPRT(J)(1:M),COMPRT(J)(37:37),
     1   COMPRT(J)(38:44),ICOMPR(9,J),J = IA,IB)
         ILINE = ILINE + 1
         IF(ILINE .GE. NLINES .OR. ILINE + I2 + 1 .GT. NLINES) THEN
            ILINE = 4
            CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,C103)
         END IF
 27      CONTINUE
C
C         DETERMINE IF A PARTIAL FINAL LINE MUST BE PRINTED
C
         IF(I6 .GT. 0) THEN
            IA = IB + 1
            WRITE (6,IFMT) CBLANK(1:1),(COMPRT(J)(1:M),COMPRT(J)(37:37),
     1      COMPRT(J)(38:44),ICOMPR(9,J),J = IA,I4)
            ILINE = ILINE + 1
            IF(ILINE .GE. NLINES .OR. ILINE + I2 + 1 .GT. NLINES) THEN
               ILINE = 4
               CFMTH(3:3) = C1(1:1)
               IPAGE = IPAGE + 1
               WRITE (6,CFMTH) IPAGE
               WRITE (6,C103)
            END IF
         END IF
      END IF
C
C         DETERMINE IF ANY OF THE COMMON BLOCK'S VARIABLES ARE IN AN
C         EQUIVALENCE STATEMENT
C
C         SORT THE COMMON BLOCK VARIABLE NAMES IN COMPRT INTO ASCENDING
C         SEQUENCE. THIS WILL ALLOW TABSRH TO BE USED FOR MATCHING IN
C         SUBROUTINE PEQUIV.
C
      CTYPE(1) = CBLANK(1:1)
      ISTART(1) = 1
      IFLEN(1) = 32
      CTYPE(1) = CCC
      IF(I4 .GT. 2) THEN
         CALL MSORT (COMPRT,I4,52,26000,1)
      ELSE IF(I4 .EQ. 1) THEN
         CONTINUE
      ELSE IF(I4 .EQ. 2) THEN
         IF(COMPRT(1)(1:32) .GT. COMPRT(2)(1:32)) THEN
            CWK68(1:52) = COMPRT(2)(1:52)
            COMPRT(2)(1:52) = COMPRT(1)(1:52)
            COMPRT(1)(1:52) = CWK68(1:52)
         END IF
      END IF
C
C         PROCESS ANY EQUIVALENCED VARIABLES THAT BELONG TO A COMMON
C         BLOCK
C
      IF(IREC12 .GT. 0) CALL PEQUIV (COMPRT,ICOMPR,I4,K7,IADDR,JEQGRP,
     1   JGRPKT)
      IF(I .EQ. ICOMKT) GO TO 29
 28   CONTINUE
C
C         ROUTINE EXIT
C
 29   RETURN
      END
C
C    *******************************************************************
C
C     PURPOSE
C
C        THIS ROUTINE PRODUCES A LISTING OF ALL EQUIVALENCE DEFINITIONS
C        WITHIN ALL COMMON BLOCKS.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CDIM   - CHARACTER VARIABLE, CONTAINS A TABLE OF DIMENSIONED
C                  VARIABLE NAMES, THE SIZE IN BYTES OF ITS DIMENSION,
C                  AND THE INDIVIDUAL SUBSCRIPT LIMIT VALUES.
C                  COLUMNS TYPE WORD DESCRIPTION
C                   1 - 32 A*32 8  THE DIMENSIONED VARIABLE NAME
C                  33 - 36 I*4  9  VARIABLE NAME LENGTH IN COLS 1-32
C                  37 - 40 I*4 10  NUMBER OF SUBSCRIPTS FOR THE VARIABLE
C                  41 - 44 I*4 11  FIRST SUBSCRIPT UPPER RANGE VALUE
C                  45 - 48 I*4 12  SECOND SUBSCRIPT UPPER RANGE VALUE
C                  49 - 52 I*4 13  THIRD SUBSCRIPT UPPER RANGE VALUE
C                  53 - 56 I*4 14  FOURTH SUBSCRIPT UPPER RANGE VALUE
C                  57 - 60 I*4 15  FIFTH SUBSCRIPT UPPER RANGE VALUE
C                  61 - 64 I*4 16  SIXTH SUBSCRIPT UPPER RANGE VALUE
C                  65 - 68 I*4 17  SEVENTH SUBSCRIPT UPPER RANGE VALUE
C                  69 - 72 I*4 18  FIRST SUBSCRIPT LOWER STARTING VALUE
C                  73 - 76 I*4 19  SECOND SUBSCRIPT LOWER STARTING VALUE
C                  77 - 80 I*4 20  THIRD SUBSCRIPT LOWER STARTING VALUE
C                  81 - 84 I*4 21  FOURTH SUBSCRIPT LOWER STARTING VALUE
C                  85 - 88 I*4 22  FIFTH SUBSCRIPT LOWER STARTING VALUE
C                  89 - 92 I*4 23  SIXTH SUBSCRIPT LOWER STARTING VALUE
C                  93 - 96 I*4 24  SEVENTH SUBSCRIPT LOWER STARTING
C                                  VALUE
C                  97 -100 I*4 25  TOTAL NUMBER OF WORDS OF MEMORY FOR
C                                  THE VARIABLE NAME IN COLS 1-32
C                 101 -104 I*4 26  ISN OF THE DEFINING DIMENSION
C                                  STATEMENT
C         CEQNAM - CHARACTER VARIABLE, A LIST OF EQUIVALENCED VARIABLE
C                  NAMES TO BE PRINTED FOR A SINGLE COMMON BLOCK; A
C                  MAXIMUM OF 100 ARE ALLOWED.
C                  RECORD STRUCTURE
C                  COLS.   TYPE WORD  CONTENTS
C                   1 - 32 A*32  8  EQUIVALENCED VARIABLE NAME
C                  33 - 40 A*8  10  VARIABLE TYPE AND LENGTH
C                  41 - 44 I*4  11  VARIABLE ADDRRESS WITHIN COMMON
C         CF111  - CHARACTER VARIABLE, ERROR MESSAGE THAT AN ADDRESS IS
C                  GREATER THAN DEFINED COMMON LENGTH
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CI4WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I4WK1
C         CMATCH - CHARACTER VARIABLE, THE VARIABLE NAME IN AN
C                  EQUIVALENCE GROUP THAT MATCHES A VARIABLE NAME IN THE
C                  COMMON BLOCK. THIS VARIABLE IS NOT LISTED IN THE
C                  EQUIVALENCE DATA LISTING.
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL VARIABLE NAMES
C                  OCCURING IN THE PROGRAM, INCLUDING ALL VARIABLE NAMES
C                  BROUGHT INTO A PROGRAM MODULE BY USING AN INCLUDE
C                  STATEMENT.
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 WILL CONTAIN '|' WHEN NO TYPE OR DATA
C                  CHARACTERISTICS EXIST. SUBROUTINE , ENTRY, COMMON
C                  BLOCK, AND NAMELIST DEFINITION VARIABLES MEET THIS
C                  CONDITION.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         COMPRT - CHARACTER VARIABLE, VARIABLES THAT WERE PRINTED IN A
C                  COMMON BLOCK. EQUIVALENCED TO ICOMPR. THIS IS A
C                  LIST OF ALL VARIABLE NAMES IN A COMMON BLOCK. THE
C                  ARRAY IS USED BY SUBROUTINE PEQUIV SO ANY
C                  EQUIVALENCED VARIABLE'S ADDRESS CAN BE DETERMINED.
C                  A MAXIMUM OF 500 VARIABLES MAY OCCUR IN A COMMON
C                  BLOCK. THIS ARRAY IS CREATED IN ROUTINE PCOMM.
C                  RECORD STRUCTURE:
C                  COLUMN
C                  NUMBER TYPE WORD DESCRIPTION
C                   1-32  A*32   8  VARIABLE NAME
C                  33-36  I*4    9  RELATIVE ADDRESS IN BYTES
C                  37-44  A*8   11  TYPE AND LENGTH CHARACTERISTICS
C                  45-48  I*4   12  LENGTH OF THE VARIABLE NAME
C         CTEMP  - CHARACTER VARIABLE, INPUT BUFFER TO CONTAIN RECORDS
C                  READ FROM UNIT 12. A MAXIMUM OF 20 VARIABLE NAMES MAY
C                  BELONG TO AN EQUIVALENCED GROUP.
C                  RECORD STRUCTURE:
C                  COLS TYPE WORD DESCRIPTION
C                   1-32 C*32  8  VARIABLE NAME
C                  33-36 I*4   9  ISN VALUE; SET NEGATIVE WHEN THE FIRST
C                                 VARIABLE OF NAME OF AN EQUIVALENCED
C                                 GROUP
C                  37-40 I*4  10  INTEGER VALUE OF THE NUMBER OF
C                                 SUBSCRIPTS
C                  41-44 I*4  11  INTEGER VALUE OF THE STARTING LOCATION OF
C                                 A CHARACTER VARIABLE SUBSTRING
C                  45-48 I*4  12  INTEGER VALUE OF THE FIRST SUBSCRIPT
C                  49-52 I*4  13  INTEGER VALUE OF THE SECOND SUBSCRIPT
C                  53-56 I*4  14  INTEGER VALUE OF THE THIRD SUBSCRIPT
C                  57-60 I*4  15  INTEGER VALUE OF THE FOURTH SUBSCRIPT
C                  61-64 I*4  16  INTEGER VALUE OF THE FIFTH SUBSCRIPT
C                  65-68 I*4  17  INTEGER VALUE OF THE SIXTH SUBSCRIPT
C                  69-72 I*4  18  INTEGER VALUE OF THE SEVENTH SUBSCRIPT
C                  73-76 I*4  19  BIT SWITCHES
C                  77-80 I*4  20  THE ASSOCIATE VARIABLE VALUE OF THE
C                                 RECORD ON UNIT 12. USED TO WRITE THE
C                                 RECORD BACK ONTO UNIT 12 WHEN THE
C                                 RECORD HAS BEEN PROCESSED AS AN
C                                 EQUIVALENCED GROUP; PREVENTS ANY
C                                 FURTHER PROCESSING OF THE GROUP.
C         CWK7   - CHARACTER VARIABLE, WORK ARE TO CONVERT A NUMERIC
C                  TEXT FIELD TO INTEGER
C         IA     - SUBSCRIPT VARIABLE USED TO WRITE THE OUTPUT LISTING
C         IB     - SUBSCRIPT VARIABLE USED TO WRITE THE OUTPUT LISTING
C         IC     - THE NUMBER OF FULL LINES OF PRINT IN THE OUTPUT
C                  LISTING
C         IADDR  - THE ADDRESS OF AN EQUIVALENCED VARIABLE WITHIN THE
C                  GROUP.
C         ICOMPR - EQUIVALENCED TO COMPRT
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME.
C         IEQNAM - EQUIVALENCED TO CEQNAM
C         ILINE  - COUNT OF THE NUMBER OF LINES WRITTEN ON A PAGE
C         INAME  - COUNT OF THE NUMBER OF VARIABLE NAMES IN CNAME
C         IPRT   - COUNT OF THE NUMBER OF EQUIVALENCED VARIABLES TO BE
C                  PRINTED FOR A SINGLE COMMON BLOCK
C         IREC0  - COUNT OF THE NUMBER OF MESSAGES ON UNIT 10
C         IREC12 - COUNT OF THE NUMBER OF RECORDS ON UNIT 12
C         IRET1  - RETURN INDEX VALUE FROM TABSRH FOR CDIM
C         IRET2  - RETURN INDEX VALUE FROM TABSRH FOR COMPRT (MATCH)
C         IRET3  - RETURN INDEX VALUE FROM TABSRH FOR CNAME. USED TO
C                  DETERMINE IF THE NUMBER OF SUBSCRIPTS FOR AN
C                  EQUIVALENCED VARIABLE ARE CORRECT
C         IRET4  - RETURN INDEX VALUE FROM TABSRH FOR COMPRT (NO MATCH)
C         ITEMP  - EQUIVALENCED WITH CTEMP
C         IVLEN  - NUMBER OF CHARACTERS IN A VARIABLE NAME
C         I2     - WORK AREA, USED TO CREATE FORMAT CF111
C         I2WK1  - WORK AREA FOR THE ADDRESS ADJUSTMENT FACTOR FOR
C                  ALEGEBRAIC VARIABLES, EQUIVALENCED TO CI2WK1
C         I4     - NUMBER OF VARIABLE NAMES IN COMPRT, THE LIST OF
C                  VARIABLES BELONGING TO THE CURRENT COMMON BLOCK.
C         I4WK1  - USED TO CREATE THE TEXT LENGTH OF A VARIABLE NAME.
C                  EQUIVALENCED TO CI4WK1.
C         JDIM   - THE NUMBER OF DIMENSION TABLE ENTRIES IN CDIM
C         JDIMSZ - SIZE ADJUSTMENT FOR EACH SUBSCRIPT LEVEL COMPUTED
C                  FROM THE DIMENSION SPECIFICATIONS
C         JEQGRP - LOCATION OF THE FIRST VARIABLE OF AN EQUIVALENCE
C                  GROUP ON UNIT 12.
C                  SUBSCRIPT 1 VALUE  MEANING
C                  1 - THE ASSOCIATE VARIABLE VALUE OF THE RECORD ON
C                      UNIT 12
C                  2 - COUNT OF THE NUMBER OF VARIABLES BELONGING TO THE
C                      EQUIVALENCE GROUP
C                  3 - THE MASTER ADDRESS OF ALL EQUIVALENCE VARIABLES
C                      BELONGING TO THE EQUIVALENCE GROUP WHEN ONE OF
C                      THE EQUIVALENCE GROUP VARIABLES MATCH A VARIABLE
C                      IN THE CURRENT COMMON BLOCK.
C                  SUBSCRIPT 2 DETERMINES THE GROUP CHOICE
C         JGRPKT - COUNT OF THE NUMBER OF EQUIVALENCE GROUPS ON UNIT 12
C                  USED TO INSURE ALL EQUIVALENCE GROUPS ARE PROCESSED
C                  AGAINST THE CURRENT COMMON BLOCK
C         K      - ASSOCIATE VARIABLE TO READ A RECORD FROM UNIT 12
C         KDIM   - EQUIVALENCED TO CDIM
C         K1     - SUBSCRIPT VARIABLE
C         K2     - SUBSCRIPT VARIABLE, THIS IS THE SUBSCRIPT VALUE OF
C                  THE NUMBER OF EQUIVALENCE GROUP VARIABLES THAT ARE
C                  ARE TO BE WRITTEN ON UNIT 6. THIS IS RESET EACH
C                  TIME A NEW COMMON BLOCK IS PROCESSED.
C         K3     - SUBSCRIPT VARIABLE AND WORK AREA
C         K4     - WORK AREA TO COMPUTE EQUIVALENCE ADDRESS
C         K5     - WORK AREA, DO LOOP LIMIT
C         K6     - WORK AREA
C         K7     - NUMBER OF VARIABLES IN A COMMON BLOCK
C         K8     - NUMBER OF VARIABLES IN A COMMON BLOCK
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LTRUE  - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL TRUE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN A VARIABLE IN ONE OF
C                  THE EQUIVALENCE GROUP MATCHES A VARIABLE IN THE
C                  CURRENT COMMON BLOCK, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN AN EQUIVALENCED
C                  VARIABLE IN THE CURRENT EQUIVALENCE GROUP MATCHES
C                  A VARIABLE IN THE CURRENT COMMON BLOCK, SET FALSE
C                  OTHERWISE.
C         M      - THE NUMBER OF ADDRESSES FOR A SINGLE EQUIVALENCED
C                  GROUP THAT ARE TO BE PRINTED
C         MADDR  - THE TOTAL LENGTH OF THE CURRENT COMMON BLOCK
C         MASADR - THE MASTER ADDRESS FOR THE CURRENT EQUIVALENCE
C                  GROUP
C         MIDX   - INDEX OF THE RECORD ON UNIT 12 WITH THE VARIABLE NAME
C                  MATCHING A COMMON BLOCK
C         MRET   - LOCATION OF THE MATCHING COMMON AND EQUIVALENCE
C                  VARIABLE NAME IN THE MASTER NAME TABLE, CNAME
C         MVSIZE - THE LENGTH OF THE LARGEST EQUIVALENCED VARIABLE NAME
C                  IN THE PRINT LIST OF VARIABLES.
C         N      - THE NUMBER OF EQUIVALENCED VARIABLES THAT CAN BE
C                  PRINTED IN A SINGLE LINE OF PRINT
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         6      - THE OUTPUT LISTING FILE TO BE PRINTED
C        10      - ERROR MESSAGES
C        12      - LIST OF EQUIVALENCED VARIABLES BY GROUP, RECORD
C                  LENGTH IS 80 CHARACTERS
C
C              RECORD STRUCTURE:
C
C              COLS TYPE WORD DESCRIPTION
C              1-32 C*32   8  VARIABLE NAME
C             33-36 I*4    9  ISN VALUE; SET NEGATIVE TO INDICATE THE
C                             VARIABLE IN COLS. 1-32 IS THE INITIAL
C                             VARIABLE OF AN EQUIVALENCED GROUP; FOR ALL
C                             OTHER VARIABLE NAMES BELONGING TO THE SAME
C                             GROUP, THIS A POSITIVE VALUE.
C             37-40 I*4   10  INTEGER VALUE OF THE NUMBER OF SUBSCRIPTS
C             41-44 I*4   11  INTEGER VALUE OF THE STARTING LOCATION OF
C                             A CHARACTER VARIABLE SUBSTRING
C             45-48 I*4   12  INTEGER VALUE OF THE FIRST SUBSCRIPT
C             49-52 I*4   13  INTEGER VALUE OF THE SECOND SUBSCRIPT
C             53-56 I*4   14  INTEGER VALUE OF THE THIRD SUBSCRIPT
C             57-60 I*4   15  INTEGER VALUE OF THE FOURTH SUBSCRIPT
C             61-64 I*4   16  INTEGER VALUE OF THE FIFTH SUBSCRIPT
C             65-68 I*4   17  INTEGER VALUE OF THE SIXTH SUBSCRIPT
C             69-72 I*4   18  INTEGER VALUE OF THE SEVENTH SUBSCRIPT
C             73-76 I*4   19  BIT SWITCHES
C             77-80 I*4   20  ASSOCIATE VARIABLE INDEX OF THE RECORD
C
C     COMMENTS
C
C         COMPOUND VARIABLE NAMES CAN NOT OCCUR IN AN EQUIVALENCE
C         STATEMENT
C
C         BIT SWITCH 18 IS SET TO OFF (ZERO) FOR EACH RECORD WRITTEN
C         ON UNIT 12. ONCE A RECORD IS PROCESSED BY ROUTINE PEQUIV,
C         BIT 18 IS SET TO ON (ONE). THIS ALLOWS EQUIVALENCED GROUPS
C         THAT ARE NOT IN ANY COMMON BLOCK TO BE DISTINGUISHED FROM
C         COMMON BLOCK VARIABLES.
C
C         THE WORD LENGTH IS THE LENGTH CHARACTERISTIC DEFINED FOR THE
C         VARIABLE
C
C         WHEN AN EQUIVALENCED VARIABLE MATCHES A VARIABLE IN A COMMON
C         BLOCK, NO OTHER VARIABLE NAME IN THE EQUIVALENCED GROUP MAY
C         MATCH A DIFFERENT VARIABLE NAME IN THE COMMON BLOCK.
C
C         VARIABLES BELONGING TO EQUIVALENCED GROUPS WILL NOT APPEAR
C         IN THE OUTPUT LISTING WHEN NO VARIABLE WITHIN THE GROUP
C         MATCHES A VARIABLE NAME IN ONE OF THE DEFINED COMMON BLOCKS.
C
C     METHODOLOGY
C
C         VARIABLE COMPRT CONTAINS ALL VARIABLE NAMES BELONGING TO A
C         PARTICULAR COMMON BLOCK, EACH EQUIVALENCED GROUP OF VARIABLE
C         NAMES IS READ FROM UNIT 12; THEN A SEARCH IS MADE OF COMPRT
C         FOR ANY COMMON VARIABLE MATCHING ONE OF THE EQUIVALENCED
C         GROUP VARIABLES.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         BTEST IBSET MSORT NUPAGE TABSRH
C
C     ******************************************************************
C
      SUBROUTINE PEQUIV (COMPRT,ICOMPR,I4,K7,MADDR,JEQGRP,JGRPKT)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION COMPRT(500), IADDR(20), ICOMPR(13,500), IMATCH(20),
     1ITEMP(20), JDIMSZ(7), KDIM(26,1000)
      DIMENSION CEQNAM(100), IEQNAM(11,100), JEQGRP(3,200)
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION ICONTL(2,100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*114   CF111
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE, CMATCH, CTEMP
      CHARACTER*75    CF112
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, COMPRT, CPARAM, CWORK
      CHARACTER*44    CEQNAM, CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CTYPE
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       LASC, L1, L2
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CNAME(1),IENAME(1,1)),
     1            (I4WK1,CI4WK1), (CTEMP,ITEMP), (CMATCH,IMATCH),
     2            (CSUBTB,JSUBTB)
      EQUIVALENCE (CWK8(2:2),CWK7), (CDIM,KDIM), (CEQNAM,IEQNAM),
     1            (NLINE,ILINE)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA CF111 /'('' ISN:'',I6,'' LOCATION OF EQUIVALENCED VARIABLE ''
     1,AXX,'' AT '',I8/11X,'' IS GREATER THAN DEFINED COMMON LENGTH '',I
     28)'/
      DATA CF112 /'('' ISN:'',I6,'' VARIABLE '',AXX,'' IS EQUIVALENCED T
     1O MULTIPLE COMMON BLOCKS'')'/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(A1,T36,'EQUIVALENCED VARIABLES WITHIN THIS COMMON BLOCK')
 101  FORMAT(A1,4('VAR. NAME  TYPE   REL. ADDR. '))
 102  FORMAT(A1,3('VAR. NAME            TYPE   REL. ADDR. '))
 103  FORMAT(A1,2('VAR. NAME                        TYPE  REL. ADDR.   '
     1))
 104  FORMAT(' ISN:',I6,' EQUIVALENCED GROUP HAS A SINGLE VARIABLE')
 105  FORMAT(' ISN:',I6,' EQUIVALENCE VARIABLE HAS MORE SUBSCRIPTS THAN
     1ITS DIMENSION: ',A32)
 107  FORMAT(A1,4(A10,1X,A1,'*',A6,1X,I8,1X))
 108  FORMAT(A1,3(A20,1X,A1,'*',A6,1X,I8,1X))
 109  FORMAT(A1,2(A32,1X,A1,'*',A6,1X,I8,1X))
 110  FORMAT(' ISN:',I6,' MORE THAN 20 VARIABLES IN AN EQUIVALENCE GROUP
     1: ',A32)
C
C         WHEN THE NUMBER OF ALREADY PROCESSED EQUIVALENCED VARIABLES
C         EQUALS THE NUMBER OF RECORDS ON UNIT 12, NO PROCESSING FOR
C         SUBSEQUENT COMMON BLOCK ARE NECESSARY FOR THIS ROUTINE.
C
      IF(K7 .EQ. IREC12) GO TO 21
C
C         INITIALIZATION
C
      K = 0
      IA = 0
      IPRT = 0
      CI4WK1(1:4) = CBLANK(1:4)
C
C         INITIALIZE ARRAYS FOR PROCESSING OF EQUIVALENCED GROUPS FOR
C         ADDITIONAL COMMON BLOCKS
C
      DO 10 J = 1,20
      IADDR(J) = 0
      IF(J .LE. 7) JDIMSZ(J) = 0
10    CONTINUE
      DO 11 J = 1,100
      CEQNAM(J)(1:32) = CBLK52(1:32)
      CEQNAM(J)(1:8) = CBLANK(1:8)
 11   CONTINUE
C
C         WHEN JGRPKT IS LESS THAN 2, CHECK IF IREC12 IS EQUAL TO 2,
C         AND FORCE JGRPKT TO 2
C
C         DETERMINE IF ANY EQUIVALENCE GROUP HAS MORE THAN 20 VARIABLES
C
      IF(JGRPKT .GT. 1) THEN
         DO 12 J = 1,JGRPKT
         K1 = JEQGRP(1,J)
         READ (12,REC=K1) CTEMP(1:80)
         IF(JEQGRP(2,J) .GT. 20) THEN
            K4 = IABS(ITEMP(9))
            IREC0 = IREC0 + 1
            WRITE (0,110) K4,CTEMP(1:32)
         END IF
         IF(JEQGRP(2,J) .EQ. 1) THEN
            K4 = IABS(ITEMP(9)) - 128
            IREC0 = IREC0 + 1
            WRITE (0,104) K4
         END IF
 12      CONTINUE
      END IF
C
C         INITIALIZE COUNT OF THE NUMBER OF RECORDS IN CEQGRP. THIS
C         IS THE TOTAL NUMBER OF VARIABLES TO APPEAR IN THE OUTPUT
C         EQUIVALENCE LISTING
C
      K2 = 0
      L1 = LFALSE
      L2 = LFALSE
      MVSIZE = 0
C
C         SEARCH ALL EQUIVALENCE GROUPS ONE AT A TIME.
C
      DO 17 K = 1,JGRPKT
      K3 = JEQGRP(1,K)
      IF(K .EQ. JGRPKT) THEN
         K5 = IREC12
      ELSE
         K5 = JEQGRP(1,K) + JEQGRP(2,K) - 1
      END IF
      MASADR = 0
C
C         PROCESS A SPECIFIC EQUIVALENCE GROUP
C
      DO 16 K1 = K3,K5
C
C         READ A VARIABLE NAME BELONGING TO AN EQUIVALENCE GROUP
C
      READ (12,REC=K1) CTEMP(1:80)
C
C         SEARCH THE CURRENT COMMON BLOCK VARIABLE NAMES FOR A MATCH
C         WITH ONE OF THE EQUIVALENCE GROUP VARIABLE NAMES
C
      CALL TABSRH (COMPRT,I4,48,1,32,CTEMP,1,32,IRET2,500)
C
C         DETERMINE IF A COMMON BLOCK VARIABLE MATCHES ONE OF THE
C         EQUIVALENCED GROUP VARIABLES
C
      IF(IRET2 .GT. 0) THEN
C
C         INDICATE ONE OF THE EQUIVALENCED GROUP VARIABLES MATCHES ONE
C         OF THE COMMON BLOCK VARIABLES
C
         L1 = LTRUE
         L2 = LTRUE
C
C         SAVE THE MATCHED COMMON AND EQUIVALENCED VARIABLE UNIT 12
C         RECORD AND INDEX LOCATION IN COMPRT
C
         CMATCH(1:80) = CTEMP(1:80)
         IMATCH(9) = IMATCH(9) - 128
         MIDX = IRET2
C
C         DETERMINE THE INDEX VALUE WHERE THE MATCHED EQUIVALENCED
C         VARIABLE IS LOCATED IN ARRAY CNAME
C
         CALL TABSRH (CNAME,INAME,52,1,32,CMATCH,1,32,MRET,4000)
C
C         DETERMINE THE BASE ADDRESS OF THE EQUIVALENCE GROUP. THIS IS
C         THE ADDRESS OF THE VARIABLE MATCHING THE COMMON VARIABLE NAME.
C
         MASADR = ICOMPR(9,IRET2)
         IF(MVSIZE .LT. IENAME(13,MRET)) MVSIZE = IENAME(13,MRET)
C
C         SET THE VARIABLE DEFINED LENGTH AS AN INTEGER
C
         CWK7(1:7) = CNAME(MRET)(38:44)
         READ (CWK7,'(I4)') IEQLEN
C
C         DETERMINE IF THE MATCHING EQUIVALENCED VARIABLE IS DIMENSIONED
C
         IF(BTEST(IENAME(12,MRET),17)) THEN
C
C         WHEN NO SUBSCRIPT VALUE EXISTS FOR THE EQUIVALENCE VARIABLE
C         MATCHING A VARIABLE IN THE CURRENT COMMON BLOCK, VARIABLE
C         MASADR WILL CONTAIN THE BASE ADDRESS OF THE EQUIVALENCE
C         GROUP.
C
C         DETERMINE IF THE MATCHING EQUIVALENCE VARIABLE HAS ANY
C         SUBSCRIPT SPECIFICATIONS
C
            IF(ITEMP(10) .GT. 0) THEN
C
C         OBTAIN THE DIMENSION INFORMATION FOR THE MATCHED EQUIVALENCED
C         VARIABLE
C
               CALL TABSRH (CDIM,JDIM,104,1,32,CMATCH,1,32,IRET1,1000)
C
C         DETERMINE IF THE NUMBER OF SUBSCRIPTS FOR THE MATCHING
C         EQUIVALENCED VARIABLE EXCEEDS ITS DIMENSION SPECIFICATION
C
               IF(IMATCH(10) .GT. KDIM(10,IRET1)) THEN
                  K4 = IABS(IMATCH(10))
                  I2WK1 = KDIM(9,IRET1)
                  IREC0 = IREC0 + 1
                  WRITE (0,105) K4,CMATCH(1:I2WK1)
               END IF
C
C         SET THE LENGTH CHARACTERISTIC OF THE MATCHED EQUIVALENCED
C         VARIABLE
C
               CWK7(1:7) = CNAME(IRET2)(38:44)
               READ (CWK7,'(I4)') I4WK1
C
C         DETERMINE IF ONLY A SINGLE DIMENSION EXISTS FOR THIS
C         MATCHED EQUIVALENCED VARIABLE
C
               IF(ITEMP(10) .EQ. 1) THEN
C
C         COMPUTE THE ADDRESS IN COMMON FOR THIS EQUIVALENCE GROUP
C
C                 K8 = (ITEMP(12) - 1) * I4WK1 + ITEMP(11)
                  K8 = (ITEMP(12) - 1)
               ELSE
C
C         COMPUTE THE ADDRESS IN COMMON FOR THIS EQUIVALENCED GROUP
C         WHEN MORE THAN ONE SUBSCRIPT IS SPECIFIED FOR THE MATCHING
C         VARIABLE
C
C         CREATE TABLE OF THE DIMENSION SIZE FOR EACH SUBSCRIPT FOR
C         MATCHING VARIABLE
C
                  JDIMSZ(1) = KDIM(11,IRET1)
                  DO 13 J = 2,7
                  IF(J .GT. ITEMP(10)) THEN
                     JDIMSZ(J) = 0
                  ELSE
                     JDIMSZ(J) = JDIMSZ(J-1) * KDIM(J+10,IRET1)
                  END IF
 13               CONTINUE
C
C        SET LOOP TO COMPUTE THE EQUIVALENCE GROUP ADDRESS IN COMMON
C
                  K8 = ITEMP(12) -1
                  K6 = ITEMP(10)
                  DO 14 J = 2,K6
                  K8 = K8 + (ITEMP(J+11) - 1) * JDIMSZ(J-1)
 14               CONTINUE
C
C         DETERMINE IF ANY CHARACTER RANGE START VALUE EXISTS FOR THE
C         MATCHED EQUIVALENCED VARIABLE
C
                  IF(ITEMP(11) .GT. 0) K8 = K8 * IEQLEN + ITEMP(11)
C
C         COMPUTE THE COMMON ADDRESS FOR THE EQUIVALENCED GROUP
C
               END IF
               MASADR = MASADR + K8 * IEQLEN
            END IF
         ELSE
C
C         THE MATCHED VARIABLE IS NOT DIMENSIONED; DETERMINE IF ANY
C         CHARACTER ADJUSTMENT MUST BE MADE IN THE MASTER ADDRESS.
C
            IF(ITEMP(11) .GT. 0) MASADR = MASADR + ITEMP(11) - 1
         END IF
C
C         PROCESS THE VARIABLES THAT DO NOT MATCH A COMMON VARIABLE FOR
C         THIS EQUIVALENCE GROUP WHEN ONE OF THE EQUIVALENCED VARIABLES
C         DOES MATCH THE COMMON VARIABLE. THESE VARIABLES WILL APPEAR
C         IN THE OUTPUT LISTING.
C
         DO 15 J = K3,K5
         READ (12,REC=J) CTEMP(1:80)
C
C         DETERMINE IF THE VARIABLE JUST READ MATCHES A COMMON VARIABLE
C
         CALL TABSRH (COMPRT,I4,48,1,32,CTEMP,1,32,IRET4,500)
         IF(IRET4 .LT. 0) THEN
C
C         DETERMINE THE INDEX VALUE WHERE AN UNMATCHED VARIABLE IN THE
C         CURRENT EQUIVALENCE GROUP VARIABLE IS LOCATED IN ARRAY CNAME
C
            CALL TABSRH (CNAME,INAME,52,1,32,CTEMP,1,32,IRET3,4000)
C
C         PLACE ALL OTHER EQUIVALENCE VARIABLE NAMES' RECORDS FROM THIS
C         GROUP IN THE ARRAY OF VARIABLES TO APPEAR IN THE OUTPUT
C         LISTING. THE MATCHING VARIABLE NAME IS NOT IN THIS ARRAY.
C
            K2 = K2 + 1
            CEQNAM(K2)(1:32) = CNAME(IRET3)(1:32) ! PRINT VARIABLE NAME
            CEQNAM(K2)(33:40) = CNAME(IRET3)(37:44)    ! TYPE & LENGTH
            IEQNAM(11,K2) = MASADR                ! ADDRESS
C
C         SET THE LENGTH OF THE VARIABLE NAME AND CREATE CF112 TO WRITE
C         AN ERROR MESSAGE
C
            IF(BTEST(IENAME(12,IRET3),18) .AND. .NOT.L2) THEN
               IVLEN = IENAME(13,IRET3)
               WRITE (CI2WK1,'(I2)') IVLEN
               IF(IVLEN .GT. 9) THEN
                  CF112(27:28) = CI2WK1(1:2)
               ELSE
                  CF112(27:28) = CI2WK1(2:2)//CBLANK(1:1)
               END IF
               ITEMP(9) = IABS(ITEMP(9))
               WRITE (0,CF112) ITEMP(9),CTEMP(1:IVLEN)
               IREC0 = IREC0 + 1
            END IF
C
C         SET THE LENGTH OF THE LONGEST VARIABLE NAME
C
            IF(MVSIZE .LT. IENAME(13,IRET3)) MVSIZE = IENAME(13,IRET3)
C
C         INDICATE THE VARIABLE NAMES WITHIN AN EQUIVALENCE GROUP THAT
C         ARE MATCHED HAVE BIT 18 OF THE RECORD ON UNIT 12 SET TO
C         INDICATE THEY ARE ALREADY MATCHED. THIS SWITCH IS USED TO
C         DETECT IF THE SAME VARIABLE IS EQUIVALENCED TO A DIFFERENT
C         COMMON BLOCK.
C
            ITEMP(19) = IBSET(ITEMP(19),18)
            IENAME(12,IRET3) = IBSET(IENAME(12,IRET3),18)
            WRITE (12,REC=J) CTEMP(1:80)
         END IF
 15      CONTINUE
      END IF
 16   CONTINUE
C
C         THE CURRENT EQUIVALENCE GROUP MATCHING A VARIABLE IN THE
C         CURRENT COMMON BLOCK HAS BEEN PROCESSED. SET THE ADDRESS
C         FOR THE EQUIVALENCE GROUP THAT IS TO BE PRINTED FOR ALL
C         VARIABLES NOT MATCHING THE COMMON VARIABLE IN THE EQUIVALENCE
C         GROUP.
C
      IF(L2) THEN
         JEQGRP(3,K) = MASADR
         L2 = LFALSE
      END IF
 17   CONTINUE
C
C         WHEN THE ABOVE SERIES OF DO LOOPS ARE FINISHED, ALL
C         EQUIVALENCE VARIABLES DEFINED FOR THE CURRENT ROUTINE ARE NOW
C         PROCESSED, AND ANY THAT DO NOT MATCH IN THE CURRENT COMMON
C         BLOCK ARE READY TO BE PRINTED. K2 CONTAINS THE NUMBER
C         OF VARIABLES THAT ARE TO BE PRINTED IN THE LISTING.
C
C         DETERMINE IF ANY VARIABLE IN ANY OF THE EQUIVALENCE GROUPS
C         MATCHES ANY VARIABLE IN THE CURRENT COMMON BLOCK.
C
      IF(.NOT.L1) GO TO 21
C
C         DETERMINE IF THE EQUIVALENCED VARIABLE LOCATION EXCEEDS THE
C         DEFINED SIZE OF THE COMMON BLOCK
C
      IF(MASADR .GT. MADDR) THEN
         IREC0 = IREC0 + 2
         I2 = IENAME(13,MRET)
         WRITE (CI4WK1,'(I4)') I2
         IF(I2 .GT. 9) THEN
            CF111(52:53) = CI4WK1(3:4)
         ELSE
            CF111(52:53) = CI4WK1(4:4)//CBLANK(1:1)
         END IF
         WRITE (0,CF111) IMATCH(9),CNAME(IRET3)(1:I2),IADDR(K1),
     1                   MADDR
      END IF
C
C         DETERMINE IF EQUIVALENCE DATA IS TO BE PRINTED
C
      IF(K2 .EQ. 0) GO TO 21
C
C         DETERMINE IF ONLY ONE VARIABLE IS IN CEQNAM
C
      IF(K2 .EQ. 1) GO TO 19
C
C         DETERMINE IF ONLY TWO VARIABLES ARE IN CEQNAM
C
      IF(K2 .EQ. 2) THEN
         IF(CEQNAM(1)(1:32) .GT. CEQNAM(2)(1:32)) THEN
            CEQNAM(3)(1:44) = CEQNAM(1)(1:44)
            CEQNAM(1)(1:44) = CEQNAM(2)(1:44)
            CEQNAM(2)(1:44) = CEQNAM(3)(1:44)
            GO TO 19
         END IF
      END IF
C
C         THE RELATIVE ADDRESS FOR ALL EQUIVALENCED VARIABLES ARE NOW
C         COMPLETE. SORT TO SORT THE EQUIVALENCED VARIABLE NAMES INTO
C         ASCENDING ORDER.
C
      DO 18 K1 = 1,5
      ISTART(K1) = 0
      IFLEN(K1) = 0
      LASC(K1) = LFALSE
 18   CTYPE(K1) = CBLANK(1:1)
      ISTART(1) = 1
      IFLEN(1) = 32
      CTYPE(1) = CCC
C
C         SORT THE EQUIVALENCED VARIABLE NAMES INTO ASCENDING ORDER
C
      CALL MSORT (CEQNAM,K2,44,100,1)
C
C         THE RELATIVE ADDRESS FOR ALL EQUIVALENCED VARIABLES ARE NOW
C         COMPLETE. WRITE OUT THE EQUIVALENCE TABLE FOR THE CURRENT
C         COMMON BLOCK.
C
 19   CALL NUPAGE (4)
      IF(ILINE .GE. NLINES) THEN
         WRITE (6,CFMTH) IPAGE
         IPAGE = IPAGE + 1
      END IF
      WRITE (6,100) C0
      ILINE = ILINE + 2
C
C         SELECT THE FORMAT TO BE USED FOR WRITING THE OUTPUT DATA FOR
C         THE EQUIVALENCED VARIABLES FOR THE COMMON BLOCK, SO THAT THE
C         LARGEST VARIABLE NAME MAY BE ACCOMMODATED.
C
      IF(MVSIZE .LE. 10) THEN
         M = 10
         N = 4
         ASSIGN 101 TO IFMT
         ASSIGN 107 TO JFMT
      ELSE IF(MVSIZE .GT. 10 .AND. MVSIZE .LE. 20) THEN
         M = 20
         N = 3
         ASSIGN 102 TO IFMT
         ASSIGN 108 TO JFMT
      ELSE IF(MVSIZE .GT. 20) THEN
         M = 32
         N = 2
         ASSIGN 103 TO IFMT
         ASSIGN 109 TO JFMT
      END IF
C
C         WRITE THE EQUIVALENCED GROUP VARIABLE NAMES TABLE FOR THE
C         CURRENT COMMON BLOCK
C
      IF(K2 .LE. N) THEN
C
C         A SINGLE LINE OF PRINT CONTAINS THE ENTIRE EQUIVALENCED GROUP
C
         ILINE = ILINE + 5
         IF(ILINE .GE. NLINES .OR. ILINE + 4 .GT. NLINES) THEN
            ILINE = 4
            CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
         END IF
         WRITE (6,IFMT) C0
         WRITE (6,JFMT) CBLANK(1:1),(CEQNAM(K1)(1:M),
     1   CEQNAM(K1)(33:33),CEQNAM(K1)(34:40),IEQNAM(11,K1),K1 = 1,K2)
      ELSE
C
C         MULTIPLE LINES OF PRINT ARE NECESSARY TO LIST ALL THE VARIABLE
C         NAMES IN THE CURRENT EQUIVALENCED GROUP
C
C         COMPUTE THE NUMBER OF FULL LINES OF PRINT
C
         IC = K2/N
C
C         CREATE THE FULL OUTPUT LINE OF PRINT
C
         DO 20 K1 = 1,IC
         IA = N * (K1 - 1) + 1
         IB = IA + N - 1
         ILINE = ILINE + 1
         IF(ILINE .GE. NLINES .OR. ILINE + 4 .GT. NLINES) THEN
            ILINE = 4
            CFMTH(3:3) = C1(1:1)
            IPAGE = IPAGE + 1
            WRITE (6,CFMTH) IPAGE
            WRITE (6,IFMT) C0
         END IF
         WRITE (6,JFMT) CBLANK(1:1),(CEQNAM(J)(1:M),
     1   CEQNAM(J)(33:33),CEQNAM(J)(34:40),IEQNAM(11,J),J = IA,IB)
 20      CONTINUE
C
C         DETERMINE IF A PARTIAL FINAL LINE MUST BE PRINTED TO LIST
C         ALL THE EQUIVALENCED VARIABLES WITHIN THE GROUP
C
         IF(K2 - IC * N .GT. 0) THEN
C
C         PRINT THE FINAL LINE LISTING THE EQUIVALENCED VARIABLES WITHIN
C         GROUP
C
            ILINE = ILINE + 1
            IF(ILINE .GE. NLINES .OR. ILINE + 4 .GT. NLINES) THEN
               ILINE = 4
               CFMTH(3:3) = C1(1:1)
               IPAGE = IPAGE + 1
               WRITE (6,CFMTH) IPAGE
               WRITE (6,IFMT) C0
            END IF
            IA = IB + 1
            IB = K2
            WRITE (6,JFMT) CBLANK(1:1),(CEQNAM(J)(1:M),
     1      CEQNAM(J)(33:33),CEQNAM(J)(34:40),IEQNAM(11,J),J = IA,IB)
         END IF
      END IF
C
C         ROUTINE EXIT
C
 21   RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C        THIS SUBROUTINE WILL DETERMINE IF THE HEADER IS TO START A NEW
C        PAGE OR NOT.
C
C     MEANING OF THE VARIABLES
C
C         CFMTH  - CHARACTER VARIABLE, FORMAT STATEMENT TO PRINT THE
C                  HEADER OF EACH PAGE OF THE OUTPUT LISTING
C         ILINE  - PAGE LINE COUNT
C         ISTEP  - THE NUMBER OF LINES TO INCREASE ILINE AFTER WRITING
C                  THE HEADER
C         NLINES - COUNT OF THE NUMBER OF LINES PRINTED PER PAGE
C
C     *****************************************************************
C
      SUBROUTINE NUPAGE (ISTEP)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION ISRECL(20)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*111   CFMTH
C     CHARACTER*44    CUNION
      CHARACTER*32    CPGNME
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CTYPE
      INTEGER*2       ISRECL
      LOGICAL*1       LASC
C
C         COMMON STATEMENTS
C
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (NLINE,ILINE)
C
C         SAVE STATEMENT
C
      SAVE
C
C         SET THE NEW PAGE OR SPACE CHARACTER IN THE CFMTH HEADER FORMAT
C
      IF(ILINE .GE. NLINES .OR. ILINE + ISTEP .GE. NLINES) THEN
         CFMTH(3:3) = C1(1:1)
         ILINE = ISTEP
         IPAGE = IPAGE + 1
      ELSE
         CFMTH(3:3) = C0(1:1)
         ILINE = ILINE + ISTEP
      END IF
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBROUTINE CHECKS ALL COMMON BLOCKS WITHIN AN ENTIRE
C         PROGRAM FOR LENGTH CONSISTANCY.
C
C     MEANING OF THE VARIABLES
C
C         CAPOS  - CHARACTER VARIABLE, THE CHARACTER: '
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CGCOMM - CHARACTER VARIABLE, THE RECORD OF A COMMON BLOCK FOR
C                  COMMON GLOBAL ANALYSIS. EQUIVALENCED TO IGCOMM.
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1; USED TO
C                  CREATE AXX TYPE FIELDS
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CTYPE  - CHARACTER VARIABLE, THE TYPE CODE FOR A VARIABLE,
C                  USED TO SORT VARIABLE NAMES
C         CWK76  - CHARACTER VARIABLE, INPUT READ BUFFER FOR UNIT 1;
C                  EQUIVALENCED TO IWK76.
C         CWK121 - CHARACTER VARIABLE, BUFFER TO WRITE ERROR MESSAGES
C         CWK7   - CHARACTER VARIABLE, BUFFER TO CREATE COMMON BLOCK
C                  LENGTH IN TEXT FORM FOR PRINTING
C         IA     - INDEX VALUE TO CREATE THE FORMAT STATEMENT IN CWK121
C         IB     - INDEX VALUE TO CREATE THE FORMAT STATEMENT IN CWK121
C         IC     - INDEX VALUE TO PLACE THE LENGTH OF THE COMMON BLOCK
C                  END LOCATION IN THE DIAGNOSTIC MESSAGE
C         ID     - INDEX VALUE TO PLACE THE LENGTH OF THE COMMON BLOCK
C                  START LOCATION IN THE DIAGNOSTIC MESSAGE
C         IFLEN  - LENGTH OF EACH FIELD TO BE SORTED IN THE SORT
C                  ROUTINES
C         IGCOMM - THE RECORD OF A COMMON BLOCK FOR COMMON GLOBAL
C                  ANALYSIS. EQUIVALENCED TO CGCOMM.
C         IREC0  - COUNT OF THE NUMBER OF RECORDS ON UNIT 0
C         IREC1  - COUNT OF THE NUMBER OF RECORDS ON UNIT 1
C         IRECL  - RECORD LENGTH FOR A SORT
C         ISTART - THE START LOCATION OF A FIELD IN A RECORD TO BE
C                  SORTED
C         IWK76  - INPUT READ BUFFER FOR UNIT 1; EQUIVALENCED TO CWK76.
C         I2WK1  - EQUIVALENCED TO CI2WK1
C         J      - SUBSCRIPT VARIABLE
C         JA     - LENGTH OF THE INITIAL RECORD BLOCK NAME FOR A GIVEN
C                  BLOCK
C         JB     - LENGTH OF OTHER THAN THE INITIAL BLOCK NAME IN UNIT 1
C                  RECORDS
C         JC     - COMPUTATION AREA FOR INDEX VALUES
C         JUNIT  - INPUT UNIT FOR A SORT
C         KA     - SUBSCRIPT VALUE FOR THE START LOCATION TO FILL CBUF
C                  WITH BLANKS
C         KB     - SUBSCRIPT VALUE FOR THE END LOCATION TO FILL CBUF
C                  WITH BLANKS
C         KC     - SUBSCRIPT VARIABLE FOR THE DO LOOP TO FILL CBUF WITH
C                  BLANKS
C         NREC   - NUMBER OF RECORDS ON JUNIT
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0 - MESSAGES
C         1 - THE LIST OF ALL COMMON BLOCKS AND THEIR LENGTH IN EVERY
C             PROGRAM MODULE WITHIN AN ENTIRE PROGRAM
C             RECORD STRUCTURE
C             COLUMN TYPE WORD DESCRIPTION
C             1 - 32 C*32   8  ROUTINE NAME WHERE THE COMMON BLOCK
C                              OCCURS
C            33 - 64 C*32  16  THE COMMON BLOCK NAME
C         #  65 - 68 I*4   17  LENGTH OF VARIABLE NAME IN COLS 1-32
C         #  69 - 72 I*4   18  LENGTH OF VARIABLE NAME IN COLS 33-64
C         #  73 - 76 I*4   19  THE LENGTH OF THE COMMON BLOCK
C
C             NOTE: FIELDS MARKED WITH # HAVE 128 ADDED TO THEIR VALUE
C
C         6 - THE LISTING FILE TO BE PRINTED
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         DSORT
C
C     ******************************************************************
C
      SUBROUTINE COMCHK
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CSREC(20), IGCOMM(19), ISRECL(20), IWK76(19)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*121   CWK121
      CHARACTER*111   CFMTH
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*76    CGCOMM, CWK76
      CHARACTER*68    CWK68
      CHARACTER*52    CBLK52, CWORK
      CHARACTER*32    CPGNME, CWK32
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*7     CWK7
      CHARACTER*4     CI4WK1
      CHARACTER*2     CI2WK1, ISRECL
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CTYPE
      INTEGER*2       I2WK1
      LOGICAL*1       LASC
      REAL*8          FP
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,CI2WK1), (CGCOMM(1:1),IGCOMM(1)),
     1(CWK76(1:1),IWK76(1)), (CI4WK1,I4WK1), (CWK8(2:2),CWK7)
C
C         SAVE STATEMENT
C
      SAVE
C
C         INITIALIZATION
C
      CWK7(1:7) = CBLANK(1:7)
      CWK121(1:52) = CBLK52(1:52)
      CWK121(53:104) = CBLK52(1:52)
      CWK121(105:121) = CBLK52(1:17)
C
C         END FILE AND REWIND UNITS 1; RESET RECORD COUNTER FOR UNIT 0
C         TO ZERO FOR GLOBAL ERROR MESSAGES.
C
      IREC0 = 0
C
C         WHEN ONLY A SINGLE RECORD EXISTS ON UNIT 1, EXIT THE ROUTINE.
C         THERE IS NOTHING TO ANALYZE.
C
      IF(IREC1 .EQ. 1) GO TO 13
C
C         SET SORT PARAMETERS FOR THE VARIABLE NAMES REFERENCED WHICH
C         ARE LOCATED ON UNIT 1
C
      JUNIT = 1
      IRECL = 76
      NREC = IREC1
      ISTART(1) = 33
      IFLEN(1) = 32
      CTYPE(1) = CCC
      ISTART(2) = 1
      IFLEN(2) = 32
      CTYPE(2) = CCC
C
C         SORT THE COMMON BLOCK NAMES ON FORTRAN UNIT 1 INTO ASCENDING
C         SEQUENCE
C
      CALL DSORT (JUNIT,IRECL,NREC,2)
C
C         READ THE INITIAL RECORD ON UNIT 1
C
      READ(1,REC=1) CGCOMM(1:76)
C
C         CORRECT LENGTHS
C
      IGCOMM(17) = IGCOMM(17) - 128
      IGCOMM(18) = IGCOMM(18) - 128
      IGCOMM(19) = IGCOMM(19) - 128
C
C         USING THE INITIAL RECORD FOR EACH COMMON BLOCK NAME, CHECK
C         THE DEFINED LENGTH OF ALL OTHER OCCURRENCES OF THE SAME
C         COMMON BLOCK NAME.
C
      DO 12 I = 2,IREC1
C
C         INITIALIZATION FOR A COMMON BLOCK NAME
C
      READ (1,REC=I,END=13) CWK76(1:76)
C
C         CORRECT LENGTHS
C
      IWK76(17) = IWK76(17) - 128
      IWK76(18) = IWK76(18) - 128
      IWK76(19) = IWK76(19) - 128
C
C         DETERMINE IF THE LENGTH OF THE COMMON BLOCK NAMES MATCH
C
      IF(IGCOMM(18) .NE. IWK76(18)) THEN
         CGCOMM(1:76) = CWK76(1:76)
         GO TO 12
      END IF
C
C         DETERMINE IF THE COMMON BLOCK NAMES MATCH AFTER THE NAME'S
C         LENGTH MATCHES
C
      JA = IGCOMM(18) + 32
      JB = IWK76(18) + 32
      IF(CGCOMM(33:JA) .NE. CWK76(33:JB)) THEN
         CGCOMM(1:76) = CWK76(1:76)
         GO TO 12
      ELSE
C
C         THE COMMON BLOCK NAMES MATCH; DETERMINE IF THE COMMON BLOCK
C         LENGTHS MATCH
C
         IF(IGCOMM(19) .EQ. IWK76(19)) GO TO 12
C        IF(IGCOMM(19) .EQ. IWK76(19)) GO TO 12
C
C         THE COMMON BLOCK LENGTHS DO NOT MATCH, WRITE A DIAGNOSTIC
C
         IA = 19
         CWK121(1:IA) = '(1X,''COMMON BLOCK /'
         WRITE (CI2WK1,'(I2)') IWK76(18)
         IA = IA + 1
         JB = IWK76(18)
         JC = IA + JB + 12
         CWK121(IA:JC) = CWK76(33:33+JB-1)//'/ IN ROUTINE '
         IA = JC + 1
         IAA = IA
         JB = IWK76(17)
         JC = IA + JB + 17
         CWK121(IA:JC) = CWK76(1:JB)//' HAS A LENGTH OF '
         IA = JC + 1
         CWK7(1:7) = CBLANK(1:7)
         WRITE (CWK7,'(I7)') IWK76(19)
         II = 0
         DO 10 J = 1,7
         IF(CWK7(J:J) .NE. CBLANK(1:1))  II = II + 1
 10      CONTINUE
         IC = 7
         ID = 8 - II
         JC = IA + II + 7
         IA = IA - 1
         CWK121(IA:JC) = CWK7(ID:IC)//', BUT'//CAPOS(1:1)//CRPAR(1:1)
         WRITE (0,CWK121)
         IREC0 = IREC0 + 1
C
C         CREATE THE SECOND PORTION OF THE MESSAGE
C
         IA = IAA
         CWK7(1:7) = CBLANK(1:7)
         CWK121(6:18) = CBLK52(1:11)
         CWK121(IA:121) = CBLK52(1:52)//CBLK52(1:52)
         IA = IWK76(18) + 25
         JB = IGCOMM(17)
         JC = IA + JB + 17
         CWK121(IA:JC) = CGCOMM(1:JB)//' HAS A LENGTH OF '
         IA = JC - 1
         CWK7(1:7) = CBLANK(1:7)
         WRITE (CWK7,'(I7)') IGCOMM(19)
         II = 0
         DO 11 J = 1,7
         IF(CWK7(J:J) .NE. CBLANK(1:1))  II = II + 1
 11      CONTINUE
         IC = 7
         ID = IC - II
         JC = IA + ID + 3
         CWK121(IA:JC+4) = CWK7(ID:IC)//CAPOS(1:1)//CRPAR(1:1)
         WRITE (0,CWK121)
         IREC0 = IREC0 + 1
      END IF
 12   CONTINUE
C
C         CLOSE THE COMMON LENGTH FILE
C
      CLOSE (UNIT=1,STATUS='DELETE')
C
C         ROUTINE EXIT
C
 13   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS SUBPROGRAM DETERMINES IF A SUBPROGRAM ARGUMENT IS OF THE
C         CORRECT TYPE AND LENGTH. NO VERIFICATION IS MADE OF ANY
C         FORTRAN INSTRINSIC FUNCTIONS, BUT FUNCTIONS FROM LIBRARIES
C         OTHER THAN THE STANDARD INTRINSIC FUNCTIONS WILL CAUSE A
C         MESSAGE TO BE ISSUED.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBUF   - CHARACTER VARIABLE, THE WORK AREA WHERE THE OUTPUT
C                  DIAGNOSTIC MESSAGE FORMAT STATEMENT IS BUILT
C         CCARG  - CHARACTER VARIABLE, ARRAY OF ARGUMENTS DEFINITIONS
C                  FOR CALLED SUBPROGRAMS; EQUIVALENCED TO CUSE.
C         CDARG  - CHARACTER VARIABLE, ARRAY OF ARGUMENTS DEFINITIONS
C                  FOR DEFINED SUBPROGRAMS, EQUIVALENCED TO CDEF.
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO READ THE
C                  DEFINITION RECORD OF A SUBPROGRAM; LENGTH IS
C                  1496 CHARACTERS (UNIT 3)
C         CEXTNL - CHARACTER VARIABLE, TABLE OF ALL EXTERNAL STATEMENT
C                  NAMES IN A ROUTINE BEING ANALYZED. THIS IS A GLOBAL
C                  TABLE CONTAINING ALL SUBPROGRAM NAMES DEFINED IN
C                  ANY ROUTINE IN THE CURRENT PROGRAM BEING PROCESSED.
C         CNAME  - CHARACTER VARIABLE, ARRAY OF ALL DEFINED SUBPROGRAM
C                  NAMES OCCURING IN THE PROGRAM. EQUIVALENCED TO IENAME
C                  TOTAL LENGTH IS 52 CHARACTERS PER VARIABLE.
C                  RECORD STRUCTURE:
C                   COLS TYPE WORD CONTENT
C                    1-32 A*32   8 VARIABLE NAME
C                   33-36 I*4    9 ISN VALUE; NEGATIVE IF FROM AN
C                                  INCLUDE FILE TO PREVENT ITS INCLUSION
C                                  INTO THE LISTING OF VARIABLE NAMES IN
C                                  ROUTINE PRINTV
C                   37-44 A*8   11 DATA TYPE & LENGTH
C                   45-48 I*4   12 BIT SWITCHES
C                   49-52 I*4   13 LENGTH OF THE VARIABLE NAME IN COLS
C                                  1 - 32
C                  COLUMN 37 CONTAINS THE FOLLOWING CODES TO INDICATE
C                  DATA TYPE
C
C                  CODE      DESCRIPTION
C                    A       BYTE
C                    B       COMPLEX
C                    C       CHARACTER
C                    D       DOUBLE PRECISION, REAL*8
C                    E       DOUBLE COMPLEX
C                    I       INTEGER
C                    L       LOGICAL
C                    R       REAL*4
C         CTYPE  - CHARACTER VARIABLE, CONTAINS THE DATA TYPE CODE.
C                  VALUES ARE:
C                   A - BYTE
C                   B - SINGLE PRECISION COMPLEX
C                   C - CHARACTER
C                   D - REAL*8, DOUBLE PRECISION FLOATING
C                   E - DOUBLE PRECISION COMPLEX
C                   I - INTEGER
C                   L - LOGICAL (NOT PROCESSED)
C                   R - REAL*4
C         CUSE   - CHARACTER VARIABLE, WORK BUFFER TO READ THE
C                  CALL STATEMENT RECORD FOR SUBPROGRAMS; LENGTH IS
C                  1532 CHARACTERS (UNIT 10)
C         CUSE1  - CHARACTER VARIABLE, THE FIRST SEGMENT OF CUSE.
C                  RECORD STRUCTURE
C
C         I      - SUBSCRIPT VARIABLE, CHOOSES AN ARGUMENT FROM THE
C                  ARGUMENT LIST, ALSO USED AS THE RESULT OF BIT SWITCH
C                  TESTING
C         IA     - COMPUTED INDEX STARTING VALUE OF A FIELD
C         IB     - COUNT OF THE NUMBER OF DEFINED SUBPROGRAM NAMES IN
C                  CNAME
C         ICBSW  - 32 BIT SWITCHES FOR THE DEFINED SUBPROGRAMS,
C                  EQUIVALENCED TO CUSE(45:48)
C         ICNARG - THE NUMBER OF ARGUMENTS IN A CALLED SUBPROGRAM
C         ICVLEN - THE LENGTH OF THE CALLED SUBPROGRAM NAME
C         IDBSW  - 32 BIT SWITCHES FOR THE DEFINED SUBPROGRAMS,
C                  EQUIVALENCED TO CDEF(45:48)
C         IDNARG - THE NUMBER OF ARGUMENTS FOR A SUBPROGRAM DEFINITION
C         IDVLEN - THE LENGTH OF THE DEFINED SUBPROGRAM NAME
C         IENAME - THE ARRAY OF VARIABLE NAMES; EQUIVALENCED TO CNAME.
C                  USED TO PERFORM LOGICAL OPERATIONS ON BIT SWITCHES
C                  IN CNAME. EQUIVALENCED TO CNAME.
C         IEND   - THE LAST CHARACTER LOCATION OF A MESSAGE ON UNIT 0
C         IEND0  - END OF FILE INDICATOR (= -1) FOR UNIT 0
C         IEND10 - END OF FILE INDICATOR (= -1) FOR UNIT 10
C         IEXTNL - COUNT OF THE NUMBER ENTRIES IN TABLE CEXTNL
C         IFLEN  - THE LENGTH OF A FIELD WITHIN THE RECORD TO BE SORTED;
C                  THIS VALUE MUST BE IN BYTES
C         INDEX  - ARRAY OF THE RECORD LOCATION ON UNIT 3 OF A DEFINED
C                  SUBPROGRAM
C         INUM   - WORK AREA FOR ARGUMENT PROCESSING
C         IQVLEN - THE LENGTH OF THE CALLING SUBPROGRAM NAME
C         IRECL  - THE LENGTH OF THE RECORDS IN THE DISK FILE TO BE
C                  SORTED
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IREC3  - RECORD COUNT FOR UNIT 3
C         IREC1O - RECORD COUNT FOR UNIT 10
C         IRET   - RETURN CODE FROM TABSRH PROVIDING THE RECORD INDEX
C                  LOCATION OF THE RECORD ON UNIT 3 CONTAINING THE
C                  DEFINED SUPROGRAM DATA. IRET IS A POSITIVE INTEGER
C                  IF THE SUBPROGRAM EXISTS; IT IS SET TO A NEGATIVE
C                  INTEGER VALUE WHEN IT DOES NOT EXIST.
C         IRET1  - RETURN CODE FROM TABSRH PROVIDING THE RECORD INDEX
C                  LOCATION OF THE RECORD ON UNIT 3 CONTAINING THE
C                  DEFINED SUPROGRAM DATA. IRET IS A POSITIVE INTEGER
C                  IF THE SUBPROGRAM EXISTS; IT IS SET TO A NEGATIVE
C                  INTEGER VALUE WHEN IT DOES NOT EXIST.
C         ISN    - WORK AREA FOR PRINTING THE ISN AFTER SUBTRACTING 128
C         ISND   - ISN OF THE DEFINED SUBPROGRAM
C         ISNU   - ISN OF THE CALLED SUBPROGRAM, EQUIVALENCED TO CUSE
C         ISTART - THE START LOCATION OF A FIELD WITHIN THE RECORD TO
C                  BE SORTED; THIS VALUE MUST BE IN BYTES
C         I4WK1  - WORK AREA
C         I4WK2  - WORK AREA
C         J      - SUBSCRIPT VARIABLE
C         JUNIT  - THE INPUT UNIT CONTAINING THE RECORDS TO BE SORTED
C         J17    - RECORD LOCATION INDEX TO READ UNIT 10
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         L1     - LOGICAL VARIABLE, USED TO TEST BIT 18 IN CNAME
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN CALLED SUBPROGRAMS'
C                  UNIT 10 END OF FILE EXISTS, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN A SUBPROGRAM NAME
C                  HAS BEEN CALLED BUT IS NOT DEFINED, SET FALSE
C                  OTHERWISE
C         NREC   - THE NUMBER OF RECORDS IN THE FILE ON JUNIT
C         NARG   - NUMBER OF ARGUMENTS FOR THE DO LOOP PROCESSING
C                  INDIVIDUAL AREUMENTS
C
C     COMMENTS
C
C         FUNCTIONS AND SUBROUTINES FROM PRIVATE LIBRARIES WILL CAUSE
C         MESSAGES THAT THE ROUTINE IS NOT DEFINED.
C
C         EACH CALLED SUBPROGRAM ARGUMENT MAY OF A PARTICULAR TYPE. SOME
C         ARGUMENT TYPES ARE NOT VARIABLES. THESE TYPE OF ARGUMENTS MUST
C         HAVE MATCHING TYPES OF THE DEFINITION SUBPROGRAM ARGUMENTS.
C         THEY ARE REPRESENTED BY SYNTHETIC VARIABLES GENERATED WHERE
C         APPROPRIATE BY SEVERAL ROUTINES. THESE SYNTHETIC VARIABLE
C         NAMES ARE:
C
C            C##EX    - A LOGICAL OR MATHEMATICAL EXPRESSION
C            C##LIT   - A SINGLE LITERAL NOT PART OF A CONCANTINATION
C                       OF CHARACTER OR LITERALS
C            C##LOG   - A LOGICAL CONSTATNT VALUE
C            C##NUM   - A NUMERICAL VALUE
C            C##STM   - A RETURN STATEMENT NUMBER
C            C##nnn   - A LITERAL WHERE nnn IS A NUMBER (USED FOR
C                       CHARACTER EXPRESSIONS)
C
C         SINCE ALL PROCESSING FOR THE CURRENT PROGRAM IS COMPLETE WHEN
C         THIS SUBPROGRAM IS EXECUTED, VARIABLE CNAME NO LONGER CONTAINS
C         ANY MEANINGFUL DATA. THIS ARRAY IS USED TO STORE ALL THE
C         DEFINED SUBPROGRAM NAMES FROM UNIT 3 WHICH CREATES A TABLE OF
C         DEFINED SUBPROGRAM NAMES OCCURRING IN THE PROGRAM. SUBROUTINE
C         TABSRH IS USED TO DETERMINE THE RECORD NUMBER OF A PARTICULAR
C         DEFINED SUBPROGAM ON UNIT 3 TO ACCESS THE DATA FOR THE
C         SUBPROGRAM.
C
C         RECORD STRUCTURES FOR UNITS 3 AND 10
C
C         UNIT 3
C
C         RECORD STRUCTURE OF THE INPUT SUBPROGRAM DEFINITIONS FILE.
C         THE RECORD CONTAINS SUBROUTINE, ENTRY, AND FUNCTION
C         DEFINITIONS OF THE PROGRAM BEING PROCESSED. IT DOES NOT
C         CONTAIN THE CALLED SUBPROGRAM RECORDS, NOR DOES IT CONTAIN
C         ANY INTRINSIC FUNCTIONS FROM THE FORTRAN LIBRARY.
C
C         SECTION 1:
C
C         DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C         COLUMN       TYPE &
C         NUMBER  WORD LENGTH  DESCRIPTION
C
C         1 - 32    8  C*32  THE SUBPROGRAM NAME
C        33 - 36    9  I*4   ISN OF THE SUBPROGRAM STATEMENT
C        37            C*1   SUBPROGRAM NAME DATA TYPE
C        38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C        45 - 48   12  C*4   32 BIT SWITCHES FOR THE SUBPROGRAM NAME
C                            ATTRIBUTES. IF BIT IS ZERO, SWITCH IS OFF;
C                            IF BIT IS ONE, SWITCH IS ON.
C        49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE SUBPROGAM NAME
C        53 - 56   14  I*4   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C
C        NOTE: BIT 18 OF THE BIT SWITCHES WORD IN COLUMNS 45-48 IS USED
C              TO INDICATE A DEFINED SUBPORGRAM HAS BEEN CALLED FROM
C              SOME WHERE WITHIN THE PROGRAM. SET ON WHEN REFERENCED IN
C              A CALL STATEMENT; SET OFF OTHERWISE.
C
C         SECTION 2:
C
C         THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS REPEATED
C         FOR EACH ARGUMENT IN A SUBPROGRAM STATEMENT UP TO A MAXIMUM OF
C         30 ARGUMENTS. SUBSCRIPTS MAY NOT BE USED IN SUBPROGRAM
C         STATEMENTS, SINCE ARGUMENTS ARE ALL DUMMY VARIABLES.
C
C         COLUMN       FIELD
C         NUMBER  WORD TYPE   DESCRIPTION
C
C         1 - 32    8  C*32  ARGUMENT VARIABLE NAME
C        33            C*1   ARGUMENT VARIABLE DATA TYPE
C        34 - 40   10  C*7   ARGUMENT VARIABLE DATA TYPE LENGTH
C        41 - 44   11  I*4   32 BIT SWITCHES FOR THE ARGUMENT VARIABLE
C                            NAME ATTRIBUTES. IF BIT IS ZERO, SWITCH IS
C                            OFF; IF BIT IS ONE, SWITCH IS ON.
C        45 - 48   12  I*4   NUMBER OF CHARACTERS IN THE ARGUMENT
C                            VARIABLE NAME
C
C         TOTAL RECORD LENGTH IS 1496 CHARACTERS
C
C         UNIT 10
C
C         RECORD STRUCTURE OF THE INPUT SUBPROGRAM ARGUMENT LIST IN A
C         CALL STATEMENT
C
C         SECTION 1:
C
C         DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C         COLUMN  WORD TYPE &
C         NUMBER       LENGTH  DESCRIPTION
C
C         1 - 32    8  C*32  CALLED SUBPROGRAM NAME
C        33 - 36    9  I*4   ISN OF THE CALL STATEMENT
C        37            C*1   SUBPROGRAM NAME DATA TYPE
C        38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C        45 - 48   12  I*4   32 BIT SWITCHES FOR THE SUBPROGRAM NAME
C                            ATTRIBUTES. IF BIT IS ZERO, SWITCH IS OFF;
C                            IF BIT IS ONE, SWITCH IS ON.
C        49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE CALLED
C                            SUBPROGRAM NAME IN COLS 1- 32
C        53 - 84   21  C*32  ROUTINE NAME WHERE THE CALL STATEMENT
C                            OCCURS
C        85 - 88   22  I*4   NUMBER OF CHARACTERS IN THE VARIABLE NAME
C                            IN COLUMNS 53 - 84.
C        89 - 92   23  I*4   NUMBER OF ARGUMENTS FOR THIS CALL STATEMENT
C
C         SECTION 2:
C
C         THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS REPEATED
C         FOR EACH ARGUMENT IN A CALL STATEMENT UP TO A MAXIMUM OF 30
C         ARGUMENTS. SUBSCRIPTS OF ARGUMENTS ARE NOT COUNTED AND ARE
C         NOT PROCESSED.
C
C         COLUMN WORD  FIELD  DESCRIPTION
C         NUMBER       TYPE
C
C         1 - 32   8   C*32  ARGUMENT VARIABLE NAME
C        33            C*1   ARGUMENT VARIABLE DATA TYPE
C        34 - 40  10   C*7   ARGUMENT VARIABLE DATA TYPE LENGTH
C        41 - 44  11   C*4   BIT SWITCHES FOR THE ARGUMENT VARIABLE
C                            NAME ATTRIBUTES. IF BIT IS ZERO, SWITCH IS
C                            OFF; IF BIT IS ONE, SWITCH IS ON.
C        45 - 48  12   I*4   NUMBER OF CHARACTERS IN THE ARGUMENT VARIABLE
C                            NAME
C
C         THE TOTAL RECORD LENGTH IS 1532 CHARACTERS
C
C         ONE OF THE FOLLOWING CODES DESCRIBES THE VARIABLE TYPE
C
C         CODE      DESCRIPTION
C
C           B       COMPLEX
C           C       CHARACTER
C           D       DOUBLE PRECISION, REAL*8
C           E       DOUBLE COMPLEX
C           I       INTEGER
C           L       LOGICAL
C           R       REAL*4
C
C         BIT SWITCHES USED TO INDICATE A CONDITION EXISTS OR A
C         PARTICULAR USAGE OF THE VARIABLE WHEN SET TO 1, ON.
C
C     CHAR &
C        BIT  HEX  PRINT
C     NUMBER VALUE CODE  DESCRIPTION
C
C     45  0   1        NOT USED
C         1   2    C   THE VARIABLE IS IN A COMMON BLOCK
C         2   4    R   THE VARIABLE IS IN A RECORD DEFINITION
C         3   8    E   THE VARIABLE IS IN AN EQUIVALENCE DEFINITION
C         4   1    N   THE VARIABLE IS IN A NAMELIST DEFINITION
C         5   2    U   THE VARIABLE IS IN A UNION DEFINITION
C         6   4    T   THE VARIABLE IS IN A STRUCTURE DEFINITION
C         7   8    A   THE VARIABLE IS AN ARGUMENT IN A SUBPROGRAM CALL
C                      OR AN INPUT - OUPUT CONTROL LIST
C     46  8   1    B   THE VARIABLE IS AN ENTRY SUBPROGRAM DEFINITION
C                      NAME
C         9   2    S   THE VARIABLE IS A SUBROUTINE SUBPROGRAM
C                      DEFINITION NAME
C        10   4    F   THE VARIABLE IS A FUNCTION SUBPROGRAM DEFINITION
C                      NAME
C        11   8    C   THE VARIABLE IS A COMMON BLOCK DEFINITION NAME
C        12   1    N   THE VARIABLE IS A NAMELIST DEFINITION NAME
C        13   2    T   THE VARIABLE IS A STRUCTURE DEFINITION NAME
C        14   4    P   THE VARIABLE IS A PARAMETER DEFINITION NAME
C        15   8        THE VARIABLE IS TO APPEAR IN THE OUTPUT LISTINGS
C     47 16   1    F   THE VARIABLE IS AN INTRINSIC FUNCTION NAME
C        17   2    D   THE VARIABLE IS DIMENSIONED
C        18   4        A CALLED SUBPROGRAM NAME MATCHES A DEFINED
C                      SUBPROGRAM NAME
C        19   8        A FUNCTION STATEMENT HAS A LENGTH BUT NO DATA
C                      TYPE
C        20   1        THIS VARIABLE IS AN ENTRY, FUNCTION, OR SUBROUTINE
C                      DUMMY ARGUMENT
C        21   2        NOT USED
C        22   4        NOT USED
C        23   8        NOT USED
C     48 24   1        NOT USED
C        25   2        NOT USED
C        26   4        NOT USED
C        27   8        NOT USED
C        28   1        NOT USED
C        29   2        NOT USED
C        30   4        NOT USED
C        31   8        NOT USED
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         0 - MESSAGES
C         3 - SUBPROGRAM DEFINITIONS FILE
C        10 - CALLED SUBPROGRAM ARGUMENTS
C
C     SUBROUTINS CALLED BY THIS MODULE
C
C         BTEST DSORT GERR1 GERR2 GERR3 GERR4 GERR5 GERR6 IBSET TABINS
C         TABSRH
C
C     ******************************************************************
C
      SUBROUTINE ARGCHK
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION CCARG(30), CDARG(30), ICARG(12,30), IDARG(12,30)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION CUSE2(30), IUSE2(12,30)
      DIMENSION INDEX(8000)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*200   CBUF
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*48    CCARG, CDARG
      CHARACTER*48    CUSE2
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*1     CTYPE
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L2, L3
      LOGICAL*1       LASC
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*4       J17
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CDEF(57:1496),CDARG,IDARG), (CWK8(2:2),CWK7),
     1            (CUSE(93:93),CCARG(1)(1:1),ICARG(1,1))
      EQUIVALENCE (CDEF(45:48),IDBSW), (CUSE(45:48),ICBSW),
     1            (CDEF(49:52),IDVLEN), (CUSE(85:88),ICVLEN),
     2            (CDEF(53:56),IDNARG), (CUSE(89:92),ICNARG),
     3            (CUSE(49:52),IQVLEN)
      EQUIVALENCE (CUSE(33:36),ISNU), (CNAME(1),IENAME(1,1)),
     1            (CDEF(33:36),ISND)
      EQUIVALENCE (CUSE(93:1440),CUSE2(1),IUSE2(1,1))
      EQUIVALENCE (CBUF(33:36),IBUF)
      EQUIVALENCE (FCONFT(1),INDEX(1))
      EQUIVALENCE (CSUBTB,JSUBTB)
C
C         SAVE STATEMENT
C
      SAVE
C
C         DATA STATEMENTS
C
      DATA J17/0/, L2/.FALSE./, L3/.FALSE./
C
C         FORMAT STATEMENTS
C
 100  FORMAT('0 GLOBAL MESSAGES'/)
 101  FORMAT(A121)
 102  FORMAT(121A1)
 103  FORMAT(' MORE THAN 1000 SUBPROGRAMS EXIST')
 104  FORMAT(' A DUPLICATE SUBPROGRAM DEFINITION OCCURS, NAMED: ',A32)
C
C         DETERMINE IF MORE THAN 1000 DEFINED SUBPROGRAMS ARE USED IN
C         THE CURRENT PROGRAM
C
      IF(IREC3 .GT. 1000) THEN
         WRITE (0,103)
         IREC0 = IREC0 + 1
      END IF
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
      DO 10 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 10   CONTINUE
C
C         FILL THE INDEX ARRAY FOR RECORD LOCATION ON UNIT 3 WITH ZEROS
C
      DO 11 KC = 1,8000
      INDEX(KC) = 0
 11   CONTINUE
C
C         BLANK THE ARRAY CNAME TO PREPARE FOR THE DEFINED SUBPROGRAM
C         TABLE CREATION
C
      DO 12 KC = 1,4000
      CNAME(KC)(1:52) = CBLK52(1:52)
 12   CONTINUE
C
C         SORT THE RECORDS ON UNIT 3 BY SUBPROGRAM NAME
C
      IF(IREC3 .GT. 1) THEN
         JUNIT = 3
         IRECL = 1496
         NREC = IREC3
         ISTART(1) = 1
         IFLEN(1) = 32
         CTYPE(1) = CCC
         CALL DSORT (JUNIT,IRECL,IREC3,1)
C
C         CREATE THE CNAME TABLE OF DEFINED SUBPROGRAM NAMES IN THE
C         CURRENT PROGRAM FROM UNIT 3
C
         IB = 0
         DO 13 KC = 1,IREC3
         READ (3,REC=KC) CWORK(1:52)
         IF(IB .GT. 0) CALL TABSRH (CNAME,IB,52,1,32,CWORK,1,32,IRET,
     1      4000)
C
C         WRITE ERROR MESSAGE THAT MULTIPLE SUBPROGRAMS EXIST WITH
C         IDENTICAL NAMES
C
         IF(IB .GT. 0 .AND. IRET .GT. 0) THEN
            IF(CNAME(IRET+1)(1:32) .EQ. CNAME(IRET)(1:32)) THEN
               WRITE (0,104) CWORK(1:32)
               IREC0 = IREC0 + 1
            END IF
         END IF
         CALL TABINS (CNAME,IB,52,1,32,CWORK,1,32,IRET,4000)
         INDEX(IRET) = IRET
 13      CONTINUE
         IREC3 = IB
      ELSE IF(IREC3 .EQ. 1) THEN
         READ (3,REC=1) CNAME(1)(1:52)
      END IF
C
C         SORT THE RECORDS ON UNIT 10 BY ISN WITHIN CALLED SUBPROGRAM
C         NAME WITHIN CALLING SUBPROGRAM NAME
C
      IF(IREC10 .GT. 1) THEN
         JUNIT = 10
         IRECL = 1532
         NREC = IREC10
         ISTART(1) = 53
         IFLEN(1) = 32
         CTYPE(1) = CCC
         LASC(1) = LFALSE
         ISTART(2) = 1
         IFLEN(2) = 32
         CTYPE(2) = CCC
         LASC(2) = LFALSE
         ISTART(3) = 33
         IFLEN(3) = 4
         CTYPE(3) = CII
         LASC(3) = LFALSE
         CALL DSORT (JUNIT,IRECL,IREC10,3)
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE IF ANY DEFINED SUBPROGRAMS EXIST, BUT NOT CALLED   *
C     *                                                                *
C     ******************************************************************
C
      IF(IREC3 .GT. 0 .AND. IREC10 .EQ. 0) THEN
         DO 14 I = 1,IREC3
         READ (3,REC=I) CDEF(1:1496)
         CALL GERR1 (IDVLEN,CDEF)
 14      CONTINUE
         GO TO 20
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   DETERMINE IF ANY CALLED SUBPROGRAMS EXIST, BUT NONE DEFINED  *
C     *                                                                *
C     ******************************************************************
C
 15   IF(IREC3 .EQ. 0 .AND. IREC10 .GT. 0) THEN
         J17 = J17 + 1
C
C         READ A CALLED SUBPROGRAM RECORD
C
         READ (10,REC=J17,IOSTAT=IEND10) CUSE(1:1532)
         IF(IEND10 .EQ. -1) THEN
            GO TO 20
         ELSE
C
C         DETERMINE IF THE SUBPROGRAM NAME IS DEFINED IN AN EXTERNAL
C         STATEMEMT
C
            CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CUSE,1,32,IRET,1000)
            IF(IRET .LT. 0) THEN
               L3 = LTRUE
               CALL GERR2
            END IF
            GO TO 15
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   NO CALLED OR DEFINED SUBPROGRAMS EXIST                       *
C     *                                                                *
C     ******************************************************************
C
      IF(IREC3 .EQ. 0 .AND. IREC10 .EQ. 0) GO TO 27
C
C     ******************************************************************
C     *                                                                *
C     *   BOTH CALLED AND DEFINED ROUTINES EXIST                       *
C     *                                                                *
C     ******************************************************************
C
C         READ A RECORD OF THE FILE OF CALLED SUBPROGRAMS FROM UNIT 10
C
 16   J17 = J17 + 1
      READ (10,REC=J17,IOSTAT=IEND10) CUSE(1:1532)
      IF(IEND10 .EQ. -1) L2 = LTRUE
C
C         DETERMINE IF UNIT 0 HAS REACHED AN END OF FILE
C
      IF(L2) GO TO 18
C
C         DETERMINE THE RECORD INDEX VALUE OF A DEFINED SUBPROGRAM NAME
C
      IRET = 0
      CALL TABSRH (CNAME,IREC3,52,1,32,CUSE,1,32,IRET,4000)
      IF(IRET .GT. 0) IRET = INDEX(IRET)
C
C         DETERMINE IF A DEFINED SUBPROGRAM RECORD EXISTS
C
      IF(IRET .LT. 0) THEN
C
C         DETERMINE IF THE SUBPROGRAM NAME IS DEFINED IN AN EXTERNAL
C         STATEMEMT
C
         CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CUSE,1,32,IRET,1000)
         IF(IRET .LT. 0) THEN
            L3 = LTRUE
            CALL GERR2
            GO TO 16
         END IF
      ELSE
C
C         A DEFINED SUBPROGRAM FOR A CALL EXISTS, SET THE BIT SWITCH TO
C         INDICATE THIS
C
         L3 = LFALSE
         IENAME(12,IRET) = IBSET(IENAME(12,IRET),18)
C
C         READ THE DEFINED SUBPROGRAM RECORD FROM UNIT 3 FOR PROCESSING
C
         READ (3,REC=IRET) CDEF(1:1496)
C
C         DETERMINE IF ANY ARGUMENTS EXIST. WHEN NO ARGUMENTS EXIST, NO
C         NO FURTHER PROCESSING IS NECESSARY.
C
         IF(IDNARG .EQ. 0) THEN
            IF(ICNARG .EQ. 0) THEN
C
C         WHEN THE DEFINED ROUTINE IS A SUBROUTINE OR ENTRY, BUT IS
C         USED AS A FUNCTION, OR THE DEFINED ROUTINE IS A FUNCTION,
C         BUT IS USED AS AN ENTRY OR SUBROUTINE, WRITE A DIAGNOSTIC
C         MESSAGE.
C
               IF(((BTEST(IDBSW,8) .OR. BTEST(IDBSW,9)) .AND.
     1            BTEST(ICBSW,10)) .OR. ((BTEST(ICBSW,8) .OR.
     2            BTEST(ICBSW,9)) .AND. BTEST(IDBSW,10))) THEN
                  IF(.NOT.L3) CALL GERR5 (ICBSW,IDBSW)
                  GO TO 16
               END IF
            ELSE
C
C         THE DEFINED SUBPROGRAM HAS NO ARGUMENTS, BUT THE CALLING
C         SUBPROGRAM DOES HAVE ARGUMENTS
C
               IF(.NOT.L3) CALL GERR6
               GO TO 15
            END IF
         END IF
      END IF
C
C         DETERMINE IF A CALLED SUBPROGRAM NAME LENGTH IS THE SAME AS
C         THE LENGTH OF THE DEFINED NAME
C
      IF(IDVLEN .EQ. IQVLEN) THEN
C
C         DETERMINE IF THE CALLED AND DEFINED SUBPROGRAM NAMES MATCH
C
         IF(CDEF(1:IDVLEN) .EQ. CUSE(1:IQVLEN)) THEN
C
C         DETERMINE IF THE NUMBER OF ARGUMENTS ARE EQUAL
C
            IF(IDNARG .NE. ICNARG) THEN
               ISNU = ISNU - 128
C
C         THE NUMBER OF ARGUMENTS ARE NOT EQUAL; CREATE THE FORMAT
C         TO WRITE AN ERROR MESSAGE.
C
               IF(.NOT.L3) CALL GERR6
               GO TO 16
            END IF
C
C         DETERMINE IF ANY ARGUMENTS EXIST
C
            IF(IDNARG .EQ. 0 .AND. ICNARG .EQ. 0) THEN
C
C         READ ANOTHER ENTRY FROM THE CALLED SUBPROGRAM FILE ON UNIT 10
C
               IF(.NOT.L2) READ (10,IOSTAT=IEND10) CUSE(1:1532)
               IF(IEND10 .EQ. -1) L2 = LTRUE
               IF(L2) GO TO 18
               GO TO 16
            END IF
C
C         WHEN AN ARGUMENT LIST EXITS, DETERMINE WHICH RECORD HAS THE
C         LEAST NUMBER OF ARGUMENTS TO SET THE DO LOOP PROCESSING LIMIT
C         FOR INDIVIDUAL ARGUMENTS. WHEN THE ARGUMENT COUNTS ARE NOT
C         EQUAL, THE LOWEST COUNT IS USED FOR THE DO LOOP TO PROCESS
C         THE ARGUMENT LIST. THUS, ONLY NARG ARGUMENTS WILL BE
C         PROCESSED.
C
            IF(IDNARG .GE. ICNARG) THEN
               NARG = ICNARG
            ELSE
               NARG = IDNARG
            END IF
C
C         ARGUMENT PROCESSING WHEN THE NUMBER OF ARGUMENTS ARE EQUAL
C
            ISNU = ISNU - 128
            DO 17 I = 1,NARG
C
C         DETERMINE IF THE ARGUMENT TYPE CODES ARE EQUAL
C
            IF(CDARG(I)(33:33) .NE. CCARG(I)(33:33) .AND. .NOT.L3 .AND.
     1         CCARG(I)(1:6) .NE. 'C##STM' .AND. CCARG(I)(1:32) .EQ.
     2         CDARG(I)(1:32)) THEN
C
C         WRITE AN ERROR MESSAGE ONLY WHEN THE ARGUMENT IS NOT A
C         SUBROUTINE ENTRY OR FUNCTION NAME
C
               IF(CCARG(I)(33:33) .NE. CBAR) CALL GERR3
            END IF
C
C         DETERMINE IF THE ARGUMENT LENGTH CHARACTERISTIC MATCHES
C
            IF(CDARG(I)(34:40) .NE. CCARG(I)(34:40) .AND.
     1         CDARG(I)(34:36) .NE. '(*)' .AND. CCARG(I)(1:6) .NE.
     2         'C##NUM' .AND. CCARG(I)(1:6) .NE. 'C##STM' .AND.
     3         CCARG(I)(34:36) .NE. '(*)') THEN
C
C         WRITE AN ERROR MESSAGE IF THE ARGUMENT IS NOT A SUBPROGRAM
C         NAME AND NO LENGTH IS DEFINED
C
               IF(.NOT.L3 .AND. CCARG(I)(34:40) .NE. CBLANK(1:7))
     1            CALL GERR4
            END IF
 17         CONTINUE
C
C         READ THE NEXT ENTRY FROM THE CALLED SUBPROGRAM FILE ON UNIT
C         10
C
            IF(.NOT.L2) READ (10,IOSTAT=IEND10) CUSE(1:1532)
            IF(IEND10 .EQ. -1) L2 = LTRUE
C
C         DETERMINE IF AN END OF FILE HAS BEEN REACHED ON UNIT 10
C
            IF(L2) THEN
               GO TO 18
            ELSE
               GO TO 16
            END IF
C
C         CALLED AND DEFINED SUBPROGRAM NAMES DO NOT MATCH
C
         ELSE
C
C         DETERMINE IF THE SUBPROGRAM NAME IS DEFINED IN AN EXTERNAL
C         STATEMEMT
C
         CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CUSE,1,32,IRET,1000)
         IF(IRET .LT. 0) THEN
            L3 = LTRUE
            CALL GERR2
         END IF
C
C         DETERMINE IF AN END OF FILE HAS BEEN REACHED ON BOTH UNITS
C         3 AND 10
C
            IF(L2) THEN
               GO TO 18
            ELSE
               GO TO 16
            END IF
         END IF
      ELSE
C
C         THE DEFINED SUBPROGRAM VARIABLE NAME AND THE CALLED SUBPROGRAM
C         VARIABLE NAMES HAVE DIFFERENT LENGTHS
C
C
C         DETERMINE IF THE SUBPROGRAM NAME IS DEFINED IN AN EXTERNAL
C         STATEMEMT
C
         CALL TABSRH (CEXTNL,IEXTNL,32,1,32,CUSE,1,32,IRET,1000)
         IF(IRET .LT. 0) THEN
            L3 = LTRUE
            CALL GERR2
         END IF
C
C         DETERMINE IF AN END OF FILE HAS BEEN REACHED ON BOTH UNIT 10
C
         IF(L2) THEN
            GO TO 18
         ELSE
            GO TO 16
         END IF
      END IF
C
C         ALL SUBPROGRAM CALLS ARE NOW PROCESSED; EXAMINE THE DEFINED
C         SUBPROGRAM TABLE TO DETERMINE IF ANY DEFINED SUBPROGRAMS HAVE
C         NOT BEEN CALLED.
C
 18   DO 19 I = 1,IREC3
      IF(.NOT.BTEST(IENAME(12,I),18)) THEN
         CALL GERR1 (IENAME(13,I),CNAME(I))
      END IF
 19   CONTINUE
C
C         EXAMINE ALL THE DUMMY ARGUMENTS OF SUBPROGRAM DEFINITIONS
C         ON FILE 3 TO DETERMINE IF ONE OF THE SUBPROGRAM ARGUMENTS
C         IS A SUBROUTINE NAME DEFINITION.
C
 20   DO 22 I = 1,IREC3
      READ (3,REC=I) CDEF(1:1496)
      DO 21 J = 1,IDNARG
C
C         DETERMINE IF A DEFINED SUBPROGRAM NAME IS USED AS A DUMMY
C         VARIABLE ARGUMENT
C
      CALL TABSRH (CNAME,IREC3,52,1,32,CDARG(J),1,32,IRET,4000)
      IF(IRET .GT. 0) THEN
         CBUF(1:200) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:50)//
     1                 CBLK52(1:50)
         IREC0 = IREC0 + 1
         CBUF(1:13) = CLPAR//''' ISN:'',I6,'''
         I4WK1 = IDVLEN + 77
         IF(BTEST(IDBSW,8)) THEN
            CBUF(14:I4WK1) = ' IN ENTRY STATEMENT '//
     1         CNAME(I)(1:IDVLEN)//', ARGUMENT'',I3,'//
     2         ''' IS A SUBPROGRAM NAME'')'
         ELSE IF(BTEST(IDBSW,10)) THEN
            CBUF(14:I4WK1) = ' IN FUNCTION STATEMENT '//
     1         CNAME(I)(1:IDVLEN)//', ARGUMENT'',I3,'//
     2         ''' IS A SUBPROGRAM NAME'')'
         ELSE IF(BTEST(IDBSW,9)) THEN
            CBUF(14:I4WK1) = ' IN SUBROUTINE STATEMENT '//
     1         CNAME(I)(1:IDVLEN)//', ARGUMENT'',I3,'//
     2         ''' IS A SUBPROGRAM NAME'')'
         END IF
         ISN = ISND - 128
         WRITE (0,CBUF) ISN,J
         IREC0 = IREC0 + 1
      END IF
 21   CONTINUE
 22   CONTINUE
C
C         WHEN GLOBAL ERROR MESSAGES EXIST ON UNIT 0, COPY THE MESSAGES
C         TO THE OUTPUT LISTING ON UNIT 3.
C
      IF(IREC0 .GT. 0) THEN
         END FILE (0)
         REWIND (0)
         WRITE (6,100)
C
C         LOOP TO WRITE ALL GLOBAL MESSAGES ON UNIT 6
C
         DO 26 J = 1,IREC0
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
         DO 23 KC = 1,4
         KA = 50 * (KC - 1) + 1
         KB = 50 * KC
         CBUF(KA:KB) = CBLK52(1:50)
 23      CONTINUE
         READ (0,101,IOSTAT=IEND0) CBUF(1:121)
         IF(IEND0 .EQ. -1) GO TO 27
C
C         DETERMINE THE END OF THE LINE OF PRINT FOR THE ERROR MESSAGE
C
         DO 24 KC = 121,1,-1
         IF(CBUF(KC:KC) .NE. CBLANK(1:1)) THEN
            IEND = KC
            GO TO 25
         END IF
 24      CONTINUE
 25      WRITE (6,102) (CBUF(I:I),I = 1,IEND)
 26      CONTINUE
      END IF
C
C         ROUTINE EXIT
C
 27   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         CREATES VARIOUS ERROR MESSAGES FOR SUBPROGRAM ARGUMENTS WHEN
C         ROUTINE ARGCHK DETECTS INVALID USAGE.
C
C     MEANING OF THE VARIABLES
C
C         CBLANK - CHARACTER VARIABLE, 8 BLANKS
C         CBUF   - CHARACTER VARIABLE, THE WORK AREA WHERE THE OUTPUT
C                  DIAGNOSTIC MESSAGE FORMAT STATEMENT IS BUILT
C         CCARG  - CHARACTER VARIABLE, ARRAY OF ARGUMENTS DEFINITIONS
C                  FOR CALLED SUBPROGRAMS; EQUIVALENCED TO CUSE.
C         CDARG  - CHARACTER VARIABLE, ARRAY OF ARGUMENTS DEFINITIONS
C                  FOR DEFINED SUBPROGRAMS, EQUIVALENCED TO CDEF.
C         CDEF   - CHARACTER VARIABLE, WORK BUFFER TO READ THE
C                  DEFINITION RECORD OF A SUBPOROGRAM; LENGTH IS
C                  1496 CHARACTERS
C         CF102  - CHARACTER VARIABLE, THE FORMAT TO WRITE NUMBER OF
C                  ARGUMENTS ERROR
C         CF104  - CHARACTER VARIABLE, THE FORMAT TO WRITE THE
C                  SUBPROGRAM NOT CALLED ERROR
C         CMESX  - CHARACTER VARIABLES, PORTIONS OF FORMAT STATEMENTS
C                  USED TO SYNTHESIZE ERROR MESSAGES FORMAT STATEMENTS
C                  X HAS VALUES FROM 1 THROUGH ZZ
C         CNUM   - CHARACTER VARIABLE, ASCII NUMBER CONVERTED FROM
C                  INTEGER. USED TO CREATE FORMAT STATEMENTS FOR ERROR
C                  MESSAGES.
C         CUSE   - CHARACTER VARIABLE, WORK BUFFER TO READ THE
C                  CALL STATEMENT RECORD FOR SUBPOROGRAMS; LENGTH IS
C                  2493 CHARACTERS
C         CVNME  - CHARACTER VARIABLE, THE NAME OF A SUBPROGRAM THAT
C                  IS DEFINED BUT NOT CALLED
C         CWK7   - CHARACTER VARIABLE, A SEVEN CHARACTER WORK AREA.
C                  THE NUMBER OF CHARACTERS IN A TYPE LENGTH DEFINITION
C         I      - SUBSCRIPT VARIABLE, CHOOSES AN ARGUMENT FROM THE
C                  ARGUMENT LIST, ALSO USED AS THE RESULT OF BIT SWITCH
C                  TESTING
C         IA     - COMPUTED INDEX STARTING VALUE OF A FIELD
C         IB     - COMPUTED INDEX ENDING VALUE OF A FIELD
C         IC     - LENGTH OF A CALLED ARGUMENT NAME, ALSO USED FOR THE
C                  THE LENGTH OF A NUMERIC FIELD
C         ICBSW  - 32 BIT SWITCHES FOR THE DEFINED SUBPROGRAMS,
C                  EQUIVALENCED TO CUSE(45:48)
C         ICNARG - THE NUMBER OF ARGUMENTS IN A CALLED SUBPROGRAM
C         ICVLEN - THE LENGTH OF THE CALLED SUBPROGRAM NAME
C         IDBSW  - 32 BIT SWITCHES FOR THE DEFINED SUBPROGRAMS,
C                  EQUIVALENCED TO CDEF(45:48)
C         IDNARG - THE NUMBER OF ARGUMENTS FOR A SUBPROGRAM DEFINITION
C         IDVLEN - THE LENGTH OF THE DEFINED SUBPROGRAM NAME
C         IEND   - END OF FILE INDICATOR (= -1) FOR UNIT 0
C         IEND3  - END OF FILE INDICATOR (= -1) FOR UNIT 3
C         IEND10 - END OF FILE INDICATOR (= -1) FOR UNIT 10
C         INDEX  - THE SUBSCRIPT VALUE TO CHOOSE THE LENGTH OF A LITERAL
C                  FROM ARRAY
C         INUM   - WORK AREA FOR ARGUMENT PROCESSING
C         IQVLEN - THE LENGTH OF THE CALLING SUBPROGRAM NAME
C         IREC0  - RECORD COUNT FOR UNIT 0
C         IREC3  - RECORD COUNT FOR UNIT 3
C         IREC10 - RECORD COUNT FOR UNIT 10
C         IRET   - A VALUE RETURNED FROM A TABLE SEARCH. IF >0, TABLE
C                  ENTRY EXISTS; IF <0, TABLE ENTRY DOES NOT EXIST.
C         ISNU   - ISN OF THE CALLED SUBPROGRAM, EQUIVALENCED TO CUSE
C         I4WK1  - WORK AREA
C         I4WK2  - WORK AREA
C         J      - LENGTH OF THE WRITTEN ERROR MESSAGE
C         JDVLEN - LENGTH OF A DEFINED VARIABLE
C         J16    - RECORD LOCATION INDEX TO READ UNIT 3
C         J17    - RECORD LOCATION INDEX TO READ UNIT 10
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LD1    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR A SUBROUTINE DEFINITION; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         LD2    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR AN ENTRY DEFINITION; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         LD3    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR A FUNCTION DEFINITION; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         LU1    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR A CALLED SUBROUTINE; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         LU2    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR AN CALLED ENTRY; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         LU3    - LOGICAL VARIABLE, USED TO DETERMINE BIT SWITCH
C                  SETTING FOR A CALLED FUNCTION; SET TRUE WHEN
C                  THE BIT IS SET TO 1, SET FALSE WHEN THE BIT IS SET
C                  TO ZERO.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN DEFINED SUBPROGRAMS'
C                  UNIT 3 HAS REACHED AN END OF TILE, SET FALSE
C                  OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN CALLED SUBPORGRAMS'
C                  UNIT 10 END OF FILE EXISTS, SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE AFTER INITIAL PROCESSING
C                  OF A SUBPROGRAM NAME IS PROCESSED, SET FALSE
C                  OTHERWISE. PREVENTS MULTIPLE TESTING FOR SUBPROGRAM
C                  TYPE AGREES WITH ITS USAGE.
C         L4       LOGICAL VARIABLE, SET TRUE WHEN A MESSAGE MUST BE
C                  PRINTED ON MULTIPLE LINES, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN THE GENERATED FORMAT
C                  IN CBUF DOES NOT ALLOW THE ISN TO BE PRINTED, SET
C                  FALSE OTHEERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN A PARTICULAR ERROR
C                  MESSAGE HAS BEEN WRITTEN, SET FALSE OTHERWISE. THIS
C                  PREVENTS DUPLICATE MESSAGE BEING WRITTEN ON UNIT 10.
C
C         NARG   - NUMBER OF ARGUMENTS FOR THE DO LOOP PROCESSING
C                  INDIVIDUAL AREUMENTS
C
C     COMMENTS
C
C         UNIT 3
C
C         RECORD STRUCTURE OF THE INPUT SUBPROGRAM DEFINITIONS FILE.
C         THE RECORD CONTAINS SUBROUTINE, ENTRY, AND FUNCTION
C         DEFINITIONS OF THE PROGRAM BEING PROCESSED. IT DOES NOT
C         CONTAIN THE CALLED SUBPROGRAM RECORDS, NOR DOES IT CONTAIN
C         ANY INTRINSIC FUNCTIONS FROM THE FORTRAN LIBRARY.
C
C         SECTION 1:
C
C         DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C         COLUMN       TYPE &
C         NUMBER  WORD LENGTH  DESCRIPTION
C
C         1 - 32    8  C*32  THE SUBPROGRAM NAME
C        33 - 36    9  I*4   ISN OF THE SUBPROGRAM STATEMENT
C        37            C*1   SUBPROGRAM NAME DATA TYPE
C        38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C        45 - 48   12  C*4   32 BIT SWITCHES FOR THE SUBPROGRAM NAME
C                            ATTRIBUTES. IF BIT IS ZERO, SWITCH IS OFF;
C                            IF BIT IS ONE, SWITCH IS ON.
C        49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE SUBPROGAM NAME
C        53 - 56   14  I*4   NUMBER OF ARGUMENTS FOR THIS SUBPROGRAM
C
C         SECTION 2:
C
C         THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS REPEATED
C         FOR EACH ARGUMENT IN A SUBPROGRAM STATEMENT UP TO A MAXIMUM OF
C         30 ARGUMENTS. SUBSCRIPTS MAY NOT BE USED IN SUBPROGRAM
C          STATEMENTS, SINCE ARGUMENTS ARE ALL DUMMY VARIABLES.
C
C         COLUMN       FIELD
C         NUMBER  WORD TYPE   DESCRIPTION
C
C         1 - 32    8  C*32  ARGUMENT VARIABLE NAME
C        33            C*1   ARGUMENT VARIABLE DATA TYPE
C        34 - 40   10  C*7   ARGUMENT VARIABLE DATA TYPE LENGTH
C        41 - 44   11  I*4   32 BIT SWITCHES FOR THE ARGUMENT VARIABLE
C                            NAME ATTRIBUTES. IF BIT IS ZERO, SWITCH IS
C                            OFF; IF BIT IS ONE, SWITCH IS ON.
C        45 - 48   12  I*4   NUMBER OF CHARACTERS IN THE ARGUMENT
C                            VARIABLE NAME
C
C         TOTAL RECORD LENGTH IS 1496 CHARACTERS
C
C         UNIT 10
C
C         RECORD STRUCTURE OF THE INPUT SUBPROGRAM ARGUMENT LIST IN A
C         CALL STATEMENT
C
C         SECTION 1:
C
C         DESCRIBES THE SUBPROGRAM NAME AND CHARACTERISTICS
C
C         COLUMN  WORD TYPE &
C         NUMBER       LENGTH  DESCRIPTION
C
C         1 - 32    8  C*32  CALLED SUBPROGRAM NAME
C        33 - 36    9  I*4   ISN OF THE CALL STATEMENT
C        37            C*1   SUBPROGRAM NAME DATA TYPE
C        38 - 44   11  C*7   SUBPROGRAM NAME DATA TYPE LENGTH
C        45 - 48   12  I*4   32 BIT SWITCHES FOR THE SUBPROGRAM NAME
C                            ATTRIBUTES. IF BIT IS ZERO, SWITCH IS OFF;
C                            IF BIT IS ONE, SWITCH IS ON.
C        49 - 52   13  I*4   NUMBER OF CHARACTERS IN THE CALLED
C                            SUBPROGRAM NAME IN COLS 1- 32
C        53 - 84   21  C*32  ROUTINE NAME WHERE THE CALL STATEMENT
C                            OCCURS
C        85 - 88   22  I*4   NUMBER OF CHARACTERS IN THE VARIABLE NAME
C                            IN COLUMNS 53 - 84.
C        89 - 92   23  I*4   NUMBER OF ARGUMENTS FOR THIS CALL STATEMENT
C
C         SECTION 2:
C
C         THIS SECTION IMMEDIATELY FOLLOWS SECTION ONE AND IS REPEATED
C         FOR EACH ARGUMENT IN A CALL STATEMENT UP TO A MAXIMUM OF 30
C         ARGUMENTS. SUBSCRIPTS OF ARGUMENTS ARE NOT COUNTED AND ARE
C         NOT PROCESSED.
C
C         COLUMN WORD  FIELD  DESCRIPTION
C         NUMBER       TYPE
C
C         1 - 32   8   C*32  ARGUMENT VARIABLE NAME
C        33            C*1   ARGUMENT VARIABLE DATA TYPE
C        34 - 40  10   C*7   ARGUMENT VARIABLE DATA TYPE LENGTH
C        41 - 44  11   C*4   BIT SWITCHES FOR THE ARGUMENT VARIABLE
C                            NAME ATTRIBUTES. IF BIT IS ZERO, SWITCH IS
C                            OFF; IF BIT IS ONE, SWITCH IS ON.
C        45 - 48  12   I*4   NUMBER OF CHARACTERS IN THE ARGUMENT VARIABLE
C                            NAME
C
C         THE TOTAL RECORD LENGTH IS 1532 CHARACTERS
C
C         ONE OF THE FOLLOWING CODES DESCRIBES THE VARIABLE TYPE
C
C         CODE      DESCRIPTION
C
C           B       COMPLEX
C           C       CHARACTER
C           D       DOUBLE PRECISION, REAL*8
C           E       DOUBLE COMPLEX
C           I       INTEGER
C           L       LOGICAL
C           R       REAL*4
C
C         BIT SWITCHES USED TO INDICATE A CONDITION EXISTS OR A
C         PARTICULAR USAGE OF THE VARIABLE WHEN SET TO 1, ON.
C
C     CHAR &
C        BIT  HEX  PRINT
C     NUMBER VALUE CODE  DESCRIPTION
C
C     45  0   1        NOT USED
C         1   2    C   THE VARIABLE IS IN A COMMON BLOCK
C         2   4    R   THE VARIABLE IS IN A RECORD DEFINITION
C         3   8    E   THE VARIABLE IS IN AN EQUIVALENCE DEFINITION
C         4   1    N   THE VARIABLE IS IN A NAMELIST DEFINITION
C         5   2    U   THE VARIABLE IS IN A UNION DEFINITION
C         6   4    T   THE VARIABLE IS IN A STRUCTURE DEFINITION
C         7   8    A   THE VARIABLE IS AN ARGUMENT IN A SUBPROGRAM CALL
C                      OR AN INPUT - OUPUT CONTROL LIST
C     46  8   1    B   THE VARIABLE IS AN ENTRY SUBPROGRAM DEFINITION
C                      NAME
C         9   2    S   THE VARIABLE IS A SUBROUTINE SUBPROGRAM
C                      DEFINITION NAME
C        10   4    F   THE VARIABLE IS A FUNCTION SUBPROGRAM DEFINITION
C                      NAME
C        11   8    C   THE VARIABLE IS A COMMON BLOCK DEFINITION NAME
C        12   1    N   THE VARIABLE IS A NAMELIST DEFINITION NAME
C        13   2    T   THE VARIABLE IS A STRUCTURE DEFINITION NAME
C        14   4    P   THE VARIABLE IS A PARAMETER DEFINITION NAME
C        15   8        THE VARIABLE IS TO APPEAR IN THE OUTPUT LISTINGS
C     47 16   1    F   THE VARIABLE IS AN INTRINSIC FUNCTION NAME
C        17   2    D   THE VARIABLE IS DIMENSIONED
C        18   4        A CALLED SUBPROGRAM NAME MATCHES A DEFINED
C                      SUBPROGRAM NAME
C        19   8        A FUNCTION STATEMENT HAS A LENGTH BUT NO DATA
C                      TYPE
C        20   1        THIS VARIABLE IS AN ENTRY, FUNCTION, OR SUBROUTINE
C                      DUMMY ARGUMENT
C        21   2        NOT USED
C        22   4        NOT USED
C        23   8        NOT USED
C     48 24   1        NOT USED
C        25   2        NOT USED
C        26   4        NOT USED
C        27   8        NOT USED
C        28   1        NOT USED
C        29   2        NOT USED
C        30   4        NOT USED
C        31   8        NOT USED
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C        BTEST
C
C     ******************************************************************
C
      SUBROUTINE GERR1 (JDVLEN,CVNME)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CCARG(30), CDARG(30), ICARG(12,30), IDARG(12,30),
     1          IDEF(374)
      DIMENSION FUNTBL(143), CLITLN(500), NFLOC(30)
      DIMENSION ISRECL(20), CSREC(20)
C     DIMENSION CVNME(JDIM)
C
C         TYPE STATEMENTS
C
      CHARACTER*(*)   CVNME
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*200   CBUF
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*68    CWK68
      CHARACTER*52    CBLK52, CWORK
      CHARACTER*48    CCARG, CDARG
      CHARACTER*45    CF104
      CHARACTER*35    FUNTBL
      CHARACTER*32    CWK32
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*7     CWK7, CLITLN
      CHARACTER*2     CNUM
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       L4, L5, L6
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FP
      INTEGER*2       ISRECL, I2WK1
C
C         COMMON STATEMENTS
C
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CDEF(57:57),CDARG,IDARG),(CDEF,IDEF),
     1            (CUSE(93:93),CCARG(1)(1:1),ICARG(1,1))
      EQUIVALENCE (CDEF(49:52),IDVLEN), (CUSE(85:88),ICVLEN),
     1            (CDEF(53:56),IDNARG), (CUSE(89:92),ICNARG),
     2            (CUSE(49:52),IQVLEN)
      EQUIVALENCE (CUSE(33:36),ISNU)
      EQUIVALENCE (CWK8(2:2),CWK7), (CI4WK1,I4WK1)
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT DATA STATEMENTS
C
      DATA CF104 /'('' DEFINED SUBPROGRAM '',AXX,'' IS NOT CALLED'')'/
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
      DO 10 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 10   CONTINUE
C
C     ******************************************************************
C     *                                                                *
C     *   A DEFINED SUBPROGRAM EXISTS, BUT IT HAS NOT BEEN CALLED      *
C     *                                                                *
C     ******************************************************************
C
C         THE DEFINED SUBPROGRAM IS NOT CALLED, CREATE THE FORMAT TO
C         WRITE AN ERROR MESSAGE
C
C         DETERMINE THE DEFINED ROUTINE NAME LENGTH IN ASCII
C
      CNUM(1:2) = CBLANK(1:2)
      WRITE (CNUM,'(I2)') JDVLEN
      IF(CNUM(1:1) .EQ. CBLANK(1:1)) THEN
        CF104(26:26) = CNUM(2:2)
        CF104(27:27) = CBLANK(1:1)
      ELSE
        CF104(26:27) = CNUM(1:2)
      END IF
C
C         WRITE THE ERROR MESSAGE CF104, DEFINED SUBPROGRAM NOT CALLED
C
      IREC0 = IREC0 + 1
      WRITE (0,CF104) CVNME(1:JDVLEN)
C
C         ROUTINE EXIT
C
      RETURN
C
C     ******************************************************************
C     *                                                                *
C     *   A SUBPROGRAM HAS BEEN CALLED, BUT IT IS NOT DEFINED          *
C     *                                                                *
C     ******************************************************************
C
      ENTRY GERR2
C
C         WHEN THE VARIABLE NAME IS AN INTRINSIC FUNCTION, DO NOT WRITE
C         THE ERROR MESSAGE
C
      CALL TABSRH (FUNTBL,143,35,1,32,CUSE,1,32,IRET,I43)
      IF(IRET .GT. 0) RETURN
C
C         CREATE THE FORMAT TO WRITE THE ERROR MESSAGE THAT A SUBPROGRAM
C         HAS BEEN CALLED, BUT IT HAS NOT BEEN DEFINED.
C
      DO 11 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 11   CONTINUE
C
C         DETERMINE THE CALLING ROUTINE NAME LENGTH
C
      J = ICVLEN + IQVLEN + 58
      ISNU = ISNU - 128
      IA = 28
      CBUF(1:IA) =  '('' ISN:'',I6,'' IN ROUTINE '',A'
      CNUM(1:2) = CBLANK(1:2)
      WRITE (CNUM,'(I2)') ICVLEN
      IA = IA + 1
      IF(CNUM(1:1) .EQ. CBLANK(1:1)) THEN
         IB = IA
         IC = 2
      ELSE
         IB = IA + 1
         IC = 1
      END IF
      CBUF(IA:IB) = CNUM(IC:2)
C
C         DETERMINE THE CALLED ROUTINE NAME LENGTH
C
      IA = IB + 1
      IB = IA + 24
      CBUF(IA:IB) = ','', CALLED SUBPROGRAM '',A'
         WRITE (CNUM,'(I2)') IQVLEN
      IA = IB + 1
      IF(CNUM(1:1) .EQ. CBLANK(1:1)) THEN
         IB = IA
         IC = 2
      ELSE
         IB = IA + 1
         IC = 1
      END IF
      CBUF(IA:IB) = CNUM(IC:2)
C
C         DETERMINE IF THE TOTAL LENGTH OF THE OUTPUT ERROR MESSAGE WILL
C         EXCEED 121 CHARACTERS
C
      IF(J .GT. 121) THEN
         IA = IB + 1
         CBUF(IA:IA) = CRPAR(1:1)
         IREC0 = IREC0 + 1
         WRITE (0,CBUF) ISNU,CUSE(53:ICVLEN+52),CUSE(1:IQVLEN)
         IA = 1
         IB = 23
         CBUF(IA:IB) = CLPAR(1:1)//'11X,'' IS NOT DEFINED'')'
         IREC0 = IREC0 + 1
         WRITE (0,CBUF)
      ELSE
         IA = IB + 1
         IB = IA + 18
         CBUF(IA:IB) = ','' IS NOT DEFINED'')'
         IREC0 = IREC0 + 1
         WRITE (0,CBUF) ISNU,CUSE(53:ICVLEN+52),CUSE(1:IQVLEN)
      END IF
C
C         ROUTINE EXIT
C
      RETURN
C
C     ******************************************************************
C     *                                                                *
C     *   THE ARGUMENT OF A CALL STATEMENT HAS A DIFFERENT TYPE CODE   *
C     *   THAN THE ARGUMENT IN THE DEFINITION STATEMENT.               *
C     *                                                                *
C     ******************************************************************
C
      ENTRY GERR3
C
C         CREATE THE FORMAT TO WRITE VARIABLE TYPE CODE ERROR
C
C         SET CALLING ROUTINE NAME LENGTH AND NAME
C
      DO 12 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 12   CONTINUE
      L4 =LFALSE
      IA = ICVLEN + 27
      CBUF(1:IA) = '('' ISN:'',I6,'' IN ROUTINE '//CUSE(53:ICVLEN+52)//
     1              COMMA(1:1)
C
C         SET ARGUMENT NUMBER
C
      CNUM(1:2) = CBLANK(1:2)
      WRITE (CNUM,'(I2)') I
      IF(I .LT. 10) THEN
         IB = IA + 19
         IC = 2
         ID = 2
      ELSE
         IB = IA + 20
         IC = 1
         ID = 2
      END IF
      CBUF(IA:IB) = ' CALLED ARGUMENT '//CNUM(IC:ID)//CBLANK(1:1)//
     1              CLPAR(1:1)
C
C         SET ARGUMENT NAME
C
      IC = ICARG(12,I)
      IA = IB + 1
      IB = IA + IC
      CBUF(IA:IB) = CCARG(I)(1:IC)//CRPAR(1:1)
C
C         SET ARGUMENT TYPE CODE
C
      IA = IB + 1
      IB = IA + 26
C
C         DETERMINE IF IB EXCEEDS 121 CHARACTERS
C
      IF(IB .GT. 121) THEN
         L4 = LTRUE
         CBUF(IA:IA+1) = CAPOS//CRPAR
         IREC0 = IREC0 + 1
         WRITE (0,CBUF) ISNU
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
         DO 13 KC = 1,4
         KA = 50 * (KC - 1) + 1
         KB = 50 * KC
         CBUF(KA:KB) = CBLK52(1:50)
 13      CONTINUE
         IA = 1
         IB = IA + 17
         CBUF(IA:IB) = CLPAR(1:1)//'11X,'//CAPOS(1:1)//' IS TYPE '//
     1                 CCARG(I)(33:33)//COMMA(1:1)
      ELSE
         IB = IA + 10
         IREC10 = IREC10 + 1
         CBUF(IA:IB) = ' IS TYPE '//CCARG(I)(33:33)//COMMA(1:1)
      END IF
C
C         SET DEFINED ARGUMENT TYPE CODE
C
      IA = IB + 1
      IB = IA + 26
      IREC10 = IREC10 + 1
      CBUF(IA:IB) = ' BUT IS DEFINED AS TYPE '//CDARG(I)(33:33)//
     1                CAPOS(1:1)//CRPAR(1:1)
      IREC0 = IREC0 + 1
      IF(L4) THEN
         WRITE (0,CBUF)
      ELSE
        WRITE (0,CBUF) ISNU
      END IF
      L6 = LTRUE
C
C         DETERMINE IF IB EXCEEDS 121 CHARACTERS
C
      IF(IB .GT. 121) THEN
         IF(IB - 121 .GE. 2) THEN
            L4 = LTRUE
            CBUF(IA:IA+1) = CAPOS//CRPAR
            IREC0 = IREC0 + 1
            WRITE (0,CBUF) ISNU
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
            DO 14 KC = 1,4
            KA = 50 * (KC - 1) + 1
            KB = 50 * KC
            CBUF(KA:KB) = CBLK52(1:50)
 14         CONTINUE
            IA = 1
            IB = IB + IC + 38
            CBUF(IA:IB) = CLPAR(1:1)//'11X,'//CAPOS(1:1)//
     1                    ' BUT IS DEFINED AS TYPE '//CDARG(I)(33:33)//
     2                    CAPOS(1:1)//CRPAR(1:1)
            IREC0 = IREC0 + 1
            WRITE (0,CBUF) ISNU
         ELSE
C
C         CREATE THE REMAINDER OF THE SECOND FORMAT WHEN IB IS LESS THAN
C         121 CHARACTERS
C
            IF(.NOT.L6) THEN
               CBUF(IA:IB) = 'BUT IS DEFINED AS TYPE'//
     1                        CDARG(I)(33:33)//CAPOS(1:1)//CRPAR(1:1)
               IREC0 = IREC0 + 1
               WRITE (0,CBUF)
            END IF
         END IF
C
C         DETERMINE IF THE MESSAGE CAN BE WRITTEN ON A SINGLE LINE OF
C         PRINT
C
         IF(.NOT.L6) THEN
            IB = IA + 26
            CBUF(IA:IB) = ' BUT IS DEFINED AS TYPE '//CDARG(I)(33:33)//
     1                    CAPOS(1:1)//CRPAR(1:1)
C
C         WRITE ERROR MESSAGE THAT THE ARGUMENT VARIABLE TYPE CODES
C         CHARACTERISTICS DIFFER
C
            IREC0 = IREC0 + 1
            WRITE (0,CBUF)
            L5 = LFALSE
         END IF
      END IF
C
C         ROUTINE EXIT
C
      RETURN
C
C     ******************************************************************
C     *                                                                *
C     *  CREATE THE FORMAT TO WRITE AN ARGUMENT LENGTH CHARACTERISTIC  *
C     *  ERROR                                                         *
C     *                                                                *
C     ******************************************************************
C
      ENTRY GERR4
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
      DO 15 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 15   CONTINUE
C
C         SET CALLING ROUTINE NAME LENGTH AND NAME
C
      L4 = LFALSE
      L5 = LFALSE
      IA = ICVLEN + 26
      CBUF(1:IA) = '('' ISN:'',I6,'' IN ROUTINE '//CUSE(53:ICVLEN+52)//
     1             COMMA
      CNUM(1:2) = CBLANK(1:2)
      WRITE (CNUM,'(I2)') I
C
C         SET ARGUMENT NUMBER
C
      IA = IA + 1
      IF(I .LT. 10) THEN
         IB = IA + 20
         IC = 2
         ID = 2
      ELSE
         IB = IA + 21
         IC = 1
         ID = 2
      END IF
      CBUF(IA:IB) = ' CALLED ARGUMENT '//CNUM(IC:ID)//CBLANK(1:1)//
     1              CLPAR(1:1)
C
C         SET ARGUMENT NAME
C
      IC = ICARG(12,I)
      IA = IB
      IB = IA + IC + 2
      CBUF(IA:IB) = CCARG(I)(1:IC)//CRPAR(1:1)//CBLANK(1:1)
C
C         SET CALLED ARGUMENT DATA LENGTH
C
      IA = IB
      DO 16 KC = 1,7
      IF(CCARG(I)(KC+33:KC+33) .NE. CBLANK(1:1)) IC = KC
 16   CONTINUE
      IB = IA + IC + 16
C
C         DETERMINE IF IB EXCEEDS 121 CHARACTERS
C
      IF(IB .GT. 121) THEN
         CBUF(IA:IA+1) = CAPOS//CRPAR
         IREC0 = IREC0 + 1
         WRITE (0,CBUF) ISNU
         L5 = LTRUE
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
         DO 17 KC = 1,4
         KA = 50 * (KC - 1) + 1
         KB = 50 * KC
         CBUF(KA:KB) = CBLK52(1:50)
 17      CONTINUE
         IA = 1
         IB = IA + IC + 23
         IREC10 = IREC10 + 1
         CBUF(IA:IB) = CLPAR(1:1)//'12X,'//CAPOS(1:1)//
     1                 'HAS A LENGTH OF '//CCARG(I)(34:IC+33)//
     2                 COMMA(1:1)
      ELSE
C
C         CBUF LENGTH DOES NOT EXCEED 121 CHARACTERS
C
         CBUF(IA:IB) = 'HAS A LENGTH OF '//CCARG(I)(34:IC+33)//
     1                 COMMA(1:1)
      END IF
C
C         SET DEFINED ARGUMENT DATA LENGTH
C
      IA = IB + 1
      IC = 0
      DO 18 KC = 7,1,-1
      IF(CDARG(I)(KC+33:KC+33) .NE. CBLANK(1:1)) IC = IC + 1
 18   CONTINUE
      IB = IA + IC + 33
C
C         DETERMINE IF IB EXCEEDS 121 CHARACTERS
C
      IF(IB .GT. 121) THEN
         IF(IB - 121 .GE. 3) THEN
            L4 = LTRUE
            CBUF(IA:IA+1) = CAPOS//CRPAR
            IREC0 = IREC0 + 1
            WRITE (0,CBUF) ISNU
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
            DO 19 KC = 1,4
            KA = 50 * (KC - 1) + 1
            KB = 50 * KC
            CBUF(KA:KB) = CBLK52(1:50)
 19         CONTINUE
            IA = 1
            IB = IA + IC + 41
            CBUF(IA:IB) = CLPAR(1:1)//'11X,'//CAPOS(1:1)//
     1                    ' BUT IS DEFINED WITH A LENGTH OF '//
     2                     CDARG(I)(34:IC+33)//CAPOS(1:1)//CRPAR(1:1)
            IREC0 = IREC0 + 1
            WRITE (0,CBUF)
         END IF
C
C         DETERMINE IF THE MESSAGE CAN BE WRITTEN ON A SINGLE LINE OF
C         PRINT
C
         IF(.NOT.L4) THEN
            CBUF(IA:IB) = 'BUT IS DEFINED WITH A LENGTH OF '//
     1                     CDARG(I)(34:IC+33)//CAPOS(1:1)//CRPAR(1:1)
C
C         WRITE ERROR MESSAGE THAT ARGUMENT DATA TYPE LENGTHS DIFFER
C
            IREC0 = IREC0 + 1
            IF(L5) THEN
               WRITE (0,CBUF)
            ELSE
               WRITE (0,CBUF) ISNU
            END IF
            L5 = LFALSE
         END IF
      ELSE
C
C         THE MESSAGE IS LESS THAN 121 CHARACTERS
C
         IA = IA + 1
         IB = IA + IC + 35
         CBUF(IA:IB) = 'BUT IS DEFINED WITH A LENGTH OF '//
     1                  CDARG(I)(34:IC+33)//CAPOS(1:1)//CRPAR(1:1)
         IREC0 = IREC0 + 1
         WRITE (0,CBUF) ISNU
      END IF
C
C        ROUTINE EXIT
C
      RETURN
C
C     ******************************************************************
C     *                                                                *
C     *   CREATE THE FORMAT TO WRITE SUBPROGRAM CALLING ERROR          *
C     *                                                                *
C     ******************************************************************
C
      ENTRY GERR5 (ICBSW,IDBSW)
C
C         BLANK THE FORMAT CREATION BUFFER TO WRITE AN ERROR MESSAGE
C
      DO 20 KC = 1,4
      KA = 50 * (KC - 1) + 1
      KB = 50 * KC
      CBUF(KA:KB) = CBLK52(1:50)
 20   CONTINUE
C
C         CREATE THE FORMAT TO WRITE A FUNCTION CALLED AS A SUBROUTINE
C         OR ENTRY, OR A SUBROUTINE OR ENTRY CALLED AS A FUNCTION
C
      ISNU = ISNU - 128
      IA = ICVLEN + 26
      CBUF(1:IA) = '('' ISN:'',I6,'' IN ROUTINE '//
     1             CUSE(53:ICVLEN+52)//COMMA
      IA = IA + 1
      IB = IA + IDVLEN + 11
      CBUF(IA:IB) = ' SUBPROGRAM '//CDEF(1:IDVLEN)
      IA = IB + 1
      IB = IA + 15
      CBUF(IA:IB) = ' IS DEFINED AS A'
      IF(BTEST(IDBSW,8)) THEN
         IA = IB + 1
         IB = IA + 26
         CBUF(IA:IB) = 'N ENTRY, BUT IS CALLED AS A'
      END IF
      IF(BTEST(IDBSW,10)) THEN
         IA = IB + 1
         IB = IA + 28
         CBUF(IA:IB) = ' FUNCTION, BUT IS CALLED AS A'
      END IF
      IF(BTEST(IDBSW,9)) THEN
         IA = IB + 1
         IB = IA + 30
         CBUF(IA:IB) = ' SUBROUTINE, BUT IS CALLED AS A'
      END IF
      IF(BTEST(ICBSW,8)) THEN
         IA = IB + 1
         IB = IA + 8
         CBUF(IA:IB) = 'N ENTRY'')'
      END IF
      IF(BTEST(ICBSW,10)) THEN
         IA = IB + 1
         IB = IA + 10
         CBUF(IA:IB) = ' FUNCTION'')'
      END IF
      IF(BTEST(ICBSW,9)) THEN
         IA = IB + 1
         IB = IA + 12
         CBUF(IA:IB) = ' SUBROUTINE'')'
      END IF
C
C         WRITE THE MESSAGE
C
      IREC0 = IREC0 + 1
      WRITE (0,CBUF) ISNU
C
C         ROUTINE EXIT
C
      RETURN
C
C     ******************************************************************
C     *                                                                *
C     *   NUMBER OF ARGUMENTS IN THE DEFINED SUBPROGRAM AND THE        *
C     *   CALL STATEMENT ARE NOT EQUAL                                 *
C     *                                                                *
C     ******************************************************************
C
      ENTRY GERR6
C
C         SET CALLING ROUTINE NAME LENGTH
C
      IA = ICVLEN + 26
      CBUF(1:IA) = '('' ISN:'',I6,'' IN ROUTINE '//
     1             CUSE(53:ICVLEN+52)//COMMA
      IA = IA + 1
      IB = IA + IQVLEN + 24
      CBUF(IA:IB) = ' CALLED SUBPROGRAM '//CUSE(1:IQVLEN)//' HAS '
      IA = IB + 1
      WRITE (CNUM,'(I2)') ICNARG
      IF(CNUM(1:1) .EQ. CBLANK(1:1)) THEN
         CBUF(IA:IA) = CNUM(2:2)
         IA = IA + 1
      ELSE
         CBUF(IA:IA+1) = CNUM(1:2)
         IA = IA + 2
      END IF
      IB = IA + 32
      CBUF(IA:IB) = ' ARGUMENTS, BUT IS DEFINED WITH '
      IA = IB
      WRITE (CNUM,'(I2)') IDNARG
      IF(CNUM(1:1) .EQ. CBLANK(1:1)) THEN
         CBUF(IA:IA) = CNUM(2:2)
         IA = IA + 1
      ELSE
         CBUF(IA:IA+1) = CNUM(1:2)
         IA = IA + 2
      END IF
      IB = IA + 12
      CBUF(IA:IB) = ' ARGUMENTS'')'
C
C         WRITE ERROR MESSAGE THAT THE NUMBER OF ARGUMENTS DIFFER
C
      IREC0 = IREC0 + 1
      WRITE (0,CBUF) ISNU
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     *****************************************************************
C
C     PURPOSE
C
C     THIS MODULE WILL CREATE A POSTSCRIPT FILE TO PRINT THE FXREF
C     OUTPUT TEXT FILE
C
C     MEANING OF THE VARIABLES
C
C         ALL VARIABLE NAME STARTING WITH THE LETTER C ARE CHARACTER
C         VARIABLES. ALL VARIABLE NAMES STARTING WITH THE LETTER L
C         ARE LOGICAL VARIABLES. THE REMAINING VARIABLE NAMES CONFORM
C         TO THE FORTRAN DEFAULT STANDARD.
C
C         CARRET - CHARACTER VARIABLE, HEX 0D
C         CASTER - CHARACTER VARIABLE, AN ASTERISK, *
C         CBLNK4 - CHARACTER VARIABLE, 4 BLANKS
C         CDATA  - CHARACTER VARIABLE LENGTH 4, THE INPUT FILE RECORDS
C                  TO BE PRINTED. THE MAXIMUM RECORD LENGTH IS 256
C                  CHARACTERS.
C         CDATA1 - CHARACTER VARIABLE LENGTH 1, EQUIVALENCED TO CDATA TO
C                  ALLOW SINGLE CHARACTER MANIPULATION
C         CDATA2 - CHARACTER VARIABLE LENGTH 1, SAVE AREA FOR CDATA1 TO
C                  PROVIDE REPLACEMENT OF '(' AND ')' WITH '\(' AND '\)'
C                  IN THE INPUT DATA.  THIS ALLOWS CORRECT PRINTING.
C         CDATA3 - CHARACTER VARIABLE LENGTH 4, THE INPUT FILE RECORDS
C                  TO BE PRINTED. THE MAXIMUM RECORD LENGTH IS 256
C                  CHARACTERS.
C         CDATE  - CHARACTER VARIABLE, TODAY'S DATE
C         CEND   - CHARACTER VARIABLE, HEX 0A CONSTANT
C         CFILE  - CHARACTER VARIABLE, THE PATH AND NAME OF THE INPUT
C                  FILE, AND THE OUTPUT FILES. SUBSCRIPT VALIES ARE
C                  SHOWN IN THE TABLE BELOW:
C                  VALUE  MEANING
C                    1    CONTAINS THE EVEN PAGES OF THE PRINT FILE
C                    2    CONTAINS THE ODD PAGES OF THE PRINT FILE
C                    3    CONTAINS THE INPUT FILE TO BE PRINTED
C         CFILEE - THE EVEN PAGE NUMBERS OUTPUT FILE. EQUIVALENCED TO
C                  CFILE(2)
C         CFILED - CHARACTER VARIABLE, NAME OF FILE TO BE DOWN LOADED
C         CFILEO - THE ODD PAGE NUMBERS OUTPUT FILE. EQUIVALENCED TO
C                  CFILE(1)
C         CFILE2 - CHARACTER VARIABLE, THE PATH AND NAME OF THE FILE TO
C                  BE PRINTED AS READ FROM THE CONTROL CARD.
C                  EQUIVALENCED TO CFILE(3).
C         CFMT   - FORMAT STATEMENT FOR THE POSTSCRIPT HEADER
C         CFMT2  - FORMAT FOR THE OUTPUT PRINT RECORD
C         CFMT3  - DATA FOR CFMT2 AND CFMT4
C         CFMT4  - FORMAT FOR THE SECOND PART OF THE OUTPUT PRINT RECORD
C                  WHEN FOLDED
C         CFNAME - CHARACTER VARIABLE, THE ARRAY OF THE STANDARD 35
C                  POSTSCRIPT FONT NAMES. DINGBATS, SYMBOLS, AND
C                  TECHNICAL FONTS ARE INCLUDED. SEE THE TABLE IN
C                  THE DATA STATEMENT FOR INCLUDED FONTS.
C         CFINAL - CHARACTER VARIABLE, HEX '1A'
C         CFONT  - CHARACTER VARIABLE, NAME OF THE FONT TO BE USED BY
C                  THE PRINTER. IT IS READ FROM THE CONTROL CARD. IT
C                  MUST BE THE EXACT NAME SPECIFIED BY THE FONT LIBRARY
C                  AND EXPECTED BY THE POSTSCRIPT PRINTER. THE NAMES ARE
C                  CASE SENSITIVE.
C         CF101  - CHARACTER VARIABLE, FORMAT TO ROTATE PRINT TO LAND-
C                  SCAPE ORIENTATION
C         CF103  - CHARACTER VARIABLE, FORMAT TO PLACE CURSOR ON THE
C                  POSTSCRIPT PAGE
C         CF107  - CHARACTER VARIABLE, FORMAT TO ISSUE SHOWPAGE POST-
C                  SCRIPT COMMAND
C         CF108  - CHARACTER VARIABE, FORMAT TO ISSUE THE FINAL TRAILER
C         CI2WK1 - CHARACTER VARIABLE, OVERLAYS I2WK1
C         CI8WK1 - CHARACTER VARIABLE, USED TO CREATE THE %%Page VALUES
C         CPAGE  - CHARACTER VARIABLE, LIST OF EVEN PAGES IN THE
C                  POSTSCRIPT OUTPUT FILE TO BE PRINTED
C         CLPARN - CHARACTER VARIABLE, A LEFT PARENTHESIS, (
C         CPOINT - CHARACTER VARIABLE, THE FONT POINT SIZE THE BE USED
C                  BY THE PRINTER
C         CRPARN - CHARACTER VARIABLE, A RIGHT PARENTHESIS, )
C         CSTEM  - CHARACTER VARIABLE, THE EIGHT CHARACTER NAME OF THE
C                  INPUT FILE TO BE USED TO CREATE THE OUTPUT FILES
C         CSYS   - CHARACTER VARIABLE, THE FONTLOAD COMMAND TO DOWNLOAD A
C                  PARTICULAR FONT NOT PART OF THE STANDARD POSTSCRIPT 30
C                  FONTS
C         CSYS1  - CHARACTER VARIABLE, OVERLAYS CSYS AND ALLOWS SINGLE
C                  CHARACTER ACCESS
C         CTIME  - CHARACTER VARIABLE, TIME OF THE DAY
C         CTEXT  - CHARACTER VARIABLE, THE READ IN AREA FOR A CHARACTER
C                  OF THE INPUT FILES TO BE PRINTED
C         CWORK  - CHARACTER VARIABLE, WORK AREA
C         FBMAR  - SIZE OF THE BOTTOM MARGIN IN INCHES OR MM
C         FEVEN  - INDICATOR FOR EVEN OR ODD NUMBER OF PAGES. THE VALUE
C                  IS ZERO OF EVEN, AND ANY OTHER VALUE FOR ODD
C         FLMAR  - SIZE OF THE LEFT MARGIN IN INCHES OR MM
C         FPOINT - FLOATING FORM OF THE POINT SIZE FOR THE CHOSEN FONT
C         FPSIZE - FLOATING POINT FORM OF IPSIZE; WORD 1 CONTAINS THE
C                  VERTICAL DIMENSION; WORD 2 THE HORIZONTAL DIMENSION
C                  OF THE PAPER USED FOR PRINTING.
C         FRMAR  - SIZE OF THE RIGHT MARGIN IN INCHES OR MM
C         FTEMP  - COMPUTED VALUE OF THE NUMBER OF PAGES DIVIDED BY 2
C         FTMAR  - SIZE OF THE TOP MARGIN IN INCHES OR MM
C         FEXCH  - WORK VARIABLE TO DATA EXCHANGE
C         I      - SUBSCRIPT VARIABLE
C         IA     - SUBSCRIPT VARIABLE
C         IAA    - SUBSCRIPT VARIABLE, USED TO PLACE TEXT FORM THE INPUT
C                  FILE TO BE PRINTED IN THE WORK AREA WITH ADJUSTMENTS
C                  FOR HORIZONTAL TABS; A HORIZONTAL TAB CHARACTER IS
C                  REPLACED WITH 8 BLANKS. THIS IS THE START LOCATION
C                  FOR THE FIELD TO BE PLACED IN CDATA1.
C         IASTR  - PS X VALUE WHERE AN ASTERISK IS TO BE PLACED WHEN
C                  A PRINT LINE IS CONTINUED ONTO ANOTHER LINE BECAUSE
C                  THE FILE RECORD LENGTH IS LONGER THAN THE PRINT LINE
C         IB     - SUBSCRIPT VARIABLE
C         IBB    - SUBSCRIPT VARIABLE, THIS IS THE END LOCATION OF THE
C                  FIELD IN CDATA1.
C         IBMAR  - PS Y BOTTOM MARGIN COORDINATE VALUE
C         IC     - SUBSCRIPT VARIABLE
C         ID     - SUBSCRIPT VARIABLE AND WORK AREA
C         IDAY   - DAY OF THE MONTH, 1-31
C         IDELTA - POSTSCRIPT VERTICAL Y DISTANCE BETWEEN PRINT LINES
C         IDX    - SUBSCRIPT VARIABLE
C         IE     - LENGTH OF A LINE OF PRINT
C         IEND   - SET TO -1 WHEN AN END OF FILE OCCURS ON THE INPUT
C                  FILE
C         IERR   - ERROR CODE FOR OS/2 CALL; NONZERO VALUE - FAILURE
C         IG     - WORK AREA TO PRINT A CONTINUATION OF A LINE THAT CAN
C                  FIT ON A SINGLE LINE OF PRINT
C         IH     - WORK AREA TO PRINT A CONTINUATION OF A LINE THAT CAN
C                  FIT ON A SINGLE LINE OF PRINT
C         IHEADY - PS Y COORDINATE VALUE FOR THE PAGE HEADER
C         IHOUR  - THE HOUR OF THE DAY
C         IHSECS - HUNDREDTHS OF A SECOND
C         II     - THE LAST CHAACTER OF THE PRINT LINE WHEN IT IS
C                   PRINTED ON TWO OR MORE LINES
C         IIN    - INPUT UNIT TO READ THE FILE TO BE PROCESSED
C         IJ     - WORK AREA
C         IK     - WORK AREA
C         ILEN   - LENGTH OF THE INPUT FILE RECORD
C         ILENF  - LENGTH OF THE FONT NAME
C         ILEN4  - LENGTH OF THE INPUT FILE RECORD DIVIDED BY 4
C         ILMAR  - PS X LEFT MARGIN COORDINATE VALUE
C         ILOCL  - LOCATION OF THE FIRST CHARACTER OF THE BASE FILE NAME
C         ILOCR  - LOCATION OF THE FINAL CHARACTER OF THE BASE FILE NAME
C         IMAXC  - MAXIMUM NUMBER OF PRINT CHARACTERS PER LINE
C         IMAXL  - MAXIMUM NUMBER OF PRINT LINES PER PAGE
C         IMINT  - THE MINUTE OF THE HOUR
C         IMON   - THE MONTH OF THE YEAR, 1-12
C         IOUT   - THE UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT
C                  TO THE PRINTER, FORTRAN UNIT 2. WHEN REQUESTED, THIS
C                  FILE CONTAINS ODD NUMBERED PAGES ONLY.
C         IPOINT - FIXED FORM OF THE POINT SIZE FOR THE CHOSEN FONT
C         IPRRIT - PS RIGHT MARGIN X COORDINATE VALUE FOR THE LAST
C                  PRINT CHARACTER ON A LINE OF PRINT
C         IPRTOP - PS TOP OF PAGE Y COORDINATE VALUE FOR THE FIRST LINE
C                  OF PRINT ON THE PAGE
C         IPSIZE - VERTICAL AND HORIZONTAL DIMENSIONS OF THE PAPER USED
C                  IN PRINTING; WORD 1 IS THE VERTICAL (Y) DIMENSION,
C                  AND WORD 2 IS THE HORIZONTAL (X) DIMENSION IN POINTS
C         IREC   - A SINGLE RECORD OF THE FILE TO BE PRINTED.  THIS
C                  SINGLE RECORD IS A LINE OF PRINT IN THE LISTING.
C         IRMAR  - PS X RIGHT MARGIN COORDINATE VALUE
C         ISEC   - THE SECONDS OF THE MINUTE
C         ISIZEX - THE X DIMENSION POINT COORDINATE VALUE FOR THE PAGE
C         ISIZEY - THE Y DIMENSION POINT COORDINATE VALUE FOR THE PAGE
C         ITBLEN - LENGTH OF THE FONT NAMES IN CFTABL
C         ITMAR  - PS Y TOP MARGIN COORDINATE VALUE
C         ITYPE  - SET TO A VALUE OF ZERO WHEN NO CARRIAGE CONTROL
C                  CHARACTERS OR FORM FEED CHARACTERS OCCUR IN COLUMN
C                  ONE OF THE RECORD. SET TO A VALUE OF ONE WHEN FORTRAN
C                  CARRIAGE CONTROL CHARACTERS ARE THE FIRST CHARACTER
C                  OF EACH RECORD. SET TO A VALUE OF 2 WHEN A FORM FEED
C                  CHARACTER IS USED TO START A NEW PAGE.
C         IWKDAY - THE DAY OF THE WEEK, 1-7
C         IXCNT  - COUNT OF THE NUMBER OF LINES PRINTED ON A PAGE THUS
C                  FAR
C         IYEAR  - THE YEAR, 4 DIGITS
C         I1     - SUBSCRIPT VARIABLE
C         I2     - SUBSCRIPT VARIABLE, STARTS THE PRINT LINE WITH COLUMN
C                  TWO WHEN CARRIAGE CONTROL CHARACTERS ARE PRESENT.
C                  START OF PRINT LINE IN CDATA
C         I3     - END OF PRINT LINE IN CDATA
C         I2WK1  - WORK AREA FOR HEX COMPARE
C         J      - UNIT RECORD LENGTH OF THE INPUT FILE BEING PRINTED
C         JLEN   - LENGTH OF THE INPUT FILE NAME IN CFILEE
C         JOUT   - UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT TO
C                  THE PRINTER, BUT IT CONTAINS ONLY ODD NUMBERED PAGES
C         JOUTW  - UNIT NUMBER FOR THE EVEN NUMBER PAGES. USED ONLY WHEN
C                  REVERSE ORDER EVEN NUMBER SPLIT PAGES ARE BEING
C                  CREATED.
C         JX     - THE X POINT COORDINATES OF THE NEXT PRINT LINE
C         JY     - THE Y POINT COORDINATES OF THE NEXT PRINT LINE
C         J4WK1  - WORK AREA, USED TO INDICATE AN EVEN OR ODD NUMBERED
C                  PAGE IS BEING PROCESSED
C         KPAGE  - COUNT OF THE NUMBER OF EVEN PAGES IN THE OUTPUT FILE
C         L      - LOGICAL VARIABLE, WORK VARIABLE
C         LDIMU  - LOGICAL VARIABLE, SET FALSE IF PAPER DIMENSIONS
C                  ARE IN INCHES, SET TRUE IF THEY ARE IN MM
C         LEND   - LOGICAL VARIABLE, SET TRUE WHEN AN END OF FILE HAS
C                  OCURRED ON UNIT IIN, SET FALSE OTHERWISE
C         LEXIST - LOGICAL VARIABLE, SET TRUE WHEN A FILE NAME EXISTS,
C                  SET FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LORIE  - LOGICAL VARIABLE, SET FALSE IF PRINT ORIENTATION IS
C                  PORTRAIT, SET TRUE IF LANDSCAPE
C         LPAGE  - LOGICAL VARIABLE, SET TRUE THE %%Page IS WRITTEN,
C                  SET FALSE OTHERWISE
C         LPGNUM - LOGICAL VARIABLE, SET TRUE WHEN THE OUTPUT LISTING ON
C                  UNIT 2 IS TO HAVE A MAXIMUM OF 60 LINES PER PAGE AND
C                  11 x 14 INCH CONTINUOUS FORM PAPER IS BEING USED.
C                  SET FALSE WHEN THE OUTPUT LISTING IS TO HAVE A MAXIMUM
C                  OF 80 LINES PER PAGE AND 8.5 x 11 INCH PAPER IS BEING
C                  USED. EITHER CONTINUOUS FORM OR SHEETS ARE ALLOWED.
C         LREV   - LOGICAL VARIABLE, SET TRUE WHEN EVEN NUMBERED PAGES
C                  ARE TO BE WRITTEN IN REVERSE ORDER, SET FALSE WHEN
C                  THEY ARE TO BE WRITTEN IN NORMAL ORDER. THIS VARIABLE
C                  HAS NO EFFECT IF LSPLIT EQUALS .FALSE.
C         LSKIP  - LOGICAL VARIABLE, SET TRUE TO PREVENT DUPLICATE PAGE
C                  %%Page BEING WRITTEN TO THE OUTPUT PRINT FILES; SET
C                  FALSE OTHERWISE
C         LSPLIT - LOGICAL VARIABLE, SET FALSE TO CREATE A SINGLE OUT-
C                  OUT FILE, SET TRUE TO CREATE A FILE OF ODD NUMBERED
C                  PAGES AND EVEN NUMBER PAGES. THIS ALLOWS PRINTING
C                  ON BOTH SIDES OF THE PAPER.
C         LTYPE  - LOGICAL VARIABLE, SET TRUE FOR A FILE WITH
C                  CARRIAGE CONTROL CHARACTERS, SET FALSE OTHERWISE
C         LWRBLK - LOGICAL VARIABLE, SET TRUE WHEN A PRINT LINE IS ALL
C                  BLANKS, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, SET TRUE AT THE START OF EXECUTION
C                  SET FALSE AFTER THE POSTSCRIPT HEADERS ARE WRITTEN
C                  PREVENTS EXTRANEOUS WRITES ON OUTPUT UNITS
C         L2     - LOGICAL VARIABLE, SET FALSE FOR THE INITIAL PAGE OF
C                  PRINT, SET TRUE FOR ALL OTHER PAGES
C         NCHAR  - THE NUMBER OF CHARACTERS PER LINE OF PRINT
C         NLINES - THE NUMBER OF LINES OF PRINT PER PAGE
C         NCOPY  - THE NUMBER OF COPIES TO BE PRINTED, MAXIMUM IS 9
C         NPAGE  - THE CURRENT PAGE NUMBER PRINTED IN THE HEADER; AFTER
C                  ALL OUTPUT IS COMPLETE, THIS VARIABLE CONTAINS THE
C                  TOTAL NUMBER OF PAGES THAT WILL BE PRINTED.
C         NPAGEB - CURRENT PAGE NUMBER FOR SPLIT FILES; C:\PSFILB.PRT
C         PSIZE  - FLOATING FORM OF IPSIZE
C         POINT  - THE DIMENSION IN INCHES OF A SINGLE POINT (1/72)
C         SPOINT - THE SIZE OF A SINGLE POINT INCHES
C         SYSTEM - OS/2 SYSTEM FUNCTION CALL TO EXECUTE SYSTEM COMMANDS
C
C     COMMENTS
C
C         ALL METRIC DIMENSIONS ARE CONVERTED TO INCHES BY THE PROGRAM
C         FOR PROCESSING. THE TOP HALF INCH OF THE PRINTED PAGE IS
C         RESERVED FOR A PAGE HEADER.
C
C         ANY INPUT RECORD EXCEEDING THE LENGTH OF A SINGLE PRINT LINE
C         WILL BE FOLDED ONTO THE NEXT LINE, AND THAT FOLDED LINE WILL
C         BE MARKED WITH AN ASTERISK IN THE COLUMN IMMEDIATELY TO THE
C         LEFT OF THE FIRST CHARACTER OF THE CONTINUED RECORD ON THE
C         NEXT PRINT LINE.  THE PRINT LINE IS BROKEN AT A BLANK IF
C         POSSIBLE.
C
C         THE TABLE OF FONT NAMES ARE LISTED BY THE DATA STATEMENT FOR
C         THE VARIABLES CFNMXX. IF THE USER DESIRES TO MAKE A PERMANENT
C         CHANGE, ADD TO, OR MODIFY THAT VARIABLE'S VALUES, THE SIZE OF
C         ARRAY CFONT MUST BE INCREASED IF MORE THAN 30 CHOICES ARE
C         DESIRED.  THE USER MUST INSURE THE FONTS ARE DOWNLOADED TO THE
C         POSTSCRIPT PRINTER BEFORE ATTEMPTING TO PRINT. IF MORE THAN
C         40 CHARACTERS OCCUR IN A FONT NAME, CHANGE THE CFNAME DIMENS-
C         ION VALUE FOR THE FIRST SUBSCRIPT FROM 10 TO WHATEVER IS REQ-
C         UIRED, AND INCREASE THE DIMENSION OF THE CFNMXX VARIABLES TO
C         MATCH.  THESE FONTS ARE THE STANDARD 30 POSTSCRIPT TEXT FONTS
C         PROVIDED WITH MOST LASER POSTSCRIPT PRINTERS.
C
C         THE PROGRAM DOES NOT SUBMIT A FILE TO THE PRINT QUEUE. INSTEAD
C         DISK PRINT FILES ARE CREATED THAT MUST BE SUBMITTED MANUALLY.
C         THIS PERMITS CONTROL FOR PRINTING ON BOTH SIDES OF THE PAPER
C         WHEN THAT OPTION IS REQUESTED.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         CARCTL HEADPR NUMCNV
C
C     INPUT - OUTPUT FORTRAN UNITS USED
C
C         IIN    - THE UNIT NUMBER FOR THE INPUT FILE TO PRINTED,
C                  FORTRAN UNIT 1
C         IOUT   - THE UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT
C                  TO THE PRINTER, FORTRAN UNIT 2 (THE MAIN OUTPUT).
C                  IF REQUESTED, THIS UNIT CREATES A FILE CONTAINING
C                  THE ODD NUMBERED PAGES ONLY. THE VALUE FLIPS BETWEEN
C                  2, 4, OR 7 DEPENDING ON PARAMETERS CHOSEN.
C         JOUT   - THE UNIT NUMBER, 4, FOR THE POSTSCRIPT FILE TO BE
C                  SENT TO THE PRINTER OF EVEN NUMBERED PAGES ONLY. THIS
C                  UNIT CONTAINS THE FINAL VERSION OF THE EVEN PAGES
C                  WHEN SPLIT EVEN AND ODD PAGE OUTPUT FILES ARE WANTED.
C         JOUTW  - THE UNIT NUMBER 7, FOR ODD PAGES IN NORMAL ORDER.
C                  THIS UNIT IS A WORK FILE FOR EVEN PAGES USED ONLY
C                  WHEN THE FINAL EVEN PAGE OUTPUT IS TO BE IN REVERSE
C                  ORDER.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         CARCTL GETDAT GETTIM HEADPR NUMCNV PAGENM REVPRT
C
C     ******************************************************************
C
      SUBROUTINE PSPRINT (LPGNUM,ISPLIT,CFILE2)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C     DIMENSION STATEMENTS
C
      DIMENSION CDATA(64), CDATA3(64), CFNAME(35), CFILE(3),
     1CPAGE(1000), FPSIZE(2), IPSIZE(2), ITBLEN(32)
      DIMENSION ISRECL(20)
C
C     TYPE STATEMENTS
C
      CHARACTER*256 CDATA1, CDATA2
      CHARACTER*217 CFMT
      CHARACTER*80  CFILE, CFILE2, CFILEE, CFILEO, CTITLE
      CHARACTER*40  CFNAME, CFONT
      CHARACTER*40  CF108
      CHARACTER*39  CF101
      CHARACTER*41  CBLK41, CWFMT
      CHARACTER*28  CFMT4
      CHARACTER*23  CFMT2, CFMT3
      CHARACTER*15  CF103
      CHARACTER*21  CF104
      CHARACTER*16  CPAGE
      CHARACTER*12  CF107
      CHARACTER*9   CDATE
      CHARACTER*8   CTIME, CI8WK1
      CHARACTER*4   CBLNK4, CDATA, CDATA3
      CHARACTER*2   CPOINT, CI2WK1
      CHARACTER*1   CASTER, CEND, CFINAL, CLPARN, CRPARN
      INTEGER*2     IDAY, IMON, I2WK1
      INTEGER*2     IHOUR, IHSECS, IMINT, ISEC
      INTEGER*2     ISRECL
      LOGICAL*1     L, LDIMU, LEND, LORIE, LPAGE, LPGNUM, LREV, LSKIP,
     1              LSPLIT, LWRBLK, L1, L2
      LOGICAL*1     LFALSE, LTRUE
      LOGICAL*4     LEXIST
C
C         EXTERNAL STATEMENTS
C
      EXTERNAL GETDAT
      EXTERNAL GETTIM
C
C         INCLUDE STATEMENTS
C
C     INCLUDE 'E:\WATCOM\SRC\FORTRAN\FSUBLIB.FI'
C
C     EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CDATA,CDATA1), (CDATA2,CDATA3), (I2WK1,CI2WK1),
     1(CTIME(1:2),IHOUR), (CTIME(3:4),IMINT), (CTIME(5:6),ISEC),
     2(CTIME(7:8),IHSECS)
C
C     COMMON STATEMENTS
C
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
C
C         SAVE STATEMENT
C
      SAVE
C
C         PARAMETER STATEMENTS
C
      PARAMETER (LTRUE=.TRUE., LFALSE=.FALSE.)
C
C     DATA STATEMENTS
C
      DATA CASTER     /'*'/
      DATA CDATA      /64*'    '/
      DATA CDATA3     /64*'    '/
      DATA CFMT3      /'(A1,XXXA1,A1,1X,''show'')'/
      DATA CFMT4      /'(3A1,XXXA1,A1,1X,''show'')'/
      DATA CFNAME(1)  /'AvantGarde-Book                         '/
      DATA CFNAME(2)  /'AvantGarde-BookOblique                  '/
      DATA CFNAME(3)  /'AvantGarde-Demi                         '/
      DATA CFNAME(4)  /'AvantGarde-DemiOblique                  '/
      DATA CFNAME(5)  /'Bookman-Demi                            '/
      DATA CFNAME(6)  /'Bookman-DemiItalic                      '/
      DATA CFNAME(7)  /'Bookman-Light                           '/
      DATA CFNAME(8)  /'Bookman-LighItalic                      '/
      DATA CFNAME(9)  /'NewCenturySchlbk-Bold                   '/
      DATA CFNAME(10) /'NewCenturySchlbk-BoldItalic             '/
      DATA CFNAME(11) /'NewCenturySchlbk-Italic                 '/
      DATA CFNAME(12) /'NewCenturySchlbk-Roman                  '/
      DATA CFNAME(13) /'Courier                                 '/
      DATA CFNAME(14) /'Courier-Bold                            '/
      DATA CFNAME(15) /'Courier-BoldOblique                     '/
      DATA CFNAME(16) /'Courier-Oblique                         '/
      DATA CFNAME(17) /'Times-Bold                              '/
      DATA CFNAME(18) /'Times-BoldItalic                        '/
      DATA CFNAME(19) /'Times-Italic                            '/
      DATA CFNAME(20) /'Times-Roman                             '/
      DATA CFNAME(21) /'Palatino-Bold                           '/
      DATA CFNAME(22) /'Palatino-BoldItalic                     '/
      DATA CFNAME(23) /'Palatino-Italic                         '/
      DATA CFNAME(24) /'Palatino-Roman                          '/
      DATA CFNAME(25) /'Helvetica                               '/
      DATA CFNAME(26) /'Helvetica-Bold                          '/
      DATA CFNAME(27) /'Helvetica-BoldOblique                   '/
      DATA CFNAME(28) /'Helvetica-Narrow                        '/
      DATA CFNAME(29) /'Helvetica-Narrow-Bold                   '/
      DATA CFNAME(30) /'Helvetica-Narrow-BoldOblique            '/
      DATA CFNAME(31) /'Helvetica-Narrow-Oblique                '/
      DATA CFNAME(32) /'Helvetica-Oblique                       '/
      DATA CFNAME(33) /'Symbol                                  '/
      DATA CFNAME(34) /'ZapChancery-MediumItalic                '/
      DATA CFNAME(35) /'ZapfDingbats                            '/
      DATA CLPARN /'('/, CRPARN /')'/
      DATA CFMT /'(''%!PS-Adobe-3.0''/''%%DocumentFonts: '',A40/''%%Titl
     1e: Print ASCII File''/''%%Creator: FXREF''/''%%CreationDate: '',I2
     2,''/'',I2.2,''/'',I4,2X,I2,'':'',I2.2,'':'',I2.2/''%%Pages: (atend
     3)''/''%%EndComments''/,''%%End Prolog''/''newpath'')'/
      DATA IB /0/, IHOUR/0/, IMINT/0/, ISEC/0/, IHSECS/0/, IYEAR/0/,
     1     IMON/0/, IDAY/0/
      DATA ITBLEN /15,22,15,22,12,18,13,18,21,27,23,22,7,12,31,15,10,16,
     112,11,13,20,15,14,9,14,21,16,21,28,24,17/
      DATA I2WK1 /0/, LEND/.FALSE./, LSKIP/.FALSE./, LEXIST/.FALSE./
C
C     FORMAT STATEMENTS
C
 101  FORMAT(' MORE THAN 8 CHARACTERS IN FILE NAME')
 104  FORMAT(A133)
 111  FORMAT(' INPUT RECORD LENGTH GREATER THAN 256 OR ZERO')
C
C     SET INPUT-OUTPUT UNIT VALUES
C
      IIN = 6
      IOUT = 2
      IEND = 0
      JOUT = 4
      JOUTW = 7
      KPAGE = 0
      NPAGE = 1
      FTEMP = FLOAT(NPAGE)/2.
      FEVEN = FTEMP - AINT(FTEMP)
C
C     SET UP CFMT2
C
      CFMT2 = CFMT3
C
C         SET PARAMETERS FOR PRINTING POSTSCRIPT
C
      IF(ISPLIT .EQ. 1) THEN
         LSPLIT = LFALSE
         LREV = LFALSE
      ELSE IF(ISPLIT .EQ. 2) THEN
         LSPLIT = LTRUE
         LREV = LFALSE
      ELSE IF(ISPLIT .EQ. 3) THEN
         LSPLIT = LTRUE
         LREV = LTRUE
      END IF
C
C     GET THE DATE AND TIME
C
      CALL GETTIM (IHOUR,IMINT,ISEC,IHSECS)
      CALL GETDAT (IYEAR,IMON,IDAY)
C
C         FILL CFILE WORK AREA WITH BLANKS
C
      DO 10 IDX = 1,20
      IA = 4 * (IDX -1) + 1
      IB = IA + 3
      CFILEE(IA:IB) = CBLNK4(1:4)
      CFILEO(IA:IB) = CBLNK4(1:4)
 10   CONTINUE
C
C         SET THE POSTSCRIPT PRINTING PARAMETERS
C
      LDIMU = LFALSE
      ILEN = 132
      ITYPE = 1
      IF(LPGNUM) THEN
         FPSIZE(1) = 14.
         FPSIZE(2) = 11.
         FLMAR = 1.
         FRMAR = 1.
         FTMAR = 1.
         FBMAR = 1.
         LORIE = LTRUE
         CPOINT(1:2) = '10'
         FPOINT = 10.
         IHEADY = 720
      ELSE
         FPSIZE(1) = 11.
         FPSIZE(2) = 8.5
         FLMAR = .75
         FRMAR = .5
         FTMAR = .25
         FBMAR = .25
         LORIE = LFALSE
         CPOINT(1:2) = '08'
         FPOINT = 8.
         IHEADY = 774
      END IF
      NCOPY = 1
      CFONT(1:40) = CFNAME(14)(1:40)

C
C         SET LOGICAL SWITCH TO PREVENT UNECESSARY POSTSCRIPT COMMANDS
C         AT THE START OF THE LISTING
C
      L1 = LTRUE
C
C         DETERMINE THE LENGTH OF THE INPUT FILE NAME AND LOCATE THE
C         BASE FILE NAME WITHOUT ITS EXTENSION
C
      DO 11 IDX = 80,1,-1
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN THE FILE NAME
C
      IF(CFILE2(IDX:IDX) .NE. CBLNK4(1:1)) THEN
         JLEN = IDX
         GO TO 12
      END IF
 11   CONTINUE
C
C         DETERMINE THE LOCATION OF THE RIGHT CHARACTER OF THE BASE
C         FILE NAME.
C
 12   DO 13 IDX = JLEN,1,-1
      IF(CFILE2(IDX:IDX) .EQ. '.') THEN
         ILOCR = IDX - 1
         GO TO 14
      END IF
 13   CONTINUE
C
C         DETERMINE THE LOCATION OF THE LEFT CHARACTER OF THE BASE
C         FILE NAME.
C
 14   DO 15 IDX = ILOCR,1,-1
      IF(CFILE2(IDX:IDX) .EQ. '\') THEN
         ILOCL = IDX + 1
         GO TO 16
      END IF
 15   CONTINUE
      ILOCL = 1
C
C         DETERMINE IF SPLIT EVEN AND ODD PAGES' FILES ARE REQUESTED
C
 16   IF(LSPLIT) THEN
C
C         CREATE THE ODD AND EVEN PAGES OUTPUT FILE NAMES
C
         CFILEE(1:ILOCR+4) = CFILE2(1:ILOCR)//'E.PS'
         CFILEO(1:ILOCR+4) = CFILE2(1:ILOCR)//'O.PS'
C
C         THE OUTPUT FILE IS TO BE WRITTEN AS A SINGLE FILE
C
      ELSE
         CFILEO(1:ILOCR+3) = CFILE2(1:ILOCR+1)//'PS'
      END IF
C
C         DETERMINE IF THE BASE FILE NAME IS MORE THAN 8 CHARACTERS WHEN
C         A SINGLE FILE OUTPUT IS REQUESTED
C
      IF(ILOCR - ILOCL .GT. 8) THEN
         WRITE (*,101)
         STOP
      END IF
C
C     VERIFY THE INPUT RECORD LENGTH
C
      IF(ILEN .LE. 0 .OR. ILEN .GT. 256) THEN
        WRITE (*,111)
        STOP
      ELSE
        ILEN4 = ILEN/4
        IF(ILEN - 4*ILEND .NE. 0) ILEND = ILEN4 + 1
      END IF
C
C     DETERMINE PAPER ORIENTATION FOR PRINTING
C
      IF(LORIE) THEN
C
C     CHECK X < Y FOR LANDSCAPE ORIENTATION
C
        IF(FPSIZE(1) .GT. FPSIZE(2)) THEN
          FEXCH = FPSIZE(1)
          FPSIZE(1) = FPSIZE(2)
          FPSIZE(2) = FEXCH
        END IF
      ELSE
C
C     CHECK X > Y FOR PORTRAIT ORIENTATION
C
        IF(FPSIZE(1) .LT. FPSIZE(2)) THEN
          FEXCH = FPSIZE(1)
          FPSIZE(1) = FPSIZE(2)
          FPSIZE(2) = FEXCH
        END IF
      END IF
C
C     OPEN THE INPUT FILE
C
C     OPEN THE OUTPUT FILE (ALSO THE ODD PAGES FOR A SPLIT FILE OUTPUT.)
C
      INQUIRE (FILE = CFILEO,EXIST = LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT = 2,FILE = CFILEO)
         CLOSE (UNIT = 2,STATUS = 'DELETE')
      END IF
      OPEN (UNIT = 2, ACCESS = 'SEQUENTIAL',
     1FILE = CFILEO, FORM = 'FORMATTED', ACTION = 'WRITE',
     2STATUS = 'NEW', RECL=168)
C
C         DETERMINE IF EVEN PAGES ARE TO BE WRITTEN
C
      IF(LSPLIT) THEN
         INQUIRE (FILE = CFILEE,EXIST = LEXIST)
         IF(LEXIST) THEN
            OPEN (UNIT = 4,FILE = CFILEE)
            CLOSE (UNIT = 4,STATUS = 'DELETE')
         END IF
         OPEN (UNIT = 4, ACCESS = 'SEQUENTIAL', FILE = CFILEE,
     1   FORM = 'FORMATTED', ACTION = 'WRITE', RECL=168)
      END IF
C
C     VERIFY THE FONT CHOICE FOR THE PRINTER
C
      DO 17 IDX = 1,35
      IF(CFNAME(IDX)(1:32) .EQ. CFONT(1:32)) THEN
         ILENF = ITBLEN(IDX)
         GO TO 18
      END IF
 17   CONTINUE
C
C     CONVERT MM PAPER SIZES TO INCHES
C
 18   IF(LDIMU) THEN
        FLMAR = FLMAR/25.4
        FRMAR = FRMAR/25.4
        FTMAR = FTMAR/25.4
        FBMAR = FBMAR/25.4
        FPSIZE(1) = FPSIZE(1)/25.4
        FPSIZE(2) = FPSIZE(2)/25.4
      END IF
C
C     COMPUTE SIZE OF DELTA X, THIS IS THE CHANGE VALUE OF POINT
C     COORDINATE OF ONE PRINT LINE TO THE NEXT OR FROM ONE COLUMN
C     TO THE NEXT
C
      IDELTA = FPOINT
C
C     COMPUTE THE SIZE IN INCHES OF A SINGLE POINT
C
      SPOINT = FPOINT/72.
C
C     COMPUTER PAPER SIZE IN POINTS
C
      IPSIZE(1) = AINT(72. * FPSIZE(1))
      IPSIZE(2) = AINT(72. * FPSIZE(2))
      ISIZEX = IPSIZE(1)
      ISIZEY = IPSIZE(2)
C
C     COMPUTE MARGIN VALUES IN POINTS
C
      ILMAR = AINT(72. * FLMAR)
      IRMAR = AINT(72. * FRMAR)
      ITMAR = AINT(72. * FTMAR)
      IBMAR = AINT(72. * FBMAR)
      IASTR = ILMAR - IDELTA
C
C     SET TOP MARGIN Y COORDINATE VALUE IN POINTS
C
      IPRTOP = IPSIZE(1) - ITMAR
C
C     SET RIGHT MARGIN X COORDINATE VALUE IN POINTS
C
      IPRRIT = IPSIZE(2) - IRMAR
C
C     COMPUTE THE NUMBER OF LINES THAT CAN BE PRINTED PER PAGE.
C     HEADING, TOP AND BOTTOM MARGINS, AND POINT SIZE ARE ADJUSTED FOR
C     IN THE RESULT
C
      IMAXL = (IPSIZE(1) - ITMAR - IBMAR)/IDELTA
      IXCNT = IMAXL
C
C         SET NUMBER OF CHARACTERS THAT CAN BE PRINTED PER LINE
C
      IF(LORIE) THEN
C
C         FOR HORIZONTAL PAPER ORIENTATION
C
         IF(CPOINT .EQ. '08' .OR. CPOINT .EQ. ' 8') THEN
            IMAXC = 165
         ELSE IF(CPOINT .EQ. '10') THEN
            IMAXC = 132
         ELSE IF(CPOINT .EQ. '12') THEN
            IMAXC = 110
         ELSE IF(CPOINT .EQ. '14') THEN
            IMAXC = 88
         END IF
      ELSE
C
C         FOR VERTICAL PAPER ORIENTATION
C
         IF(CPOINT .EQ. '08' .OR. CPOINT .EQ. ' 8') THEN
            IMAXC = 127
         ELSE IF(CPOINT .EQ. '10') THEN
            IMAXC = 102
         ELSE IF(CPOINT .EQ. '12') THEN
            IMAXC = 85
         ELSE IF(CPOINT .EQ. '14') THEN
            IMAXC = 68
         END IF
      END IF
C
C     WRITE POSTSCRIPT HEADER
C
      WRITE (IOUT,CFMT) CFONT(1:40),IMON,IDAY,IYEAR,IHOUR,IMINT,ISEC
      IF(LSPLIT) WRITE (JOUT,CFMT) CFONT(1:40),IMON,IDAY,IYEAR
C
C     DETERMINE IF THE RECORDS BEING PRINTED HAVE CARRIAGE CONTROL
C     OR FORM FEED CHARACTERS TO CONTOL START OF A NEW PAGE
C
 19   IF(ITYPE .EQ. 0) THEN
C
C     CREATE THE HEADER FOR EACH PAGE OF PRINT IF NO CARRIAGE CONTROL
C     OR FORM FEED CONTROL
C
         IF(LSKIP) THEN
            LSKIP = LFALSE
         ELSE
            L = LTRUE
            CALL HEADPR (L,CTITLE)
         END IF
         IF(LPAGE) THEN
            LPAGE = LFALSE
         ELSE
            NPAGE = NPAGE + 1
         END IF
      END IF
C
C     READ THE INPUT FILE RECORDS
C
 20   LWRBLK = LFALSE
      READ (IIN,104,IOSTAT=IEND) CDATA1
      IF(NPAGE .GE. 0 .AND. NPAGE .LT. 4) THEN
      END IF
C
C         LOCATE THE FINAL CHARACTER OF THE RECORD
C
      DO 21 IAA = 256,1,-1
      IF(CDATA1(IAA:IAA) .NE. CBLNK4(1:1)) THEN
         IBB = IAA
         GO TO 22
      END IF
 21   CONTINUE
C
C         WHEN THE ENTIRE INPUT RECORD IS BLANK, SET LENGTH TO 2
C
      IAA = 2
      IBB = 2
C
C     TEST IF END OF FILE
C
 22   IF(IEND .EQ. -1) GO TO 33
C
C         TEST IF AN END OF A RECORD HAS BEEN REACHED, AND THE RECORD
C         CONTAINS NOTHING EXCEPT BLANKS
C
      IF(IAA .EQ. 2)  LWRBLK = LTRUE
C
C     ADJUST LINE LENGTH FOR END OF LINE CHARACTERS
C
      IA = IBB
      IB = 1
C
C     SCAN AND REPLACE LEFT & RIGHT PARENTHESES AND BACKWARD SLASHES
C
      DO 23 IDX = 1,IA
      CDATA2(IB:IB) = CDATA1(IDX:IDX)
      IF(CDATA1(IDX:IDX) .EQ. '(') THEN
         CDATA2(IB:IB+1) = '\('
         IB = IB + 1
         IF(IDX .EQ. IA) IB = IB + 1
      END IF
      IF(CDATA1(IDX:IDX) .EQ. ')') THEN
         CDATA2(IB:IB+1) = '\)'
         IB = IB + 1
         IF(IDX .EQ. IA) IB = IB + 1
      END IF
      IF(CDATA1(IDX:IDX) .EQ. '\') THEN
         CDATA2(IB:IB+1) = '\\'
         IB = IB + 1
         IF(IDX .EQ. IA) IB = IB + 1
      END IF
      IF(IDX .LE. IA) IB = IB + 1
 23   CONTINUE
C
C     SET THE RECORD LENGTH
C
      IF(IA .EQ. 1) THEN
         J = 1
      ELSE
         IF(IA .NE. IB) THEN
            IF(IA .GT. 2 .AND. IA .LE. IMAXC) THEN
               J = IB - 1
            ELSE
               J = IB
            END IF
         ELSE
            J = IB
         END IF
      END IF
      IF(J .LT. IA) J = IA
C
C     TEST IF A BLANK LINE OF PRINT
C
      IF(IB .EQ. 2 .AND. CDATA1(1:4) .EQ. CBLNK4(1:4)) THEN
C
C         WHEN EVEN PAGES ARE PRINTED IN A SEPARATE FILE AND A REVERSE
C         PAGE ORDER IS WANTED, WRITE THE POSTSCRIPT PAGE COMMENT
C
         CALL PAGENM (CI8WK1)
         WRITE (IOUT,CF103) JX,JY
         IXCNT = IXCNT - 1
         JY = JY - IDELTA
         IF(JY .LE. 0 .OR. JY .LT. IBMAR) THEN
            JY = IHEADY
            WRITE (IOUT,CF107)
            CALL HEADPR (L,CTITLE)
            IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
            IXCNT = -1
          END IF
         GO TO 30
      END IF
C
C     TEST IF THE END OF THE FILE, HEX 1A CHARACTER
C
      IF(J .EQ. 1) THEN
         IF(CDATA2(1:1) .EQ. CBLNK4(1:1)) THEN
            CI2WK1(1:1) = CDATA2(J:J)
            IF(I2WK1 .EQ. 26) GO TO 33
            IXCNT = IXCNT - 1
            JY = JY - IDELTA
            IF(JY .LE. 0 .OR. JY .LT. IBMAR) THEN
               JY = IHEADY
               WRITE (IOUT,CF107)
               CALL HEADPR (L,CTITLE)
               IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
               IXCNT = -1
               LEND = LTRUE
            END IF
            GO TO 30
         END IF
      END IF
C
C     TEST IF THIS IS A FILE WITH CARRIAGE CONTROL CHARACTERS
C
      IF(ITYPE .EQ. 1) THEN
         IB = IB - 1
         J = J - 1
      END IF
C
C     TEST IF THE RECORD CAN FIT ON A SINGLE LINE
C
      IF(J .GT. IMAXC) THEN
C
C     THE LINE OF TEXT IS LONGER THAN THE LINE OF PRINT
C     FIND THE LAST SPECIAL CHARACTER BEFORE THE END OF THE PRINT LINE
C
         IK = J/IMAXC
         IF(J - IK * IMAXC .GT. 0) IA = IA + 1
         DO 27 I1 = 1,IK
         IJ = I1 * IMAXC
         IF(I1 .NE. 1) THEN
           ID = IE + 1
         ELSE
           ID = 1
         END IF
         DO 24 IC = ID,IJ
         IE = IJ - IC + 1
         IF(CDATA2(IE:IE) .EQ. CBLNK4(1:1) .OR. CDATA2(IE:IE) .EQ. '\'
     1      .OR. CDATA2(IE:IE) .EQ. ';' .OR. CDATA2(IE:IE) .EQ. '(' .OR.
     2      CDATA2(IE:IE) .EQ. ')' .OR. CDATA2(IE:IE) .EQ. '/' .OR.
     3      CDATA2(IE:IE) .EQ. '=' .OR. CDATA2(IE:IE) .EQ. ',' .OR.
     4      CDATA2(IE:IE) .EQ. '+' .OR. CDATA2(IE:IE) .EQ. '-' .OR.
     5      CDATA2(IE:IE) .EQ. '*' .OR. CDATA2(IE:IE) .EQ. '&' .OR.
     6      CDATA2(IE:IE) .EQ. '[' .OR. CDATA2(IE:IE) .EQ. ']' .OR.
     7      CDATA2(IE:IE) .EQ. '{' .OR. CDATA2(IE:IE) .EQ. '}')
     8      GO TO 25
 24      CONTINUE
C
C       PARTITION THE LINE FOR PRINTING
C
 25      IF(IE .LE. IMAXC) THEN
            IF(ITYPE .EQ. 1) THEN
               L = LTRUE
               CALL CARCTL (CDATA2,L,CTITLE)
            END IF
            IXCNT = IXCNT - 1
            IG = IE
            II = J
C           IE = IE + 1
C
C     WRITE THE FIRST PART OF THE FOLDED LINE
C
            CALL NUMCNV (0)
            IF(ITYPE .EQ. 1) ID = ID + 1
            IF(L1) THEN
               L1 = LFALSE
               GO TO 30
            END IF
C
C         CREATE THE FORMAT TO WRITE A LINE OF THE LISTING
C
            CWFMT(1:41) = CBLK41(1:41)
            CWFMT(1:37) = CF103(1:14)//'/'//CFMT2(2:23)
            WRITE (IOUT,CWFMT) JX,JY,CLPARN,(CDATA2(I:I), I = ID,IE),
     1            CRPARN
C
C     DETERMINE POSTSCRIPT Y COORDINATE VALUE FOR THE NEXT LINE
C
            JY = JY - IDELTA
            IF(JY .LE. 0 .OR. JY .LT. IBMAR) THEN
               JY = IHEADY
               WRITE (IOUT,CF107)
               CALL HEADPR (L,CTITLE)
               IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
               IXCNT = -1
               GO TO 30
            END IF
            II = J
            IE = IE + 1
C
C     TEST FOR END OF THE PAGE
C
            IXCNT = IXCNT - 1
            IF(IXCNT .LE. 0) THEN
               L = LTRUE
               CALL HEADPR (L,CTITLE)
               IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
            END IF
C
C     WRITE THE SECOND PART OF THE FOLDED LINE WHEN NOT THE END OF A
C     PAGE OF PRINT
C
            IE = J - IE + 1
            IB = JX - IDELTA
            IH = IG + 1
            IF(ITYPE .EQ. 1) IH = IH + 1
            CALL NUMCNV (1)
            CFMT4(6:8) = CFMT2(5:7)
C
C         CREATE THE FORMAT TO WRITE A LINE OF THE LISTING
C
            CWFMT(1:41) = CBLK41(1:41)
            CWFMT(1:41) = CF103(1:14)//'/'//CFMT4(2:24)
            WRITE (IOUT,CWFMT) IB,JY,CLPARN,CASTER,CBLNK4(1:1),
     1            (CDATA2(I:I),I = IH,II),CRPARN
            IXCNT = IXCNT - 1
            JY = JY - IDELTA
            IF(JY .LE. 0 .OR. JY .LT. IBMAR) THEN
               JY = IHEADY
               WRITE (IOUT,CF107)
               CALL HEADPR (L,CTITLE)
               IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
               IXCNT = -1
               GO TO 30
            END IF
            DO 26 IE = 1,64
            CDATA(IE) = CBLNK4
 26         CONTINUE
C
C     TEST FOR END OF THE PAGE
C
            IF(IXCNT .LE. 0) THEN
               L = LTRUE
               WRITE (IOUT,CF107)
               CALL HEADPR (L,CTITLE)
               IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
            END IF
         END IF
 27      CONTINUE
      ELSE
C
C     THE DATA RECORD CAN BE PRINTED ON A SINGLE LINE;
C     DETERMINE IF A BLANK LINE IS TO BE WRITTEN
C
         IF(LWRBLK) THEN
            CDATA2(1:8) = '        '
            IE = 8
            I2 = 1
            I3 = 8
            GO TO 28
         END IF
C
C     CHECK IF CARRIAGE CONTROL CHARACTERS EXIST
C
         IF(ITYPE .EQ. 1) THEN
            L = LFALSE
            IF(NPAGE .EQ. 0) THEN
               JY = IHEADY - 2 * IDELTA
               JX = ILMAR + 1
            END IF
            IF(JY .EQ. IHEADY .AND. CDATA2(1:1) .EQ. '1') THEN
               CONTINUE
            ELSE IF(JY + 16 .EQ. IHEADY .AND. CDATA2(1:1) .EQ. '1')
     1         THEN
               CONTINUE
            ELSE IF(CDATA2(1:1) .EQ. '1' .AND. IHEADY .GT. JY) THEN
               CALL CARCTL(CDATA2,L,CTITLE)
            ELSE IF(CDATA2(1:1) .NE. '1') THEN
               CALL CARCTL (CDATA2,L,CTITLE)
            ELSE IF(NPAGE .EQ. 1) THEN
               CALL CARCTL (CDATA2,L,CTITLE)
            END IF
            I2 = 2
            I3 = J + 1
         ELSE
            I2 = 1
            I3 = J
         END IF
         IE = J
 28      CALL NUMCNV (0)
         IF(L1) THEN
            L1 = LFALSE
            IF(NPAGE .GT. 2) GO TO 30
         END IF
C
C         CREATE THE FORMAT TO WRITE A LINE OF THE LISTING
C
         CWFMT(1:41) = CBLK41(1:41)
         CWFMT(1:41) = CF103(1:14)//',1X,'//CFMT2(2:23)
         IF(JX .GT. 0 .AND. JY .GT. 0) THEN
            WRITE (IOUT,CWFMT) JX,JY,CLPARN,(CDATA2(I:I),I = I2,I3),
     1      CRPARN
         END IF
         IXCNT = IXCNT - 1
         JY = JY - IDELTA
C
C         DETERMINE IF AN END OF PRINTED PAGE HAS BEEN REACHED
C
         IF(JY .LE. 0 .OR. JY .LE. IBMAR) THEN
            IF(JY .EQ. IBMAR) THEN
               CONTINUE
            ELSE
               JY = IHEADY
           END IF
C
C         DETERMINE WHICH OUTPUT FILE IS TO BE WRITTEN
C
            FTEMP = FLOAT(NPAGE)/2.
            FEVEN = FTEMP - AINT(FTEMP)
            IF(FEVEN .EQ. 0.) THEN
               IF(LSPLIT) IOUT = 4
            ELSE
               IOUT = 2
            END IF
            IF(NPAGE .GT. 2) THEN
               WRITE (IOUT,CF107)
               L = .TRUE.
            END IF
            IF(JY .EQ. IBMAR) NPAGE = NPAGE + 1
            CALL HEADPR (L,CTITLE)
            IF(LORIE .AND. LSPLIT .AND. FEVEN .NE. 0.)
     1         WRITE (IOUT,CF101) IPSIZE(2)
            IF(ITYPE .EQ. 0) LSKIP = LTRUE
            IF(JY .EQ. IBMAR) JY = IHEADY
            GO TO 30
         END IF
         DO 29 IDX = 1,64
         CDATA3(IDX) = CBLNK4
 29      CDATA(IDX) = CBLNK4
C
C     TEST IF THE END OF A PAGE
C
         IF(JY .LE. 0 .OR. JY .LE. IBMAR) GO TO 20
      END IF
C
C     TEST FOR END OF THE PAGE
C
 30   IF(IXCNT .GT. 0) THEN
         DO 31 IDX = 1,64
         CDATA3(IDX) = CBLNK4
         CDATA(IDX) = CBLNK4
 31      CONTINUE
         GO TO 20
      ELSE
C
C     SET UP A NEW PAGE OF PRINT IN THE LISTING
C
         DO 32 IDX = 1,64
         CDATA3(IDX) = CBLNK4
         CDATA(IDX) = CBLNK4
 32      CONTINUE
C
C         DETERMINE THE UNIT NUMBER FOR THE OUTPUT PRINT FILE
C
         GO TO 19
      END IF
C
C     WRITE FINAL showpage AND THEN THE TRAILER
C
 33   WRITE (2,CF107)
      IF(.NOT.LSPLIT) THEN
         IB = NPAGE - 1
      ELSE IF(FEVEN .EQ. 0.) THEN
         IB = NPAGE - KPAGE - 1
      ELSE
         IB = NPAGE - KPAGE
      END IF
      WRITE (2,CF108) IB
      IF(LSPLIT) THEN
         WRITE (4,CF107)
         WRITE (4,CF108) KPAGE
      END IF
C
C         WHEN REVERSE ORDER OF THE EVEN PAGES HAS BEEN CHOSEN, CREATE
C         THE REVERSE LISTING FILE.
C
      CLOSE (UNIT = IIN, STATUS = 'DELETE')
      IF(LSPLIT) THEN
         ENDFILE (2)
         REWIND (2)
         ENDFILE (4)
         REWIND (4)
         CLOSE (UNIT = 2, STATUS = 'KEEP')
         IF(.NOT.LREV) CLOSE (UNIT = 4, STATUS = 'KEEP')
      END IF
      IF(LREV) THEN
         CFILE(1)(1:80) = CFILEE(1:80)
         CALL REVPRT
      END IF
C
C     CLOSE ALL FILES
C
      CLOSE (UNIT = 2, STATUS = 'KEEP')
      IF(LSPLIT) THEN
         IF(LREV) THEN
            REWIND (4)
            ENDFILE (7)
            REWIND (7)
            CLOSE (UNIT = 7, STATUS = 'KEEP')
            CLOSE (UNIT = 4, STATUS = 'DELETE')
         END IF
      END IF
C
C         CLOSE AND DELETE THE *.PRT INPUT FILE ON UNIT 6
C
      CLOSE (IIN)
C
C         PROGRAM EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     SUBROUTINE NUMCNV
C
C     PURPOSE
C
C     THIS ROUTINE CONVERTS A BINARY INTEGER NUMBER TO AN ASCII
C     CHARACTER FORMAT AND PLACES THE CHARACTERS IN THE FORMAT
C     STATEMENT CFMT2
C
C     MEANING OF THE VARIABLES
C
C         CBLNK4 - CHARACTER VARIABLE, 4 BLANKS
C         CDIGIT - THE TEN DIGITS 0 THROUGH 9 IN CHARACTER FORM
C         CFMT2  - THE FORMAT STATEMENT WHERE THE CONVERTED NUMBER WILL
C                  BE PLACED.  IT HAS THE STRUCTURE OF (XXXA1).  THIS
C                  SUBROUTINE WILL REPLACE THE XXX WITH THE VALUE OF IE
C                  PLUS 2.
C         IDIGIT - THE TEN DIGITS 0 THROUGH 9 IN INTEGER FORM
C         IDX    - SUBSCRIPT VARIABLE
C         IE     - THE LENGTH OF A LINE TO BE PRINTED
C         K      - THE VALUE OF IE PLUS 2
C         K1     - THE UNITS DIGIT OF K
C         K2     - THE TENS DIGIT OF K
C         K3     - THE HUNDREDS DIGIT OF K
C         N      - ADJUSTMENT VALUE OF IE WHEN A CONTINUATION LINE IS
C                  TO BE PRINTED. VALUE IS ZERO OR ONE.
C
C     *****************************************************************
C
      SUBROUTINE NUMCNV (N)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C     DIMENSION STATEMENTS
C
      DIMENSION CDIGIT(11), CPAGE(1000), CFILE(3), CFONT(10), IPSIZE(2)
C
C     TYPE STATEMENTS
C
      CHARACTER*1  CDIGIT
      CHARACTER*2  CPOINT
      CHARACTER*4  CBLNK4, CFONT
      CHARACTER*9  CDATE
      CHARACTER*8  CTIME
      CHARACTER*16 CPAGE
      CHARACTER*23 CFMT2
      CHARACTER*41 CBLK41
      CHARACTER*80 CFILE
      CHARACTER*1  CEND, CFINAL
      LOGICAL*1    LPAGE, LORIE, LREV, LSPLIT, L2
C
C     COMMON STATEMENTS
C
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
C
C         SAVE STATEMENT
C
      SAVE
C
C     DATA STATEMENTS
C
      DATA CDIGIT /'1','2','3','4','5','6','7','8','9','0',' '/
C
C     SEARCH FOR THE DIGITS OF VARIABLE IE
C
      CFMT2(5:7) = CBLNK4(1:3)
C
C     TEST IF ZERO LENGTH FOR OUTPUT LINE
C
      K = IE + 2
      IF(IE .EQ. 0) IE = 1
C
C     DETERMINE THE DIGITS OF VARIABLE IE
C
      IF(N .NE. 0) K = K + 1
      K3 = IE/100
      K2 = (IE - 100 * K3)/10
      K1 = (IE - 100 * K3 - 10 * K2)
      DO 10 IDX = 1,10
      IF(IDX .LT. 10) THEN
         IF(K1 .EQ. IDX) CFMT2(7:7) = CDIGIT(IDX)(1:1)
         IF(K2 .EQ. IDX) CFMT2(6:6) = CDIGIT(IDX)(1:1)
         IF(K3 .EQ. IDX) CFMT2(5:5) = CDIGIT(IDX)(1:1)
      ELSE
         IF(K1 .EQ. 0) CFMT2(7:7) = CDIGIT(IDX)(1:1)
         IF(K2 .EQ. 0) CFMT2(6:6) = CDIGIT(IDX)(1:1)
         IF(K3 .EQ. 0) CFMT2(5:5) = CDIGIT(IDX)(1:1)
      END IF
  10   CONTINUE
C
C     DELETE ZEROS IF THEY OCCURRED
C
      IF(CFMT2(5:5) .EQ. CDIGIT(10)) CFMT2(5:5) = CDIGIT(11)
      IF(CFMT2(6:6) .EQ. CDIGIT(10) .AND. CFMT2(5:5) .EQ. CDIGIT(11))
     1  CFMT2(6:6) = CDIGIT(11)
      IF(CFMT2(7:7) .EQ. CDIGIT(10) .AND. CFMT2(6:6) .EQ. CDIGIT(11)
     1  .AND. CFMT2(5:5) .EQ. CDIGIT(11)) CFMT2(7:7) = CDIGIT(11)
      RETURN
      END
C
C     *****************************************************************
C
C     PROGRAM HEADPR
C
C     PURPOSE
C
C     THIS PROGRAM WILL CREATE A HEADER AT THE TOP OF EVERY PRINTED
C     PAGE OF THE LISTING
C
C     MEANING OF THE VARIABLES
C
C         ALL VARIABLE NAMES STARTING WITH THE LETTER C ARE CHARACTER
C         VARIABLES. ALL VARIABLE NAMES STARTING WITH THE LETTER L
C         ARE LOGICAL VARIABLES. THE REMAINING VARIABLE NAMES CONFORM
C         TO THE FORTRAN DEFAULT STANDARD.
C
C         CBLNK4 - CHARACTER VARIABLE, FOUR BLANKS
C         CDATE  - CHARACTER VARIABLE, TODAY'S DATE
C         CFILE  - CHARACTER VARIABLE, THE PATH AND NAME OF THE FILE TO
C                  BE PRINTED
C         CFONT  - CHARACTER VARIABLE, NAME OF THE FONT TO BE USED BY
C                  THE PRINTER.  IT MUST BE EXACT NAME SPECIFIED BY
C                  THE FONT LIBRARY AND EXECTED BY THE POSTSCRIPT
C                  PRINTER.  THE NAMES ARE CASE SENSITIVE.
C         CF105  - CHARACTER VARIABLE, THE FORMAT TO SET THE POSTSCRIPT
C                  FONT CHOICE
C         CI8WK1 - CHARACTER VARIABLE, USED TO CREATE THE %%Page VALUES
C         CPOINT - CHARACTER VARIABLE, THE FONT POINT SIZE TO BE USED
C         C2WK1  - CHARACTER VARIABLE, WORK AREA TO CREATE THE LENGTH OF
C                  THE FONT NAME FOR FORMAT STATEMENT
C         I      - SUBSCRIPT VARIABLE
C         IDELTA - PS X DISTANCE BETWEEN PRINT LINES
C         IHEADY - PS Y COORDINATE VALUE FOR THE PAGE HEADER
C         ILENF  - LENGTH OF THE FONT NAME
C         ILMAR  - PS X LEFT MARGIN COORDINATE VALUE
C         IMAXL  - MARIMUM NUMBER OF PRINT LINES PER PAGE
C         IOUT   - THE UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT
C                  TO THE PRINTER, FORTRAN UNIT 2. WHEN REQUESTED, THIS
C                  FILE CONTAINS ODD NUMBERED PAGES ONLY.
C         IS     - X COORDINATE VALUE FOR THE PAGE HEADER
C         IT     - Y COORDINATE VALUE FOR THE PAGE HEADER
C         IXCNT  - COUNT OF THE NUMBER OF LINES PRINTED ON A PAGE THUS
C                  FAR
C         I2WK1  - WORK AREA
C         I2WK2  - WORK AREA
C         J4WK1  - WORK AREA, USED TO INDICATE AN EVEN OR ODD NUMBERED
C                  PAGE IS BEING PROCESSED
C         JOUT   - UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT TO
C                  THE PRINTER, BUT IT CONTAINS ONLY EVEN NUMBERED PAGES
C         JX     - THE X POINT COORDINATES OF THE NEXT PRINT LINE
C         JY     - THE Y POINT COORDINATES OF THE NEXT PRINT LINE
C                  LISTING PAGE HEADER
C         L      - LOGICAL VARIABLE, SET TRUE AFTER INITIALIZING THE
C                  LENGTH OF AXX IN VARIABLE CF101, SET FALSE INITIALLY
C         LA     - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST PAGE WHEN
C                  NO CARRIAGE CONTROL CHARACTERS EXIST IN THE FILE
C                  BEING PRINTED, SET FALSE INITIALLY. THIS PREVENTS A
C                  PREMATURE ISSUING OF A showpage COMMAND.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LORIE  - LOGICAL VARIABLE, SET FALSE IF PRINT ORIENTATION IS
C                  PORTRAIT, SET TRUE IF LANDSCAPE
C         LPAGE  - LOGICAL VARIABLE, SET TRUE THE %%Page IS WRITTEN,
C                  SET FALSE OTHERWISE
C         LSPLIT - LOGICAL VARIABLE, SET FALSE TO CREATE A SINGLE OUT-
C                  OUT FILE, SET TRUE TO CREATE A FILE OF ODD NUMBERED
C                  PAGES AND EVEN NUMBER PAGES. THIS ALLOWS PRINTING
C                  ON BOTH SIDES OF THE PAPER.
C         LTYPE  - LOGICAL VARIABLE, SET TRUE FOR A FILE WITH
C                  CARRIAGE CONTROL CHARACTERS, SET FALSE OTHERWISE
C         L2     - LOGICAL VARIABLE, SET FALSE FOR THE INITIAL PAGE OF
C                  PRINT, SET TRUE FOR ALL OTHER PAGES
C         NPAGE  - THE CURRENT PAGE NUMBER PRINTED IN THE HEADER
C         NPAGEB - THE CURRENT PAGE NUMBER FOR FILE C:\PSFILB.PRT
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         PAGENM
C
C     ******************************************************************
C
      SUBROUTINE HEADPR (L,CTITLE)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CFILE(3), CPAGE(1000), IPSIZE(2)
C
C     TYPE STATEMENTS
C
      CHARACTER*80 CFILE, CTITLE
      CHARACTER*46 CF105
      CHARACTER*40 CFONT
      CHARACTER*40 CF108
      CHARACTER*39 CF101
      CHARACTER*41 CBLK41, CWFMT
      CHARACTER*23 CFMT2
      CHARACTER*21 CF104
      CHARACTER*16 CPAGE
      CHARACTER*15 CF103
      CHARACTER*12 CF107
      CHARACTER*9  CDATE
      CHARACTER*8  CTIME, CI8WK1
      CHARACTER*4  CBLNK4
      CHARACTER*2  CPOINT, C2WK1, C2WK2
      CHARACTER*1  CEND, CFINAL
      LOGICAL*1    L, LA, LB, LFALSE, LPAGE, LORIE, LREV, LSPLIT,
     1             LTRUE, L2
      INTEGER*2    I2WK1, I2WK2
C
C     COMMON STATEMENTS
C
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
C
C     EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (I2WK1,C2WK1), (I2WK2,C2WK2), (CTIME(1:2),IHOUR)
C
C         SAVE STATEMENT
C
      SAVE
C
C         PARAMETER STATEMENTS
C
      PARAMETER (LTRUE=.TRUE., LFALSE=.FALSE.)
C
C     DATA STATEMENTS
C
      DATA CF105 /'(''/'',AXX,'' findfont '',A2,'' scalefont setfont'')'
     1/
      DATA LA/.FALSE./, LB/.FALSE./
C
C     FORMAT STATEMENTS
C
 100  FORMAT('/Bookman-Light findfont 10 scalefont setfont'/
     12I5,' moveto')
 102  FORMAT('(',5X,'FILE:  ',A28,') show')
 103  FORMAT('(',5X,'FILE:  ',A40,') show')
 105  FORMAT('(DATE: ',A9,2X,'TIME: ',A8,2X,'PAGE ',I3,')',1X,'show')
C
C     SET THE X AND Y VALUES FOR THE PAGE'S PRINTED HEADER
C
      IS = 2
      IT = IHEADY
C
C     DETERMINE IF A SPLIT LISTING IS WANTED
C
      IF(LSPLIT .AND. LA) THEN
C
C         DETERMINE IF THE LAST WRITE WAS ON UNIT 2
C
         FTEMP = FLOAT(NPAGE)/2.
         FEVEN = FTEMP - AINT(FTEMP)
         IF(FEVEN .EQ. 0.) THEN
C
C         DETERMINE IF REVERSE ORDER IS TO BE CREATED
C
            IOUT = JOUT
            GO TO 10
         END IF
         IF(IOUT .EQ. JOUT .OR. IOUT .EQ. JOUTW) THEN
C
C         DETERMINE WHICH OUTPUT FILE IS TO BE WRITTEN
C
            IF(FEVEN .EQ. 0.) THEN
               IF(LSPLIT) IOUT = 4
            ELSE
               IOUT = 2
            END IF
         END IF
      ELSE
         IF(LSPLIT) THEN
            FTEMP = FLOAT(NPAGE)/2.
            FEVEN = FTEMP - AINT(FTEMP)
            IF(FEVEN .EQ. 0.) THEN
               IOUT = 4
            ELSE
               IOUT = 2
            END IF
         END IF
      END IF
C
C         DETERMINE IF THIS IS THE SECOND PAGE OF OUTPUT
C
 10   CALL PAGENM (CI8WK1)
C
C         WRITE THE POSTSCRIPT PAGE NUMBER COMMENT
C
      IF(NPAGE .EQ. 2) THEN
         WRITE (IOUT,CF107)
      END IF
      WRITE (IOUT,CF104)
C
C     WRITE INITIAL POSTSCRIPT FONT AND POINT SIZE COMMANDS AND
C     SET THE CURRENT POSITION TO THE TOP OF THE PAGE
C     THIS STARTS A NEW PAGE OF THE LISTING
C
C     WRITE THE POSTSCRIPT FILE HEADER FONT CHOICE
C
      IF(ITYPE .EQ. 0) WRITE (IOUT,100) IS,IT
C
C     SET NEXT PRINT LINE POINT COORDINATES
C
      JY = IHEADY - 2 * IDELTA
      JX = ILMAR
C
C     ADJUST LEFT MARGIN WHEN CARRIAGE CONTROL DATA IS BEING PRINTED
C
      IF(ITYPE .EQ. 1) JX = JX + 1
C
C     MODIFY VARIABLE CF105 FORMAT AXX LENGTH
C
      IF(L) THEN
         I2WK1 = 0
         I2WK2 = 0
         IF(ILENF .LT. 10) THEN
C
C     THE FIELD LENGTH IS LESS THAN 10, CONVERT THE NUMERIC TO ALPHA
C
            I2WK1 = ILENF + 48
            CF105(8:8) = CBLNK4(1:1)
            CF105(7:7) = C2WK1(1:1)
         ELSE
C
C     THE FIELD LENGTH IS GREATER THAN OR EQUAL TO 10
C
            I2WK1 = ILENF/10
            I2WK2 = ILENF - (10 * I2WK1) + 48
            I2WK1 = I2WK1 + 48
            CF105(7:7) = C2WK1(1:1)
            CF105(8:8) = C2WK2(1:1)
         END IF
         L = LFALSE
      END IF
C
C     SET LOOP FOR THE NUMBER OF LINES THAT CAN BE PRINTED PER PAGE
C
      IXCNT = IMAXL
C
C     TEST IF CARRIAGE CONTROL IS PRESENT IN THE LISTING
C     IF PRESENT, NO PAGE HEADER WILL BE PRINTED
C
      IF(ITYPE .EQ. 1) GO TO 11
C
C     WRITE A HEADER FOR EACH PAGE OF OUTPUT TO BE PRINTED ACCORDING
C     TO PAPER ORIENTATION
C
      IF(LORIE) THEN
         WRITE (IOUT,103) CTITLE(1:48)
         JX = 492
         WRITE (IOUT,CF103) JX,IHEADY
         WRITE (IOUT,105) CDATE,CTIME(1:8),NPAGE
      ELSE
         WRITE (IOUT,102) CTITLE(1:28)
         JX = 358
         WRITE (IOUT,CF103) JX,IHEADY
         WRITE (IOUT,105) CDATE,CTIME(1:8),NPAGE
      END IF
C
C     SET NEXT LINE COORDINATES
C
      JX = ILMAR
      JY = JY - IDELTA
C
C     SET FONT CHOICE AND POINT SIZE FOR THE TEXT TO BE PRINTED
C
 11   WRITE (IOUT,CF105) CFONT(1:ILENF),CPOINT
      IF(LORIE) WRITE (IOUT,CF101) IPSIZE(2)
C
C         INCREMENT PAGE COUNT
C
      IF(.NOT.L2) THEN
         L2 = LTRUE
      ELSE
         IF(IEND .NE. -1) THEN
            NPAGE = NPAGE + 1
            LPAGE = LTRUE
         END IF
         FTEMP = FLOAT(NPAGE)/2.
         FEVEN = FTEMP - AINT(FTEMP)
      END IF
C
C         SET SWITCH TO INDICATE THE FIRST PAGE HAS BEEN PROCESSED
C
      IF(LSPLIT) THEN
         IF(FEVEN .NE. 0.) LB = LTRUE
      ELSE
         LA = LTRUE
      END IF
C
C     ROUTINE END
C
      RETURN
      END
C
C     *****************************************************************
C
C     SUBROUTINE CARCTL
C
C     PURPOSE
C
C     THIS ROUTINE WILL CONTROL PRINT SPACING WHEN CARRIAGE CONTROL
C     CHARACTERS FOR A PRINTER ARE THE FIRST CHARACTER OF EACH RECORD
C
C     MEANING OF THE VARIABLES
C
C         CDATA2 - CHARACTER VARIABLE LENGTH 1, SAVE AREA FOR CDATA1 TO
C                  PROVIDE REPLACEMENT OF '(' AND ')' WITH '\(' AND '\)'
C                  IN THE INPUT DATA.  THIS ALLOWS CORRECT PRINTING.
C         CFORMF - CHARACTER VARIABLE, A FORM FEED CHARACTER
C         CF101  - CHARACTER VARIABLE, FORMAT TO ROTATE PRINT TO LAND-
C                  SCAPE ORIENTATION
C         CF103  - CHARACTER VARIABLE, FORMAT TO PLACE CURSOR ON THE
C                  POSTSCRIPT PAGE, I.E., MOVETO
C         CF107  - CHARACTER VARIABLE, FORMAT TO ISSUE SHOWPAGE POST-
C                  SCRIPT COMMAND
C         IE     - LENGTH OF A LINE OF PRINT
C         IG     - WORK AREA TO PRINT A CONTINUATION OF A LINE THAT CAN
C                  FIT ON A SINGLE LINE OF PRINT
C         II     - THE LAST CHAACTER OF THE PRINT LINE WHEN IT IS
C                   PRINTED ON TWO OR MORE LINES
C         IMAXL  - MAXIMUM NUMBER OF PRINT LINES PER PAGE
C         IOUT   - THE UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT
C                  TO THE PRINTER, FORTRAN UNIT 2. WHEN REQUESTED, THIS
C                  FILE CONTAINS ODD NUMBERED PAGES ONLY.
C                  TO THE PRINTER, FORTRAN UNIT 2
C         IPSIZE - VERTICAL AND HORIZONTAL DIMENSIONS OF THE PAPER USED
C                  IN PRINTING; WORD 1 IS THE VERTICAL (Y) DIMENSION,
C                  AND WORD 2 IS THE HORIZONTAL (X) DIMENSION IN POINTS
C         IXCNT  - COUNT OF THE NUMBER OF LINES PRINTED ON A PAGE THUS
C                  FAR
C         JOUT   - UNIT NUMBER FOR THE POSTSCRIPT FILE TO BE SENT TO
C                  THE PRINTER, BUT IT CONTAINS ONLY EVEN NUMBERED PAGES
C         JY     - THE Y POINT COORDINATES OF THE NEXT PRINT LINE
C         L      - LOGICAL VARIABLE, SET TRUE WHEN A FOLDED LINE FOR
C                  THE OUTPUT LISTING, SET FALSE FOR A SINGLE LINE
C         LA     - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST PAGE WHEN
C                  NO CARRIAGE CONTROL CHARACTERS EXIST IN THE FILE
C                  BEING PRINTED, SET FALSE INITIALLY. THIS PREVENTS A
C                  PREMATURE ISSUING OF A showpage COMMAD.
C         LORIE  - LOGICAL VARIABLE, SET FALSE IF PRINT ORIENTATION IS
C                  PORTRAIT, SET TRUE IF LANDSCAPE
C         LONCEA - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST PAGE OF
C                  THE SINGLE OUTPUT LISTING OR THE ODD PAGES LISTING
C                  IS WRITTEN
C         LONCEB - LOGICAL VARIABLE, SET TRUE AFTER THE FIRST PAGE OF
C                  THE EVEN PAGE LISTING IS WRITTEN
C         LTYPE  - LOGICAL VARIABLE, SET TRUE FOR A FILE WITH
C                  CARRIAGE CONTROL CHARACTERS, SET FALSE OTHERWISE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE TOP OF THE
C                  NEXT PAGE POINTS VALUE HAS BEEN SET, SET FALSE
C                  OTHERWISE. THIS WILL PREVENT AA BLANK PAGE OF PRINT.
C         L2     - LOGICAL VARIABLE, SET FALSE FOR THE INITIAL PAGE OF
C                  PRINT, SET TRUE FOR ALL OTHER PAGES
C         NPAGE  - THE CURRENT PAGE NUMBER PRINTED IN THE HEADER
C         NPAGEB - COUNT OF PAGES FOR THE EVEN PAGE LISTING
C         NPAGEC - WORK AREA
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         HEADPR
C
C     *****************************************************************
C
      SUBROUTINE CARCTL (CDATA2,L,CTITLE)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C     DIMENSION STATEMENTS
C
      DIMENSION CFILE(3), CPAGE(1000), IPSIZE(2)
C
C     TYPE STATEMENTS
C
      CHARACTER*256 CDATA2
      CHARACTER*80  CFILE, CTITLE
      CHARACTER*40  CFONT
      CHARACTER*40  CF108
      CHARACTER*39  CF101
      CHARACTER*41  CBLK41, CWFMT
      CHARACTER*23  CFMT2
      CHARACTER*15  CF103
      CHARACTER*21  CF104
      CHARACTER*16  CPAGE
      CHARACTER*12  CF107
      CHARACTER*9   CDATE
      CHARACTER*8   CTIME
      CHARACTER*4   CBLNK4
      CHARACTER*2   CPOINT
      CHARACTER*1   CEND, CFINAL, CFORMF
      LOGICAL*1     L, LA, LONCEA, LONCEB, LPAGE, LORIE, LREV,
     1              LSPLIT, L1, L2
      LOGICAL*1     LTRUE, LFALSE
C
C     COMMON STATEMENTS
C
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
C
C         SAVE STATEMENT
C
      SAVE
C
C         PARAMETER STATEMENTS
C
      PARAMETER (LTRUE=.TRUE.,LFALSE=.FALSE.)
C
C         DATA STATEMENTS
C
      DATA LA/ .FALSE./, LONCEA/.FALSE./, LONCEB/.FALSE./, CFORMF/'0C'X/
C
C     TEST FOR CARRIAGE CONTROL CHARACTERS
C     TEST IF SINGLE SPACING
C
      IF(CDATA2(1:1) .EQ. CBLNK4(1:1)) GO TO 11
C
C     TEST IF DOUBLE SPACING
C
      IF(CDATA2(1:1) .EQ. '0') THEN
         JY = JY - IDELTA
         IF(JY .LE. 0 .OR. JY .LT. IBMAR) THEN
            WRITE (IOUT,CF107)
            GO TO 10
         END IF
         IXCNT = IXCNT - 1
         GO TO 11
      END IF
C
C     TEST IF THE START OF A NEW PAGE.
C
      L1 = LFALSE
      IF(CDATA2(1:1) .EQ. '1' .OR. CDATA2(1:1) .EQ. CFORMF(1:1)) THEN
         IF(IOUT .EQ. 2 ) THEN
            IF(.NOT.L2) L2 = LTRUE
            NPAGEC = NPAGE
         ELSE
            IF(.NOT.L2) L2 = LTRUE
            NPAGEC = NPAGEB
         END IF
C
C         DETERMINE WHICH OUTPUT FILE IS TO BE WRITTEN
C
         IF(FEVEN .EQ. 0.) THEN
            IF(LSPLIT) IOUT = 4
         ELSE
            IOUT = 2
         END IF
         IF(IOUT .EQ. 2) THEN
            IF(LONCEA) THEN
               IF(NPAGE .GT. 2) WRITE (IOUT,CF107)
            ELSE
               LONCEA = LTRUE
               LONCEB = LTRUE
            END IF
         ELSE
            IF(LONCEB) THEN
               IF(NPAGE .GT. 2) THEN
                  WRITE (IOUT,CF107)
               END IF
            ELSE
               LONCEB = LTRUE
            END IF
         END IF
C
C         DETERMINE THE UNIT NUMBER FOR THE OUTPUT PRINT FILE
C
         IF(LSPLIT .AND. LA) THEN
C
C         DETERMINE THE UNIT VALUE USED
C
            IF(IOUT .EQ. 2) THEN
               IOUT = JOUT
               GO TO 10
            END IF
            IF(IOUT .EQ. JOUT .OR. IOUT .EQ. JOUTW) IOUT = 2
         END IF
      END IF
C
C         NEW PAGE
C
 10   IXCNT = IMAXL
      JY = IHEADY
      IG = IE
      IE = IE + 1
      L = LTRUE
      CALL HEADPR (L,CTITLE)
C
C     DO NOT ADVANCE TO THE NEXT LINE
C
      IF(CDATA2(1:1) .EQ. '+') THEN
C
C     BACKUP TWO LINES IF THE PRINT LINE IS FOLDED; ONE LINE IF THE
C     PRINT LINE IS NOT FOLDED
C
         IF(L) THEN
            IXCNT = IXCNT + 1
            JY = JY + IDELTA
         END IF
         IXCNT = IXCNT + 1
         JY = JY + IDELTA
      END IF
C
C         SET LOGICAL SWITCH TO INDICATE THE FIRST PAGE HAS BEEN WRITTEN
C
 11   LA = LTRUE
C
C     END OF ROUTINE
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE CREATES THE POSTSCRIPT %%Page: VALUES
C
C     MEANING OF THE VARIABLES
C
C         CI8WK1 - CHARACTER VARIABLE, WORK AREA TO CREATE THE PAGE
C                  NUMBER FOR %%Page, CHARACTER FORM OF I8WK1. THIS
C                  VALUE IS DERIVED FROM NPAGE.
C         CI8WK2 - CHARACTER VARIABLE, WORK AREA TO CREATE THE PAGE
C                  NUMBER FOR %%Page, CHARACTER FORM OF I8WK2. THIS
C                  VALUE IS DERIVED FROM KPAGE
C         CI8WK3 - CHARACTER VARIABLE, WORK AREA TO CREATE THE PAGE
C                  NUMBER FOR %%Page, CHARACTER FORM OF I8WK3. THIS
C                  VALUE IS DERIVED FROM JPAGE
C         CBLNK4 - CHARACTER VARIABLE, FOUR BLANKS
C         I2WK1  - WORK AREA
C         I4WK1  - INTEGER FORM OF CI4WK1, EQUIVALENCED TO CI4WK1
C         JPAGE  - THE CURRENT PAGE NUMBER PRINTED IN THE HEADER FOR ODD
C                  PAGES
C         KPAGE  - THE CURRENT PAGE NUMBER PRINTED IN THE HEADER FOR
C                  EVEN PAGES
C         LSPLIT - LOGICAL VARIABLE, SET FALSE TO CREATE A SINGLE OUT-
C                  OUT FILE, SET TRUE TO CREATE A FILE OF ODD NUMBERED
C                  PAGES AND EVEN NUMBER PAGES. THIS ALLOWS PRINTING
C                  ON BOTH SIDES OF THE PAPER.
C         L1     - LOGICAL VARIABLE, SET TRUE AFTER NPAGEE AND NPAGEO
C                  ARE INITIALIZED. THIS PREVENTS THEM FROM CHANGED ONCE
C                  INITIALIZED.
C         NPAGE  - TOTAL PAGE COUNT IN THE ENTIRE PRINT DOCUMENT
C
C     ******************************************************************
C
      SUBROUTINE PAGENM (CI8WK1)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CFILE(3), CPAGE(1000), IPSIZE(2)
C
C         TYPE STATEMENTS
C
      CHARACTER*80  CFILE
      CHARACTER*40  CFONT
      CHARACTER*40  CF108
      CHARACTER*39  CF101
      CHARACTER*41  CBLK41, CWFMT
      CHARACTER*23  CFMT2
      CHARACTER*15  CF103
      CHARACTER*21  CF104
      CHARACTER*16  CPAGE
      CHARACTER*12  CF107
      CHARACTER*9   CDATE
      CHARACTER*8   CTIME, CI8WK1, CI8WK2, CI8WK3
      CHARACTER*4   CBLNK4
      CHARACTER*2   CPOINT
      CHARACTER*1   CEND, CFINAL
      LOGICAL*1     LPAGE, LORIE, LREV, LSPLIT, L2
C
C     COMMON STATEMENTS
C
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
C
C         SAVE STATEMENT
C
      SAVE
C
C        DATA STATEMENTS
C
      DATA JPAGE/0/
C
C     FORMAT STATEMENTS
C
 100  FORMAT(I8)
 101  FORMAT(' MORE THAN 10,000 EVEN NUMBERED PAGES')
 102  FORMAT(' MORE THAN 10,000  PAGES')
C
C         DETERMINE IF THE PAGE NUMBER IS EVEN; FEVEN IS ZERO WHEN
C         THE PAGE NUMBER IS EVEN. COMPUTE THE CPAGE SUBSCRIPT INSERTION
C         VALUE.
C
      FTEMP = FLOAT(NPAGE)/2.
      FEVEN = FTEMP - AINT(FTEMP)
      IF(FEVEN .EQ. 0.) THEN
         KPAGE = KPAGE + 1
         IF(KPAGE .GT. 10000) WRITE (IOUT,101)
      ELSE
         JPAGE = JPAGE + 1
         IF(JPAGE .GT. 10000) WRITE (IOUT,102)
      END IF
C
C         CREATE THE PAGE NUMBER IN TEXT FORM FOR THE POSTSCRIPT PAGE
C         NUMBER.
C
      CF104(11:19) = CBLNK4(1:4)//CBLNK4(1:4)//CBLNK4(1:1)
      CI8WK1(1:4) = CBLNK4(1:4)//CBLNK4(1:4)
      CI8WK2(1:4) = CBLNK4(1:4)//CBLNK4(1:4)
      CI8WK3(1:4) = CBLNK4(1:4)//CBLNK4(1:4)
      WRITE (CI8WK1,100) NPAGE
      IF(FEVEN .EQ. 0.) THEN
         WRITE (CI8WK2,100) KPAGE
      ELSE
         WRITE (CI8WK3,100) JPAGE
      END IF
C
C         SET THE TEXT FORM OF THE PAGE NUMBER IN FORMAT CF104
C
      IF(NPAGE .LT. 10) THEN
C
C         PAGE NUMBER IS LESS THAN 10; ONE CHARACTER FIELD LENGTH
C
         CF104(11:11) = CI8WK1(8:8)
         IF(.NOT.LSPLIT) THEN
            CF104(13:13) = CI8WK1(8:8)
         ELSE
            IF(FEVEN .EQ. 0.)  THEN
               CF104(13:13) = CI8WK2(8:8)
            ELSE
               CF104(13:13) = CI8WK3(8:8)
            END IF
         END IF
C
C         PAGE NUMBER IS LESS THAN 100; TWO CHARACTER FIELD
C
      ELSE IF(NPAGE .LT. 100 .AND. NPAGE .GE. 10) THEN
         CF104(11:12) = CI8WK1(7:8)
         IF(.NOT.LSPLIT) THEN
            CF104(14:15) = CI8WK1(7:8)
         ELSE
            IF(FEVEN .EQ. 0.)  THEN
               CF104(14:15) = CI8WK2(7:8)
            ELSE
               CF104(14:15) = CI8WK3(7:8)
            END IF
         END IF
C
C         PAGE NUMBER IS LESS THAN 1000; THREE CHARACTER FIELD
C
      ELSE IF(NPAGE .LT. 1000 .AND. NPAGE .GE. 100) THEN
         CF104(11:13) = CI8WK1(6:8)
         IF(.NOT.LSPLIT) THEN
            CF104(15:17) = CI8WK1(6:8)
         ELSE
            IF(FEVEN .EQ. 0.)  THEN
               CF104(15:17) = CI8WK2(6:8)
            ELSE
               CF104(15:17) = CI8WK3(6:8)
            END IF
         END IF
C
C         PAGE NUMBER IS LESS THAN 10000; FOUR CHARACTER FIELD
C
      ELSE IF(NPAGE .LT. 10000 .AND. NPAGE .GE. 1000) THEN
         CF104(11:14) = CI8WK1(5:8)
         IF(.NOT.LSPLIT) THEN
            CF104(16:19) = CI8WK1(5:8)
         ELSE
            IF(FEVEN .EQ. 0.)  THEN
               CF104(16:19) = CI8WK2(5:8)
            ELSE
               CF104(16:19) = CI8WK3(5:8)
            END IF
         END IF
      END IF
C
C         INSERT THE EVEN PAGE VALUE INTO ITS SAVE AREA. THIS TABLE
C         IS USED TO REVERSE THE PAGE ORDER WHEN REQUESTED.
C
      IF(KPAGE .LE. 10000 .AND. FEVEN .EQ. 0.) CPAGE(KPAGE)(1:17) =
     1   CF104(3:19)
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE CREATES AN EVEN PAGE POSTSCRIPT OUTPUT FILE WITH
C         THE PAGES WRITTEN IN REVERSE ORDER
C
C     MEANING OF THE VARIABLES
C
C         CBLNK4 - CHARACTER VARIABLE, 4 BLANKS
C         CEND   - CHARACTER VARIABLE, HEX 0A CONSTANT
C         CFILE  - CHARACTER VARIABLE, THE PATH AND NAME OF THE INPUT
C                  FILE, AND THE OUTPUT FILES. SUBSCRIPT VALUES ARE
C                  SHOWN IN THE TABLE BELOW:
C                  VALUE  MEANING
C                    1    CONTAINS THE EVEN PAGES PRINT FILE NAME
C                    2    CONTAINS THE ODD PAGES PRINT FILE NAME
C                    3    CONTAINS THE INPUT FILE TO BE PROCESSED
C         CFILEE - CHARACTER VARIABLE, THE PATH AND NAME OF THE FILE TO
C                  BE PRINTED AS READ FROM THE CONTROL CARD.
C         CFILER - THE ODD PAGE NUMBERS OUTPUT FILE NAME
C         CFINAL - CHARACTER VARIABLE, HEX '1A'
C         CFMTX  - CHARACTER VARIABLE, THE FORMAT USED TO WRITE EACH
C                  POSTSCRIPT RECORD FROM UNIT4 ONTO UNIT 2
C         FEVEN  - INDICATOR FOR EVEN OR ODD NUMBER OF PAGES. THE VALUE
C                  IS ZERO OF EVEN, AND ANY OTHER VALUE FOR ODD
C         FTEMP  - COMPUTED VALUE OF THE NUMBER OF PAGES DIVIDED BY 2
C         CI4WK1 - CHARACTER VARIABLE, WORK AREA TO SET THE LENGTH OF
C                  A RECORD TO BE WRITTEN ON UNIT 2 IN THE FORMAT CFMTX
C         CPAGE  - CHARACTER VARIABLE, LIST OF EVEN PAGES IN THE
C                  POSTSCRIPT OUTPUT FILE TO BE PRINTED
C         CREC   - THE INPUT BUFFER WORK AREA FOR THE POSTSCRIPT RECORDS
C         I      - SUBSCRIPT VARIABLE, ALSO DETERMINES THE LENGTH OF THE
C                  RECORD READ FROM UNIT 4 WITHOUT THE 'ODOA' TRAILER
C         IA     - USED IN THE SAME MANNER AS I
C         IEND   - INPUT STATUS VARIABLE, SET TO -1 ON END OF FILE
C         IPAGEN - NEW PAGE NUMBER FOR EVEN PAGES OUTPUT FILE IN REVERSE
C                  ORDER
C         ITEMP  - NUMBER OF EVEN PAGES IN THE OUTPUT LISTING
C         NPAGE  - TOTAL NUMBER OF PAGES TO BE PRINTED
C         J      - SUBSCRIPT VARIABLE
C         JOUT   - VARIABLE UNIT VALUE OF 4
C         JOUTW  - VARIABLE UNIT VALUE OF 7
C         KPAGE  - COUNT OF THE NUMBER OF EVEN PAGES IN THE OUTPUT FILE
C         LEXIST - LOGICAL VARIABLE, SET TRUE IS A FILE EXISTS,SET
C                  FALSE OTHERWISE
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO A LOGICAL FALSE
C         LREV   - LOGICAL VARIABLE, SET TRUE WHEN EVEN NUMBERED PAGES
C                  ARE TO BE WRITTEN IN REVERSE ORDER, SET FALSE WHEN
C                  THEY ARE TO BE WRITTEN IN NORMAL ORDER. THIS VARIABLE
C                  HAS NO EFFECT IF LSPLIT EQUALS .FALSE.
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST NONBLANK
C                  CHARACTER OF %%Page: IS FOUND, SET FALSE OTHERWISE.
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN %%Page: IS FOUND THAT
C                  MATCHES THE VALUE IN CPAGE(I), SET FALSE UNTIL A
C                  MATCH IS FOUND. THIS FORCES ALL RECORDS BETWEEN A
C                  %%Page: AND showpage TO BE WRITTEN ON UNIT 7.
C
C     ******************************************************************
C
      SUBROUTINE REVPRT
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CFILE(3), CPAGE(1000), IPSIZE(2)
C
C     TYPE STATEMENTS
C
      CHARACTER*170 CREC
      CHARACTER*80  CFILE, CFILEE, CFILER
      CHARACTER*40  CFONT
      CHARACTER*40  CF108
      CHARACTER*39  CF101
      CHARACTER*41  CBLK41, CWFMT
      CHARACTER*23  CFMT2
      CHARACTER*15  CF103
      CHARACTER*21  CF104
      CHARACTER*16  CPAGE
      CHARACTER*12  CF107
      CHARACTER*9   CDATE
      CHARACTER*8   CTIME
      CHARACTER*6   CFMTX
      CHARACTER*4   CBLNK4, CI4WK1
      CHARACTER*3   CNPAGE
      CHARACTER*2   CPOINT
      CHARACTER*1   CEND, CFINAL
      LOGICAL*4     LEXIST
      LOGICAL*1     LFALSE, LORIE, LPAGE, LREV, LSPLIT, LTRUE, L1, L2
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CFILE(1)(1:80),CFILEE(1:80))
C
C     COMMON STATEMENTS
C
      COMMON /PAGEST/ FEVEN, FTEMP, IBMAR, IDELTA, IDX, IEND, IHEADY,
     1ILENF, ILMAR, IMAXL, IOUT, IPSIZE, ITYPE, IXCNT, JOUT, JOUTW,
     2JX, JY, J4WK1, KPAGE, NPAGE, NPAGEB, CEND, CDATE, CFILE, CFINAL,
     3CFONT, CPOINT, CTIME, LORIE, LPAGE, LSPLIT, LREV, L2
      COMMON /FMTS/ CF101, CF103, CF104, CF107, CF108, CWFMT
      COMMON /CFMTWK/ CBLNK4, CBLK41, IE, CFMT2, CPAGE
C
C         SAVE STATEMENT
C
      SAVE
C
C         PARAMETER STATEMENTS
C
      PARAMETER (LTRUE=.TRUE., LFALSE=.FALSE.)
C
C         DATA STATEMENTS
C
      DATA CFMTX/'(A   )'/, CNPAGE/'   '/
C
C         FORMAT STATEMENTS
C
 100  FORMAT(I4)
 101  FORMAT(A170)
 102  FORMAT(A14)
 103  FORMAT(I3)
C
C         SET WORK AREA FOR THE NEW PAGE COUNT FOR %%Page TO BLANKS
C
      CNPAGE(1:3) = CBLNK4(1:3)
      KPAGEN = 0
C
C         CREATE FILE NAME FOR THE REVERSE EVEN PAGES FILE
C
      CFILER(1:80) = CFILEE(1:80)
      DO 10 IDX = 80,1,-1
      IF(CFILER(IDX:IDX) .EQ. '.') THEN
         CFILER(IDX-1:IDX+3) = 'R.PS'
         GO TO 11
      END IF
 10   CONTINUE
C
C         OPEN THE REVERSE EVEN PAGE FILE
C
 11   INQUIRE (FILE = CFILER,EXIST = LEXIST)
      IF(LEXIST) THEN
         OPEN (UNIT = 7,FILE = CFILER)
         CLOSE (UNIT = 7,STATUS = 'DELETE')
      END IF
      OPEN (UNIT = 7, ACCESS = 'SEQUENTIAL', FILE = CFILER,
     1      FORM = 'FORMATTED', ACTION = 'WRITE', RECL=168,
     2      STATUS = 'KEEP')
C
C         COPY THE POSTSCRIPT HEADER FROM UNIT 4 TO UNIT 7
C
 12   DO 13 IDX = 1,42
      IA = 1 + 4*(IDX-1)
      IB = IA + 3
      CREC(IA:IB) = CBLNK4(1:4)
 13   CONTINUE
      READ (4,101,IOSTAT = IEND) CREC
C
C         DETERMINE IF AN END OF FILE EXITS
C
      IF(IEND .EQ. -1) STOP 'REVPRT ERROR 3'
C
C         LOOP TO FIND RECORD LENGTH
C
      DO 14 IDX = 168,1,-1
C
C         DETERMINE IF AN END OF RECORD EXISTS
C
      IF(CREC(IDX:IDX) .NE. CBLNK4(1:1)) GO TO 15
 14   CONTINUE
C
C         DETERMINE IF A %%Page RECORD HAS BEEN READ; THE FIRST SUCH
C         RECORD TERMINATES PROCESSING OF THE POSTSCRIPT HEADER.
C
 15   IF(CREC(1:7) .EQ. '%%Page:') GO TO 16
C
C         CONVERT THE RECORD LENGTH TO TEXT FORM
C
      CI4WK1(1:4) = CBLNK4(1:4)
      CFMTX(3:5) = CBLNK4(1:3)
      WRITE (CI4WK1,100) IDX
C
C         CREATE THE FORMAT TO WRITE THE RECORD ON UNIT 4
C
      IF(CI4WK1(3:3) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:3) = CI4WK1(4:4)
      ELSE IF(CI4WK1(2:2) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:4) = CI4WK1(3:4)
      ELSE IF(CI4WK1(1:1) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:5) = CI4WK1(2:4)
      END IF
C
C         WRITE A POSTSCRIPT HEADER RECORD ON UNIT 7
C
      WRITE (7,CFMTX) CREC(1:IDX)
      GO TO 12
C
C         DETERMINE IF THE TOTAL NUMBER OF PAGES FOR THE CURRENT
C         DOCUMENT IS EVEN OR ODD. VARIABLE FEVEN HAS A VALUE OF ZERO
C         WHEN THE FINAL PAGE IS EVEN; IT HAS A VALUE GREATER THAN
C         ZERO WHEN THE FINAL PAGE IS ODD.
C
 16   FTEMP = FLOAT(NPAGE)/2.
      ITEMP = INT(FTEMP)
      FEVEN = FTEMP - AINT(FTEMP)
C
C         WHEN THE TOTAL NUMBER OF PAGES IN THE DOCUMENT BEING PRINTED
C         IS ODD, FORCE AN EJECT OF THE LAST ODD PAGE SINCE IT CAN
C         NOT HAVE A MATCHING EVEN PAGE.
C
      IF(FEVEN .GT. 0.) WRITE (7,CF107)
C
C         THE INITIAL %%Page RECORD WAS FOUND; SET LOOP TO PROCESS EACH
C         PAGE IN REVERSE ORDER.
C
      DO 29 IDX = KPAGE,1,-1
C
C         SET THE SWITCH TO PREVENT WRITING OF RECORDS BETWEEN %%Page
C         AND showpage UNTIL A PAGE MATCH EXISTS WITH CPAGE(I)
C
      L2 = LFALSE
      REWIND (4)
C
C         FILL THE INPUT BUFFER WITH BLANKS; SEARCH FOR THE START OF
C         A PAGE.
C
 17   DO 18 J = 1,42
      IA = 1 + 4*(J-1)
      IB = IA + 3
      CREC(IA:IB) = CBLNK4(1:4)
 18   CONTINUE
C
C         READ A RECORD FROM UNIT 4
C
      READ (4,101,IOSTAT = IEND) CREC
      IF(CPAGE(IDX)(1:16) .NE. CREC(1:16)) GO TO 17
C
C         TEST FOR AN END OF FILE. THIS CONDITION SHOULD NEVER BE
C         REACHED.
C
      IF(IEND .EQ. -1) STOP 'REVPRT ERROR 1'
C
C         LOOP TO FIND RECORD LENGTH
C
      DO 19 IA = 168,1,-1
      IF(CREC(IA:IA) .NE. CBLNK4(1:1)) GO TO 20
 19   CONTINUE
C
C         DETERMINE IF THE END OF A PAGE HAS BEEN FOUND
C
 20   IF(L2 .AND. CREC(1:8) .EQ. 'showpage') THEN
         WRITE (7,'(A8)') CREC(1:8)
         GO TO 29
      END IF
C
C         CREATE THE NEW %%Page OUTPUT RECORD
C
      L1 = LFALSE
      L2 = LTRUE
      DO 21 J = 14,1,-1
      IF(CREC(J:J) .NE. CBLNK4(1:1) .AND. .NOT.L1) L1 = LTRUE
      IF(L1 .AND. CREC(J:J) .EQ. CBLNK4(1:1)) GO TO 22
 21   CONTINUE
      J = 12
 22   CREC(J:14) = CBLNK4(1:14-J+1)
      KPAGEN = KPAGEN + 1
      WRITE (CNPAGE,103) KPAGEN
      CREC(12:14) = CNPAGE(1:3)
C
C         A MATCH WAS FOUND; WRITE THE %%Page RECORD ON UNIT 7
C
      WRITE (7,102) CREC(1:14)
C
C         PROCESS THE REMAINING RECORDS OF THE CURRENT PAGE;
C         FILL THE INPUT BUFFFER WITH BLANKS.
C
 23   DO 24 J = 1,42
      IA = 1 + 4*(J-1)
      IB = IA + 3
      CREC(IA:IB) = CBLNK4(1:4)
 24   CONTINUE
C
C         PROCESS ALL RECORDS FOLLOWING THE %%Page RECORD UNTIL ANOTHER
C         RECORD WITH COLS 1 & 2 CONTAINING %% IS FOUND
C
      READ (4,101,IOSTAT = IEND) CREC
C
C         TEST FOR AN END OF FILE. THIS CONDITION SHOULD NEVER BE
C         REACHED.
C
      IF(IEND .EQ. -1) STOP 'REVPRT ERROR 2'
C
C         DETERMINE IF showpage IS FOUND INDICATING THE END OF THE
C         CURRENT PAGE
C
      IF(CREC(1:14) .EQ. 'showpage      ') THEN
         IA = 8
         GO TO 26
      END IF
C
C         DETERMINE IF A %% TYPE RECORD WAS FOUND INDICATING THE END OF
C         THE CURRENT PAGE
C
      IF(CREC(1:2) .EQ. '%%') GO TO 27
C
C         DETERMINE THE LENGTH OF THE INPUT RECORD FROM UNIT 4
C
      DO 25 IA = 168,1,-1
      IF(CREC(IA:IA) .NE. CBLNK4(1:1)) GO TO 26
 25   CONTINUE
C
C         CONVERT THE RECORD LENGTH TO TEXT FORM
C
 26   CI4WK1(1:4) = CBLNK4(1:4)
      CFMTX(3:5) = CBLNK4(1:3)
      CI4WK1(1:4) = CBLNK4(1:4)
      WRITE (CI4WK1,100) IA
C
C         CREATE THE FORMAT TO WRITE THE RECORD ON UNIT 4
C
      IF(CI4WK1(3:3) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:3) = CI4WK1(4:4)
      ELSE IF(CI4WK1(2:2) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:4) = CI4WK1(3:4)
      ELSE IF(CI4WK1(1:1) .EQ. CBLNK4(1:1)) THEN
         CFMTX(3:5) = CI4WK1(2:4)
      END IF
C
C         WRITE THE RECORD ON UNIT 7
C
      WRITE (7,CFMTX) CREC(1:IA)
      GO TO 23
C
C         REWIND UNIT 4 TO SEARCH FOR THE NEXT PAGE
C
 27   REWIND (4)
C
C         DETERMINE IF PAGE 2 HAS BEEN PROCESSED. THIS COMPLETES ALL
C         EVEN PAGE PROCESSING
C
      IF(IDX .EQ. 1) THEN
C
C         WRITE THE TRAILER ON UNIT 7
C
         WRITE (7,CF108) KPAGE
         GO TO 30
      END IF
 29   CONTINUE
C
C         EXIT ROUTINE
C
 30   RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C         THIS ROUTINE PERFORMS A SYNTAX CHECK ON A FORTRAN FORMAT
C         STATEMENT
C
C     MEANING OF THE VARIABLES
C
C         CAA    - CHARACTER VARIABLE, THE CHARACTER A
C         CBB    - CHARACTER VARIABLE, THE CHARACTER B
C         CBSLAS - CHARACTER VARIABLE, A BACKSLASH
C         CDD    - CHARACTER VARIABLE, THE CHARACTER D
C         CDOL   - CHARACTER VARIABLE, A DOLLAR SIGN
C         CDOT   - CHARACTER VARIABLE, A DECIMAL POINT (OR PERIOD)
C         CEE    - CHARACTER VARIABLE, THE CHARACTER E
C         CFF    - CHARACTER VARIABLE, THE CHARACTER F
C         CGG    - CHARACTER VARIABLE, THE CHARACTER G
C         CII    - CHARACTER VARIABLE, THE CHARACTER I
C         CLL    - CHARACTER VARIABLE, THE CHARACTER L
C         CLPAR  - CHARACTER VARIABLE, A LEFT PARENTHESIS
C         COO    - CHARACTER VARIABLE, THE ALPABETIC CHARACTER O (OH)
C         COLON  - CHARACTER VARIABLE, A COLON
C         COMMA  - CHARACTER VARIABLE, A COMMA
C         CPP    - CHARACTER VARIABLE, THE CHARACTER P
C         CQQ    - CHARACTER VARIABLE, THE CHARACTER Q
C         CRPAR  - CHARACTER VARIABLE, A RIGHT PARENTHESIS
C         CSS    - CHARACTER VARIABLE, THE CHARACTER S
C         CSTMT  - CHARACTER VARIABLE, THE COMPRESSED FORMAT STATEMENT
C                  TO BE CHECKED
C         CSYMCF - CHARACTER VARIABLE, THE HEX VALUE CF. IT INDICATES
C                  A FORMAT FIELD IS A LITERAL.
C         CTT    - CHARACTER VARIABLE, THE CHARACTER T
C         CXX    - CHARACTER VARIABLE, THE CHARACTER X
C         CZZ    - CHARACTER VARIABLE, THE CHARACTER Z
C         C0     - CHARACTER VARIABLE, THE NUMERIC CHARACTER ZERO
C         C9     - CHARACTER VARIABLE, THE MUMERIC CHARACTER 9
C         IGREAT - LOCATION OF A GREATER THAN SYMBOL THAT IS NOT MATCHED
C                  BY A GREATER THAN SYMBOL
C         ILESS  - LOCATION OF A LESS THAN SYMBOL THAT IS NOT MATCHED
C                  BY A GREATER THAN SYMBOL
C         ILOC   - CURRENT LOCATION IN CSTMT
C         ILOCLP - LOCATION OF A LEFT PARENTHESIS
C         ILOCRP - CURRENT LOCATION IN CSTMT
C         IREC0  - COUNT OF THE NUMBER OF RECORDS WRITTEN ON UNIT 0
C         ISN    - ISN OF THE FORMAT STATEMENT
C         I1     - SUBSCRIPT VARIABLE AND WORK AREA
C         I2     - SUBSCRIPT VARIABLE AND WORK AREA
C         JGREAT - TABLE OF THE LOCATION OF A GREATER THAN SYMBOLS IN
C                  THE ENTIRE FORMAT STATEMENT
C         JGRKNT - COUNT OF THE NUMBER OF GREATER THAN SYMBOLS FOUND IN
C                  THE ENTIRE FORMAT STATEMENT
C         JLESS  - TABLE OF THE LOCATION OF A LESS THAN SYMBOLS IN THE
C                  ENTIRE FORMAT STATEMENT
C         JLEKNT - COUNT OF THE NUMBER OF LESS THAN SYMBOLS FOUND IN
C                  ENTIRE FORMAT STATEMENT
C         KB     - THE LOCATION OF THE FINAL CHARACTER IN THE STATEMENT
C         KBB    - SAVE AREA FOR THE LOCATION OF THE FINAL CHARACTER
C                  IN THE STATEMENT
C         LFALSE - LOGICAL VARIABLE, CONTAINS THE LOGICAL VALUE FALSE
C         LDOT   - LOGICAL VARIABLE, SET TRUE WHEN A PERIOD IN AN F OR
C                  G FIELD HAS OCCURRED, SET FALSE OTHERWISE.
C         LFALSE - LOGICAL VARIABLE, ALWAYS SET TO LOGICAL FALSE
C         LGREAT - LOGICAL VARIABLE, SET TRUE WHEN A GREATER THAN SYMBOL
C                  HAS OCCURRED
C         LESS   - LOGICAL VARIABLE, SET TRUE WHEN A LESS THAN SYMBOL
C                  HAS OCCURRED
C         LREP   - LOGICAL VARIABLE, SET TRUE WHEN A REPEAT FIELD IS
C                  SPECIFIED, SET FALSE OTHERWISE
C         LTRUE  - LOGICAL VARIABLE, CONTAINS THE LOGICAL VALUE TRUE
C         L1     - LOGICAL VARIABLE, ALWAYS SET TO FALSE
C
C     COMMENTS
C
C        THE FIRST DETECTED ERROR TERMINATES ALL FURTHER PROCESSING OF
C        THE FORMAT STATEMENT FOR SYNTAX ERRORS.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C        EXPR
C
C     ******************************************************************
C
      SUBROUTINE FMTSYN
C
C         IMPLICIT STATEMENT
C
      IMPLICIT REAL*4 (A-H,O-Z), INTEGER*4 (I-N)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CSREC(20), ISRECL(20), JGREAT(100), JLESS(100)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*68    CWK68
      CHARACTER*52    CBLK52, CWORK
      CHARACTER*32    CWK32
      CHARACTER*8     CBLANK, CWK8
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      REAL*8          FP
      INTEGER*2       ISRECL, I2WK1
      LOGICAL*1       LDOT, LGREAT, LESS, LREP, L1
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
C
C         SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(' ISN:',I6,' FORMAT LACKS A LEFT BOUNDING PARENTHESIS: ',
     1A9)
 101  FORMAT(' ISN:',I6,' FORMAT LACKS A RIGHT BOUNDING PARENTHESIS: ',
     1A9)
 102  FORMAT(' ISN:',I6,' FORMAT IS MISSING A COMMA: ',A9)
 103  FORMAT(' ISN:',I6,' FORMAT HAS AN ILLEGAL COMMA: ',A9)
 104  FORMAT(' ISN:',I6,' FORMAT HAS AN ILLEGAL RIGHT PARENTHESIS: ',A9)
 105  FORMAT(' ISN:',I6,' FORMAT HAS AN ILLEGAL DECIMAL POINT: ',A9)
 106  FORMAT(' ISN:',I6,' FORMAT HAS AN ILLEGAL CHARACTER: ',A9)
 107  FORMAT(' ISN:',I6,' FORMAT HAS NO MATCHING SYMBOL > OR <: ',A9)
 108  FORMAT(' ISN:',I6,' FORMAT HAS NO MATCHING RIGHT PARENTHESIS: ',A9
     1)
 109  FORMAT(' ISN:',I6,' FORMAT HAS A DECIMAL POINT WITHOUT LEFT AND RI
     1GHT DIGITS: ',A9)
C
C         INITIALIZATION
C
      KBB = KB
      LREP = LFALSE
      LGREAT = LFALSE
      JGRKNT = 0
      JLEKNT = 0
C
C         SET GREATER THAN AND LESSER THAN TABLES TO ZERO
C
      DO ILOC = 1,100
      JGREAT(ILOC) = 0
      JLESS(ILOC) = 0
      END DO
C
C         DETECT, COUNT, AND FILL TABLES FOR GREATER THAN AND LESS
C         THAN SYMBOLS
C
      DO ILOC = 1,KB
      IF(CSTMT(ILOC:ILOC) .EQ. '<') THEN
         JLEKNT = JLEKNT + 1
         JLESS(JLEKNT) = ILOC
      END IF
      IF(CSTMT(ILOC:ILOC) .EQ. '>') THEN
         JGRKNT = JGRKNT + 1
         JGREAT(JGRKNT) = ILOC
      END IF
      END DO
C
C         WHEN A GREATER THAN SYMBOL OCCURS, IT MUST BE MATCHED BY A
C         LESS THAN SYMBOL.
C
      IF(JGRKNT .GT. 0 .AND. JLEKNT .LT. JGRKNT) THEN
         I1 = JGREAT(1)
         WRITE (0,107) ISN,CSTMT(I1-4:I1+4)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
C
C         WHEN A LESS THAN SYMBOL OCCURS, IT MUST BE MATCHED BY A
C         GREATER THAN SYMBOL.
C
      IF(JLEKNT .GT. 0 .AND. JGRKNT .LT. JLEKNT) THEN
         I1 = JLESS(1)
         WRITE (0,107) ISN,CSTMT(I1-4:I1+4)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
C
C         WHEN THE LOCATION OF THE FIRST GREATER THAN SYMBOL OCCURS
C         PRIOR TO THE FIRST LESS THAN SYMBOL, WRITE AN ERROR MESSAGE.
C
      IF(JGREAT(1) .LT. JLESS(1)) THEN
         I1 = JGREAT(1)
         WRITE (0,107) ISN,CSTMT(I1-4:I1+4)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
C
C         WHEN ANY LESS THAN AND GREATER THAN SYMBOLS EXIST AND THEIR
C         COUNTS MATCH, PROCESS THE EXPRESSION BETWEEN THEM. THE NUMBERS
C         AND VARIABLES WILL BE WRITTEN IN THE PROPER OUTPUT TABLES.
C
      IF(JLEKNT .EQ. JGRKNT) THEN
         DO ILOC = 1,JLEKNT
         I1 = JLESS(ILOC) + 1
         I2 = JGREAT(ILOC) - 1
         L1 = LFALSE
         CALL EXPR (I1,I2,LFALSE,CSTMT)
         KB = KBB
         END DO
      END IF
C
C         DETERMINE THE IF THE LEFT BOUNDING PARENTHESIS EXISTS
C
      IF(CSTMT(7:7) .NE. CLPAR(1:1)) THEN
C
C         WRITE MESSAGE THE LEFT PARENTHESIS IS MISSING
C
C     WRITE (13,100) ISN,CSTMT(1:9)
         WRITE (0,100) ISN,CSTMT(1:9)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
C
C         DETERMINE THE IF THE RIGHT BOUNDING PARENTHESIS EXISTS
C
      IF(CSTMT(KB:KB) .NE. CRPAR(1:1)) THEN
C
C         WRITE MESSAGE THE RIGHT PARENTHESIS IS MISSING
C
         WRITE (0,101) ISN,CSTMT(KB-8:KB)
         IREC0 = IREC0 + 1
         GO TO 12
      ELSE
C
C         WHEN THE RIGHT BOUNDING PARENTHESIS EXISTS, DETERMINE IF THE
C         PRECEEDING CHARACTER IS ALSO A RIGHT PARENTHESIS, AND
C         DECREMENT KB BY ONE.
C
         IF(CSTMT(KB -1:KB-1) .EQ. CRPAR(1:1)) KB = KB - 1
      END IF
C
C         INITIALIZE THE LOGICAL SWITCHES FOR THE EXISTANCE OF < AND >
C
      LGREAT = LFALSE
      LESS = LFALSE
      ILESS = 0
      IGREAT = 0
C
C         SET THE START LOCATION OF THE FORMAT FIELD SPECIFICATIONS
C
      ILOC = 8
C
C     *****************************************************************
C     *                                                               *
C     *   PROCESSING OF ALL FORMAT LIST FIELDS START HERE             *
C     *                                                               *
C     *****************************************************************
C
C         DETERMINE IF THE END OF THE FORMAT STATEMENT HAS BEEN REACHED
C
 10   IF(ILOC .GE. KB) GO TO 12
C
C         WHEN A LESS THAN SYMBOL OCCURS, DO NOT PROCESS ANY CHARACTERS
C         UNTIL A GREATER THAN SYMBOL OCCURS.
C
      IF(LESS) THEN
C
C         WHEN A GREATER THAN SYMBOL OCCURS, TURN OFF THE LESS SWITCH
C
         IF(CSTMT(ILOC:ILOC) .EQ. '>') THEN
C
C         WHEN A GREATER THAN SYMBOL OCCURS, AND NO LESS THAN SYMBOL
C         PRECEEDED IT, WRITE ERROR MESSAGE
C
            IF(.NOT.LESS .AND. LGREAT) THEN
               WRITE (0,107) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            LESS = LFALSE
            ILESS = 0
            ILOC = ILOC +1
            GO TO 10
         END IF
         ILOC = ILOC +1
         GO TO 10
      END IF
C
C         DETERMINE IF THE FIELD IS A LITERAL
C
      IF(CSTMT(ILOC:ILOC) .EQ. CSYMCF(1:1)) THEN
C
C         WHEN A COMMA FOLLOWS THE LITERAL, IT TERMINATES THE CURRENT
C         FORMAT FIELD
C
         ILOC = ILOC + 1
C
C         WHEN A DIGIT FOLLOWS A LITERAL, THIS IS AN ERROR
C
         IF(CSTMT(ILOC:ILOC) .GE. C0 .AND. CSTMT(ILOC:ILOC) .LE. C9)
     1      THEN
            WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 10
         END IF
C
C         DETERMINE IF A COMMA FOLLOWS A LITERAL
C
         IF(CSTMT(ILOC:ILOC) .EQ. COMMA(1:1)) THEN
            ILOC = ILOC + 1
C
C         DETERMINE IF A ',/' FOLLOWS A LITERAL
C
            IF(CSTMT(ILOC:ILOC) .EQ. CSLASH(1:1)) THEN
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
C
C         IF A RIGHT PARENTHESIS FOLLOWS THE SLASH, THEN THIS PROBABLY
C         INDICATES A CLOSING RIGHT PARENTHESIS FOR A REPEAT FIELD IF
C         LREP IS TRUE.
C
               IF(CSTMT(ILOC+1:ILOC+1) .EQ. CRPAR) THEN
                  LREP = LTRUE
                  ILOCLP = ILOC
                  ILOC = ILOC + 1
                  GO TO 10
               END IF
               GO TO 12
            END IF
C
C         DETERMINE IF ONE LITERAL FOLLOWS ANOTHER
C
            IF(CSTMT(ILOC:ILOC) .EQ. CSYMCF(1:1) .OR. CSTMT(ILOC:ILOC)
     1         .NE. COMMA(1:1)) GO TO 10
C
C         DETERMINE IF TWO SEQUENTIAL COMMAS OCCUR
C
            IF(CSTMT(ILOC+1:ILOC+1) .EQ. COMMA(1:1)) THEN
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS OR A SLASH FOLLOWS A COMMA
C
            IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
               WRITE (0,104) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            GO TO 10
         ELSE
C
C         DETERMINE IF A SLASH FOLLOWS A LITERAL
C
            IF(CSTMT(ILOC:ILOC) .EQ. CSLASH(1:1)) THEN
               ILOC = ILOC +1
               GO TO 10
            END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS FOLLOWS A LITERAL
C
            IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
               IF(LREP) LREP = LFALSE
               ILOC = ILOC + 1
               GO TO 10
            END IF
C
C         WRITE MISSING COMMA ERROR MESSAGE
C
            WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
      END IF
C
C         DETERMINE IF AN ASTERISK OCCURS. SOME OLDER FORTRAN COMPILERS
C         USES AN ASTERISK INSTEAD OF QUOTATION AMRKS OR APOSTROPHES
C         AS LITERAL DELIMITERS. AN ASTERISK IS NOT A LEGAL CHARCDTER AT
C         THIS STAGE OF FORMAT PROCESSING, AND AN ERROR MESSAGE WILL
C         BE WRITTEN.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CASTER(1:1)) THEN
         WRITE (0,106) ISN, CSTMT(ILOC-4:ILOC+4)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
C
C         DETERMINE IF A DECIMAL POINT OCCURS
C
      IF(CSTMT(ILOC:ILOC) .EQ. CDOT(1:1)) THEN
C
C         A DECIMAL POINT MUST BE PRECDED AND FOLLOWED BY A NUMERICAL
C         DIGIT, A GREATER THAN, OR A LESS THAN SYMBOL
C
         IF(CSTMT(ILOC-1:ILOC-1) .GE. C0 .AND. CSTMT(ILOC-1:ILOC-1) .LE.
     1      C9 .AND. CSTMT(ILOC+1:ILOC+1) .GE. C0 .AND. CSTMT(ILOC+1:
     2      ILOC+1) .LE. C9 .OR. CSTMT(ILOC-1:ILOC-1) .EQ. '>' .OR.
     2      CSTMT(ILOC+1:ILOC+1) .EQ. '<') THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE
            WRITE (0,109) ISN,CSTMT(ILOC-4:ILOC+4)
            GO TO 12
         END IF
      END IF
C
C         DETERMINE IF THE FORMAT FIELD STARTS WITH A SLASH. MULTIPLE
C         SEQUENTIAL SLASHES ARE ALLOWED.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CSLASH(1:1)) THEN
         ILOC = ILOC + 1
C
C         A COMMA MAY NOT FOLLOW A SLASH UNLESS IT IS ALSO PRECEEDED
C         BY A COMMA OR A LEFT PARENTHESIS
C
         IF(CSTMT(ILOC:ILOC) .EQ. COMMA(1:1)) THEN
            IF(CSTMT(ILOC-2:ILOC-2) .EQ. COMMA(1:1) .OR.
     1         CSTMT(ILOC-2:ILOC-2) .EQ. CLPAR(1:1)) THEN
               ILOC = ILOC +1
               GO TO 10
            ELSE
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
         END IF
C
C         A DECIMAL POINT MAY NOT FOLLOW A SLASH
C
         IF(CSTMT(ILOC:ILOC) .EQ. CDOT(1:1)) THEN
            WRITE (0,105) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
C
C         DETERMINE IF THE CHARACTER FOLLOWING THE SLASH IS ALLOWED
C
         IF(CSTMT(ILOC:ILOC) .EQ. CSYMCF(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CBLANK(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CSLASH(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CLPAR(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
            IF(LREP) LREP = LFALSE
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. COLON(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CBSLAS(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'BN') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'BZ') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CQQ(1:1)) THEN
            ILOC = ILOC + 1
            IF(CSTMT(ILOC:ILOC) .NE. COMMA(1:1)) THEN
C     WRITE (3,8040)
C8040 FORMAT(' TRACE 8040 FMTSYN')
               WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'SP') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'SS') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CSS(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'TL') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'TR') THEN
            ILOC = ILOC + 2
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CTT(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CXX(1:1)) THEN
            ILOC = ILOC + 1
            IF(CSTMT(ILOC:ILOC) .NE. COMMA(1:1) .OR. CSTMT(ILOC:ILOC)
     1         .NE. CRPAR(1:1)) THEN
C     WRITE (3,8041)
C8041 FORMAT(' TRACE 8041 FMTSYN')
               WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .GE. C0 .AND. CSTMT(ILOC:ILOC) .LE.
     1      C9) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CAA(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CDD(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CEE(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CFF(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CGG(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CII(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CLL(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. COO(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CZZ(1:1)) THEN
            ILOC = ILOC + 1
            IF(CSTMT(ILOC:ILOC) .LT. C0 .AND. CSTMT(ILOC:ILOC) .GT. C9
     1         .OR. CSTMT(ILOC:ILOC) .EQ. '<') THEN
               WRITE (0,106) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. '<') THEN
            LESS = LTRUE
            ILESS = ILOC
            ILOC = ILOC + 1
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. '>') THEN
            IF(LESS) THEN
               LESS = LFALSE
               ILOC = ILOC + 1
               GO TO 10
            END IF
            ILESS = ILOC
            ILOC = ILOC + 1
            LGREAT = LTRUE
            GO TO 10
         ELSE IF(CSTMT(ILOC:ILOC) .EQ. CSHARP .OR. CSTMT(ILOC:ILOC+1)
     1      .EQ. 'C#') THEN
            IF(CSTMT(ILOC-1:ILOC+1) .EQ. 'C##') THEN
              ILOC = ILOC + 2
              GO TO 10
            ELSE IF(CSTMT(ILOC-1:ILOC) .EQ. 'C#') THEN
              ILOC = ILOC + 1
              GO TO 10
            END IF
            IF(CSTMT(ILOC:ILOC+2) .EQ. 'C##') THEN
              ILOC = ILOC + 2
              GO TO 10
            ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'C#') THEN
              ILOC = ILOC + 1
              GO TO 10
            END IF
         ELSE
            WRITE (0,106) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
         GO TO 10
      END IF
C
C         DETERMINE IF THE FORMAT FIELD STARTS WITH A LEFT PARENTHESIS
C         INDICATING REPEAT SPECIFICATION FOLLOWS THE PARENTHESIS.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CLPAR(1:1)) THEN
         LREP = LTRUE
         ILOCLP = ILOC
         ILOC = ILOC + 1
         GO TO 10
      END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS OCCURS. THIS SHOULD TERMINATE
C         A REPEAT SPECIFICATION; OTHERWISE IT IS AN ERROR.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
         IF(LREP) THEN
            LREP = LFALSE
            ILOCRP = ILOC
            ILOC = ILOC + 1
            GO TO 10
         ELSE
            WRITE (0,104) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
      END IF
C
C         DETERMINE IF A COLON OCCURS. IT TERMINATES FORMAT EXECUTION
C         WHEN THE I/O LIST IS DONE
C
      IF(CSTMT(ILOC:ILOC) .EQ. COLON(1:1)) THEN
         ILOC = ILOC + 1
         GO TO 10
      END IF
C
C         DETERMINE IF A DOLLAR OCCURS. IT SUPPRESSES CARRIAGE RETURN
C         FOR INTERACTIVE LISTS.  IT MUST BE THE FINAL CHARACTER IN THE
C         FORMAT STATEMENT IMMEDIATELY PRECEEDING THE LAST RIGHT
C         PARENTHESIS.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CDOL(1:1)) THEN
         ILOC = ILOC + 1
C
C         THE NEXT CHARACTER MUST BE THE END OF THE FORMAT STATEMENT,
C         A RIGHT PARENTHESIS
C
         IF(ILOC .EQ. KB) THEN
            IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
               GO TO 12
            ELSE
               WRITE (0,101) ISN,CSTMT(KB-9:KB)
               GO TO 12
            END IF
         END IF
      END IF
C
C         DETERMINE IF A BACKSLASH OCCURS. IT SUPPRESSES CARRIAGE
C         RETURN FOR INTERACTIVE LISTS. IT MUST BE THE FINAL CHARACTER
C         IN THE FORMAT STATEMENT IMMEDIATELY PRECEEDING THE LAST RIGHT
C         PARENTHESIS
C
      IF(CSTMT(ILOC:ILOC) .EQ. CBSLAS(1:1)) THEN
         ILOC = ILOC + 1
C
C         THE NEXT CHARACTER MUST BE THE END OF THE FORMAT STATEMENT,
C         A LEFT PARENTHESIS
C
         IF(ILOC .EQ. KB) THEN
            IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
               GO TO 12
            ELSE
               WRITE (0,101) ISN,CSTMT(KB-9:KB)
               GO TO 12
            END IF
         END IF
      END IF
C
C         DETERMINE IF THE CHARACTERS BN OCCUR. THEY SPECIFY THAT
C         EMBEDDED AND TRAILING BLANKS ARE IGNORED IN NUMERIC INPUT.
C
      IF(CSTMT(ILOC:ILOC+1) .EQ. 'BN') THEN
         ILOC = ILOC + 2
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTERS BZ OCCUR. THEY SPECIFY THAT
C         EMBEDDED AND TRAILING BLANKS ARE CONSIDERED ZEROS.
C
      IF(CSTMT(ILOC:ILOC+1) .EQ. 'BZ') THEN
         ILOC = ILOC + 2
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTER P OCCURS
C
      IF(CSTMT(ILOC:ILOC) .EQ. CPP(1:1)) THEN
C
C         DETERMINE IF A NUMERICAL DIGIT PRECEEDS THE CHARACTER P
C
         IF(CSTMT(ILOC-1:ILOC-1) .GE. C0 .AND. CSTMT(ILOC-1:ILOC-1) .LE.
     1      C9) THEN
            CONTINUE
         ELSE
            WRITE (0,106) ISN,CSTMT(ILOC-5:ILOC-3)
            IRET0 = IRET0 + 1
            GO TO 12
         END IF
C
C         DETERMINE IF A NUMERICAL DIGIT FOLLOWS THE CHARACTER P
C
         IF(CSTMT(ILOC+1:ILOC+1) .GE. C0 .AND. CSTMT(ILOC+1:ILOC+1)
     1      .LE. C9) THEN
            ILOC = ILOC + 1
            GO TO 10
         END IF
C
C         ONLY CHARACTERS D, E, F, AND G MAY FOLLOW A P CHARACTER
C
         ILOC = ILOC + 1
         IF(CSTMT(ILOC:ILOC) .EQ. CDD(1:1) .OR. CSTMT(ILOC:ILOC) .EQ.
     1      CEE(1:1) .OR. CSTMT(ILOC:ILOC) .EQ. CFF(1:1) .OR.
     2      CSTMT(ILOC:ILOC) .EQ. CGG(1:1)) THEN
            GO TO 10
         ELSE
            WRITE (0,106) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
      END IF
C
C         DETERMINE IF THE CHARACTER Q OCCURS. IT IS USED TO OBTAIN THE
C         NUMBER OF CHARACTERS REMAINING IN AN INPUT RECORD.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CQQ(1:1)) THEN
         ILOC = ILOC + 1
         IF(CSTMT(ILOC:ILOC) .NE. COMMA(1:1)) THEN
            WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTERS S, SP, SS OCCUR. THEY CONTROL
C         ARITHMETIC SIGN USAGE.
C
      IF(CSTMT(ILOC:ILOC+1) .EQ. 'SP') THEN
         ILOC = ILOC + 2
         GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'SS') THEN
         ILOC = ILOC + 2
         GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CSS(1:1)) THEN
         ILOC = ILOC + 1
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTERS T, TL, TR OCCUR. THEY ARE TAB
C         SETTINGS.
C
      IF(CSTMT(ILOC:ILOC+1) .EQ. 'TL') THEN
         ILOC = ILOC + 2
         GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC+1) .EQ. 'TR') THEN
         ILOC = ILOC + 2
         GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CTT(1:1)) THEN
         ILOC = ILOC + 1
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTER X OCCURS. IT SKIPS FORWARD IN THE
C         INPUT OR OUTPUT RECORDS BEING READ OR WRITTEN.
C
      IF(CSTMT(ILOC:ILOC) .EQ. CXX(1:1)) THEN
         ILOC = ILOC + 1
C
C         WHEN THE CHARACTER FOLLOWING THE X CHARACTER IS A RIGHT
C         PARENTHESIS, DETERMINE IF IT IS THE FINAL CHARACTER OF
C         FORMAT STATEMENT.
C
         IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1) .AND. ILOC .EQ. KB) THEN
            LREP = LFALSE
            GO TO 10
         END IF
         IF(CSTMT(ILOC:ILOC) .NE. COMMA(1:1) .AND. CSTMT(ILOC:ILOC)
     1      .NE. CRPAR(1:1)) THEN
            WRITE (0,102) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTER IS AN A, E, F, G, I, L, OR, Z
C
      IF(CSTMT(ILOC:ILOC) .EQ. CAA(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CDD(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CEE(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CFF(1:1) .OR. CSTMT(ILOC:ILOC) .EQ.
     1      CGG(1:1)) THEN
C
C         DETERMINE IF THE CHARACTER TERMINATING IS NUMERIC
C
            LDOT = LFALSE
            DO 11 I = ILOC+1,KB
C
C         DETERMINE IF THE CHARACTER IS A DIGIT
C
            IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9) THEN
               IF(CSTMT(I+1:I+1) .EQ. CSLASH(1:1)) GO TO 10
               GO TO 11
            END IF
C
C         WHEN THE DECIMAL POINT HAS ALREADY BEEN PROCESSED, AND THE
C         CHARACTER IS THE FINAL CHARACTER OF THE FORMAT STATEMENT,
C         EXIT THE ROUTINE.
C
            IF(.NOT.LDOT .AND. I .EQ. KB) THEN
               LREP = LFALSE
               GO TO 12
            END IF
C
C         WHEN A COMMA FOLLOWS A DIGIT AND THE DECIMAL POINT HAS ALREADY
C         BEEN PROCESSED OR DOES NOT EXIST, THIS ENDS THE NUMERIC FIELD.
C
            IF(.NOT.LDOT .AND. CSTMT(I-1:I-1) .EQ. COMMA(1:1)) THEN
               ILOC = I + 1
               GO TO 10
            END IF
C
C         WHEN THE CHARACTER IS A COMMA SKIP TO THE NEXT CHARACTER
C
            IF(CSTMT(I:I) .EQ. COMMA(1:1)) THEN
               ILOC = ILOC + 1
               GO TO 10
            END IF
C
C         THE END OF THE NUMERIC FIELD HAS BEEN FOUND; DETERMINE IT
C         THE CHARACTER IS A PERIOD (DECIMAL POINT); ANY OTHER
C         CHARACTER IS ILLEGAL.
C
            IF(CSTMT(I:I) .EQ. CDOT(1:1)) THEN
C
C         DETERMINE IF THE DIGIT IS FOLLOWED BY A SLASH WHEN THE
C         DIGITS FOLLOWING A DECIMAL POINT HAVE ALREADY BEEN PROCESSED
C
               IF(LDOT .AND. CSTMT(I+1:I+1) .EQ. CSLASH(1:1)) THEN
                  ILOC = ILOC + 1
                  GO TO 10
               END IF
               LDOT = LTRUE
               ILOC = I
               GO TO 11
            ELSE
C
C         DECIMAL POINT HAS ALREADY BEEN PROCESSED
C
               IF(LDOT) THEN
C
C         DIGITS OR A LESS THAN SYMBOL MAY FOLLOW A DECIMAL POINT
C
                  LDOT = LFALSE
                  IF(CSTMT(I:I) .GE. C0 .AND. CSTMT(I:I) .LE. C9 .OR.
     1               CSTMT(I:I) .EQ. '<') THEN
                     ILOC = I
                     GO TO 10
                  END IF
               ELSE
                  IF(CSTMT(I:I) .EQ. CXX(1:1)) THEN
                     ILOC = ILOC + 1
                     GO TO 10
                  END IF
                  IF(CSTMT(I:I) .EQ. CSLASH(1:1)) THEN
                     ILOC = ILOC + 1
                     GO TO 10
                  END IF
                  IF(CSTMT(I:I) .EQ. COMMA(1:1)) THEN
                     WRITE (0,103) ISN,CSTMT(I-4:I+4)
                     IREC0 = IREC0 + 1
                  ELSE
                     IF(CSTMT(I:I) .NE. '<' .AND. CSTMT(I:I) .NE.
     1                  CSYMCF(1:1)) THEN
                        WRITE (0,106) ISN,CSTMT(I-4:I+4)
                        IREC0 = IREC0 + 1
                     END IF
                  END IF
                  GO TO 12
               END IF
            END IF
 11         CONTINUE
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CII(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CLL(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. COO(1:1)) THEN
            ILOC = ILOC + 1
            GO TO 10
      ELSE IF(CSTMT(ILOC:ILOC) .EQ. CZZ(1:1)) THEN
            ILOC = ILOC + 1
            IF(CSTMT(ILOC:ILOC) .GE. C0 .AND. CSTMT(ILOC:ILOC) .LE. C9
     1         .OR. CSTMT(ILOC:ILOC) .EQ. '<') THEN
               GO TO 10
            ELSE
               WRITE (0,106) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
            END IF
            GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTER IS A NUMERICAL DIGIT
C
      IF(CSTMT(ILOC:ILOC) .GE. C0 .AND. CSTMT(ILOC:ILOC) .LE. C9) THEN
         ILOC = ILOC + 1
C
C         WHEN A COMMA OR RIGHT PARENTHESIS FOLLOWS THE DIGIT, IT
C         TERMINATES THE NUMERIC FIELD
C
         IF(CSTMT(ILOC:ILOC) .EQ. COMMA(1:1) .OR. CSTMT(ILOC:ILOC) .EQ.
     1      CRPAR(1:1)) THEN
            IF(LREP .AND. CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1))
     1         LREP = LFALSE
            ILOC = ILOC + 1
            GO TO 10
         END IF
C
C         WRITE MESSAGE WHEN A LITERAL, Q, B, OR S FOLLOWS THE DIGIT
C
         IF(CSTMT(ILOC:ILOC) .EQ. CSYMCF(1:1) .OR. CSTMT(ILOC:ILOC) .EQ.
     1      CQQ(1:1) .OR. CSTMT(ILOC:ILOC) .EQ. CTT .OR.
     2      CSTMT(ILOC:ILOC) .EQ. CBB(1:1) .OR. CSTMT(ILOC:ILOC) .EQ.
     3      CSS(1:1)) THEN
            WRITE (0,106) ISN,CSTMT(ILOC-4:ILOC+4)
            IREC0 = IREC0 + 1
            GO TO 12
         END IF
         GO TO 10
      END IF
C
C         DETERMINE IF THE CHARACTER IS A COMMA
C
      IF(CSTMT(ILOC:ILOC) .EQ. COMMA(1:1)) THEN
C
C         CHECK FOR CHARACTERS NOT ALLOWED AFTER A COMMA
C
C         DOES ANOTHER COMMA FOLLOW?
C
         ILOC = ILOC + 1
         IF(CSTMT(ILOC:ILOC) .EQ. COMMA(1:1)) THEN
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
         END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS FOLLOWS A COMMA
C
         IF(CSTMT(ILOC:ILOC) .EQ. CRPAR(1:1)) THEN
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
         END IF
C
C         DETERMINE IF A DECIMAL POINT FOLLOWS A COMMA
C
         IF(CSTMT(ILOC:ILOC) .EQ. CDOT(1:1)) THEN
               WRITE (0,103) ISN,CSTMT(ILOC-4:ILOC+4)
               IREC0 = IREC0 + 1
               GO TO 12
         END IF
C
C         DETERMINE IF A LESS THAN SYMBOL FOLLOWS A COMMA
C
         IF(CSTMT(ILOC:ILOC) .EQ. '<') THEN
               ILESS = ILOC
               ILOC = ILOC + 1
               LESS = LTRUE
               GO TO 10
         END IF
C
C         DETERMINE IF A GREATER THAN SYMBOL FOLLOWS A COMMA
C
         IF(CSTMT(ILOC:ILOC) .EQ. '>') THEN
               IF(LESS) THEN
                  LESS = LFALSE
                  ILOC = ILOC + 1
                  GO TO 10
               END IF
               LGREAT = LTRUE
               IGREAT = ILOC
               ILOC = ILOC + 1
               GO TO 10
         END IF
      END IF
C
C         DETERMINE IF A LESS THAN SYMBOL FOLLOWS A COMMA
C
      IF(CSTMT(ILOC:ILOC) .EQ. '<') THEN
         ILESS = ILOC
         ILOC = ILOC + 1
         LESS = LTRUE
         GO TO 10
      END IF
C
C         DETERMINE IF A GREATER THAN SYMBOL FOLLOWS A COMMA
C
      IF(CSTMT(ILOC:ILOC) .EQ. '>') THEN
         IF(LESS) THEN
            LESS = LFALSE
            ILOC = ILOC + 1
            GO TO 10
         END IF
         LGREAT = LTRUE
         IGREAT = ILOC
         ILOC = ILOC + 1
         GO TO 10
      END IF
C
C         DETERMINE IF AN ASTERISK HAS OCCURRED
C
      IF(CSTMT(ILOC:ILOC) .EQ. CASTER(1:1)) THEN
         WRITE (0,106) ISN, CSTMT(ILOC-4:ILOC+4)
         IREC0 = IREC0 + 1
         GO TO 12
      END IF
      ILOC = ILOC + 1
      GO TO 10
C
C         WHEN A REPEAT FIELD DOES NOT HAVE A MATCHING RIGHT PARENTHESIS
C         WRITE AN ERROR MESSAGE
C
 12   IF(LREP) THEN
         WRITE (0,108) ISN,CSTMT(ILOCLP-4:ILOCLP+4)
         IREC0 = IREC0 + 1
      END IF
C
C         ROUTINE EXIT
C
      RETURN
      END
C
C     ******************************************************************
C
C     PURPOSE
C
C        THIS ROUTINE READS UNIT 5, THE INPUT FORTRAN SOURCE CODE TO
C        BUILD A TABLE OF ALL ENTRY, FUNCTION, AND SUBROUTINE NAMES
C        DEFINED WITHIN THE PROGRAM. NO PROCESSING OF OTHER STATEMENTS
C        IS PERFORMED.
C
C     MEANING OF THE VARIABLES
C
C         CAS    - CHARACTER VARIABLE, THE LETTER: A
C         CBLANK - CHARACTER VARIABLE, EIGHT BLANKS
C         CBLK52 - CHARACTER VARIABLE, 52 BLANKS, USED TO INITIALIZE
C                  CWORK
C         CFILEB - CHARACTER VARIABLE, THE FORTRAN PROGRAM FILE NAMES
C                  TO BE PROCESSED.
C         CHAR1  - CHARACTER VARIABLE, THE FIRST ALPHABETIC CHARACTER
C                  IN THE RECORD AFTER COLUMN 6
C         CHAR2  - CHARACTER VARIABLE, THE FIRST ALPHABETIC CHARACTER
C                  IN THE RECORD AFTER AN ENTRY, FUNCTION OR SUBROUTINE
C                  STATEMENT. THIS IS THE START OF THE SUBPORGRAM NAME
C         CIMPL  - CHARACTER VARIABLE, EACH ELEMENT OF THIS ARRAY IS
C                  8 CHARACTERS IN LENGTH; CHARACTER ONE CONTAINS AN
C                  ALPHABETIC CODE FOR AN IMPLICIT DECLARATION OF
C                  EACH LETTER OF THE ALPHABET AND THE UNDERSCORE,
C                  REPRESENTING THE FIRST CHARACTER OF A VARIABLE NAME.
C                  THE REMAINING 7 CHARACTERS CONTAIN THE DEFINED LENGTH
C                  OF THE VARIABLES WHOSE NAME BEGINS WITH THE LETTER OF
C                  THE ALPHABET DETERMINED BY THE SUBSCRIPT NUMBER. THE
C                  DEFAULT VALUES ARE A - H, O - Z: R*4; I - N: I*4;
C                  AND THE UNDERSCORE: R*4
C         CI2WK1 - CHARACTER VARIABLE, EQUIVALENCED TO I2WK1
C         CREC   - CHARACTER VARIABLE, A RECORD IMAGE WORK AREA FOR
C                  READING IN FORTRAN STATEMENTS
C         CSUBTB - CHARACTER VARIABLE, THE TABLE OF ALL ENTRY, FUNCTION,
C                  AND SUBROUTINE NAMES. A MAXIMUM OF 1000 DEFINITIONS
C                  MAY EXIST FOR A SINGLE PROGRAM.
C                  RECORD STRUCTURE
C                  COLS  WORD  CONTENTS
C                   1-32   8   ENTRY, FUNCTION, OR SUBROUTINE NAME
C                  33-36   9   ISN (SET TO ZERO)
C                  37-44  11   CODE AND LENGTH CHARACTERISTIC
C                  45-48  12   BIT SWITCHES
C                  49-52  13   NUMBER OF CHARACTERS IN COLS 1-32
C                  53-56  14   NUMBER OF ARGUMENTS IN THIS DEFINITION
C         CWK8   - CHARACTER VARIABLE, SAVES LENGTH DEFINED IN A
C                  FUNCTION STATEMENT
C         CWORK  - CHARACTER VARIABLE, WORK AREA TO SYNTHESIZE AN ENTRY
C                  IN SUBTBL
C         CZS    - CHARACTER VARIABLE, THE LETTER: Z
C         C0     - CHARACTER VARIABLE, THE DIGIT ZERO
C         C9     - CHARACTER VARIABLE, THE DIGIT NINE
C         I      - SUBSCRIPT VARIABLE
C         IARGCT - COUNT OF THE NUMBER OF ARGUMENTS IN A SUBPRORAM.
C                  EQUIVALENCED TO SUB. A MAXIMUM FOR 30 ARGUMENTS
C                  ARE ALLOWED BY FXREF; ALTHOUGH FORTRAN HAS NO
C                  SPECIFIED LIMIT.
C         ICAPS  - THE VALUE TO SUBTRACT FROM A LOWER CASE ALPHABETIC
C                  CHARACTER TO CONVERT IT TO UPPER CASE FOR ASCII CODE
C         IDXE   - THE INDEX VALUE USED TO POSITION A CHARACTER FOR
C                  CONVERSION; FOR LITTLE ENDIAN, VALUE IS 1; FOR EBCDIC
C         IEOF   - INDICATES AN END OF FILE WHEN IT EQUALS -1
C         ILOC   - LOCATION OF THE INITIAL ALPHABETIC CHARACTER IN THE
C                  INPUT RECORD
C         ILOCE  - LOCATION OF THE INITIAL E WITHIN A RECORD
C         ILOCF  - LOCATION OF THE FINAL CHARACTER IN A RECORD
C         ILOCFF - LOCATION OF THE INITIAL F CHARACTER IN A RECORD
C         ILOCS  - LOCATION OF THE INITIAL S WITHIN A RECORD
C         ILOC1  - LOCATION OF THE INITIAL NUMERIC DIGIT OF THE LENGTH
C                  CHARACTERISTIC OF A FUNCTION STATEMENT
C         ILOC2  - LOCATION OF THE FINAL NUMERIC DIGIT OF THE LENGTH
C                  CHARACTERISTIC OF A FUNCTION STATEMENT
C         ILOC3  - LOCATION OF THE INITIAL CHARACTER OF A FUNCTION NAME
C         ILOC4  - LOCATION OF THE FINAL CHARACTER OF A FUNCTION NAME
C         ILOC5  - LOCATION OF THE CHARACTER FOLLOWING A DATA TYPE
C                  DESIGNATION
C         ILOC6  - LOCATION OF THE INITIAL CHARACTER OF THE STATEMENT
C         INFILE - COUNT OF THE NUMBER OF FILE NAMES IN CFILEB
C         IRET   - A VALUE RETURNED FROM SUBROUTINE COMPRS. SET TO ZERO
C                  TO CONTINUE THE NEXT STATEMENT, SET TO 1 TO EXECUTE
C                  STATEMENT NUMBER 17. SUBROUTINE COMPRS RETURNS A
C                  VALUE OF 1 WHEN AN INCLUDE STATEMENT HAS AN INVALID
C                  LITERAL AS ITS ARGUMENT. THE INCLUDE STATEMENT IS NOT
C                  PROCESSED.
C         ISUBTB - COUNT OF THE NUMBER OF ENTRIES IN CSUBTB
C         I1     - SUBSCRIPT VARIABLE
C         I2WK1  - LENGTH 2 INTEGER VARIABLE. USED TO FORCE ALPHABETIC
C                  CHARACTERS TO UPPER CASE
C         JBITS  - EQUIVALENCED TO CWORK, BIT SWITCHES
C         J1     - LOCATION OF THE FIRST CHARACTER FOLLOWING ENTRY,
C                  FUNCTION, OR SUBROUTINE TEXT
C         J2     - LOCATION OF THE FIRST ALPHABETIC CHARACTER FOLLOWING
C                  ENTRY, FUNCTION, OR SUBROUTINE TEXT
C         J3     - LOCATION OF THE FIRST CHARACTER FOLLOWING AN ASTERISK
C         J4     - SUBSCRIPT VARIABLE
C         J5     - LOCATION OF THE CHARACTER FOLLOWING THE FUNCTION TEXT
C                  OR THE LENGTH DESIGNATION AFTER FUNCTION. THE
C                  FUNCTION NAME OCCURS AFTER THIS LOCATION.
C         J6     - WORK AREA
C         J7     - WORK AREA
C         J8     - LOCATION OF AN ASTERISK IN A LENGTH SPECIFICATION
C         K      - SUBSCRIPT VARIABLE, INDEX OF THE CURRENT FILE NAME
C                  IN CFILEB BEING PROCESSED
C         LTRUE  - LOGICAL VARIABLE, THE LOGICAL CONSTANT TRUE
C         LFALSE - LOGICAL VARIABLE, THE LOGICAL CONSTANT FALSE
C         L1     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER OF A RECORD HAS BEEN FOUND, SET FALSE
C                  OTHERWISE
C         L2     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER FOLLOWING AN ENTRY, FUNCTION, OR SUBPROGRAM
C                  TEXT IS FOUND, SET FALSE OTHERWISE
C                  SET FALSE OTHERWISE
C         L3     - LOGICAL VARIABLE, SET TRUE WHEN THE TEXT 'FUNCTION'
C                  HAS BEEN FOUND, SET FALSE OTHERWISE
C         L4     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST NUMERIC
C                  CHARACTER OF A LENGTH CHARACTERISTIC OF A FUNCTION
C                  HAS BEEN FOUND, SET FALSE OTHERWISE
C         L5     - LOGICAL VARIABLE, SET TRUE WHEN THE LAST NUMERIC
C                  CHARACTER OF A LENGTH CHARACTERISTIC OF A FUNCTION
C                  HAS BEEN FOUND, SET FALSE OTHERWISE
C         L6     - LOGICAL VARIABLE, SET TRUE WHEN THE FIRST ALPHABETIC
C                  CHARACTER FOLLOWING 'FUNCTION' IS FOUND, SET FALSE
C                  OTHERWISE. THIS INDICATES THE START OF THE FUNCTION
C                  SUBPROGRAM NAME HAS BEEN FOUND.
C         L7     - LOGICAL VARIABLE, SET TRUE WHEN THE LAST ALPHABETIC
C                  CHARACTER OF THE FUNCTION SUBPORGRAM NAME HAS BEEN
C                  FOUND, SET FALSE OTHERISE.
C         L8     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK EXISTS
C                  FOLLOWING A DATA TYPE SPECIFICATION PRIOR TO
C                  'FUNCTION', SET FALSE OTHERWISE.
C         L9     - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK EXISTS
C                  FOLLOWING 'FUNCTION' TEXT IN THE RECORD, SET FALSE
C                  OTHERWISE.
C         L10    - LOGICAL VARIABLE, SET TRUE WHEN A TYPE DEFINTION
C                  EXISTS PRIOR TO 'FUNCTION', SET FALSE OTHERWISE
C         L11    - LOGICAL VARIABLE, SET TRUE WHEN A NUMERICAL DIGIT
C                  EXISTS PRIOR TO 'FUNCTION', SET FALSE OTHERWISE
C         L12    - LOGICAL VARIABLE, SET TRUE WHEN AN ASTERISK PRECEDES
C                  'FUNCTION', SET FALSE OTHERWISE
C         L13    - LOGICAL VARIABLE, SET TRUE WHEN AN ENTRY, FINCTION,
C                  OR SUBROUTINE STATAMENT IS RECOGNIZED, SET FALSE
C                  OTHERWISE
C         NCOLS  - THE LENGTH OF THE FORTRAN INPUT SOURCE CODE RECORD
C                  TO CONTAIN THE FORTRAN SOURCE CODE TEXT
C
C     FORTRAN INPUT - OUTPUT UNITS USED
C
C         5      - THE FORTRAN PROGRAM TO BE CROSS REFERENCED; RECORD
C                  LENGTH IS UP TO 132 CHARACTERS.
C
C     COMMENTS
C
C         INTRINSIC FUNCTION NAMES ARE NOT PLACED IN THIS TABLE.
C
C         THIS SUBROUTINE IS EXECUTED ONLY ONCE EACH TIME FXREF BEGINS
C         EXECUTION PRIOR TO ANY ANAYLSIS OF FORTRAN STATEMENTS. A
C         MAXIMUM OF 1000 SUBPROGRAMS MAY OCCUR WITHIN A SINGLE
C         PROGRAM.
C
C         THE NUMBER OF ARGUMENTS FIELD IN CSUBTB IS NOT COMPUTED IN
C         THIS ROUTINE. IT IS COMPUTED IN SUBPROGRAM ARGLST WHEN AN
C         ENTRY, FUNCTION, OR SUBPROGRAM STATEMENT IS PROCESSED FOR
C         ANALYSIS. CONSEQUENTLY, THE NUMBER OF ARGUMENTS IS UNKNOWN
C         WHEN PROCESSING OF INDIVIUAL FORTRAN STATEMENTS BEGINS.
C
C         AN ENTRY STATEMENT HAS THE FOLLOWING FORM:
C         ENTRY {NAME} [ARGUMENTS]
C
C         A FUNCTION STATEMENT HAS ONE OF THE FOLLOWING FORMS:
C         CASE 1: FUNCTION {NAME} [ARGUMENTS]
C         CASE 2: {DATA TYPE} FUNCTION {NAME} [ARGUMENTS]
C         CASE 3: {DATA TYPE} FUNCTION {NAME}*{LENGTH} [ARGUMENTS]
C         CASE 4: {DATA TYPE}*{LENGTH} FUNCTION {NAME} [ARGUMENTS]
C
C         NOTE THAT THE FORM:
C         FUNCTION*{LENGTH} {NAME} [ARGUMENTS]
C         IS AN ILLEGAL SYNTAX.
C
C         A SUBROUTINE STATEMENT HAS THE FOLLOWING FORM:
C         SUBROUTINE {NAME} [ARGUMENTS]
C
C         A COLON, EQUAL SIGN, APOSTROPHE, OR A QUOTATION MARK MAY
C         FOLLOW AN ENTRY, FUNCTION, OR SUBROUTINE STATEMENT
C
C         A COLON, COMMA, APOSTROPHE, QUOTATION MARK, LEFT OR RIGHT
C         PARENTHESIS, OR EQUAL SIGN MAY PRECEDE AN ENTRY, FUNCTION, OR
C         SUBROUTINE STATEMENT.
C
C     SUBROUTINES CALLED BY THIS MODULE
C
C         IBSET SETTL TABINS
C
C     ******************************************************************
C
      SUBROUTINE SUBTBL (CFILEB,INFILE)
C
C         IMPLICIT STATEMENT
C
      IMPLICIT INTEGER*4 (I-N), REAL*4 (A-H,O-Z)
C
C         DIMENSION STATEMENTS
C
      DIMENSION CDIM(1000), CEXTNL(1000), CIFILE(20), CIMPL(27),
     1  CNAME(4000), COMTBL(200), CPARAM(4000), COUTV(100), CSREC(20),
     2  CRECTB(1000), CSTR(1000), CSTRNM(20), CUNION(500), CSUBTB(1000),
     3  CVARST(1000), FCONFT(4000), ICONIT(2,2000), IENAME(13,4000),
     4  IOUTC(100), ISNUM(2,1000), ISRECL(20), JCONFT(4000), JSTR(20),
     5  JSUBTB(17,1000)
      DIMENSION FUNTBL(143), CLITLN(500), ICONTL(2,100), NFLOC(30)
      DIMENSION CTYPE(5), IFLEN(5), ISNW(1000), ISTART(5), LASC(5)
      DIMENSION CFILEB(10)
C
C         TYPE STATEMENTS
C
      CHARACTER*6606  CSTMT
      CHARACTER*1532  CUSE
      CHARACTER*1496  CDEF, CDEFS
      CHARACTER*132   CREC, CSREC, CSAVST
      CHARACTER*111   CFMTH
      CHARACTER*104   CDIM
      CHARACTER*92    CLITWK
      CHARACTER*82    CFMTL
      CHARACTER*80    CFILEN, CFILEB, CIFILE
      CHARACTER*72    CVARST
      CHARACTER*68    CRECTB, CWK68
      CHARACTER*56    CSUBTB
      CHARACTER*52    CBLK52, CNAME, CPARAM, CWORK
      CHARACTER*44    CUNION
      CHARACTER*40    COMTBL
      CHARACTER*36    CSTR, CSTRNM
      CHARACTER*35    FUNTBL
      CHARACTER*32    CEXTNL, COUTV, CPGNME, CWK32
      CHARACTER*8     CBLANK, CIMPL, CWK8
      CHARACTER*8     CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1                CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      CHARACTER*7     CLITLN
      CHARACTER*2     CI2WK1
      CHARACTER*1     CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1                CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT,
     2                CUU, CVV, CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      CHARACTER*1     C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      CHARACTER*1     CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1                CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR,
     2                CMINUS, COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK,
     3                CRPAR, CSLASH, CSHARP, CSYMCD, CSYMCE, CSYMCF,
     4                CUNDER
      CHARACTER*1     CHAR1, CHAR2, CTYPE
      REAL*8          FCONFT, FP
      INTEGER*2       ISRECL, I2WK1
      INTEGER*2       ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1                IDXF
      LOGICAL*1       L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1                LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM,
     2                LNONE, LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART,
     3                LSTMT, LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR,
     4                LZEND
      LOGICAL*1       LASC, L1, L2, L3, L4, L5, L6, L7, L8, L9, L10,
     1                L11, L12, L13
C
C         COMMON STATEMENTS
C
      COMMON /ALPHA/ CAA, CBB, CCC, CDD, CEE, CFF, CGG, CHH, CII, CJJ,
     1       CKK, CLL, CMM, CNN, COO, CPP, CQQ, CRR, CSS, CTT, CUU, CVV,
     2       CWW, CXX, CYY, CZZ, CAS, CCS, CSC, CZS
      COMMON /DIGITS/ C0, C1, C2, C3, C4, C5, C6, C7, C8, C9
      COMMON /SYMBOL/ CAMP, CAPOS, CAPOSD, CASTER, CBAR, CBSLAS, CCR,
     1       CDASH, CDOL, CDOT, CEQ, CEXCL, CLBRAK, CLF, CLPAR, CMINUS,
     2       COLON, COMMA, CPERC, CPLUS, CQUES, CRBRAK, CRPAR, CSLASH,
     3       CSHARP, CSYMCD, CSYMCE, CSYMCF, CUNDER
      COMMON /WERK/  FP, I, IA, IB, IC, IEOF, INPUT, ISPLIT, I4WK1, J,
     1       JA, JB, JC, K, KA, KB, KC, KD, KE, KF, KI, KISN, KSNA,
     2       NA, NB, NBITS, I2WK1, CBLANK, CLITWK, CWK8
      COMMON /KOUNT/ ICALKT, ICOMKT, ICONF, ICONI, ICONT, IEXTNL, JDIM,
     1       ILIT, INAME, IOUTNC, IOUTNV, IP, IPAGE, IPGNME, IRECD,
     2       IREC0, IREC1, IREC2, IREC3, IREC4, IREC5, IREC6, IREC7,
     3       IREC8, IREC9, IREC10, IREC11, IREC12, ISN, ISRECL, ISTRUC,
     4       ISUBTB, IUNION, JINCL, JSNA, JSTRUC, JUNION, MNUM, NARGS,
     5       NARGM, NCOLS, NLINE, NLINES, NMELEN, NVARST
      COMMON /LOGIC/ L, LAPOS, LBIT, LCALL, LEND, LENDS, LEOF, LEXEC,
     1               LFALSE, LFOR, LFORCE, LGLOBL, LINCL, LINCLM, LNONE,
     2               LPARAM, LPAREN, LPROG, LREC, LSNUM, LSTART, LSTMT,
     3               LSTRUC, LTEST, LTRUE, LUNION, LVAR, LWR, LZEND
      COMMON /STATE/ CBLK52, CFMTL, CREC, CSAVST, CSREC, CSTMT, CWORK,
     1               CWK32, CWK68
      COMMON /TABLES/ FCONFT, ICONIT, ICONTL, IOUTC, ISNUM, JCONFT,
     1                JSTR, CDIM, CEXTNL, CIFILE, CIMPL, CNAME,
     2                COMTBL, COUTV, CPARAM, CRECTB, CSTR, CSTRNM,
     3                CSUBTB, CUNION, CVARST
      COMMON /PDATA/ IFLEN, ISNW, ISTART, LASC, CFMTH, CTYPE, CPGNME
      COMMON /FILES/ CFBUFF, CFCALL, CFCOMM, CFEQUI, CFFUNT, CFIUNT,
     1               CFCLEN, CFMESS, CFSLIT, CFSUBP, CFSNUM, CFVNME
      COMMON /CHECK/ ILITCT, NFCNT, NFLOC, FUNTBL, CLITLN, CDEF, CDEFS,
     1               CUSE
      COMMON /ASCII/ ICAPS, ICTN, IDTN, IDXA, IDXB, IDXC, IDXD, IDXE,
     1               IDXF
C
C         EQUIVALENCE STATEMENTS
C
      EQUIVALENCE (CI2WK1,I2WK1), (CSUBTB,JSUBTB), (CWORK(49:52),IVCNT),
     1            (CWORK(45:48),JBITS), (CNAME,IENAME)
C
C       SAVE STATEMENT
C
      SAVE
C
C         FORMAT STATEMENTS
C
 100  FORMAT(A72)
 101  FORMAT(A132)
 102  FORMAT(' SUBPROGRAM NAME TABLE FULL')
C
C         SET TABLE CSUBTB TO BLANKS, INITALIZE BIT SWITCHES, AND SET
C         THE ISN TO ZERO
C
      DO 10 I = 1,1000
      CSUBTB(I)(1:52) = CBLK52(1:52)
      JSUBTB(12,I) = 0
      JSUBTB(9,I) = 0
 10   CONTINUE
C
C         INITIALIZE LOGICAL SWITCHES
C
      L1 = LFALSE
      L2 = LFALSE
      L3 = LFALSE
      L4 = LFALSE
      L5 = LFALSE
      L6 = LFALSE
      L7 = LFALSE
      L8 = LFALSE
      L9 = LFALSE
      L13 = LFALSE
C
C         SET LOOP TO PROCESS ALL INPUT FILES CONTAINING FORTRAN CODE
C         FOR ANALYSIS. THEY ARE IN RECORDS 3 THROUGH 12 ON UNIT 1.
C
      DO 48 K = 1,INFILE
C
C         SET THE FILE NAME TO BE PROCESSED
C
      CFILEN(1:80) = CFILEB(K)(1:80)
C
C         OPEN ONE OF THE FILES OF INPUT FORTRAN CODE
C
      OPEN (UNIT=5,FILE=CFILEN,ACCESS='SEQUENTIAL',FORM='FORMATTED',
     1ACTION='READ')
C
C         READ UNIT 5 RECORDS
C
 11   CREC(1:132) = CBLK52(1:50)//CBLK52(1:50)//CBLK52(1:32)
      CWORK(1:52) = CBLK52(1:52)
      JBITS = 0
      IF(NCOLS .LE. 72) THEN
         READ (5,100,IOSTAT=IEOF) CREC(1:NCOLS)
      ELSE
         READ (5,101,IOSTAT=IEOF) CREC(1:NCOLS)
      END IF
C
C         DETERMINE IF AN END OF FILE OCCURRED
C
      IF(IEOF .EQ. -1) THEN
         REWIND (5)
         CLOSE (5)
         GO TO 48
      END IF
C
C         DETERMINE IF AN INLINE COMMENT OCCURS AND REMOVE IT FROM THE
C         RECORD. THIS WILL PREVENT TEXT SPECIFYING ENTRY, FUNCTION, OR
C         SUBROUTINE AS COMMENTS FROM BEING TREATED AS A FORTRAN
C         STATEMENT.
C
      DO 12 I = NCOLS,1,-1
      IF(CREC(I:I) .EQ. CEXCL) THEN
         J6 = NCOLS - I + 1
         IF(J6 .LE. 52) THEN
            CREC(I:NCOLS) = CBLK52(1:J6)
         ELSE
            CREC(I:I+51) = CBLK52(1:52)//CBLK52(1:J6-52)
         END IF
      END IF
 12   CONTINUE
C
C         DETERMINE IF THE RECORD IS A COMMENT OR COMPILER DIRECTIVE.
C         THESE RECORDS ARE NOT PROCSSED.
C
      IF(.NOT.(CREC(1:1) .GE. C0 .AND. CREC(1:1) .LE. C9) .AND.
     1   CREC(1:1) .NE. CBLANK(1:1)) GO TO 11
C
C         DO NOT PROCESS CONTINUATION RECORDS
C
      IF(CREC(6:6) .NE. CBLANK(1:1)) GO TO 11
C
C         FORCE UPPER CASE
C
      ILOCF = 0
      DO 13 I = 7,NCOLS
      I2WK1 = 0
C
C         FORCE ALL ALPHABETIC CHARACTERS IN THE RECORD TO UPPER CASE
C
      IF(CREC(I:I) .GE. CAS .AND. CREC(I:I) .LE. CZS) THEN
         CI2WK1(IDXE:IDXE) = CREC(I:I)
         I2WK1 = I2WK1 - ICAPS
         CREC(I:I) = CI2WK1(IDXE:IDXE)
      END IF
C
C         DETERMINE THE LOCATION OF THE FINAL CHARACTER IN A RECORD
C
      J = NCOLS - (I + 7)
      IF(ILOCF .EQ. 0 .AND. CREC(J:J) .NE. CBLANK(1:1)) THEN
         ILOCF = J                    ! FINAL CHARACTER OF RECORD
      END IF
 13   CONTINUE
C
C         DETERMINE IF THE ENTIRE RECORD IS BLANK
C
      IF(ILOCF .EQ. 0) GO TO 11
C
C         LOOP FOR TO LOCATE THE FIRST ALPHABETIC CHARACTER OF THE
C         RECORD
C
      CHAR1(1:1) = CBLANK(1:1)
      ILOC = 0
      ILOCE = 0
      ILOCFF = 0
      ILOCS = 0
      L1 = LFALSE
      DO 14 I = 7,ILOCF
C
C         SAVE THE FIRST NON-BLANK CHARACTER OF THE RECORD AFTER COLUMN
C         6 AND ITS LOCATION
C
      IF(.NOT.L1 .AND. (CREC(I:I) .GE. CAA .AND. CREC(I:I) .LE. CZZ .OR.
     1    CREC(I:I) .EQ. CUNDER)) THEN
          CHAR1(1:1) = CREC(I:I)
          ILOC = I                    ! INITIAL CHARACTER OF THE RECORD
          ILOC6 = I                   ! INITIAL CHARACTER OF THE RECORD
          L1 = LTRUE
      END IF
C
C         IDENTIFY THE LOCATION OF THE INITIAL OCCURRENCE OF THE LETTERS
C         E, F, OR S IN THE RECORD. THEY MAY BE THE START OF AN ENTRY,
C         FUNCTION, OR SUBROUTINE STATEMENT.
C
      IF(ILOCE .EQ. 0 .AND. CREC(I:I) .EQ. CEE) THEN
         IF(L13) GO TO 11
         ILOCE = I
         IF(CREC(ILOCE:ILOCE+4) .EQ. 'ENTRY') THEN
            IF(CREC(ILOCE-1:ILOCE-1) .NE. CBLANK(1:1) .AND.
     1         CREC(ILOCE+5:ILOCE+5) .NE. CBLANK(1:1)) THEN
               GO TO 11
            ELSE
               ILOC = ILOCE
               L13 = LTRUE
               GO TO 15
            END IF
         END IF
      END IF
      IF(ILOCFF .EQ. 0 .AND. CREC(I:I) .EQ. CFF) THEN
         IF(L13) GO TO 11
         ILOCFF = I
         IF(CREC(ILOCFF:ILOCFF+7) .EQ. 'FUNCTION') THEN
            IF(CREC(ILOCFF-1:ILOCFF-1) .NE. CBLANK(1:1) .AND.
     1         CREC(ILOCFF+8:ILOCFF+8) .NE. CBLANK(1:1)) THEN
               GO TO 11
            ELSE
               ILOC = ILOCFF
               L13 = LTRUE
               GO TO 15
            END IF
         END IF
      END IF
      IF(ILOCS .EQ. 0 .AND. CREC(I:I) .EQ. CSS) THEN
         IF(L13) GO TO 11
         ILOCS = I
         IF(CREC(ILOCS:ILOCS+9) .EQ. 'SUBROUTINE') THEN
            IF(CREC(ILOCS-1:ILOCS-1) .NE. CBLANK(1:1) .AND.
     1         CREC(ILOCS+10:ILOCS+10) .NE. CBLANK(1:1)) THEN
               GO TO 11
            ELSE
               ILOC = ILOCS
               L13 = LTRUE
               GO TO 15
            END IF
         END IF
      END IF
 14   CONTINUE
C
C         SEARCH THE RECORD FOR AN ENTRY, FUNCTION, OR SUBROUTINE
C         STATEMENT
C
 15   DO 47 I1 = ILOC,ILOCF
C
C         DETERMINE THE LOCATION OF THE FIRST NON-BLANK CHARACTER OF
C         THE RECORD
C
C     IF(CREC(I1:I1) .NE. CBLANK(1:1)) THEN
C        I = I1
C        LL = LTRUE
C     END IF
C
C     ******************************************************************
C     *                                                                *
C     *   ENTRY STATEMENT PROCESSING                                   *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF THE LOCATION OF THE CHARACTER E IS THE FIRST
C         NON-BLANK CHARACTER OF THE RECORD.
C
      IF(CREC(I:I) .EQ. CEE) THEN
C
C         DETERMINE IF THE CHARACTER E IS THE START OF AN ENTRY
C         STATEMENT
C
         IF(CREC(I:I+4) .NE. 'ENTRY') GO TO 21
         IF(CREC(I:I+4) .EQ. 'ENTRY' .AND. ILOC .EQ. I) THEN
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK, LEFT
C         OR RIGHT PARENTHESIS, OR COLON PRECEDES 'ENTRY'.
C
            DO 16 J7 = I-1,7,-1
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. CLPAR .OR.
     2         CREC(J7:J7) .EQ. CRPAR .OR. CREC(J7:J7) .EQ. COLON)
     3         GO TO 21
 16         CONTINUE
C           END DO
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK,
C         OR COLON FOLLOWS 'ENTRY'.
C
            DO 17 J7 = I+5,ILOCF
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. COLON)
     2         GO TO 21
C    2         GO TO 271
 17         CONTINUE
C
C         DETERMINE THE NAME OF THE ENTRY DEFINITION
C
            J1 = I + 5
            L2 = LFALSE
            DO 19 J = J1,ILOCF
C
C         SAVE THE FIRST ALPHABETIC CHARACTER FOLLOWING 'ENTRY' AND ITS
C         LOCATION
C
            IF(.NOT.L2 .AND. (CREC(J:J) .GE. CAA .AND. CREC(J:J) .LE.
     1         CZZ) .OR. CREC(J:J) .EQ. CUNDER) THEN
               CHAR2(1:1) = CREC(J:J)
               J2 = J
               L2 = LTRUE
            END IF
C
C         DETECT THE INITIAL OCCURRENCE OF A LEFT PARENTHESIS
C
            IF(CREC(J:J) .EQ. CLPAR(1:1)) THEN
C
C         SCAN BACKWARDS TO LOCATE THE END OF THE ENTRY NAME
C
               DO 18 J3 = J2,J1,-1
C
C         DETERMINE THE FIRST NON-BLANK CHARACTER TO LOCATE THE END OF
C         THE SUBPROGRAM NAME
C
               IF(CREC(J3:J3) .NE. CBLANK(1:1)) THEN
C
C         DETERMINE IF THE CHARACTER IS VALID IN A VARIABLE NAME
C
                  IF(CREC(J3:J3) .GE. CAA .AND. CREC(J3:J3) .LE. CZZ
     1               .OR. CREC(J3:J3) .GE. C0 .AND. CREC(J3:J3) .LE. C9
     2               .OR. CREC(J3:J3) .EQ. CUNDER .OR. CREC(J3:J3) .EQ.
     3               CDOL) THEN
                     IVCNT = J3 - J2 + 1
                     CWORK(1:IVCNT) = CREC(J2:J3)
                     GO TO 20
                  END IF
               END IF
 18            CONTINUE
            ELSE
C
C         WHEN ANY OTHER CHARACTER FOLLOWING 'ENTRY' OCCURS BEFORE A
C         LEFT PARENTHESIS THAT IS NOT A BLANK, THIS IS NOT AN ENTRY
C         STATEMENT.
C
               IF(CREC(J:J) .NE. CBLANK(1:1)) GO TO 11
            END IF
 19         CONTINUE
C
C         ENTRY NAME LENGTH WHEN NO ARGUMENT LIST EXISTS
C
            IVCNT = ILOCF - I + 1
C
C         SET UP TABLE ENTRIES
C
 20         CWORK(I:ILOCF) = CREC(I:IVCNT)
            JBITS = IBSET(JBITS,8)
C
C         PLACE AN ENTRY NAME IN CSUBTB
C
            IF(ISUBTB .GT. 1000) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102)
               GO TO 49
            END IF
            CALL TABINS (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,1000)
            GO TO 11
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   FUNCTION STATEMENT PROCESSING                                *
C     *                                                                *
C     ******************************************************************
C
C         SEARCH FOR THE FIRST F CHARACTER IN THE RECORD
C
 21   IF(CREC(I:I) .EQ. CFF) THEN
         L8 = LFALSE
         L11 = LFALSE
         L12 = LFALSE
C
C         DETERMINE IF THE F CHARACTER IS THE START OF 'FUNCTION'
C
         IF(CREC(I:I+7) .EQ. 'FUNCTION') THEN
C
C         DETERMINE IF THE WORD FUNCTION IS A SUBROUTINE VARIABLE
C         NAME
C
            IF(CREC(ILOC6:ILOC6+10) .EQ. 'SUBROUTINE ') GO TO 41
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK, LEFT
C         OR RIGHT PARENTHESIS, COLON OR A NUMERICAL DIGIT PRECEDES
C         'FUNCTION'
C
            J8 = 0
            DO 22 J7 = I+7,7,-1
            IF(CREC(J7:J7) .GE. C0 .AND. CREC(J7:J7) .LE. C9)
     1         L11 = LTRUE
C
C         SET BIT SWITCH TO INDICATE THIS FUNCTION HAS A LENGTH
C         SPECIFIED
C
            IF(CREC(J7:J7) .EQ. CASTER) THEN
               JBITS = IBSET(JBITS,10)
               J5 = I + 8
               J8 = J7
               L12 = LTRUE
            END IF
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. CLPAR .OR.
     2         CREC(J7:J7) .EQ. CRPAR .OR. CREC(J7:J7) .EQ. COLON) THEN
               IF(L12) THEN
                  GO TO 24
               ELSE
                  GO TO 41
               END IF
            END IF
 22         CONTINUE
C           END DO
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK,
C         OR COLON FOLLOWS 'FUNCTION'.
C
            DO 23 J7 = I+8,ILOCF
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. COLON)
     2         GO TO 41
 23         CONTINUE
 24         ILOC5 = 0
C
C         THIS IS CASE 1
C         NO TYPE OR LENGTH DESIGNATED WHEN 'FUNCTION' IS IN THE INITIAL
C         EIGHT CHARACTERS OF THE RECORD
C
C         WHEN ILOC EQUALS I , THE CHARACTER F IS THE FIRST CHARACTER
C         OF THE RECORD.
C
            IF(J8 .EQ. I .OR. .NOT.L11 .AND. .NOT.L12) THEN
C
C         IF 'FUNCTION' CONTAINS NO PRIOR TYPE AND LENGTH SPECIFICATION,
C         NO LENGTH SPECIFICATION MAY FOLLOW 'FUNCTION'. LOCATE THE
C         START AND END LOCATION OF THE FUNCTION NAME.
C
               J1 = I + 8             ! NEXT CHARACTER AFTER FUNCTION
               ILOC3 = 0
               ILOC4 = 0
               L6 = LFALSE
               L7 = LFALSE
               DO 25 J = J1,ILOCF
C              DO 18 J = J1,ILOCF
C
C         DETERMINE THE START LOCATION OF THE FUNCTION NAME
C
               IF(.NOT.L6 .AND. CREC(J:J) .GE. CAA .AND. CREC(J:J) .LE.
     1             CZZ .OR. CREC(J:J) .EQ. CUNDER) THEN
                   L6 = LTRUE
                   ILOC3 = J          ! START LOCATION OF FUNCTION NAME
               END IF
C
C         DETERMINE IF A FUNCTION STATEMENT SYNTAX OF THE FORM:
C         FUNCTION*{NUMBER} (NAME) [ARGUMENTS]
C         EXISTS. THIS WILL CAUSE AN ERROR MESSAGE THEN THE FUNCTION
C         ANALYSIS ROUTINE, STMT29, IS EXECUTED.
C
C
C         DETERMINE THE END LOCATION OF THE FUNCTION NAME
C
               IF(L6 .AND. .NOT.L7 .AND. CREC(J:J) .EQ. CBLANK(1:1) .OR.
     1            CREC(J:J) .EQ. CLPAR(1:1)) THEN
                  L7 = LTRUE
                  ILOC4 = J           ! END LOCATION OF FUNCTION NAME
                  GO TO 26
C                 GO TO 19
               END IF
 25            CONTINUE
C
C         PLACE THE FUNCTION NAME IN CWORK
C
 26            IVCNT = ILOC4 - ILOC3         ! LENGTH OF FUNCTION NAME
               CWORK(1:IVCNT) = CREC(ILOC3:ILOC4)
C
C         SET THE FUNCTION DEFINITION BIT SWITCH
C
               JBITS = IBSET(JBITS,10)
C
C         SET THE TYPE CODE AND LENGTH CHARACTERISTIC FROM THE IMPLICIT
C         TABLE
C
               CALL SETTL (CWORK)
C
C         PLACE THE FUNCTION DEFINITION IN CSUBTB
C
               IF(ISUBTB .GE. 1000) THEN
                  IREC0 = IREC0 + 1
                  WRITE (0,102)
                  GO TO 49
               END IF
C
C         WHEN AN ASTERISK PRECEDES 'FUNCTION', DO NOT INSERT AN ENTRY
C         INTO CSUBTB. THE TYPE AND LENGTH ARE WRONG AT THIS STAGE OF
C         PROCESSING.
C
               IF(.NOT.L12) CALL TABINS (CSUBTB,ISUBTB,56,1,32,CWORK,1,
     1            32,IRET,1000)
C
C         DETERMINE IF THE CHARACTER PRECEDING THE CHARACTER F IS A
C         NUMERICAL DIGIT
C
               IF(.NOT.L11) GO TO 11
            END IF
C
C         WHEN THE CHARACTER F IS NOT THE FIRST CHARACTER OF THE
C         STATEMENT, DETERMINE IF A DATA TYPE DECLARATION PRECEDES THE
C         THE 'FUNCTION' TEXT.
C
C         THIS MAY BE CASES 2, 3, OR 4
C
            IF(CHAR1(1:1) .EQ. CCC) THEN
               IF(CREC(ILOC6:ILOC6+8) .EQ. 'CHARACTER') THEN
C
C         A CHARACTER DATA TYPE EXISTS
C
                  L10 = LTRUE
                  ILOC5 = ILOC6 + 9    ! LOCATION FOLLOWING 'CHARACTER'
                  CWORK(37:37) = CCC
               END IF
C
C         DETERMINE IF 'COMPLEX' IS THE TYPE DESIGNATION
C
               IF(CREC(ILOC:ILOC6+6) .EQ. 'COMPLEX') THEN
C
C         A COMPLEX DATA TYPE EXISTS
C
                  L10 = LTRUE
                  ILOC5 = ILOC6 + 7      ! LOCATION FOLLOWING 'COMPLEX'
                  CWORK(37:37) = CBB
               END IF
            ELSE IF(CHAR1(1:1) .EQ. CDD .AND. CREC(ILOC6:ILOC6+5) .EQ.
     1               'DOUBLE') THEN
C
C         DETERMINE IF COMPLEX OR PRECISION FOLLOWS 'DOUBLE'
C
               J1 = ILOC6 + 6
               DO 27 J = J1,I
C
C         A DOUBLE COMPLEX DATA TYPE EXISTS
C
               IF(CREC(J:J) .EQ. CBLANK(1:1)) GO TO 27
C              IF(CREC(J:J) .EQ. CBLANK(1:1)) GO TO 20
               IF(CREC(J:J+6) .EQ. 'COMPLEX') THEN
                  ILOC5 = J + 7         ! LOCATION FOLLOWING 'COMPLEX'
                  CWORK(37:37) = CEE
                  CWORK(38:39) = '16'
                  GO TO 40
               END IF
C
C         A DOUBLE PRECISION DATA TYPE EXISTS
C
               IF(CREC(J:J) .EQ. 'PRECISION') THEN
                  ILOC5 = J + 9         ! LOCATION FOLLOWING 'PRECISION'
                  CWORK(37:37) = CDD
                  CWORK(38:38) = C8
                  GO TO 40
               END IF
 27            CONTINUE
            ELSE IF(CHAR1(1:1) .EQ. CII .AND. CREC(ILOC6:ILOC6+6) .EQ.
     1              'INTEGER') THEN
C
C         AN INTEGER DATA TYPE EXISTS
C
               L10 = LTRUE
               ILOC5 = ILOC6 + 7      ! LOCATION FOLLOWING 'INTEGER'
               CWORK(37:37) = CII
            ELSE IF(CHAR1(1:1) .EQ. CLL .AND. CREC(ILOC6:ILOC6+6) .EQ.
     1              'LOGICAL') THEN
C
C         A LOGICAL DATA TYPE EXISTS
C
               L10 = LTRUE
               ILOC5 = ILOC6 + 7      ! LOCATION FOLLOWING 'LOGICAL'
               CWORK(37:37) = CLL
            ELSE IF(CHAR1(1:1) .EQ. CRR .AND. CREC(ILOC6:ILOC6+3) .EQ.
     1              'REAL') THEN
C
C         A REAL DATA TYPE EXISTS
C
               L10 = LTRUE
               ILOC5 = ILOC6 + 4       ! LOCATION FOLLOWING REAL
               CWORK(37:37) = CRR
            END IF
C
C         WHEN ILOC5 IS ZERO, NO DATA TYPE SPECIFICATION EXISTS BEFORE
C         'FUNCTION'
C
            IF(ILOC5 .EQ. 0) GO TO 32
C
C         WHEN THIS POINT IS REACHED, THE DATA TYPE CODE IS NOW IN
C         CWORK. ADD THE LENGTH CHARACTERISTIC TO CWORK IF ONE IS
C         SPECIFIED.
C
C         DETERMINE IF THE START AND END OF THE NUMERICAL FIELD DEFINING
C         THE LENGTH CHARACTERISTIC PRECEDES 'FUNCTION'
C
            DO 31 J = ILOC5,I
C
C         SKIP OVER BLANK CHARACTERS
C
            IF(CREC(J:J) .EQ. CBLANK(1:1)) GO TO 31
C
C         DETECT AN ASTERISK BETWEEN THE DATA TYPE AND 'FUNCTION'.
C         THIS MEANS THE LENGTH SPECIFICATION PRECEDES 'FUNCTION'
C
            IF(CREC(J:J) .EQ. CASTER(1:1)) THEN
C
C         THIS IS CASE 4
C
C         LOCATE THE START AND END LOCATIONS OF THE NUMERICAL VALUE OF
C         LENGTH DESIGNATION. THE LENGTH LENGTH MUST BE NUMERIC, SINCE
C         A FUNCTION STATEMENT MUST PRECEDE ANY PARAMETER DEFINITIONS.
C         CONSEQUENTLY, THE LENGTH MAY NOT BE A VARIABLE NAME OR AN
C         EXPRESSION.
C
               J2 = J + 1
               L4 = LFALSE
               DO 29 J1 = J2,I
C
C         A FUNCTION DATA TYPE DEFINITION PRECEDES THE WORD 'FUNCTION'
C
               L5 = LFALSE
               L8 = LTRUE
C
C         LOCATE THE FIRST NUMERICAL DIGIT FOLLOWING THE ASTERISK
C
               IF(CREC(J1:J1) .GE. C0 .AND. CREC(J1:J1) .LE. C9 .AND.
     1            .NOT. L4) THEN
                  ILOC1 = J1
                  L4 = LTRUE
               END IF
C
C         LOCATE THE LAST NUMERICAL DIGIT FOLLOWING THE ASTERISK
C
               IF(CREC(J1:J1) .EQ. CFF .AND. L4) THEN
                  IF(CREC(J1-1:J1-1) .GE. C0 .AND. CREC(J1-1:J1-1) .LE.
     1               C9) THEN
                     ILOC2 = J1
                  ELSE
                     DO 28 J7 = J1,J2,-1
                     IF(CREC(J7:J7) .GE. C0 .AND. CREC(J7:J7) .LE. C9)
     1                  THEN
                        ILOC2 = J7
                        GO TO 30
                     END IF
 28                  CONTINUE
                  END IF
               END IF
 29            CONTINUE
C
C         PLACE THE LENGTH TEXT INTO CWORK
C
 30            IF(ILOC1 .EQ. ILOC2) THEN
                  J7 = 1
               ELSE
                  J7 = ILOC2 - ILOC1
               END IF
               CWORK(38:38+J7) = CREC(ILOC1:ILOC2)
            END IF
 31         CONTINUE
C
C         DETERMINE IF THE LENGTH SPECIFICATION FOLLOWS 'FUNCTION'
C
 32         IF(.NOT.L8) THEN
               J5 = 0
               L9 = LFALSE
               L10 = LFALSE
               ILOC1 = 0
               ILOC2 = 0
C
C         DETERMINE IF AN ASTERISK FOLLOWS 'FUNCTION' INDICATING A
C         LENGTH DESIGNATION WHEN NO LENGTH FOLLOWED THE DATA TYPE
C         DECLARATION.
C
               J1 = I + 8
C
C         DETERMINE IF AN ASTERISK IMMEDIATELY FOLLOWS 'FUNCTION'. THIS
C         IS AN ILLEGAL SYNTAX AND IS NOT PROCESSED
C
               IF(.NOT. L8 .AND. CREC(J1:J1) .EQ. CASTER) GO TO 11
               DO 35 J = J1,ILOCF
C
C          DETERMINE THE CHARACTER FOLLOWING 'FUNCTION'. WHEN AN
C          ASTERISK IS THE FIRST NON-BLANK CHARACTER FOLLOWING
C          'FUNCTION', THIS IS AN ILLEGAL SYNTAX.
C
               IF(CREC(J:J) .EQ. CBLANK(1:1) .OR. ((CREC(J:J) .GE. CAA
     1            .AND. CREC(J:J) .LE. CZZ) .OR. CREC(J:J) .EQ.
     2            CUNDER)) THEN
C
C         WHEN THE START OF THE FUNCTION NAME HAS BEEN DETERMINED, A
C         BLANK WILL TERMINATE THE FUNCTION NAME
C
                  IF(ILOC3 .GT. 0 .AND. CREC(J:J) .EQ. CBLANK(1:1))
     1               ILOC4 = J - 1
C
C         DETERMINE IF AN ALPHABETIC CHARACTER IS THE FIRST CHARACTER
C         FOLLOWING THE BLANK
C
                  IF(J .EQ. J1) THEN
                     IF((CREC(J+1:J+1) .GE. CAA .AND. CREC(J+1:J+1) .LE.
     1                  CZZ) .OR. CREC(J+1:J+1) .EQ. CUNDER) THEN
                        J3 = J + 1
                        ILOC3 = J + 1
                     END IF
                  END IF
                  CONTINUE
               ELSE
C
C         WHEN A CHARACTER IS NOT BLANK AND NOT AN ASTERISK, NO LENGTH
C         SPECIFICATION EXISTS.
C
                  IF(CREC(J:J) .NE. CASTER(1:1)) THEN
C
C         THIS IS CASE 2: {DATA TYPE} FUNCTION {NAME} [ARGUMENTS]
C
                     J5 = J
                     GO TO 36
                  END IF
               END IF
C
C         DETERMINE IF THE CHARACTER IS AN ASTERISK.
C
               IF(CREC(J:J) .EQ. CASTER(1:1)) THEN
C
C         SET LOCATION OF THE END OF THE FUNCTION NAME
C
                  ILOC4 = J - 1
C
C         DETERMINE IF THIS IS OF THE FORM: FUNCTION*{LENGTH}. THIS
C         IS AN ILLEGAL SYNTAX. SKIP FURTHER PROCESSING.
C
                  IF(CREC(J-8:J-1) .EQ. 'FUNCTION') GO TO 11
C
C         LOCATE THE START AND FINAL NUMERICAL DIGIT FOLLOWING THE
C         ASTERISK. THIS IS CASE 3.
C         {DATA TYPE} FUNCTION {NAME}*{LENGTH) [ARGUMENTS]
C
                  L10 = LTRUE
                  J3 = J + 1
                  DO 34 J6 = J3,ILOCF
C
C         DETERMINE IF THE FIRST CHARACTER FOLLOWING THE ASTERISK IS A
C         NUMERICAL DIGIT
C
                  IF(CREC(J6:J6) .GE. C0 .AND. CREC(J6:J6) .LE. C9 .AND.
     1               ILOC1 .EQ. 0) THEN
                     ILOC1 = J6       ! LENGTH INITIAL DIGIT LOCATION
                     GO TO 34
                  END IF
C
C         DETECT THE FIRST NON-NUMERIC CHARACTER AND DETERMINE THE
C         LOCATION OF THE FINAL NUMERIC DIGIT OF THE LENGTH
C
                  IF(.NOT.(CREC(J6:J6) .GE. C0 .AND. CREC(J6:J6) .LE.
     1               C9) .AND. ILOC6 .NE. 0 .AND. ILOC2 .EQ. 0) THEN
                     ILOC2 = J6 - 1   ! LENGTH FINAL DIGIT LOCATION
C
C         DETERMINE LOCATION OF THE FINAL DIGIT OF THE LENGTH FIELD
C
                     DO 33 J2 = ILOC1,J6
                     IF(CREC(J2:J2) .GE. C0 .AND. CREC(J2:J2) .LE. C9)
     1                  THEN
                        L5 = LTRUE
                        J4 = ILOC2 - ILOC1     ! SIZE OF LENGTH FIELD
                        J5 = ILOC2 + 1
C
C         PLACE THE FUNCTION NAME IN CWORK
C
                        CWORK(1:ILOC4-ILOC3+1) = CREC(ILOC3:ILOC4)
C
C         DETERMINE IF A TYPE CODE EXISTS IN CWORK
C
                        IF(CWORK(37:37) .EQ. CBLANK(1:1)) THEN
                           CALL SETTL (CWORK)
                        END IF
                        JBITS = IBSET(JBITS,10)
C
C         PLACE LENGTH IN CWORK
C
                        CWORK(38:38+J4) = CREC(ILOC1:ILOC2)
                        GO TO 40
                     END IF
 33                  CONTINUE
                  END IF
 34               CONTINUE
               END IF
 35            CONTINUE
            END IF
C
C         DETERMINE THE FUNCTION NAME
C
 36         DO 39 J = J5,ILOCF
C
C         DETERMINE THE FINAL CHARACTER OF THE FUNCTION NAME
C
            IF(CREC(J:J) .EQ. CBLANK(1:1)) THEN
               GO TO 39
            ELSE
               IF(CREC(J:J) .GE. CAA .AND. CREC(J:) .LE. CZZ .OR.
     1            CREC(J:J) .EQ. CUNDER) THEN
                  ILOC3 = J
C
C         THE FIRST CHARACTER OF THE FUNCTION NAME HAS BEEN FOUND.
C
                  DO 37 J6 = ILOC3,ILOCF
C
C         LOCATE THE END OF THE FUNCTION NAME
C
                  IF(CREC(J6:J6) .EQ. CLPAR(1:1) .OR. CREC(J6:J6) .EQ.
     1               CBLANK(1:1)) THEN
                     ILOC4 = J6 - 1
                     GO TO 38
                  ELSE IF(J6 .EQ. ILOCF) THEN
                     ILOC4 = ILOCF
                     GO TO 38
                  END IF
 37               CONTINUE
C
C         PLACE THE FUNCTION NAME IN CWORK
C
 38               IVCNT = ILOC4 - ILOC3 + 1
                  CWORK(1:IVCNT) = CREC(ILOC3:ILOC4)
                  GO TO 40
               END IF
            END IF
 39         CONTINUE
C
C         PLACE A FUNCTION NAME IN CSUBTB
C
 40         IF(ISUBTB .GE. 1000) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102)
               GO TO 49
            END IF
            CALL TABINS (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,1000)
C
C         WHEN NO DATA TYPE IS DEFINED BUT A LENGTH IS DEFINED, THIS
C         FUNCTION DEFINITION IS ILLEGAL
C
            GO TO 11
         ELSE
            GO TO 41
         END IF
      END IF
C
C     ******************************************************************
C     *                                                                *
C     *   SUBROUTINE STATEMENT PROCESSING                              *
C     *                                                                *
C     ******************************************************************
C
C         DETERMINE IF THE LOCATION OF THE CHARACTER S IS THE FIRST
C         NON-BLANK CHARACTER OF THE RECORD.
C
 41   IF(CREC(I:I) .EQ. CSS) THEN
C
C         DETERMINE IF THE CHARACTER S IS THE START OF A SUBROUTINE
C         STATEMENT
C
         IF(CREC(I:I+9) .NE. 'SUBROUTINE') GO TO 11
         IF(CREC(I:I+9) .EQ. 'SUBROUTINE' .AND. ILOC .EQ. I) THEN
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK, LEFT
C         OR RIGHT PARENTHESIS, OR COLON PRECEDES 'SUBROUTINE'.
C
            DO 42 J7 = I-1,7,-1
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. CLPAR .OR.
     2         CREC(J7:J7) .EQ. CRPAR .OR. CREC(J7:J7) .EQ. COLON)
     3         GO TO 11
 42         CONTINUE
C
C         DETERMINE IF AN EQUAL SIGN, APOSTROPHE, QUOTATION MARK,
C         OR COLON FOLLOWS 'SUBROUTINE'.
C
            DO 43 J7 = I+10,ILOCF
            IF(CREC(J7:J7) .EQ. CEQ .OR. CREC(J7:J7) .EQ. CAPOS .OR.
     1         CREC(J7:J7) .EQ. CAPOSD .OR. CREC(J7:J7) .EQ. COLON)
     2         GO TO 11
 43         CONTINUE
C
C         DETERMINE THE NAME OF THE SUBROUTINE DEFINITION
C
            J1 = I + 10
            L2 = LFALSE
            DO 45 J = J1,ILOCF
C
C         DETERMINE IF THE CHARACTER IS A BLANK
C
            IF(CREC(J:J) .EQ. CBLANK(1:1)) GO TO 45
C
C         SAVE THE FIRST ALPHABETIC CHARACTER FOLLOWING 'SUBROUTINE' AND
C         ITS LOCATION
C
            IF(.NOT.L2 .AND. CREC(J:J) .GE. CAA .AND. CREC(J:J) .LE.
     1         CZZ .OR. CREC(J:J) .EQ. CUNDER) THEN
               CHAR2(1:1) = CREC(J:J)
               J2 = J
               L2 = LTRUE
            END IF
C
C         DETERMINE IF A RIGHT PARENTHESIS TERMINATES THE STATEMENT.
C         WHEN A RIGHT PARENTHESIS IS NOT THE FINAL CHARACTER OF THE
C         STATEMENT, NO ARGUMENT LIST EXISTS.
C
            IF(CREC(ILOCF:ILOCF) .NE. CRPAR(1:1)) THEN
               IVCNT = ILOCF - J2 + 1
               CWORK(1:IVCNT) = CREC(J1:ILOCF)
               GO TO 46
            END IF
C
C         DETECT THE INITIAL OCCURRENCE OF A LEFT PARENTHESIS
C
            IF(CREC(J:J) .EQ. CLPAR(1:1) .OR. J .EQ. ILOCF) THEN
C
C         SCAN BACKWARDS TO LOCATE THE END OF THE SUBROUTINE NAME
C
               DO 44 J3 = J,J1,-1
C
C         DETERMINE THE FIRST NON-BLANK CHARACTER TO LOCATE THE END OF
C         THE SUBPROGRAM NAME
C
               IF(CREC(J3:J3) .NE. CBLANK(1:1)) THEN
C
C         DETERMINE IF THE CHARACTER IS VALID IN A VARIABLE NAME
C
                  IF(CREC(J3:J3) .GE. CAA .AND. CREC(J3:J3) .LE. CZZ
     1               .OR. CREC(J3:J3) .GE. C0 .AND. CREC(J3:J3) .LE. C9
     2               .OR. CREC(J3:J3) .EQ. CUNDER .OR. CREC(J3:J3) .EQ.
     3               CDOL) THEN
                     IVCNT = J3 - J1 + 1
                     CWORK(1:IVCNT) = CREC(J2:J3)
                     GO TO 46
                  END IF
               END IF
 44            CONTINUE
            ELSE
C
C         WHEN ANY OTHER CHARACTER FOLLOWING 'SUBROUTINE' OCCURS BEFORE
C         A LEFT PARENTHESIS THAT IS NOT A BLANK, THIS IS NOT A
C         SUBROUTINE STATEMENT.
C
               IF(CREC(J:J) .NE. CBLANK(1:1)) GO TO 45
            END IF
 45         CONTINUE
C
C         SET UP TABLE ENTRIES
C
            IVCNT = ILOCF - I + 1
            CWORK(I:ILOCF) = CREC(I:IVCNT)
 46         JBITS = IBSET(JBITS,9)
C
C         PLACE A SUBROUTINE NAME IN CSUBTB
C
            IF(ISUBTB .GE. 1000) THEN
               IREC0 = IREC0 + 1
               WRITE (0,102)
               GO TO 49
            END IF
            CALL TABINS (CSUBTB,ISUBTB,56,1,32,CWORK,1,32,IRET,1000)
            GO TO 11
         END IF
      END IF
 47   CONTINUE
C
C         WHEN THE RECORD IS NOT AN ENTRY, FUNCTION, OR SUBROUTINE
C         SUBPROGRAM STATEMENT, CONTINUE PROCESSING THE NEXT RECORD.
C
      GO TO 11
 48   CONTINUE
C
C         ROUTINE END
C
 49   RETURN
      END
