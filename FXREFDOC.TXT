










                                     FXREF

                    A PROGRAM TO CREATE CROSS REFERENCE LISTINGS
                            OF FORTRAN 77 PROGRAMS
                        TABLE OF CONTENTS

PURPOSE:

   This program uses FORTRAN 77 source code as input to produce
   cross reference listings of variable names, statement numbers,
   input-output units, integer constants, floating point const-
   ants, constants, character constants, COMMON and EQUIVALENCE
   references, subprograms used, and a statistical count of these
   items.  In addition, diagnostic error messages are provided
   when syntax errors occur that prevent correct analysis of
   statements.  Some syntax errors generate multiple messages,
   and detection of errors is not as complete as that of a pre-
   processor, compiler, or FORTRAN Lint analysis program.  FXREF
   will perform limited global analysis of the analyzed code as
   an option.

REQUIREMENTS

   At the time this program was developed, there are two FORTRAN
   77 compilers available for OS/2-ECS.  They are from MICROWAY,
   Inc. of Kingston, Massachusetts and the WATCOM compiler from
   the OPEN WATCOM Organization.  The Microway compiler is deriv-
   ed from IBM mainframe and UNIX compiler standards.  While, the
   WATCOM compiler adheres to IBM PC standards.  FXREF was devel-
   oped using the WATCOM FORTRAN 77 compiler, and its syntax
   adheres to that standard.  MICROWAY has withdrawn its FORTRAN
   compiler from the market; however, the compiler is still main-
   tained by them.

   The program source code will require modification to compile
   on the Microway FORTRAN 77 OS/2 compiler because different
   language syntax and language extensions are used.  As of the
   spring of 2003, an open source version of the WATCOM compiler
   was issued by the OPEN WATCOM Organization at WWW.OPENWATCOM.
   ORG and is available for the DOS, WINDOWS, and OS/2-ECS
   operating systems.

   FXREF is designed to be executed on an IBM type PC.  Although
   the source code, which is written in FORTRAN 77, should
   compile successfully on most computers having a FORTRAN
   compiler that compiles to the FORTRAN 77 standard syntax, the
   program is designed to execute on a little endian, ASCII
   computer under OS/2-ECS.  If recompiled for DOS, the program
   should execute successfully using thE DOS WATCOM compiler,
   but modification of the source code may be necessary for other
   DOS FORTRAN 77 compilers.  FXREF has not been tested under
   DOS.  Modification of source codeis most likely required to
   compile the program under other compilers, operating systems,
   endian computers.

   FXREF presumes two characters terminate each input record of
   the FORTRAN source code being processed.  These are the carr-
   iage return, HEX 0D, and the line feed, HEX 0A.  A record in
   a file is terminated by the sequence of HEX 0D0A.  This is
   standard for DOS and OS/2-ECS.  Use of FXREF on other operating
   systems may require program modification to adjust the record
   termination characters for the particular operating system
   on which the program is to be compiled.  The variable names
   CCR and CLF defined in the BLOCK DATA subroutine contain the
   definitions for these two codes, and they are stored in the
   block common named /ASCII/.

   Some editor programs allow the user to utilize the horizontal
   tab character, ASCII HEX 09, to position text automatically.
   Since the locations where the tab character is inserted into
   a record is controlled by the user of such editor programs,
   FXREF makes the following assumptions when this character
   occurs in a record of the source FORTRAN code being analyzed.

   1. If a horizontal tab character occurs before column 7 of the
      input record, it will be replaced by a blank character, and
      text following the tab character will start in column 7 and
      all subsequent characters will be shifted to the right for
      processing by FXREF.

   2. Any horizontal tab character occurring after column 6 will
      be replaced with a single blank character, and no shift of
      characters will occur.

   The end of file condition is indicated by the character HEX
   1A.  No processing of records will continue beyond the occur-
   ence of this character.  This is the standard for an IBM type
   PC.  Other operating systems and EBCDIC computers may require
   this code to be changed.

   No additional libraries or other programs are necessary to compile
   and execute FXREF other than those generated and used by the
   WATCOM F77 COMPILER.

PROGRAM INSTALLATION AND EXECUTION

   Installation

   Create a directory on one of your hard disk partitions.  Use
   an UNZIP utility program to convert to normal format into the
   directory created.

   For OS/2-ECS

   Copy the FXREF.EXE file into any directory desired.  All
   other files in the distribution are either documentation
   files or FORTRAN source code files for FXREF and may be
   copied into any other directory on any disk desired.

   For Other Operating systems

   Compile the FORTRAN source module FXREF.FOR using a FORTRAN
   compiler and linker to create an execution module for the
   chosen operating system.  The computer must use a little
   endian CPU.  See the section PROGRAM NOTIFICATIONS FOR OTHER
   COMPUTERS & SYSYTEMS at the end of this document for a big
   endian CPU computer.

   Execution

   1. For OS/2-ECS, create a file and name it FXREF.CCD.  This
      file must be in the same directory where FXREF.EXE is
      located unless CONFIG.SYS has a search path pointing to a
      directory where FXREF.CCD is placed.

   2. Other operating systems' search path must allow location
      of the execution module and the control car file.  FXREF
      assumes the control cards file, FXREF.CCD, is in the same
      directory as its execution module.

   3. Use an editor program to create up to 12 records for the
      file FXREF.CCD as described BELOW.  This file may exist
      on any input device on the computer except the keyboard.

      RECORD 1

      In column 1 of this record, enter either a T or an F, as
      described below.

      T - The output listing file is to be 60 lines of print per
          page, and horizontal, i.e., landscape, paper orientat-
          ion is desired.  This choice causes a ten point font
          size to be used for printing when the output file is to
          be a postscript file.  A text output file will use the
          standard font of the printer.  Paper size is assumed to
          be 11 x 14 inches.

      F - The output listing is to be 80 lines per page and is to
          be printed on vertical, i.e., portrait, paper orientat-
          ion.  This choice causes an eight point font size to be
          used for printing when the output file is to be a post-
          script file.  A text output file will use the standard
          font of the printer.  Paper size is assumed to be 8 x
          11 inches.

      In column 2 of this record, enter either a T or an F, as
      described below.

      T - The output listing file is to be written as a post-
          script file.
      F - The output listing file is to be written as a text
          file with carriage control characters as the first
          character of each record.  If the printer is unable
          to interpret carriage control characters use a
          utility program that will edit the print records of
          FXREF so that the printer in use will print correctly.

      In column 3 of this record, enter a T or an F, as described
      below.

      T - A global analysis of all common blocks defined in all
          modules within a program is to be made, and the arg-
          ument lists of CALL, ENTRY, FUNCTION, and SUBROUTINE
          statements will be checked for type, length, and
          number of arguments consistancy.
      F - No global analysis is to be performed.

      In column 4 of this record:

      Type one of the three values listed below:

      1 - Use this value to indicate the output listing is a
          single file of all pages to be in the listing starting
          with page 1 and terminating with the final page.  Col-
          umn 2 may be T or F.

      2 - When column 2 is coded T, use this value to indicate
          the output listing is to be two different files.  One
          file will contain all odd pages starting with page 1
          and terminating with the final odd page.  The other
          file will contain all the even pages starting with page
          2 and terminating with the final even page.

          The odd page file will be named with the path and file
          name in record 2 except the final four characters are
          changed to 'O.PS'.  The even page file will be named
          with the path and file name in record 2 except the last
          four characters following the period are changed to
          to 'E.PS'.  IF card 2 contains an output listing file
          name of C:\PRINTER\TEST.PRT, the odd page output file
          will be modified to: C:\PRINTER\TESTO.PS, and the even
          page file will be modified to: C:\PRINTER\TESTE.PS.

          Both output files will be in ascending page order; i. e.,
          the odd pages file will start with page 1 and terminate
          terminate with the final odd page of the listing.  Like-
          wise, the even page listing will start with page 2 and
          terminate with the final even page of the listing.

          Note that this choice is invalid when column 2 is
          coded F.

      3 - When column 2 is coded T, use this value to indicate
          the output listing is to be created as two separate
          files.  One file will contain all odd pages starting
          with page 1 and terminating with the final odd page.
          The other file will contain all even pages sarting
          with the final even page and terminating with page 2.
          The even pages will be in reverse order.

          The odd page file will be named with the path and file
          name in record 2 except the final four characters are
          changed to 'O.PS'.  The even page file will be named
          with the path and file name in record 2 except the last
          four characters following the period are changed to
          'R.PS'.  If card 2 contains an output listing file name
          of C:\PRINTER\TEST.PRT, the odd page output file will
          be modified to: C:\PRINTER\TESTO.PS, and the even page
          file will be modified to: C:\PRINTER\TESTR.PS.

          The odd page file will be in ascending page order;
          i.e., the odd pages file will start with page 1 and
          terminate with the final odd page of the listing.
          However, the even page listing will start with the
          final even page and terminate with page 2 of the list-
          ing.  The even pages are in reverse oder.

          Note that this choice is invalid when column 2 is
          coded F.

      These choices allow continuous form paper and sheet paper
      to be used.  Code 3 simplifies printing on both sides of
      the paper for single sheet fed printers that do not print
      on both sides of the paper in a single pass.  Postscript
      files may be printed by turning over the paper after print-
      ing the odd pages and reinserting them into the sheet
      feeder tray.  For printers that print only on one side of
      the paper (continuous forms or sheet fed), use code 1.
      For sheet fed printers that print on both sides of the
      paper in a single pass of the paper, use code 1.

      In columns 5 through 7:

      Enter the number of columns to be read from a FORTRAN
      source code record.  The maximum value is 132; the minimum
      is 72.  This value will designate the number of characters
      in a FORTRAN source code record to be considered as source
      code and it is set to a value of 132 if columns 5 through 7
      are left blank.  If characters beyond column 72 are to be
      treated as source code, the value must be large enough to
      insure all source code is processed.  The value must be
      right adjusted within the three digit field, i.e., the
      units digits must be in column 7.

      RECORD 2

      Starting in column one of the record:

      Enter the pathname and file name of the output listing file
      where the listing is to be written.  The record must not
      exceed 80 characters in length.  The print file (or files)
      will not be submitted to the print queue for printing; this
      must be done separately by the user.  See the OUTPUT
      section for additional information regarding printing the
      output listing.  The output file name provided in this
      field will be changed when two output files are requested
      in column 4 of card 1.

      EXAMPLE: D:\PRHOLD\FORLST.PRT

      If column one of this record is blank, a default output
      listing file name will be created from the first node of
      the input file name from record 3 with PRT appended after
      the input file name and written into the current directory.
      Using the example in record 3 as the input file, the
      default output file name would be:

      EXAMPLE: TEST.PRT

      Note that no path name is generated, so the output file
      will always be placed in the current directory for this
      case.

      IMPORTANT: Do not provide an output file name that is
      identical to any of the file names provided in records 3-12
      below.  FXREF will cease execution with a diagnostic mess-
      age on unit 0, and, if not executed in the background, a
      STOP 'IDENTICAL FILE NAMES' will appear on the monitor's
      screen.  This prevents the input file from being deleted as
      an output file as the program checks for duplicate output
      file names.  Obviously, any other file name already exist-
      ing with an identical path and name will be destroyed.

      RECORDS 3 - 12

      Starting in Column one of each record:

      Enter the pathname and file name of the FORTRAN source code
      to be used as input for analysis by FXREF.  If the path
      name is omitted, the current directory will be used to find
      the file specified.  This record must not exceed 80 charac-
      ters in length.  The specified path or file name must begin
      in the first character position, i.e., column one.

      Record 3 may be repeated nine times, i.e., nine different
      file names may be specified in additional records if desir-
      ed.  The first record with a blank in column 1 will termin-
      ate the reading of file names if fewer than ten file names
      are provided.  This option permits large programs stored in
      in multiple files to be treated as a single program for
      analysis.

      EXAMPLE: For the FORTRAN program named TEST.FOR located in
               the directory FPROG on drive C, enter the follow-
               ing text in columns 1 through 17.

      C:\FPROG\TEST.FOR

      If the FORTRAN program being analyzed is in the current di-
      rectory, the path name may be omitted, and the following
      text may be entered in columns 1 through 9.

      TEST.FOR

      Any file specified in an INCLUDE statement within the FORTRAN
      program must have the path and name provided by this statement.
      It is assumed to be located in the current directory unless
      the INCLUDE statement provides a path name.  Although some
      FORTRAN compilers do have search capabilities, no search
      method is provided by FXREF to locate INCLUDE files not in the
      current directory.

      When and INCLUDE statement is used and the file can not be
      found, FXREF will write two messages on the monitor screen.
      These are:

      INCLUDE FILE NOT FOUND
      {record}
      FXREF REQUIRES A MISSING FILE

      After writing these messages, FXREF will stop execution.
      The user has three options:

      1. Set the INCLUDE statement as a comment, 2. delete the
         INCLUDE statement, or 3. make the INCLUDE file available
         to FXREF.

      Other operating systems should use syntax notation appropr-
      iate for their file naming standards.

      A Complete example:

      The records to cause FXREF to produce cross reference list-
      ings of itself are shown below.  This example assumes the
      source code of FXREF is located on drive C.

      RECORD 1:     FFF1 72
      RECORD 2:     C:\FXREF.PRT
      RECORD 3:     C:\FXREF.FOR
      RECORD 4-13:  All blank

      Record 1 uses F in position 1 of the record to indicate the
      paper orientation is vertical format with 80 lines of print
      per page.  Position 2 uses F to indicate a text output file
      with carriage control characters occurring in position one
      of each print record of the output listing file.  Position
      3 uses F to indicate a continuous forms paper is used by
      the printer.  Positions 6 and 7 provide the number of col-
      umns of text in the file(s) specified in records 3 - 12
      that are to be considered FORTRAN code for processing. If
      position 2 were a T, postscript output listing file would
      be created.

      Record 2 specifies the location and name of the output
      printer listing file created by FXREF.  The C disk is
      assigned in the above example, but other output unit desig-
      nations may be used.

      Record 3 provides the input file name containing the FORTRAN
      program to be processed.  The source file in this example
      will be treated as a single program.  In this case, it is
      assumed the file exists on disk C.  Any input device
      (except the keyboard may be specified to indicate the loc-
      ation of the file.  Note that other operating systems will
      use different syntax to designate the equivalent of the C
      disk partition used under OS/2-ECS.

   4. FXREF.EXE may be started from a window or a full screen
      command prompt, or run in a background session in OS.2-ECS
      It has been designed to require no monitor or keyboard
      input, so execution in the background is particularly app-
      ropriate for the analysis of large programs.  If the
      program is executed from a windowed or full screen, the
      message:

      STOP: FXREF ENDED NORMALLY

      will be written on the window screen if the program is run
      in the foreground when the program completes successfully.
      If run in a background session, the message is discarded.

      A. Starting FXREF at the OS/2-ECS command prompt in either a
         windowed screen or a full session.

         EXAMPLE: At the OS/2-ECS prompt, type:

         FXREF.EXE

         and depress the ENTER key.

         This example assumes that FXREF.EXE is located in the
         current directory or that CONFIG.SYS contains an entry
         in the PATH statement to permit OS/2-ECS to locate the
         program. The FXREF.CCD file is expected to be in the
         same directory.

      B. Starting FXREF in a background session.

         EXAMPLE: At the OS/2-ECS command prompt type:

         DETACH C:\PROGRAMS\FXREF.EXE

         and depress the ENTER key.

      C. For other operating systems, start execution of the
         execution module in the normal manner for those systems.
         The C disk partition used in the above examples must be
         changed to the correct syntax for the operating system
         in use.

         FXREF will execute in the background and free the wind-
         owed or full screen session to be used simultaneously.
         When a large FORTRAN program is being analyzed, back-
         ground execution allows other work to be done during
         the analysis.  The above example assumes no PATH state-
         ment in CONFIG.SYS of OS/2-ECS allows the program's
         location to be determined, when the program is not located
         in the current directory.  Other operating systems should
         use should use use the correct methods and syntax for
         use their requirements.

   5. Discounting the central processing unit's clock rate, exec-
      ution time depends upon the size of the program being
      analyzed and the complexity of the individual statements.
      Programs making extensive use of INCLUDE files will exec_
      ute somewhat more slowly, because of the file management
      requirements for the included files and the repetitious
      processing of the included files for each subprogram that
      uses them.  Also, execution time is slower when INCLUDE
      files are used.

   6. Since FORTRAN is not case sensitive, except for literals,
      all statements are forced to upper case by FXREF.  This
      affects the output print tables 2 through 6 and tables 8
      through 10.  See individual table descriptions below.

   7. FXREF is a full 32 bit native OS/2-ECS program.

   8. Since FXREF is not a Presentation Manager program, no icon
      is provided for the OS/2-ECS Presentation Manager desktop for
      FXREF.  However, the user may create their own.  Likewise,
      if a user desires a desktop icon for other operating
      systems than OS/2-ECS, they may create their own.

STATEMENTS PROCESSED:

   The table below lists the FORTRAN 77 statements processed by
   FXREF.

   ACCEPT          DO WHILE          EXTERNAL        PRINT
   ASSIGN          DOUBLE COMPLEX    FORMAT          PROGRAM
   BACKSPACE       DOUBLE PRECISION  FUNCTION        READ
   BLOCKDATA       ELSE              GO TO           RECORD
   BYTE            ELSE IF           IF              REAL
   CALL            ENCODE            IFMPLICIT       REWIND
   CHARACTER       END               INCLUDE         SAVE
   CLOSE           END DO            INQUIRE         STOP
   COMMON          ENDFILE           INTEGER         STRUCTURE
   COMPLEX         END IF            INTRINSIC       SUBROUTINE
   CONTINUE        END MAP           LOGICAL         TYPE
   CYCLE           END STRUCTURE     MAP             UNION
   DATA            END UNION         NAMELIST        VIRTUAL
   DECODE          ENTRY             OPEN            VOLATILE
   DIMENSION       EQUIVALENCE       PARAMETER       WHILE
   DO              EXIT              PAUSE           WRITE

   Not all of these statements are part of the FORTRAN 77 stand-
   ard.  Any statement that can not be determined to be one list-
   ed in the table will be considered an arithmetic statement.
   The accepted statements considered as extensions are discuss-
   ed in the next section.

   Many FORTRAN compilers have other statements and different use
   of some special characters that are not supported by FXREF.  A
   diagnostic message will be written when such statements are
   found indicating the statement is not a FORTRAN 77 statement.

EXTENSIONS:

   ADDITIONAL STATEMENTS

      FXREF provides processing of a number of extensions for
      standard FORTRAN 77 statements.  These are listed below.
      However, not all possible extensions provided by compilers
      are accepted.  Any statement not processed by the program
      will cause the message

      "NOT A FORTRAN STATEMENT"

      to appear at the end of the listing of each program and
      subprogram.  All statements will be identified by internal
      statement numbers assigned by FXREF if one has been creat-
      ed for the statement.  Otherwise, variant forms of this
      message will occur.  Also, some FORTRAN statements will
      cause this message if they have non standard syntax that
      can not be identified by FXREF.

      ACCEPT is a VMS extension.  No input-output control list is
             allowed.

      BYTE is equivalent to a LOGICAL*1 statement.

      CALL arguments specifying alternate return statement numb-
         ers may use either of the forms: *nn or &nn, where nn
         is a statement number

      CLOSE input-output control arguments accepted are:

         Standard:  ERR, IOSTAT, STATUS, UNIT
         Extension: DISP, DISPOSE

      DECODE is available in a number of FORTRAN 77 compilers.
         Input-output control list aruments accepted are:

         Extension: ERR, IOSTAT

      DO without a statement number, indicating the start of the
         DO loop, is available in some FORTRAN 77 compilers  This
         form of a DO statement requires the END DO statement to
         indicate the end of a DO loop of this type.

      DO WHILE is available in some FORTRAN 77 compilers.  This
         statement requires termination by an END DO statement.

      ENCODE is available in some FORTRAN 77 compilers.  Input-
         output control list arguments accepted are:

         Extension: ERR, IOSTAT

      END DO is available in some FORTRAN 77 compilers.  This
         statement is required for the DO statement ommitting
         a statement number and DO WHILE to indicate where the DO
         statement terminates.

      ENDFILE input-output control list arguments accepted are:

         Standard:  ERR, IOSTAT, UNIT

         Extension: none

      END MAP is available on some FORTRAN compilers using the
         MAP statement to terminate the MAP definition and will
         always follow it.

      END STRUCTURE is available in some FORTRAN 77 compilers.
         This statement terminates a STRUCTURE definition and
         will always follow it.

      END UNION is available in some FORTRAN 77 compilers.  This
         statement terminates a UNION definition and will always
         follow it.

      END WHILE is available in some FORTRAN 77 compilers.  This
         statement terminates a WHILE statement and must follow
         it.  This statement does not terminate a DO WHILE
         statement.

      FORMAT statements are allowed to use the <...> syntax to
         specify field specifications within the statement that
         are to be modified by the results of program execution.
         This feature is only available in FORMAT statements that
         are compiled.  Not all FORTRAN compilers allow this
         usage.

         Subroutine FMTSYN checks for FORMAT statements syntax
         errors, but not all features of the FORMAT statement are
         analyzed.  In most of the FORMAT messages, nine charact-
         ers will appear in the message.  If a hollerith or
         literal field occurs within the nine characters, it is
         shown as the hexadecimal character CF on the monitor and
         as a blank when the listing is printed.  A single error
         in a FORMAT statement may cause additional messages.

      INCLUDE is available in some FORTRAN 77 compilers.  It
         allows FORTRAN source code in a separate file or files
         to be brought into a program or subprogram for compila-
         tion.  Some FORTRAN compilers using this statement
         permit INCLUDE statements to be nested.  FXREF allows
         nesting up to 6 deep; however, the actual nesting factor
         is a function of the compiler in use.  Note that an END
         statement in an INCLUDE statement's file will cause
         FXREF to cease processing.

      INQUIRE input-output control list arguments accepted are:

         Standard:  ACCESS, BLANK, DIRECT, ERR, EXIST, FILE,
                    FORM, FORMATTED, IOSTAT, NAME, NAMED,
                    NEXTREC, NUMBER, OPENED, RECL, SEQUENTIAL,
                    UNIT, NAMED, NEXTREC, NUMBER, OPENED, RECL,
                    SEQUENTIAL, UNIT

         Extension: ACTION, BINARY, BLOCKSIZE, BUFFERCOUNT,
                    CARRIAGECONTROL, KEYED, MODE, ORGANIZATION,
                    RECORDTYPE, UNFORMATTED

      IMPLICIT may be expanded in some FORTRAN 77 compilers with
         the arguments UNDEFINED or NONE.  Variable names start-
         ing with an underscore are set to REAL*4 by default. The
         IMPLICIT statement may be used to change the default
         type length of variables.

      MAP is available in some FORTRAN 77 compilers.

      OPEN input-output control list arguments accepted are:

         Standard:  ACCESS, BLANK, ERR, FILE, FORM, IOSTAT, RECL,
                    STATUS, UNIT

         Extension: ACTION, ASSOCIATEVARIAB, ASSOCIATEVARIABLE,
                    BLOCKSIZE, BUFFERCOUNT, CARRIAGECONTROL,
                    DISPOSE, EXTENDSIZE, INITIALSIZE, KEY, MODE,
                    NAME, NOSPANBLOCKS, ORGANIZATION, READONLY,
                    RECORDSIZE, RECORDTYPE, SHARE, SHARED, TYPE,
                    USEROPEN

      PRINT is available in some FORTRAN 77 compilers.  No input-
         output control list is allowed.

      READ input-output control list arguments accepted are:

         Standard:  END, ERR, FMT, IOSTAT, REC, UNIT

         Extension: NML

         A READ statement with an asterisk for the FORMAT statem-
         ent number will not have a cross reference entry of the
         format designation in any table produced by FXREF.

      RECORD is available in some FORTRAN 77 compilers.

      STRUCTURE is available in some FORTRAN 77 compilers.

      TYPE is available in some FORTRAN 77 compilers.

      UNION is available in some FORTRAN 77 compilers.

      VIRTUAL is available in some FORTRAN compilers.

      VOLATILE is available in some FORTRAN 77 compilers.

      WHILE is available in some FORTRAN 77 compilers.

         The WHILE statement has two standard forms; these are:
           WHILE (logical condition) [another executable FORTRAN
                  statement]
           WHILE (logical condition) DO
         Both of the above forms are processed by FXREF.  The
         WHILE statement must be closed by and END WHILE state-
         ment.

      WRITE input-output control list arguments accepted are:

         Standard:  END, ERR, FMT, IOSTAT, REC, UNIT

         Extension: NML

         A WRITE statement with an asterisk for the FORMAT state-
         ment number will not have a cross reference entry of the
         format designation in any table produced by FXREF.

   ADDITIONAL FEATURES OF STATEMENTS ACCEPTED BY FXREF

      Character Constant Delimiters

         Standard:  The FORTRAN 77 standard uses apostrophes as
                    as the delimiters of character strings, i.e.,
                    character constants.  Only apostrophes may
                    be used to define character constants in CALL
                    statements.

         Extension: Some compilers provide for use of either apo-
                    strophes or quotation marks, and either may
                    be used.  FXREF will determine which type is
                    is used from the context of the statements.

      Character Constant Definitions for Binary, Octal, or
      Hexadecimal Constants

         Binary:  Some FORTRAN compilers allow binary constants
                  to be specified using the notation:
                  B'00101101' or '00101101'B as a single byte
                  byte constant.  Only zeros and ones may be
                  used to specify the constant value.  FXREF
                  will accept either of these notations.  The
                  binary constant may any arbitrary lemgth up to
                  the capacity of the particular compiler used.

         Octal:   Most FORTRAN compilers allow octal constants
                  to be specified using the notation O'7' or
                  '7'O as a single byte constant.  Only the
                  digits between zero through seven may be used
                  to specify the constant value.  FXREF accepts
                  either of these notations.  The octal constant
                  may be any arbitrary length accepted by the
                  particular compiler used.

         Hexadecimal: Most FORTRAN compilers allow hexadecimal
                  constants to be specified using Z'0A' or '0A'Z
                  as a single byte constant.  The fortran 77
                  standard uses the form Z'0A', but some compil-
                  ers use '0A'X.  Only the digits zero through
                  nine and the letters A through F may be used
                  to specify the constant value.  FXREF will
                  accept either of these notations.  The hexa-
                  decimal constant may be any arbitrary length
                  accepted by the particular compiler used.
                  Some FORTRAN compilers use X instead of Z to
                  indicate hexadecimal constants, and FXREF
                  FXREF accepts this option.

                  Some compilers allow the use of the character
                  C with string literal definitions encapsulat-
                  ed between apostrophes or quotation marks to
                  indicate the string is terminated with a null
                  character, HEX 00, for compatibility with the
                  C/C++ language standard.  The null character
                  is then included in the literal but not shown
                  in any listings.  The literal length will be
                  one character longer than it appears in the
                  listings since the null is not a printable
                  character.

                  EXAMPLE: The character string literal 'ABC'C
                           will appear in memory as: ' CBA',
                           where the blank is the null charact-
                           er, HEX 00, which is not a printable
                           character.  This literal would appear
                           as HEX 00434241 ASCII in memory of a
                           PC.  In mainframe and minicomputers
                           with a big endian architecture, the
                           literal would appear in memory as HEX
                           41424300 ASCII.

         Not all FORTRAN compilers provide all types of these
         constants.  The specification of binary and octal const-
         ants without encapsulating apostrophes or quotation
         marks is not accepted by FXREF except in a DATA statement.

         The FORTRAN source code of FXREF uses the forms:
         B'00101101', O'7', and Z'0A' which conforms to IBM main-
         frame and DEC minicomputer standards.  If FXREF is to be
         compiled on a system with a different compiler than that
         described, verify the notation used to specify character
         constants in that compiler conforms to the standards in
         FXREF source code.  Modify all character constants in the
         source code when required.

      Comment Statements

         Standard:  The letter C in column one of the input
                    source code identifies the record as a
                    comment statement containing no FORTRAN
                    statement code.

         Extension: An asterisk , *, in column one of the
                    input source code is also recognized as a
                    comment statement containing no FORTRAN
                    statement code.  A record of blanks is
                    treated as a comment statement.

                    Some FORTRAN compilers allow the use of
                    the character D, d, X, and x as switches
                    to the compiler that the statements, when
                    they occur in column one of the statement,
                    are debugging statements and are compiled
                    into a program only when a debugging switch
                    is set.  FXREF treats these cases as a stand-
                    ard comment line, and they are ignored.

                    Some FORTRAN compilers use a dollar sign,
                    $, or the sharp sign, #, in column one of
                    an input record to indicate such state-
                    ments are operating system or compiler
                    commands rather than a FORTRAN language
                    statement to be compiled.  These state-
                    ments are treated as comment statements.

                    Some FORTRAN compilers permit the use of
                    an exclamation sign, !, as the beginning
                    of a line comment following a statement
                    within a record.  FXREF will not process
                    any source text as FORTRAN source code
                    after an exclamation sign occurs.  For a
                    literal containing an exclamation sign,
                    FXREF will process the literal normally,
                    and the exclamation sign will not cause
                    line processing to cease.

      Continuation Statements

         Standard:  Any nonblank character in column six of
                    the input record identifies the record as
                    containing additional FORTRAN code that
                    continues the statement.
         Extension: An ampersand, &, in column one also ident-
                    ifies the input record as containing add-
                    itional FORTRAN code that continues the
                    statement.

         The number of continuation records is 99 when columns
         5 through 7 on control card one is 72.  If the value of
         columns 5 through 7 sets the maximum record of the
         FORTRAN source code to 132 characters, the maximum
         number of continuation records is 49.

      DIMENSION Subscripts

         The subscript values may be numeric or an arithmetic
         expression using previously defined named integer
         constants in a PARAMETER statement.  The PARAMETER
         statement must precede the DIMENSION statement when an
         arithmetic expression is used.

         Standard:  The subscript values of a dimensioned var-
                    iable range from 1 to 2,147,483,647 which
                    is the maximum integer value a four byte
                    byte word can contain.

         Extension: The subscript values of a dimensioned
                    variable range from -2,147,483,648 to
                    +2,147,483,647 (including zero) which is the
                    minimum and maximum values a four byte
                    word can contain.

         Note that a two byte integer has a range of -32,768 to
         +32,767, and those limits apply when two byte integer
         variables are used.

      EQUIVALENCE Subscripts and Substrings

         Standard:  The subscript values of an equivalenced var-
                    iable may be specified as a numeric integer
                    or as an arithmetic expression using pre-
                    viously defined named integer constants in a
                    PARAMETER statement.  The PARAMETER statement
                    must precede the EQUIVALENCE statement when
                    an arithmetic expression is used.

                    Substring specification values must be
                    numeric integers only.

        Intrinsic Functions

        All FORTRAN compilers provide a library of functions that
        can be used for various purposes.  The library of funct-
        ions depends upon the particular compiler used.  Since
        each compiler has some unique features in its intrinsic
        function library, FXREF processes the most common and
        standard functions.  The most important of these are the
        the mathematical functions which permit computation of
        trigonometric, exponential, square root, logarithm, and
        other mathematical functions' values when required.  Some
        compilers allow a programmer to use a generic function
        name for all length and type specifications.  When used
        in this manner, the compiler determines the function
        results type and length characteristics from the context
        of the statement.  FXREF does not perform as complete an
        analysis as a compiler; consequently, type and length of
        intrinsic functions may not have the correct information
        in the various tables.  Some intrinsic functions will
        have a length designation of ? in the output listing when
        the length can not be determined.

        Although FORTRAN does not have any reserved variable
        names, the intrinsic function names are treated as res-
        erved by FXREF.  Thus, a statement such as Y = SIN(X) is
        used to compute the value of the trigonometric sine of
        the angle X.  However, if SIN(N) is used where SIN is
        defined in a DIMENSION statement, then conflict occurs
        because the variable name no longer has a unique meaning.
        FXREF will write a warning diagnostic message for this
        case, and the name is treated as a variable name rather
        than a function name. The INTRINSIC statement may be used
        to prevent conflicts of this kind.

        If desired, FXREF may be modified to either expand or
        reduce the entries in the intrinsic function table.
        Instructions on requirements for changing the the funct-
        ion table names are documented in the subroutine CHKNME.
        If any names are added or deleted from the function table,
        collating sequence must be maintained, since the search
        routine for matching function names requires sequence
        order for the coding system used.  The table currently
        contains 143 entries.  The table values are defined in
        the BLOCK DATA subroutine.

        The address functions %LOC, %REF, and %VAL provide spec-
        ial data and information to the compiler.  %LOC, will
        provide a signed integer value of the address of its arg-
        ument and may be used as an arithmetic value in arithmet-
        ic expressions or arithmetic assignment statements.  %REF
        and %VAL may be used only in the argument list of a FUNC-
        TION invocation or called SUBROUTINE.  %REF causes the
        argument variable's address to be passed, while %VAL
        causes the argument variable's actual value to be passed.

        While it is best to avoid defining variable names that
        are identical to any intrinsic function name, FXREF can
        discern the difference in most cases.  If the program is
        unable to make a definitive decision, a default choice
        will be made and a diagnostic message will be written as
        a warning.

        A list of the intrinsic functions recognized by FXREF is
        shown below.

                ABSOLUTE VALUE FUNCTIONS

        ABS     - Absolute value of a number, generic form
                  number
        ABS     - Absolute value of a single precision real
                  number
        CABS    - Absolute value of a single precision complex
                  number
        DABS    - Absolute value of a double precision number
        IABS    - Absolute value of an integer number
        ZABS    - Absolute value of a double precision complex
                  number

                ADDRESSING FUNCTIONS

        %LOC    - Creates a memory address of the variable name
                  argument
        %REC    - Passes an argument's address in a CALL, ENTRY,
                  FUNCTION, or SUBROUTINE statement
        %VAL    - Passes an argument's actual value in a CALL,
                  ENTRY, FUNCTION, or SUBROUTINE statement

                ARCCOSINE FUNCTIONS

        ACOS    - Real single precision Arccosine
        DACOS   - Real double precision Arccosine

                ARCSINE FUNCTIONS

        ASIN    - Real single precision Sine
        DASIN   - Real double precision Sine

                ARCTANGENT FUNCTIONS

        ATAN    - Real single precision Arctangent
        ATAN2   - Real single precision arctangent of a ratio
        DATAN   - Real double precision Acrtangent
        DATAN2  - Real double precision arctangent of a ratio

                BIT MANIPULATION FUNCTIONS

        BTEST   - Determines if a bit is set to a 1 or 0.
        IBCLR   - Sets a bit to zero
        IBSET   - Sets a bit to one

                COSINE FUNCTIONS

        COS     - Generic cosine
        COS     - Real single precision cosine
        CCOS    - Complex single precision cosine
        CDCOS   - Complex double precision cosine
        DCOS    - Double precision cosine
        ZCOS    - Complex double precision cosine

                SINE FUNCTIONS

        SIN     - Generic sine
        SIN     - Real single precision sine
        CSIN    - Complex single precision sine
        CDSIN   - Complex double precision sine
        DSIN    - Double precision sine
        ZSIN    - Complex double precision sine

                TANGENT FUNCTIONS

        TAN     - Generic tangent
        TAN     - Single precision real tangent
        DTAN    - Double precision real tangent

                COTANGENT FUNCTIONS

        COTAN   - Generic cotangent
        COTAN   - Single precision cotangent
        DCOTAN  - Double precision cotangent

                HYPERBOLIC FUNCTIONS

        COSH    - Generic hyperbolic cosine
        COSH    - Single precision hyperbolic cosine
        SINH    - Generic hyperbolic sine
        SINH    - Single precision hyperbolic sine
        TANH    - Generic hyperbolic tangent
        TANH    - Single precision hyperbolic tangent
        DCOSH   - Double precision hyperbolic cosine
        DSINH   - Double precision hyperbolic sine
        DTANH   - Double precision hyperbolic tangent

                CHARACTER CONVERSION FUNCTIONS

        CHAR    - Converts a character in collating sequence with
                  index I to a one byte character variable
        ICHAR   - Converts a single character to an integer of
                  length 4

                COMPLEX CONVERSION FUNCTIONS

        AIMAG   - Changes a complex number imaginary part to a
                  single precision real number
        CMPLX   - Converts two real, integer, or double precision
                  arguments to a single precision complex number
        CONJG   - Changes a complex number into its single preci-
                  sion complex conjugate
        DCMPLX  - Converts two real, integer, or double precision
                  arguments to a double precision complex number
        DCONJG  - Changes a complex number into its double pre-
                  cision complex conjugate
        DIMAG   - Changes a complex number imaginary part to a
                  double precision real number

                EXPONENTIAL FUNCTIONS

        CEXP    - Complex single precision exponential
        CDEXP   - Complex double precision exponential
        DERF    - ERROR function of a double precision real
                  number
        DERFC   - Complementary ERROR function of a double
                  precision real number
        DEXP    - Double precision exponential
        EXP     - Generic exponential
        EXP     - Real single precision exponential
        ERF     - ERROR function of single and double precision
                  real numbers
        ERFC    - Complementary ERROR function of single and
                  double precision real numbers
        LGAMMA  - Natural logarithm of the GAMMA function

                  Note: Some compilers intrinsic library use
                  GAMMA as the function name of LGAMMA and do
                  not provide the GAMMA function directly.

                LOGARITHMIC FUNCTIONS

        ALOG    - Natural logarithm of a single precision real
                  number
        ALOG10  - Base 10 logarithm of a single precision real
                  number
        CDLOG   - Natural logarithm of a double precision complex
                  number
        CLOG    - Natural logarithm of a single precision complex
                  number
        DLOG    - Natural logarithm of a double precision real
                  number
        DLOG10  - Base 10 logarithm of a double precision real
                  number
        LOG     - Generic logarithm
        LOG     - Natural logarithm of a single or double pre-
                  cision number
        LOG10   - Base 10 logarithm of a single or double pre-
                  cision number
        ZLOG    - Natural logarithm of a double precision complex
                  number

                SQUARE ROOT FUNCTIONS

        CSQRT   - Complex single precision square root
        CDSQRT  - Complex double precision square root
        DSQRT   - Double precision real square root
        SQRT    - Generic square root
        SQRT    - Single precision real square root
        ZSQRT   - Complex double precision square root

                NUMERIC CONVERSION - INTEGER FUNCTIONS

        AINT    - Converts a single precision real number to a
                  single precision integer real number
        ANINT   - Rounds a single precision real number up or
                  down to the nearest single precision integer
                  real number
        DAINT   - Converts a double precision real number to a
                  double precision integer value
        DINT    - Converts a double precision number to a double
                  precision integer value
        NINT    - Rounds a double precision real number up or
                  down to the nearest double precision integer
                  value
        IDINT   - Rounds a single or double precision real number
                  to an integer of any length
        INT     - Generic conversion of a number to an integer of
                  any length
        INT     - Converts a real single or double precision
                  number to an integer of any length
        NINT    - Converts a real single or double precision
                  number, rounds up or down to the nearest
                  integer of any length.

                NUMERIC CONVERSION - FLOAT FUNCTIONS

        DBLE    - Generic conversion of an integer number to a
                  double precision number
        DBLE    - Convert an integer or single precision real to
                  a double precision number
        DFLOAT  - Convert an integer number to a double precision
                  real number
        FLOAT   - Convert an integer number to a single precision
                  real number

                NUMERIC CONVERSION - DIFFERENCE FUNCTIONS

        DDIM    - Computes the difference between two double
                  precision numbers
        DIM     - Generic Computation of the difference between
                  numbers
        DIM     - Computes the difference between two single
                  precision numbers
        IDIM    - Computes the difference between two integer
                  numbers
        DPROD   - Computes the product of two single precision
                  numbers and produces a double precision result
        NEAREST - Assigns the nearest single or double precision
                  number represented by the data type

                NUMERIC CONVERSION - FIX FUNCTIONS

        IFIX    - Converts a single precision real number to an
                  integer
        REAL    - Generic single precision real part of a complex
                  number
        SNGL    - Converts a double precision real number to a
                  single precision real number

                NUMERIC CONVERSION - SIGN TRANSFER FUNCTIONS

        DSIGN   - Moves the algebraic sign from one double
                  precision number to another
        ISIGN   - Moves the algebraic sign from one integer to
                  another
        SIGN    - Generic algebraic sign from one real number to
                  another
        SIGN    - Moves the algebraic sign from one single or
                  double precision number to another

                MODULAR ARITHMETIC FUNCTIONS

        AMOD    - Computes the remainder of division of two
                  single precision real numbers subtracted from
                  the first number
        DMOD    - Computes the remainder of division of two
                  double precision real numbers subtracted  from
                  the first number
        IMOD    - Computes the remainder of division of two
                  integer numbers subtracted from the first
        MOD     - Generic Computation of the remainder of
                  division of two integer numbers subracted from
                  the first
        MOD     - Computes the remainder of division of two
                  integer numbers subracted from the first

                MINIMUM AND MAXIMUM FUNCTIONS

        AMAX0   - Chooses the largest value from a list of
                  integers of any length to a single precision
                  real number
        AMAX1   - Chooses the largest value from a list of single
                  recision real numbers
        DMAX1   - Chooses the largest value from a list of double
                  precision real numbers
        IMAX1   - Chooses the largest value from a list of single
                  precision real numbers and converts it to an
                  integer of any length
        MAX     - Generic form for choosing the largest value
                  from a list of any type of numbers; whether
                  a list of any type of numbers; real or integer
        MAX0    - Chooses the largest value from a list of
                  integers of any length
        MAX1    - Chooses the largest value form a list of single
                  precision real numbers and converts it to an
                  integer of any length
        AMIN0   - Chooses the smallest value from a list of
                  integers of any length to a single prrecision
                  real number
        AMIN1   - Chooses the smallest value from a list of
                  single precision real numbers
        DMIN1   - Chooses the smallest value from a list of
                  double precision real numbers
        IMIN0   - Chooses the smallest value from a list of
                  integers of length two
        IMIN1   - Chooses the smallest value from a list of
                  single precision real numbers and converts to
                  an integer of any length
        MIN     - Generic form for choosing the smallest value
                  from a list of any type of numbers; whether
                  real or integer
        MIN0    - Chooses the smallest value from a list of
                  integers of any length
        MIN1    - Chooses the smallest value form a list of
                  single precision real numbers and converts to
                  an integer of any length

                LOGICAL BIT MANIPULATION FUNCTIONS

        AND     - Performs a logical AND on each bit of
                  arguments.
        BTEST   - Determines if a bit is set to 1 or 0.
        IAND    - Performs a logical AND on each bit of arguments
        IBCLR   - Sets a particular bit to zero.
        IBITS   - Extracts a range of bits.
        IBSET   - Sets a particular bit to one.
        IEOR    - Performs a boolean exclusive OR.
        IOR     - Performs a boolean inclusive OR.
        ISHA    - Performs an arithmetic bit shift.
        ISHC    - Performs a circular bit shift.
        ISHFT   - Performs bit shift left or right.
        ISHFTC  - Performs circular bit shift.
        LSHIFT  - Performs a left bit shift.
        NOT     - Performs a boolean complement.
        OR      - Performs a boolean exclusive OR
        RSHIFT  - Performs a right bit shift.

                MISCELLANEOUS FUNCTIONS

        INDEX   - Obtains the position of a substring in a larger
                  string in a character variable.
        LEN     - Determines the number of characters in a
                  character variable.
        LENTRIM - Determines the number of characters in a character
                  variable without trailing blanks.
        LEN_TRIM- F95 version of LENTRIM.

        Hollerith Fields

        Data defined by Hollerith fields such as:

           25HTHIS IS A HOLLERITH FIELD
           33HCAN'T SET VALUE TO ZERO AND WON'T

        occurring in DATA statements and in argument lists of
        CALL statements are processed.  All hollerith fields are
        converted to literals and inserted in the table of
        literals created on the work file of FORTRAN unit 9.  The
        output listing will show the Hollerith field as:

           'THIS IS A HOLLERITH FIELD'
           'CAN''T SET VALUE TO ZERO AND WON''T'

        FXREF will surround the Hollerith field with apostrophes
        before entering the field in the literal table.  Holler-
        ith fields containing an apostrophe within the literal
        field will be changed to two adjacent apostrophes.

        Hollerith fields are FORTRAN 66 data notation artifacts
        and are allowed only in the DATA, FORMAT statements, and
        in the argument list of CALL and ENTRY statemenmts.  They
        They may not be used in data type statements such as
        BYTE, CHARACTER, COMPLEX, INTEGER, and REAL.  The maximum
        length of a hollerith field is 255 characters.

        Logical Operators

        Standard:   .AND.  .EQ.  .EQV.  .GE.  .GT.  .LE.  .LT.
                    .NE.  .NEQ.  .NEQV.  .NOT.  .OR.

        Extension:  .XOR.

        Numerical Constants

        Standard forms of specifying numerical constants are:

        Integer:  A continuous series of digits, such as 746201,
                  that may be optionally preceded by either a
                  plus or minus sign.

        Real:     A continuous series of digits with a decimal
                  point, such as 7.46201, that may be optionally
                  preceded by a plus or minus sign.

        Floating: A continuous series of digits with a decimal
                  point to specify the value of the number that
                  may be preceded by a plus or a minus sign, and
                  the number is followed by the letter D or E,
                  optionally a plus or minus sign, and a sequence
                  of digits specifying the power of ten to adjust
                  the location of the decimal point.  For example,
                  the number 5,692 may be written as .5692E4 or
                  as 5.692E3.  If the number is negative, then
                  -.5692E4 represents -5,692.  If the number is
                  less than one, then the value is represented by
                  .5692E0; if D is used instead of E, the number
                  is double precision.

        Hexadecimal: A hexadecimal number is represented as a
                  literal encapsulated within apostrophes or quo-
                  tation marks and preceded by the alphabetic
                  character Z.  An example is Z'AF01'.  Some
                  FORTRAN compilers place the Z after the final
                  apostrophe, i.e., 'AFO1'Z.  FXREF accepts this
                  form, though it does not conform to the FORTRAN
                  77 standard.  Also, FXREF recognizes the letter
                  X or x for the letter Z in specifying hexadec-
                  imal literals, but X or x must occur at the end
                  of the designated value.

                  The hexadecimal constant form ZAF01, where AF01
                  is the numerical value, is accepted by FXREF
                  only when it occurs in a DATA statement.  If
                  used in any other statement, it may be treated
                  as a variable name or generate an error message.
                  If used, constants in this form are listd in
                  this form are listed in the table of literals
                  as ZAF01.  Note that no apostrophes or quotat-
                  ion marks are added.  The use of X to replace Z
                  is not accepted for this format in a DATA
                  statement.  Also the form AF01Z is an illegal
                  syntax and is not accepted by FXREF.

        Octal:    An octal number is represented as a literal
                  encapsulated within either apostrophes or quo-
                  tation marks.  An example is O'264'.  Some
                  FORTRAN compilers place the O after the final
                  apostrophe, i.e., '264'O.  Constants of this
                  form are accepted by FXREF, though it does not
                  conform to the FORTRAN 77 standard.

                  The octal constant form O701, where 701 is the
                  numerical value, is accepted by FXREF only when
                  it occurs in a DATA statement.  If used in any
                  other statement, it may be treated as a
                  variable name or generate an error message.
                  Note that no apostrophes or quotation marks are
                  added.  If used, constants in this form are
                  listed in the table of literals as O701.  Also,
                  the form 701O is an illegal syntax and is not
                  accepted by FXREF.  Only the digits 0 (zero)
                  through 7 may be used.

        Binary:   A Binary number is represented as a literal
                  encapsulated within either apostrophes or quo-
                  tation marks.  An example is B'01010111'.  Some
                  FORTRAN compilers place the B after the final
                  apostrophe, i.e., '01010111'B.  Contsants of
                  this form are accepted by FXREF.

                  The binary constant form B01010111, where
                  01010111 is the numerical value, is accepted by
                  FXREF only when it occurs in a DATA statement.
                  If used in any other statement, it may be
                  treated as a variable name or generate an error
                  message.  Note that no apostrophes or quotation
                  marks are added.  If used, constants in this
                  form are listed in the table of literals as
                  B01010111.  The form 01010111B is an illegal
                  syntax and is not accepted by FXREF.

        Variable names

        Standard:  The length may not exceed six characters, and
                   the initial character must be an alphabetic
                   character.  The remaining five characters may
                   be either alphabetic or numeric characters.

        Extension: The length may not exceed 32 characters, and
                   the initial character must be an underscore or
                   an alphabetic character.  The remaining char-
                   acters may be an underscore, alphabetic char-
                   acters, numeric characters, or a dollar sign.
                   Some FORTRAN compilers will allow the dollar
                   sign, $, to also be the first character of a
                   variable name.  FXREF does not allow this
                   choice, and variable names with a dollar sign
                   as the first character are treated as an
                   an error.  If a variable name exceeds 32 char-
                   acters, the name is truncated to the first 32
                   characters for processing and is so shown in
                   printer listings.

                   Compound variable names resulting from the use
                   of STRUCTURE, RECORD, and UNION statements are
                   processed, but only the components are cross
                   referenced and printed in the tables by FXREF.
                   The complete compound name is not shown in the
                   output tables.

                   FORTRAN compilers handle variable name defini-
                   tions within a STRUCTURE statement separately
                   from all other variable name definitions.
                   This allows identical variable names with diff-
                   erent type and length specifications.  FXREF
                   will maintain this separation of definitions.
                   A maximum of 1000 unique variable names defin-
                   ed within all STRUCTURE statements in single
                   program modules are allowed.

CONSTRAINTS:

   PROGRAM CAPACITY

   The maximum number of items that can occur in a single program
   or subprogram module processed by FXREF is listed below.

   4000 Unique variable names, includes all variable names from
        INCLUDE statements, subprogram names in EXTERNAL state-
        ments, and all synthetic names generated by FXREF.
   4000 Unique definitions of symbolic names for integer defined
        constants in PARAMETER statements.  No limit exists for
        other PARAMETER data type definitions.
   4000 Unique floating constants
   2000 Unique Integer constants
   1000 Unique Dimensioned Variables
   1000 Statement numbers
   1000 Unique STRUCTURE statements
   1000 Unique RECORD statement variable names
   1000 Unique variables defined within a STRUCTURE
   1000 References to a single variable name
   1000 Literals used in CALL statements in an entire program
   1000 EXTERNAL subprogram names in an entire program
   1000 References to a single literal in a program module
   1000 Unique ENTRY, FUNCTION, and SUBROUTINE subprograms
    500 Literals in a single FORTRAN statement
    500 References to a statement number
    500 Variable names in a COMMON block
    500 Variables used within UNION statements
    500 Unique EQUIVALENCE group definitions in a single routine
    256 Maximum length of a hollerith or literal in a single
        FORTRAN statement
    200 Number of EXTERNAL subprogram definitions in a single
        routine
    200 Number of literals that can occur in a single FORTRAN
        statement
    200 Unique COMMON definitions in an entire program
    200 Unique EQUIVALENCE group definitions for a single routine
    100 EQUIVALENCE variables in a single common block
     99 Integer input-output units
     99 Unique variable name input-output units
     99 Continuation statements
     50 Maximum number of variables in an arithmetic assignment
        statement, and arithmetic, character, or logical
        expressions
     30 Maximum number of arguments allowed in an argument list
        for CALL, ENTRY, FUNCTION, and SUBROUTINE statements.
        Length of an individual argument is 80 characters.
     20 Variable names in an EQUIVALENCE group
     20 MAP statements under a single UNION statement
     20 Nested UNION statements under an initial UNION statement
     10 Maximum number of arithmetic operations in an expression
        of integer type defining constants specified in PARAMETER
        statements. Such expressions may be used to define a
        length characteristic of a variable, the dimension size
        of an array variable, and the value of defined constants
        in a PARAMETER statement based on previously defined
        PARAMETER constant definitions.
      6 Nested INCLUDE statements
   Disk Capacity for character constants (literals); however,
   FXREF limits an individual routine to 1000 literals.

   There are no length or size limitations of the source program
   or subprogram if the above constraints ae not violated; how-
   ever, disk capacity is a limiting factor for all work files.

   FXREF allows 4,000 variable names in the master name table,
   which incorporates all names present from the program or sub-
   program being processed, all synthetic variables generated by
   FXREF, and all names from INCLUDE statements.  FXREF has a
   limit of 4,000 integer PARAMETER definitions; however, the
   limits of unique integer and real value constants may lower
   the integer PARAMETER limit indirectly.

   FXREF will generate synthetic variable names for the arguments
   of CALL statements when global analysis is to be performed;
   they are placed in the master table of variable names and are
   counted as a normal variable in the master name table.  These
   synthetic variables will always start with C## and are never
   printed in the output listings.  However, the name of the syn-
   thetic variables may appear in some of the global diagnostic
   and error messages are shown in the table below.

        Synthetic
          Name         Meaning

          C##EX   A logical or mathematical expression
          C##LIT  A literal not part of a literal expression
          C##LOG  A logical constant value
          C##NUM  A numerical value
          C##STM  A return statement number
          C##nnn  A literal value (nnn is a three digit number)

   However, if a variable name starting with C## occurs in the
   program module being analyzed, a diagnostic message is
   written.

   FXREF will process nested INCLUDE statements up to 6 levels
   after the first INCLUDE. The program provides capacity for a
   depth level of 20, but, since each INCLUDE statement opens an
   additional file and it is not possible to have more than 20
   simultaneously open files for a single program in OS/2-ECS,
   only seven are possible without increasing the number of total
   open files beyond 20. Units 14 through 20 are reserved for
   INCLUDE files.

   The limit of 2000 occurrences of integer and 4000 floating
   constants excludes some multiple use in the same statement.
   Statements such as:

          A = 2.14 * SIN(K+1) + 2.14 * COS(K-1)
          B = 2.14 * SIN(K-1) + 2.14 * COS(K+1)

   will cause one entry to be made in the integer and floating
   constant save arrays for each statement.  Duplicaate occurr-
   ences of a number in the same statement do not cause add-
   ional entries to be made in the save arrays, since the inte-
   rnal statement number, ISN, would be identical.

   Generally, FXREF distinguishes between algebraic sign and
   arithmetic operators for the plus and minus signs.  Thus, the
   K-1 in the expressions above causes a plus one to be entered
   in the the integer save array.  Floating numbers are treated
   similarly, and tables 5 and 6 of the output listing will have
   their values listed as positive numbers.

   FORTRAN 77 input records of source code use columns 1 through
   72 as the statement containing area.  Columns 73 through 80 do
   not contain FORTRAN statement text.  FXREF assumes all text in
   a single record represents a FORTRAN statement from column 1
   to the column of the value specified in record 3 of the file
   FXREF.CCD; see the description above.  Text beyond the spec-
   ified column limit is ignored.  A maximum of 132 columns may
   be read as a single record, since this is the length of the
   read buffer.  The EXECUTION section describes a capability to
   control the input source code record length.

   The value of the record limit only sets the maximum length of
   the FORTRAN statement record that can be read; it does not set
   the minimum.  If the hexadecimal characters HEX 0D0A occur
   before the limit is reached, processing for a record will
   stop, and the next record will be processed.

   If desired, the limits described in the program capacity table
   above may be increased by changing the DIMENSION changing the
   DIMENSION size of those variable arrays containing the data.
   However, changing the DIMENSION size will require modification
   of loop control parameters throughout the program.

   In all FORTRAN statements, any text between matched left and
   right square brackets, [ and ], occurring outside a character
   constant (e. g., a literal) will not be processed by FXREF.

   The logical constants, .TRUE. and .FALSE., are not cross ref-
   erenced in any of the tables in the output listing produced by
   FXREF.

OUTPUT:

   For each program or subprogram in the input files, FXREF prod-
   uces either a text file listing with standard carriage control
   characters as the first character of each print line, or a
   postscript printer listing of one or two files.  If a text
   output is requested, a utility program must be used to print
   the text listing on printers that do not recognize carriage
   control characters as part of the print line to control print-
   ing characteristics.  One such program, named FORPRINT, is
   available from the COSMIC library of NASA programs.

   FXREF listings can be very large, because of the volume of in-
   formation provided.  For example, the complete example of con-
   trol cards (shown above) that will analyze the entire FXREF
   program will generate a listing of approximately 100,000 lines
   of print.  While there is no limit to the number of pages of
   print in the output listing by FXREF, there is a limit of
   10,000 pages of print when the postscript output listing
   option is used.  When the postscript output listing is split
   into two files of even and odd pages, the 10,000 page limit
   applies to each split file independently, giving a total of
   20,000 pages.

   For text output, the output from FXREF is a disk file designed
   for printing on a standard mainframe or minicomputer line
   printer for text output, or some of the many types of post-
   script printers if postscript output has been chosen; however,
   the text file can be printed on any desired printer that
   accepts standard print files with carriage control characters
   in the first character of each output record as described
   above.  Note that the output print file or files are not sub-
   mitted to the print queue, because many printers on a PC do
   not accept FORTRAN carriage control text print files.

   For postscript output, many postscript printers may require
   control parameters in addition to the generated postscript
   printer file or files.  These control parameters must be sup-
   plied by the user.

   The maximum listing record length is 121 characters for both
   text and postscript output files.

   Standard FORTRAN carriage control characters are:

         Blank - Advance one line and print
             0 - Advance two lines and print
             1 - Advance to the top of the next page and print
             + - Print without advancing to the next line

   The output listing file name is the one specified in record 2
   in the control card file. Using the example in step 2 above
   and assuming no file name was specified on record 2, the output
   print file will be named: TEST.PRT, and it will be placed in
   the current directory, not necessarily in the directory of the
   input file.  If a path name is specified on record 2 of the
   FXREF.CCD file, then the output listing file will be written
   to the directory specified.  FXREF will make no modification
   of the path or file name in this case.
   this case.

   If the listing file name and its path in record 2 match al-
   ready existing path and file names on the disk, the program
   will delete the existing file to insure only the newly created
   file will exist after completion of FXREF's execution.  The
   program will not notify the user that this action has been
   taken.

   While nonstandard functions for date and time acquisition are
   provided by many FORTRAN compilers, these functions can not be
   used with other compilers and operating systems.  The speciic
   functions used by the WATCOM compiler are discussed in the
   section MODIFICATIONS FOR BIG ENDIAN COMPUTERS AND OTHER
   OPERATING SYSTEMS at the end of this document.

   If postscript output listings are requested, the file name in
   card 2 is modified as described in the execution section
   of this document.

   FXREF forces all statements to upper case characters, except
   for character constants, i. e., literals.  Table 1 will cont-
   ain the original FORTRAN source code unaltered, but tables 2
   through 6 and tables 8 through 10 will show upper case alph-
   abetic characters exclusively.  Only Tables 1 and 7 will pre-
   serve any original lower case characters.

   The listing consists of a series of tables, some of which may
   not occur in the analysis of a particular program or subprog-
   rams.  A program or subprogram lacking an entry for a table
   causes that table to be omitted from the listing.  the tables
   produced are discussed below.

   No FORTRAN source code brought into a program or subprogram by
   use of an INCLUDE statement will have any of these imported
   statements printed in any of the tables produced by FXREF.
   Only the variable names explicitly used by the program or
   subprogram that is being analyzed, which also may be used in
   the FORTRAN source code from the INCLUDE statement file, will
   appear in the listing of all tables.  No provision is made in
   FXREF for incorporating the INCLUDE file's source code into
   the listing since the INCLUDE file may be processed separately
   by FXREF.  The main use FXREF makes of the INCLUDE files cont-
   ents is to provide dimension, type, and length information for
   those variables used within the current module being analyzed.

   The listing for each program or subprogram is paginated start-
   ing at one rather than an entire listing of multiple routines
   having a single sequence of page numbers from start to finish
   for all routines processed in a single execution of FXREF.

   An unnecessary heading for a new page will be generated at the
   end of the listings when the final record on a FORTRAN source
   input file consists of blanks only.  To avoid wasting a page
   of paper, insure this condition does not occur in the input
   file to be analyzed.

   If FXREF finds no entries for a table during its analysis,
   that table will be omitted.

   The two logical constants, .TRUE. and .FALSE., are not cross
   referenced in any table.

   If global analysis is requested, any diagnostic messages will
   appear at the end of the printer listing.  Other diagnostic
   messages appear at the end of each routine's listing.

   Some generic intrinsic FORTRAN library routine functions do
   do not have a unique length definition, because the length
   depends on the arguments of the library function at the time
   it is called.  FXREF may be unable to determine the length for
   some of the generic functions used in a program since the
   FORTRAN compiler determines the length characteristic during
   compilation.  Also, a generic intrinsic function may be used
   with variables of more than a single length characteristic.
   Since FXREF does not perform as complete an analysis as a
   compiler, a question mark will be placed in the length field
   to indicate it is unknown or can not be determined.

   1.  The first table is a listing of the original source code,
       which will show all upper and lower case alphabetic char-
       acters in the original input source code, with an internal
       statement number (ISN) assigned to identify each statement
       of the FORTRAN source code.  Comment statements and blank
       statements are not assigned an ISN.  The header at the
       start of each printed page in the listing will show the
       input path and file name where the FORTRAN source code
       being analyzed exists.  This information is taken from the
       third record in the file FXREF.CCD.  If no path is desig-
       nated, none will appear in the heading.

       Note that a program using an INCLUDE statement will not
       cause the FORTRAN code requestd by this statement to
       become part of the source code being analyzed when the
       can file can not be found. This will affect output tables 2
       through 10.

       Comment statements may follow the final END statement that
       terminates each program or subprogram; although, this is not
       the best practice.  Once an END statement occurs, any
       following input records are assumed to be part of the next
       subprogram, unless an end of file follows the final comment
       statement following the END statement.  An END statement may
       not have a continuation statement following it.

   2.  The second table is a cross reference of all variable
       names occurring in the FORTRAN code being analyzed.  For
       each variable, the name, its usage, its type and length,
       and the ISNs where used in the program are listed.  No
       lower case characters will be printed.  Blanks within a
       variable name will not be printed.  Headers at the top of
       each page of print show the codes used to designate both
       usage and type.

       When a variable name exceeds the FORTRAN 77 standard of
       six characters in length,  ISN lists are shifted to the
       right to accommodate a variable name length of up to 32
       characters.

       The usage code specified for each variable name may not
       show a correct code for a function subprogram when in
       fact the name may be a function defined in the program.
       This can occur when a single module is being analyzed
       without the function subprogram or an EXTERNAL definition
       present.  A function name resembles a variable name and
       can not be distinguished from it when complete informat-
       ion is not available.

       Also, the usage code shown in this table may display a
       function subprogram name as a subroutine, depending on
       the type of usage within the program unit even when comp-
       lete information is available.  If a function subprogram
       is invoked by using a CALL statement, rather than being
       used in the normal manner in an expression, the usage
       coding will be set to an S since it has been treated as a
       SUBROUTINE.  This situation arises because FORTRAN permits
       a FUNCTION subprogram definition module to be used in a
       CALL statement, but does not allow a SUBROUTINE definition
       module to be used as a FUNCTION.  Thus, the usage codes of
       this table will show the actual usage, rather tha the
       definition type for FUNCTION and SUBROTINE subprograms.

       The usage code A designates the variable name is used as
       an argument in a CALL statement or as an argument in the
       input-output control list.  However, implied  DO loop
       control parameters' variable names are not coded A, since
       they are not arguments to be written or read by input-
       output statements. When the UNIT control list argument
       specification is a variable name, that variable will not
       have a usage code A assigned to it.  Any other type of
       control list variables names will have a usage code of A.
       Neither intrinsic nor program functions' arguments that
       are expressions of variable names will have those variab-
       les coded as argument since the expression is the arg-
       uments, not the individual arguments used in the express-
       ion.

       When the type and length is printed as ' * ' (without the
       apostrophes), and the alphabetic character O or the
       numeric character zero is used, the variable name with
       the type and length codes of ' * ' has likely been miss-
       pelled.  A zero has been used where an alphabetic O is
       intended, or an alphabetic O has been used where a zero
       is intended.

       Invalid PARAMETER statements in an INCLUDE file may cause
       arguments of ENTRY, FUNCTION, and SUBROUTINE statements
       to be listed with the type and length code of: ?*

       When the length specification *(*) appears, this indicat-
       es the variable name has an inherited length from another
       subprogram module.  When global analysis is requesed,
       a variable with an inherited length will not have its
       length checked for errors if that variable is used as an
       argument in CALL, ENTRY, FUNCTION, or SUBROUTINE state-
       ents.

       However, a CALL statement argument variable with an
       integer range values will have the length characteristic
       set to the range for the record written on unit 10.  This
       allows argument length checking in routine ARGCHK to pro-
       cess the argument without creating superfluous error
       messages.

       STRUCTURE, RECORD, AND UNION statements have no usage
       type, but do have a length definition.  The type and
       length are shown as: ?*nn, where nn is a numerical value.
       Intrinsic FORTRAN library functions may have a type code
       code but no determined length when a generic form of the
       function name is used.  This case is shown in the list-
       ing as: I*?, F*?, D*?, etc.  The actual length attribute
       of the generic function is determined by it arguments,
       and, as previously described, FXREF does not make as
       complete an analysis as a compiler or Lint program.  At
       the time the intrinsic function is processed, the arg-
       ument list is unknown.

       For all tables after the first, a heading is provided that
       shows the name of the program or subprogram.

       Intrinsic and FORTRAN library functions and subroutines
       will also have their names listed as variables.  Intrinsic
       functions will have their usage code set to F. A type
       code and length designation is provided; however, if the
       length characteristic of a generic intrinsic function can
       not be determined, a question mark, ?, is placed in the
       length specification field of this table and all occurr-
       ences in other tables where length is provided for that
       particular function name.  If used in a CALL statement,
       the names will be listed as a subroutine name with an S
       code for usage, and no type or length code will be pro-
       vided.

       The subprogram name used in a CALL statement can not be
       identified as a FUNCTION or a SUBROUTINE by FXREF, so
       FXREF assumes they are all SUBROUTINES by default unless
       the function names are specified in an EXTERNAL statement
       which has a length definition in a type statement.  A
       variable name defined as a SUBROUTINE or ENTRY name can
       not have a type and length designation.

       The type and length designations shown for variable names
       are obtained from the DIMENSION, IMPLICIT, STRUCTURE,
       UNION, and data type statements within the program or sub
       -program source code.  Standard FORTRAN data types are
       assumed unless overridden by TYPE or IMPLICIT statements.
       If an INCLUDE statement is used by the program or sub-
       program being analyzed to incorporate data type state-
       ments such as INTEGER, REAL, CHARACTER, COMPLEX, etc.,
       the type and length definitions will not be accurate in
       the listing for this table when the file provided in the
       INCLUDE statement can not be found.  For this case, inc-
       cluded code will not be present when the program or sub-
       program analysis is made.

       Any variable names not used by a program or subprogram
       that are brought into the routine being analyzed by an
       INCLUDE statement will not be shown in this table.

       A variable name defined by a RECORD statement will
       always have its type code shown as a questionmark, ?.
       Since a RECORD statement consists of a collection of
       fields of data types defined in a STRUCTURE  statement,
       it can not have any standard data type classification.
       Similarly, STRUCTURE statement names will possess a
       length characteristic but no type specification, and
       they will also have their type shown as a question mark.
       The type and length definitions of variable names def-
       ined within a STRUCTURE statement are independent of any
       other FORTRAN statement, and they do not assume their
       type and length characteristics from the default stand-
       ards or from IMPLICIT definitions.

       UNION and MAP statements have no defined names, but any
       variable name occurring within their range will have
       their usage code set appropriately.  The usage code U
       will be printed in the listing for variable names used
       between UNION and MAP and END MAP statements.  No code
       is provided for MAP because it can occur only within the
       UNION and END UNION statements.

       Compound variable names used in a FORTRAN program res-
       sulting from STRUCTURE, UNION, and RECORD statements are
       separated into their constituent parts in this table and
       are not listed in their complete compound form.  Since
       FORTRAN compilers separate the variable name definitions
       occurring within a STRUCTURE statement from all other
       variables within a program, it is possible to have mul-
       tiple defined variable names that are identical in this
       table with different type and length characteristics.
       Variables with multiple definitions of identical names
       will be shown on separate lines in this table.

       The addressing operators %LOC, %REC, and %VAL are listed
       in this table as LOC, REC, and VAL with usage codes of
       INTEGER and REAL functions.  The function %DESCR is pro-
       cessed as REAL*4.  It occurs in older VAX programs.

       In FORMAT statements, the syntax notation <...> includes
       constants and variable names that are used by the program
       module where the FORMAT statement occurs.  This syntax
       allows a computed value from the program module to set
       the field description.  Table two will include any var-
       iable names specified between <...> in the table.

       FORTRAN variable names fall into two general categories:

          1. Variable names that have defined type and length
             characteristics.  This category includes all oper-
             tional, typing, and declarative variables.

           2. Variable names without any type or length.  This
              category includes only BLOCK COMMON definition
              names, SUBROUTINE statement names, and ENTRY
              STATEMENT names.  Names in this category are
              shown on a separate line of print in the output
              listing.  Note that STRUCTURE and RECORD state-
              ment use the same notation syntax as BLOCK COMMON,
              i.e., the variable name is encapsulated within
              slashes.

   3.  The third table provides a list of the statement numbers,
       the ISN where defined, and the ISNs where referenced.  In
       the special case where an input-output statement, such as
       READ or WRITE, has an asterisk as the FORMAT reference
       statement number, it is not shown in this table and is not
       cross referenced in any of the tables by FXREF.

   4.  The fourth table lists all the integer input-output unit
       numbers and the ISNs where they are defined followed by the
       variable name unit numbers and their ISNs' list of use.

       Integer values of input-output unit designations are not
       entered in the list of integer constants in table 5, but
       the variable name units are also listed in table 2.

       When a variable name used as an input-output specification
       is used as a normal arithmetic variable elsewhere within
       the same program module, the variable specified as the unit
       will not have the statement's ISN listed in table 2.

       This table includes the console default unit designated by
       an asterisk, *, as the unit.  The variable name input-output
       units are also listed in the variable name table, but this
       fourth table excludes all references not a unit in an input-
       output or file manipulation statement.  No lower case char-
       acters will be printed.

       Variable names occurring as units may not be true input-
       output units.  When the READ and WRITE statements are used
       to convert one type of variable to another internally with-
       out an actual read or write operation, which replaces the
       ENCODE and DECODE statements, the unit parameter of READ
       and WRITE statements will appear in this table even though
       they are not FORTRAN unit designations.  When a variable
       exceeds eight characters in length, the FORTRAN 77 standard
       is six characters, the ISN list is shifted to the right to
       accommodate the additional size.

       Variable input-output units will be printed in upper case
       characters only.  Compound variable names resulting from
       definitions using STRUCTURE, UNION, and RECORD statements
        used as a unit name will have only the final name of the
       compound name appear in this table.

   5 . The fifth table lists all integer constant values in the
       source code from the lowest to the largest magnitude order
       and the ISNs where used.  Integer constants that are in
       FORMAT statements and integer input-output units are excl-
       uded.  But all length definitions occurring in TYPE state-
       ments such as INTEGER, REAL, LOGICAL, CHARACTER, etc. are
       excluded from this table.

       In FORMAT statements, the syntax notation <...> includes
       constants and variable names that are used by the program
       module where the FORMAT statement occurs.  This syntax
       allows a computed value from the program module to set the
       field description.  Table five will include any constant
       values between <...> in the table, but any other FORMAT
       constants are excluded.

       All integer constants defined by code brought into a pro-
       gram or subprogram by an INCLUDE statement will not be
       listed.

   6.  The sixth table lists all floating constants in the source
       code and the ISNs where used.  In this table, floating
       constants are listed by value in increasing magnitude, and
       no distinction is made between single and double precision
       in the printed output listing.  Double precision values
       are printed in single precision form.

       Floating constants of double and single precision numbers
       may be listed as equal by this table when in fact they are
       not.  If a double precision number differs only in the
       eighth through sixteenth digits from a single precision
       number, they are treated as equal in this listing.

       Depending upon the value of the mantissa of the floating
       point value, it may not be printed exactly as the number
       occurs in the source FORTRAN code.  Some values may show
       an extended series of digits which, when rounded, will
       then represent the original number.  For example, the num-
       ber .9E0 occurring in a statement may appear as
       .8999999E000.  Rounding of values for printing in this
       table may cause a number such as 999,999,999. to appear as
       .1E10; these results are artifacts of the conversion pro-
       cess from text to numeric format or from binary represen-
       tation to text format and is somewhat dependent upon the
       library routines of a particular FORTRAN compiler.

       Double precision numbers that differ only in digits 8
       through 16 will be printed separately, even if they will
       have identical values when printed.  Two different double
       precision numbers such as:

            .9999999999999995D0 or 1.0000000000000005D0

       will be printed in the output listing as:

            .1000000E+001

       on separate lines from numbers that are exactly 1.D0.

       Any floating constants defined by code brought into a pro-
       gram or subprogram by an INCLUDE statement will not be
       listed.

   7.  The seventh table lists all character constants, i.e. lit-
       erals, in the source code and the ISNs where used.  When
       a literal exceeds 80 characters, it is truncated to 80
       characters for the listing.  If less than 80 characters in
       length, every literal is shown with its encapsulating
       apostrophes or quotation marks.  All upper and lower case
       characters will be printed.

       Hollerith fields used in CALL, DATA, and FORMAT statements
       will appear as literals surrounded by apostrophes in this
       table.

       Hexadecimal, octal, or binary numbers specified without
       apostrophes or quotation marks in a DATA statement are
       listed as in this table exactly as they occur in the
       source program code, including leading or trailing B, O, Z,
       X, or x DATA type specificarion.  They are treated as
       literals not numbers.

       Character constants defined as binary, octal, or hexadeci-
       mal with the value surrouonded by apostrophes or surrounded
       by apostrophes or quotation marks will have the correct
       type indicator B, O, Z, X, or x DATA type specification
       preceding or following the character constant.

       Some FORTRAN compilers use X instead of Z to indicate hex-
       adecimal literal constants and may also use the character
       C to indicate a literal string encapsulated in apostrophes
       or quotation marks is a null terminated string used by the
       C/C++ language.  The null character is neither coded nor
       shown.  The C code to indicate a null terminated string
       may occur only as the final character of the literal after
       the last apostrophe or quotation mark.

       The character constants are ordered by their length then
       collated in ascending sequence.

       Any character constants defined by code brought into a
       program or subprogram by an INCLUDE statement will not be
       listed.

   8.  The eighth table shows the size of each COMMON block and
       the relative address of every variable belonging to the
       COMMON block.  If any variables are brought into a COMMON
       block by an EQUIVALENCE statement, the relative address of
       each equivalenced variable is shown.  No lower case char-
       acters will be printed.

       If any variables declared to be equivalenced exist that
       are not included in a COMMON block definition, these var-
       iables will not appear in this table.

       When a variable name exceeds six characters, the FORTRAN
       77 standard, the number of variable names printed on a
       line will change to accommodate longer names.  This
       causes a single line of print to contain from two to four
       variables.

       The type and length designations shown for variable names
       are obtained from the DIMENSION, IMPLICIT, COMMON, EQUIV-
       VALENCE, RECORD, and data type statements within the pro-
       gram or subprogram source code.  If an INCLUDE statement
       is used to incorporate data type statements such as
       INTEGER, REAL, CHARACTER, COMPLEX, etc., or DIMENSION,
       IMPLICIT, COMMON, and  EQUIVALENCE into a program or sub-
       program, the relative addresses, the type, and the length
       values  will not be accurate in the listing when the
       INCLUDE input file can not be found.

       A variable name defined in a RECORD statement will have a
       question mark, ?, as the type designation since no stand-
       ard FORTRAN type may be assigned to it, because it is
       composed of a collection of types.  The usage code will
       show that the name is a RECORD variable.  The length of a
       RECORD variable will be shown as that of the STRUCTURE
       which is used as the template for the RECORD variable.

       Also, variables in COMMON blocks that are dimensioned with
       a variable passed as an argument to a SUBROUTINE, FUNCTION,
       or ENTRY subprogram will not have the correct size for the
       COMMON block since the value of the passed argument is
       unknown during compilation.  Its true value is known only
       during execution of the program.  Each variable within
       such a common block will have its relative address set to
       zero.

       Variables equivalenced to a COMMON block variable may have
       an address greater than the total size of the COMMON block
       when the COMMON block is dimensioned.  Older FORTRAN pro-
       grams often use this technique in SUBROUTINE definitions.

   9.  The ninth table provides a listing of all subprograms
       called by the routine being analyzed.  No lower case char-
       acters will be printed.  This list is derived from CALL,
       ENTRY, and FUNCTION statements.  All FORTRAN intrinsic
       Functions will also be listed in this table if they are
       derived from ENTRY, FUNCTION, and SUBROUTINE statements.
       Any FORTRAN intrinsic functions used by the module will
       appear in this table.

       Use of a FUNCTION subprogram name in a program or sub-
       program may not be designated as one by FXREF since there
       is no way to distinguish between a subroutine name and a
       function name when the CALL statement is used.  FXREF makes
       no attempt to coordinate different routines to determine
       if a name is a variable name, function name, or a subrout-
       ine name.

       Any FUNCTION or SUBROUTINE statements used by code brought
       into a program or subprogram using the INCLUDE statement
       will not be listed in the table.

   10. The tenth table provides statistical counts of the number
       of occurrences of items in each table.  The count of the
       number of subprograms includes those defined by the pro-
       gram being analyzed.  Also, the counts exclude any occur-
       rences of variable names, statement numbers, constants,
       input-output, and subprogram names units brought into the
       program module through use of the INCLUDE statement and
       not used within the subprogram.

   11. If any errors are detected in the source FORTRAN state-
       ments, messages are printed at the end of the tables for
       each individual routine.  If no errors are detected, this
       table is omitted.

   12. If global analysis of the FORTRAN source code is requested,
       any messages generated will appear after all source code
       processing is complete.  Global messages will always appear
       at the end of the entire listing of all program modules
       processed in a single execution of FXREF, and it is assum-
       ed that all the source code read for processing constit-
       utes a single program.  Messages appearing as global mess-
       ages will be erroneous or superfluous when less than a
       complete program is processed.

       The table listings are designed to make maximum use of the
       printed page since listings can be quite lengthy.  The
       maximum record length is 121 characters including the
       carriage control character.

       When text output is chosen, vertical paper orientation
       (portrait) is used; 8.5 X 11 inch standard paper is assum-
       ed when 80 lines per page have been chosen.  If 60 lines
       of text output is selected, 11 X 14 inch paper in horiz-
       ontal paper orientation (landscape) is assumed.  Font
       choice and margin settings are the default settings of the
       printer.

       If postscript output is chosen, requesting 80 lines per
       page will use vertical paper orientation (portrait),
       8.5 x 11 inch standard paper with 1/4 top and bottom
       margins and 3/4 inch left and 1/2 inch right margins.
       Font size is 8 point.  For 60 lines per page, horizontal
       paper orientation (landscape) with 1 inch top, bottom,
       left, and right margins and a 10 point font.  Postscript
       files have the font set to courier-bold as standard.  This
       font is part of the basic 35 fonts of most postscript
       printers.

       If other than 8 or 10 point text is preferred for the
       postscript listing, the FXREF must be modified.  The
       FORTRAN code setting the two values specifying the number
       of lines are located in the main routine, FXREF, at about
       line 720 of the program.  However, all of the printing
       routines contain numerical integer constants that must be
       changed to match the new choices.

       When postscript output files are created, the font size is
       set in subroutine PSPRINT.  Modification of these values
       will require recompilation of FXREF.

VIEWING THE FXREF TABLES OUTPUT TABLES ON THE MONITOR

       Both the text and Postscript output files may be viewed as
       text files using a full screen editor.  However, the out-
       put file will not be displayed in normal form as it would
       on a printer.  If it is desired to view the output file as
       it would appear on the printed page, select the option to
       create a Postscript output file and view it with Ghost-
       script which can display the listing as it appears on
       paper.  The Ghostscript program is available from several
       internet sites without charge.

FXREF PROGRAM INFORMATION:

       FXREF is a large program with numerous subprograms.  The
       source code is approximately 2,400,000 bytes in size with
       about 26,000 lines of FORTRAN 77 code. The program is well
       documented with copious comment statements throughout.

       The execution module, FXREF.EXE, requires about 3,000,000
       characters of disk storage for EcomStation Ver. 2.0.

       FXREF uses few FORTRAN library routines, but those used
       are part of any standard FORTRAN library.  Special rout-
       ines, that may or may not be part of some FORTRAN compiler
       libraries, are written into the program to avoid any
       problems or inconsistences.  The exceptions are:

          1. GROWHANDLES function discussed in the section des-
             ribing the input-output units and their record
             descriptions;
          2. GETDATE, a subroutine to obtain the current date;
          3. GETTIME, a subroutine to obtain the current time.

       The GETDAT and GETTIM subroutines are discussed in the pro-
       gram modification section at the end of this document.

       Subroutines for conversion between alphabetic numeric
       characters and algebraic numeric values are coded within
       the program by means of arithmetic computations or by
       using READ and WRITE statements.  Arithmetic values req-
       uired to accomplish this are based on the ASCII coding
       system and require change for other coding systems and
       operating systems.  See the comments regarding modificat-
       ions at the end of this documentation. The routines of the
       program are classified into several categories; these are:

       1. The main program.
       2. Routines to read the source statements and write
          them on the listing file, and utility routines for
          the main program.
       3. Analysis routines of the FORTRAN statements.
       4. Utility routines for the analysis subprograms.
       5. Sort utilities to prepare data for the listing routines.
       6. Output file list creation routines.
       7. Utility routines for the list creation routines.
       8. Postscript output listing routines.
       9. Global analysis routines.

       A list of all the subprogram routines in FXREF are provid-
       ed by the following table with a brief description of its
       function.  Some routine names are ENTRY statements.

       1. Main Program

       FXREF   Main program, controls overall execution

       2. Input and output routines of FORTRAN source code and
          utility routines for the main program

       CHKSWS  Insures bit switches in array CNAME are correct
       COMPRS  Removes all blanks not part of a literal from a
               FORTRAN statement.  All statement numbers and
               literals are removed from the FORTRAN statement
               and saved in temporary disk files or arrays.
       GETRCD  Reads a FORTRAN source code record from an input
               file
       PRCD    Controls the synthesis of a FORTRAN statement
               including all continuation records from an input
               unit.
       RDSTMT  Reads the FORTRAN source code being analyzed
       SETUP   Initializes FXREF to start processing a new
               program or subprogram
       SUBTBL  Creates a table of all ENTRY, FUNCTION, and
               SUBROUTINE subprogram definitions in the program
               being processed
       TESTR   Determines if a possible logical syntax error is
               is a RECORD variable name
       TFUNC   Sets a logical switch when a FUNCTION or
               SUBROUTINE statement occurs while reading a
               FORTRAN input source code from unit 5
       WKCLOS  Closes and deletes all internal work files except
               global diagnostic work files
       WKOPEN  Opens all internal work files except global diag-
               nostic work files
       WRSTMT  Writes the source code with assigned ISNs in the
               output listing

       3. FORTRAN Statement Analysis Routines

       STMT01  analyzes ACCEPT
       STMT02  analyzes ACCESS
       STMT04  analyzes BACKSPACE
       STMT05  analyzes BLOCK DATA
       STMT06  analyzes BYTE
       STMT07  analyzes CALL
       STMT08  analyzes CHARACTER
       STMT09  analyzes CLOSE
       STMT10  analyzes COMMON
       STMT11  analyzes COMPLEX
       STMT12  analyzes CONTINUE
       STMT13  analyzes DATA
       STMT14  analyzes DECODE & ENCODE
       STMT15  analyzes DIMENSION & VIRTUAL
       STMT16  analyzes DO
       STMT17  analyzes DO WHILE
       STMT18  analyzes DOUBLE PRECISION
       STMT19  analyzes ELSE
       STMT21  analyzes END
       STMT22  analyzes END DO
       STMT23  analyzes END FILE
       STMT25  analyzes ENTRY
       STMT26  analyzes EQUIVALENCE
       STMT27  analyzes EXTERNAL
       STMT29  analyzes FUNCTION
       STMT30  analyzes GO TO
       STMT31  analyzes IF
       STMT32  analyzes IMPLICIT
       STMT33  analyzes INCLUDE
       STMT34  analyzes INQUIRE
       STMT35  analyzes INTEGER
       STMT36  analyzes INTRINSIC
       STMT37  analyzes LOGICAL
       STMT38  analyzes NAMELIST
       STMT39  analyzes OPEN
       STMT41  analyzes PARAMETER
       STMT42  analyzes PAUSE
       STMT43  analyzes PRINT
       STMT44  analyzes PROGRAM
       STMT45  analyzes READ
       STMT46  analyzes REAL
       STMT47  analyzes RECORD
       STMT48  analyzes RETURN
       STMT49  analyzes REWIND
       STMT50  analyzes SAVE
       STMT52  analyzes STOP
       STMT53  analyzes STRUCTURE
       STMT54  analyzes SUBROUTINE
       STMT55  analyzes TYPE
       STMT56  analyzes UNION
       STMT59  anlyzes  WHILE

       Not every FORTRAN statement has its own analysis routine.
       No routines named STMT03, STMT20, STMT22, STMT24, STMT28,
       STMT40, STMT51, STMT57, STMT58 exist.  A number of state-
       ements are processed by one of the routines listed above.
       As a result, the list of statements processed by the pro-
       gram does not match the above table.

       4. Utility routines for the FORTRAN statement analysis
          routines

       ARGLST  Processes the argument lists for CALL, ENTRY,
               FUNCTION, and SUBROUTINE statements.
       CHKNME  Places a variable name in a table of all names
               found in a program or subprogram being analyzed.
               Checks to insure a name is inserted into the
               table only once.
       CIOLST  Processes input-output and file operation state-
               ments' control lists, except for the KEY argument.
               This routine does not process input-output lists.
       CSETUP  Processes compound variable names
       CUNIT   Determines the unit number or variable name unit
               designation of input-output and file operation
               statements.
       DELCOM  Deletes line comments within a statement
       EFARGS  Processes FUNCTION names and arguments called from
               an expression.
       EINCL   Processes the end of file condition for an INCLUDE
               statement file.  This in an ENTRY statement name.
       EQUIVB  Creates disk records for EQUIVALENCE group variable
               names used by routine PEQUIV.
       ESTRUC  Sets the length characteristic of a STRUCTURE def-
               inition when the END STRUCTURE statement termina-
               tes a STRUCTURE definition.  This an ENTRY state-
               ment name, not a SUBROUTINE or FUNCTION.
       EUNION  Sets the maximum length of a UNION definition when
               an END UNION statement terminates a UNION state-
               ement.  This is an ENTRY statement name.
       EVALU   Evaluates a length or size specification specified
               as an expression for type, DIMENSION, and
               PARAMETER statements.
       EXPR    Processes arithmetic statements, arithmetic exp-
               ressions, logical statements, and logical exp-
               ressions.
       EXPRA   Processes arithmetic statements, arithmetic exp-
               ressions, logical statements, and logical exp-
               ressions occurring in CALL statement arguments, or
               as arguments of functions used within a program
               module.
       FCHECK  Places a floating point number in the table of
               real values found in a program or subprogram.
               Prevents a multiple entry of the number into the
               table for the same statement.
       FMTSYN  Processes FORMAT statements' syntax
       INSERT  Places an integer in the table of integer values
               found in a program or subprogram.  Prevents a
               multiple entry of the number into the table for
               the same statement.
       ITABIN  Inserts an entry into a table of integer variable
               array that is singly dimensioned.
       ITABSR  Performs a binary search of a singly dimensioned
               integer array.
       ITOC    Converts an integer algebraic value to ASCII text
               form. Used to provide text form of the length
               characteristic.
       KEY     Processes the KEY argument of input-output control
               lists.
       LOCERR  Writes the message that a definition statement
               occurs after the first executable statement.
       LOGERR  Creates a FORMAT statement to write a message that
               a syntax error exists in a logical operator.
       MOVREC  Places the input source code into the analysis
               work area
       NUMBER  Converts an ASCII numerical field to either an
               integer arithmetic number or to a floating point
               number.
       PARAEV  Controls evaluation of a PARAMETER variable def-
               ined as an arithmetic expression, length of a
               statement defined as an expression, and DIMENSION
               of type statements and size defined as an express-
               ion.  Length of type statements and size of
               DIMENSION statements that are expressions must be
               defined as constants or variables defined in a
               PARAMETER statement.
       PIOLST  Processes input-output lists for input-output
               statements.  This routine does not process input-
               output control lists.
       PMAP    Processes the initialization of MAP statement
       PRDWR   Determines arguments of input-output and file
               operation command lists and calls the routine to
               process them.
       RBLANK  Removes all blank characters from a FORTRAN source
               statement and generates synthetic C## variable
               names for argument lists in CALL, ENTRY, FUNCTION,
               and SUBROUTINE statements.
       REMTAB  Determines if horizontal tab characters exist in a
               record and removes them.
       SAPOSH  Converts hollerith fields to literals in all
               statements.
       SETTL   Sets the type and length of a variable from the
               FORTRAN default values as modified by an IMPLICIT
               statement.
       TABINS  Inserts an entry into a table of a character var-
               iable array that is singly dimensioned.  This
               routine is also used by the printer listing creat-
               ion routines.
       TABSRH  Performs a binary search of a singly dimensioned
               character array variable using an arbitrary length
               field.  This routine is also used by the printer
               listing creation routines.
       TBLINS  Inserts an entry into a character variable array
               that is singly dimensioned.  This routine is also
               used by the printer listing creation routines.
       TBLSRH  Performs a binary search of a singly dimensioned
               character array.  This routine is also used by the
               printer listing creation routines.
       TYPLST  Processes the argument list of type statements,
               DIMENSION statement, COMMON statement, BYTE
               statement, DATA statement, DOUBLE PRECISION state-
               ment, RECORD statement, and STRUCTURE statement.
       VSETUP  Partitions a compound variable name into its comp-
               onents and sets up the parameters and work area
               parameters and work area for routine CHKNME.

       5. Sort routines to prepare for printing the listing

       CFIELD  Used by DSORT to determine the result of comparing
               character, real, double precision, integer, and
               complex type data fields.
       CMFLD   Compares fields in separate records according to
               their data type.
       DSORT   Sorts an ASCII disk file.
       MFSORT  Sorts a singly dimensioned real array in memory.
       MISORT  Sorts a doubly dimensioned integer array in memory.
       MISRT1  Sorts a singly dimensioned integer array in memory.
       MSORT   Sorts a singly dimensioned character array in
               memory.

       All sort routines use the heap sort algorithm.

       6. Listing creation routines

       LIST    Controls the creation of the tables for the
               listing.
       PCOMM   Determines relative addresses of variables in
               BLOCK COMMON definitions and prints all common
               blocks found in the program being analyzed.
       PEQUIC  Combines multiple defined EQUIVALENCE groups that
               must treated as a single group because they are
               brought into a COMMON definition.
       PEQUIV  Determines relative addresses of variables brought
               into BLOCK COMMON by EQUIVALENCE statements and
               all such variables with their relative addresses.
       PRINTC  Prints the table of integer constants found in the
               program being analyzed.
       PRINTF  Prints the table of real constants found in the
               program being analyzed.
       PRINTI  Prints the integer input-output units found in the
               program being analyzed.
       PRINTL  Prints the literals found in the program being
               analyzed.
       PRINTS  Prints the table of statement numbers found in the
               program being analyzed.
       PRINTV  Prints the table of variable names, their usage,
               type and length, and ISNs where used within the
               program being analyzed.
       PRTVIO  Prints input-output units specified as a variable
               name.

       7. Utility routines for the list creation routines

       NUPAGE  Creates a new page format modification.
       VFMTC   Creates a format statement to write table 2.

       8. Postscript listing creation routines

       CARCTL  Controls the interpretation of carriage control
               characters occurring in the first column of each
               print record to position each record of print in
               the postscript printed page.
       HEADPR  Creates a header when carriage control characters
               are not used.
       NUMCNV  Converts binary integer values to ASCII text to
               create FORMAT statements for writing the post-
               script output listing.
       PAGENM  Creates the postscript %%Page command to locate
               the start of each print page of the output listing
       PSPRINT Controls the creation of the various forms of the
               postscript output file listing
       REVPRT  Writes two output postscript files; one containing
               the odd pages in ascending order and another cont-
               aining the even pages in reverse (descending)
               order.

       9. Global analysis routines

       ARGCHK  Verfies CALL, ENTRY, FUNCTION, and SUBROUTINE arg-
               ument lists have the correct number of arguments,
               the type and length characteristics of each arg-
               ument is correct, if a subprogram is defined but
               not called, or if a subprogram is called but not
               defined.
       COMCHK  Verifies that the same COMMON block as identical
               length in all routines that use it.
       GERR1   Creates the global diagnostic message a subprogram
               has been defined, but it has not been called in a
               program.
       GERR2   Creates the global diagnostic message a subprogram
               has been called, but it has not been defined.
       GERR3   Creates the global diagnostic message an argument
               of a CALL statement has a data type different from
               the subprogram definition.
       GERR4   Creates the global diagnostic message an argument
               of a CALL statement has a length characertistic
               different from the subprogram definition.
       GERR5   Creates the global diagnostic message that a
               FUNCTION subprogram is called as a SUBROUTINE.
       GERR6   Creates the global diagnostic message that the
               number of arguments in a CALL statement is diff-
               erent from the subprogram definition number of
               arguments.

       Routines GERR2, GERR3, GERR4, GERR5, and GERR6 are ENTRY
       statements.

       Many messages may be created by the COMMON length verific-
       ation when the erroneous length is in the initial occurr-
       ence of the common block.  FXREF assumes the correct length
       of a common block is its first occurrence in the program.
       A single syntax error may produce more than one message.

FXREF ABNORMAL HALTS DURING EXECUTION

       When FXREF terminates execution without a normal complet-
       ion message, error messages may have been written on the
       error message file named: MESS.LST.  Examine this file
       with an editor program to determine if any error messages
       exist.  Any error messages on this file can usually ident-
       ify the cause of the error in the FORTRAN source code
       causing FXREF's execution failure.

ERROR MESSAGES:

       Error messages will be written when errors occur that
       prevent correct analysis of a FORTRAN source statement.
       The messages pertain to syntax errors, and no attempt is
       made to determine other inconsistencies such as improper
       mixed mode arithmetic, improper uses of character and
       arithmetic variables, closed block if statements, closed
       do statements, etc.  Detection of these errors are proper-
       ly the task of a compiler, precompiler, or LINT program.
       Some messages may be advisory rather than an explicit
       error, particularly when INCLUDE statement files are used.

       Many messages may be created by COMMON length verification
       when the erroneous length is in the initial occurrence of
       the common block.  FXREF assumes the correct length of the
       common block is its first occurrence in the program.  A
       single error may produce more than one message.

       When FORTRAN source code in brought into a program or a
       subprogram through use of the INCLUDE statement, no diag-
       nostic messages will be written for the code of the inc-
       cluded file.  It is assumed the file specified in the
       INCLUDE statement will be analyzed separately which will
       detect any syntax or other errors recognized by FXREF.

       A list of the error messages that may be generated by this
       program are listed below.  When {number}, {name}, or
       {character} occur, these values are supplied by FXREF from
       its analysis.  When multiple {name}, {number), or
       {character} specifications occur, they are designated as
       {name1}, {name2}, etc.

       If more than one hundred error messages are written on
       unit 0, the program will stop all further source statement
       processing.  This limit is provided to prevent possible
       run away conditions during execution.  The error message:

           STOP: MORE THAN 100 ERRORS

       will appear on the monitor screen.  It is necessary to
       correct the situation causing the excess errors before
       executing FXREF again with the same FORTRAN source program
       as input.  FORTRAN unit 0 will be saved, and it can be
       examined using an editor.  A complete listing of tables
       will not be available.  This limit does not apply to global
       diagnostic messages.

       FORTRAN programs not adhering to the 1977 standard will
       usually cause many error messages to be created by FXREF.
       Some compiler may have non-standard syntax usages that
       will cause messages or abnormal termination of execution.
       In those cases, the FORTRAN source code should be edited
       remove or modify any illegal text not conforming to
       FORTRAN 77 standards.

       If it is desired to increase the 100 error limit, the
       FORTRAN statement occurring after statement number 16
       in the MAIN routine:

          IF(IREC0 .GT. 100) STOP 'STOP: MORE THAN 100 ERRORS'

       must be modified with what ever limit is desired and FXREF
       recompiled.

       FXREF produces two basic message types.  Type 1 does not
       contain ISN numbers, and type 2 does contain ISN numbers.

       Messages without the ISN specified

       A DUPLICATE SUBPROGRAM DEFINITION OCCURS, NAMED: {name}
          An ENTRY, FUNCTION, or SUBROUTINE definition has a dup-
          licate name.

       A SUBROUTINE MUST HAVE AN ISN OF 1
          The SUBROUTINE statement must be the first non-comment
          statement.

       COLUMN 1 OF A FORTRAN RECORD IS A FORM FEED
          A form feed occurs in a FORTRAN input record.  This
          usually occurs when a file of FORTRAN code used as in-
          put from unit 5 is a listing for printing.  FXREF acc-
          epts FORTRAN source code from printer listings in some
          cases.  Any form feed in column one will cause this
          message.

       COLUMN 1 OF A FORTRAN CHARACTER IS AN ILLEGAL CHARACTER
       {statement}
          Column one of a FORTRAN record from unit 5, the FORTRAN
          source code input file, contains a character other than
          the following: c, C, d, D, x, X, *, #, $, or blank; or,
          the record contains text that can not be identified as
          a FORTRAN statement.  72 characters are shown for this
          form of the message.  Occurrence of characters not part
          of the allowable FORTRAN character set will also cause
          message.

          Some older FORTRAN programs have compiler or operating
          system commands that precede FORTRAN code.  When FORTRAN
          code is found, the END STATEMENT MISSING is issued as
          well, even though the END statement does exist.

       COMMON BLOCK /{name1}/ IN ROUTINE {name2} HAS A LENGTH OF
       (number1}, BUT HAS A LENGTH OF {number2}
          The block common {name1} has a different length of
          {number1} in subprogram {name2}.  This is a global
          message.  FXREF assumes that the initial occurrence of
          {name1} is the correct length; consequently, if the
          length error exists in the first occurrence, all other
          occurrences are considered to have an erroneous length.

       CONTROL CARD ERROR: COLUMN 4 ERROR FOR TEXT OUTPUT. COLUMN
       4 IS SET TO 1.
          Inconsistent parameters exist in column 4 of control
          card 1.  Column 2 is set to F; column 4 is set to 1.

       CONTROL CARD ERROR: COLUMN 4 ERROR FOR POSTSCRIPT OUTPUT.
       COLUMN 4 IS SET TO 1.
          Inconsistent parameters exist in column 4 of control
          card 1.  Column 2 is set to F; column 4 is set to 1.

       DEFINED SUBPROGRAM {name} IS NOT CALLED
          The subprogram named {name} is defined but never called
          within the program.  This may be a local or global
          message.

          When subprogram {name} is used as an argument in OS/2-
          ECS APIs, this message may appear if it is not used as a
          function call or the subprogram name is a CALL
          statement.

       END STATEMENT MISSING
          FXREF has detected that an END statement does not occur
          where one is expected.  In certain cases, FXREF will
          synthesize an END statement which will appear in the
          output listing.

       FILE NOT FOUND: {file name}
          A file name specified as FORTRAN source code input in
          the control cards (file: FXREF.CCD) can not be found.
          FXREF terminates execution, and this message appears
          on the monitor screen when FXREF is run in a foreground
          session.  The message is discarded when FXREF runs in a
          background session.

       FXREF CAN NOT PROCESS FILE NAME
          The synthesized file name of an INCLUDE statement ex-
          ceeds 80 characters; a message and the INCLUDE state-
          ment precedes this message on the monitor screen.

       IN {name}, COMPARE FIELD LENGTH GREATER THAN RECORD LENGTH
          Subroutine TBLSRH, TABSRH, or ITABSR contains a field
          length that exceeds the record length.  This message
          should never appear and indicates some kind of hardware
          failure.

       IN {name}, LENGTH OF COMPARE FIELDS UNEQUAL
          Subroutine TBLSRH, TABSRH, or ITABSR is attempting to
          compare two fields of unequal length.  This message
          should never appear and indicates some kind of hard-
          ware failure.

       INCLUDE FILE NOT FOUND
       {statement}
          An INCLUDE statement {statement} specifies a file that
          can not be found.  Make the statement a comment state-
          ment, delete the statement from the source code, or
          make the file available to FXREF.  FXREF will stop
          execution.

       INPUT AND OUTPUT FILES ARE IDENTICAL
          The output listing file and one of the input FORTRAN
          source file names are identical.  The program will stop
          execution.

       INPUT FILE EMPTY
          The first record of file FXREF.CCD is blank.

       INPUT RECORD LENGTH GREATER THAN 256 OR ZERO
          An input record of the output listing is zero or great-
          er than 256.  This should never occur.  It would occur
          only if the output listing is a postscript file crea-
          created for the output listing.  It indicates that one
          one of the table creation routines' records have been
          damaged.

       MORE THAN 10 PARENTHESES IN A PARAMETER STATEMENT EXPRESSION
          An arithmetic expression defining a PARAMETER variable
          contains more than 10 sets of matching parentheses.
          FXREF permits only 10 general work variables to evaluate
          the expression.  The value assigned to the variable
          will be incorrect.  The output listing will not have
          the correct when the PARAMETER variable is used.

       MORE THAN 1000 SUBPROGRAMS EXIST
          A single program unit uses more than 1000 ENTRY, FUNCTION,
          and SUBROUTINE definitions.  This is a global message.

       MORE THAN 10,000 EVEN NUMBERED PAGES
          The postscript output listing exceeds 10,000 even numb-
          ed pages.  This message may appear when a postscript
          output listing is split into two files, an odd page
          file and an even page file.

       MORE THAN 10,000 NUMBER PAGES
          More than 10,000 pages occur in the postscript output
          file when a single postscript output file has been req-
          uested in FXREF.CCD.

       MORE THAN 200 COMMON DEFINITIONS
          More than 200 COMMON blocks defined.  The listing will
          be incomplete.  COMMON definitions brought into the
          program or subprogram by an INCLUDE statement are
          counted for this limit.

       MORE THAN 200 EQUIVALENCE GROUPS
          More than 200 groups of variables that are made equiv-
          alent to each other exist in a single EQUIVALENCE state-
          ment.  The remaining groups will not be processd.

       MORE THAN 4000 INTEGER PARAMETER DEFINITIONS
          The number of integer PARAMETER definitions exceeds
          4000.

       MORE THAN 4000 SUBPROGRAMS EXIST
          A single program uses more than 4000 ENTRY, FUNCTION,
          and SUBROUTINE definitions.  This is a global message.

       MORE THAN 4000 VARIABLE NAMES
          A single subprogram uses more than 4000 variable names.

       MORE THAN 8 CHARACTERS IN FILE NAME
          The base file name of the output listing file contains
          more than eight characters.  FXREF stops execution.
          This message occurs only if the output listing file is
          to be a postscript file. However, it should never appear.

       MORE THAN {number} CONTINUATION RECORDS
          FORTRAN continuation statements, indicated by a non-
          blank character in character 6 of a statement or an
          ampersand, &, in column 1, exceed the allowed limit.

       MULTIPLE FUNCTION LENGTHS ARE DEFINED
          A FUNCTION statement has more than one length charac-
          teristic defined.

       NO C0NTROL CARD FILE
          The FXREF.CCD file can not be found.

       NO FILE SPECIFIED
          No input file name is provided in the FXREF.CCD file
          that specifies where the FORTRAN source code to be
          analyzed may be found.

       NOT A FORTRAN STATEMENT
       (statement)
          Column one of an input record from unit 5, the FORTRAN
          source code input file, contains a character other than
          one of the following: C, c, *, #, $, !, or blank; or
          the record contains text that can not be identified as
          a FORTRAN statement.  72 characters are shown for this
          form of the message.  Occurrence of characters that are
          not part of the allowable FORTRAN character set will
          also cause this message.

       {statement}: NOT A FORTRAN STATEMENT
          {statement has been identified as not a FORTRAN state-
          ment nd the internal statement number *ISN) is not ava-
          ilable.  Only the initial 20 characters are shown.
          Another form of this message contains the internal
          statement number (ISN).  See the further description in
          the next section.

       STOP: MORE THAN 100 ERRORS
          More than 100 error messages have been written.  The
          program will stop all processing of further FORTRAN
          source code records.  Only a partial listing will be
          available.  FORTRAN unit 0 will contain the 100 error
          error messages.  An editor must be used to examine this
          file.  The file name is: MESS.LST.  When FXREF is re-
          started, the file will be automatically deleted if it
          exists.  It will be in the same directory as FXREF.EXE.

       SUBPROGRAM NAME TABLE FULL
          FXREF a table of all ENTRY, FUNCTION, and SUBROUTINE
          subprogram names for the input file on unit 5.  The
          The maximum allowed is 1000.

       TABLE FULL {name}
          A table maintained by subroutine TABINS or TBLINS is
          full.  No further entries are made, and output tables
          will be incomplete.  {name} will be either TABINS or
          TBLINS.

       UNIT 5 INPUT FILE NOT FOUND
          The file name specified on control card records 3 - 12
          from unit 1 as the FORTRAN input source coe can be
          found.  Correct the file name before rerunning FXREF.

       VARIABLE DEFINED IN MORE THAN ONE COMMON BLOCK: {name}
          The variable {name} is defined in multiple COMMON
          blocks.

       Messages with the ISN specified

       All of this class of messages are of the form:

          ISN: {numeric value} [message]

       Only the [message] portion is shown in this table.  The
       value of {numeric value} will be the internal statement
       statement number (ISN) of the FORTRAN statement contain-
       ing the error.

       A DIGIT MUST FOLLOW AN ASTERISK
          A type statement, such as INTEGER, REAL, etc., does not
          have a digit length specification after an asterisk.

       A DUPLICATE SUBPROGRAM DEFINITION OCCURS, NAMED: {name:}
          Two or more ENTRY, FUNCTION, or SUBROUTINE subprograms
          have been defined with identical names.

       A FUNCTION STATEMENT MUST HAVE AN ISN OF 1
          A FUNCTION statement must be the first non-executable
          statement in a subprogram.

       A NUMERICAL FIELD CONTAINS AN ALPHABETIC CHARACTER
          A required numerical field in an input-output command
          list contains an alphabetic character.  This message
          will not appear for real values expressed in scientific
          notation.

       A PARAMETER IN A CONTROL LIST IS INVALID {name}
          An input-output statement parameter control list {name}
          is invalid.

       A PROGRAM STATEMENT IS NOT THE FIRST STATEMENT
          A PROGRAM statement occurs that is not the first exec-
          utable statement in a program.

       A SUBROUTINE STATEMENT MUST HAVE AN ISN OF 1
          A SUBROUTINE statement must be the first non-comment
          statement in a subprogram.

       AN INTRINSIC FUNCTION SPECIFICATION IS INVALID
          An intrinsic function specification is not valid.

       ARGUMENT LENGTH EXCEEDS 80 CHARACTERS
          An argument of a CALL statement exceeds 80 characters,
          the maximum allowed by FXREF.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE
       CONCANTENATED EXPRESSION ARGUMENTS
          An ENTRY, FUNCTION,  or SUBROUTINE statement has a con-
          catenated character expression argument which is not
          allowed.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE CONSTANT
       ARGUMENTS
          An argument of an ENTRY, FUNCTION, or, SUBROUTINE state=
          ment contains a numeric or logical constant which is
          not allowed.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE LITERAL
       ARGUMENTS
          An argument of an ENTRY, FUNCTION, or SUBROUTINE state-
          ment contains a literal which is not allowed.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE
       MATHEMATICAL EXPRESSION ARGUMENTS
          An argument of an ENTRY, FUNCTION, or SUBPROGRAM state-
          ment contains a mathematical expression which is not
          allowed.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE
       SUBSCRIPTED OR CHARACTER RANGE ARGUMENTS
          An argument of an ENTRY, FUNCTION, or SUBROUTINE state-
          ment contains a variable with either subscripts or
          character range specifications which is not allowed.

       ARGUMENT {number}; A SUBSCRIPT MUST BE AN INTEGER
          An argument of a CALL statement contains a subscripted
          variable whose subscript can not be evaluated as an
          integer.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE STATEMENT
       NUMBER ARGUMENTS
          An argument of an ENTRY, FUNCTION, or, SUBROUTINE state-
          ment contains a statement number which is not allowed.

       ARGUMENT {number}; ONLY CALL STATEMENTS MAY HAVE
       SUBSCRIPTED RANGE SPECIFICATION ARGUMENTS
          An argument of an ENTRY, FUNCTION, or, SUBROUTINE state-
          ement contains a variable with either subscripts or
          character range specifications which is not allowed.

       ARITHMETIC IF LACKS THREE STATEMENT NUMBERS
          An arithmetic IF statement has more than or less than
          three statement numbers  None of the arguments will be
          processed.

       ASTERISK IS ILLEGAL IN THIS STATEMENT
          An asterisk is not allowed in either a DOUBLE COMPLEX
          or DOUBLE PRECISION statements.

       BACKSPACE CONTROL ARGUMENT IS A VARIABLE NAME
          A control argument for the BACKSPACE statement may not
          be a variable name.

       BACKSPACE CONTROL ARGUMENTS LACK A LEFT PARENTHESIS
       BACKSPACE CONTROL ARGUMENTS LACK A RIGHT PARENTHESIS
          A control argument for the BACKSPACE statement lacks a
          left or right parenthesis.

       BLOCK COMMON NAME NOT DEFINED: {name}
          A block common name can not be found while attempting
          to determine its total length.

       BYTE VARIABLE HAS ILLEGAL LENGTH
          A variable defined as type BYTE has an illegal length.

       CALL LACKS A LEFT PARENTHESIS
       CALL LACKS A RIGHT PARENTHESIS
          A CALL statement is lacking a left or right parenthesis.

       CALL ARGUMENT DIMENSIONED VARIABLE SUBSCRIPT CONTAINS A
       FLOATING OR REAL NUMBER {number}
          An argument of a CALL statement uses a dimensioned var-
          iable that has a subscript specified as an expression,
          and the expression contains a numeric constant that is
          a floating or real number {number}.

       CALL ARGUMENT IS NOT DEFINED AS AN EXTERNAL STATEMENT:
       {name}
          A CALL statement has a subprogram name {name} used as
          an argument, but the subprogram name is not defined as
          an EXTERNAL subprogram.  This message is usually a
          warning message if the subprogram is part of the curr-
          ent program being analyzed.

       CALL ARGUMENT LACKS A LEFT PARENTHESIS
       CALL ARGUMENT LACKS A RIGHT PARENTHESIS
          The argument of a CALL statement is lacking a left or
          right parenthesis where one is expected.

       CALL ARGUMENT DOES NOT MATCH ITS DIMENSION: {name}
          The dimensioned variable {name} used as an argument in
          CALL statement has too few or too many subscripts
          specified.

       CALLED ARGUMENT VARIABLE IS NOT DEFINED: {name}
          An argument in a CALL statement uses a variable name
          {name} that is not defined prior to its use as a CALL
          statement argument.  This message is written if a
          subprogram name is used as an argument and no EXTERNAL
          statement statement declares it as an external subpro-
          gram.  When the vaiable returns a value from the
          called subprogram and used later in the calling sub-
          program, it is not treated as a subprogram name.

       CAN NOT DIVIDE A DIMENSION SUBSCRIPT BY ZERO: {name}
          A dimension size defined by an expression contains a
          subscript variable that has a value of zero.  This is
          caused by attempting to evaluate 0/0 or A/0.  The
          value will be set to a default value.  The condition
          may be caused by failing to correctly define PARAMETER
          statement variable values.

       CHARACTER VARIABLE HAS AN ILLEGAL LENGTH
          A variable defined as type character has a length of
          zero or the provided length exceeds 7 digits.  The
          length is set to four to continue processing.

       COLUMNS 1-5 MUST BE BLANK IN CONTINUATION RECORDS
          A record read from the FORTRAN source code input unit
          is a continuation of a FORTRAN statement, and columns
          1 through 5 are not blank.

       COMMON STATEMENT HAS ILLEGAL SYNTAX: {text}
          A COMMON statement contains a syntax error.  {text}
          shows nine characters that contain the error.

       COMMON VARIABLE NOT FOUND: {name}
          A variable in common does not exist in the master name
          table.

       COMPLEX VARIABLE HAS ILLEGAL LENGTH
          A complex data type definition has an incorrect length
          specification.  The length is set to eight to continue
          processing.

       CONCANTENATED VARIABLE IS NOT DEFINED AS A CHARACTER TYPE
       IN ARGUMENT {number}
          A variable has been used in a character concatenation
          expression, but its type is not defined as character.

       CONTROL LIST ARGUMENT VALUE MUST BE A CHARACTER VARIABLE
          A control list argument in a data manipulation state-
          ment is not a character when required.

       CONTROL LIST ARGUMENT VALUE MUST BE AN INTEGER VARIABLE
          A control list argument in a data manipulation state-
          ment is not an integer variable when required.

       CONTROL LIST ARGUMENT VALUE MUST BE A LOGICAL VARIABLE
          A control list argument in a data manipulation state-
          ment is not a logical variable when required.

       CONTROL LIST ARGUMENT VALUE MUST BE A STATEMENT NUMBER
          A control list argument in a data manipulation state-
          ment is not a statement number when required.

       DATA SPECIFICATION LACKS BALANCED PARENTHESES
          A statement that has a DATA specification lacks match-
          ing left and right slashes.  This message may occur
          when hollerith field definitions containing a slash
          exist.  In this case, it is a warning message.

       DATA STATEMENT HAS ILLEGAL SYNTAX: {text}
          A data specification within encapsulating slashes has
          a syntax error.  {text} shows nine characters, and
          character 5 is the location of the error.

       DIMENSION SPECIFICATION IS REAL: {real number}
          The value of a dimension specification is a real value
          rather than an integer value.

       DIMENSION SPECIFICATION LACKS BALANCED PARENTHESES
          A statement that has a DIMENSION specification lacks
          matching left and right parentheses.

       DIMENSION SUBSCRIPT VARIABLE NAME IS NOT AN INTEGER
       SUBSCRIPT NAME IS: {name}
          A dimensioned variable has as one of its dimension
          specifications a variable name that is not an integer.
          Correct the definition of the subscript variable name
          to be an integer.

       DUMMY VARIABLE DIMENSIONING COMMON BLOCK: {name}
          A DIMENSION statement has a variable name for the dim-
          ension specification, but the variable name is not a
          named integer specified in a PARAMETER statement.

       DUMMY VARIABLE NAME EXCEEDS 32 CHARACTERS: {name}
          A dummy variable in an argument list of ENTRY, FUNCTION,
          or SUBROUTINE statement is longer than 32 characters.

       DUPLICATE ERR ARGUMENT IN ENDFILE
          The control list ERR argument is specified more than
          once in an END FILE statement.

       DUPLICATE IOSTAT ARGUMENT IN ENDFILE
          The control list IOSTAT argument is specified more than
          once in an ENDFILE statement.

       ELSE STATEMENT MISSPELLED
          The ELSE statement has not been spelled correctly.

       END PARAMETER ILLEGAL IN A WRITE STATEMENT
          A WRITE statement contains an END parameter in the
          control list

       END STATEMENT ILLEGAL IN AN INCLUDE FILE
          FORTRAN code in a file defined in an INCLUDE statement
          contains an END statement.  The END statement is
          ignored by FXREF, and processing continues.

       EQUIVALENCED GROUP HAS A SINGLE VARIABLE
          A group of equivalenced variables must have at least
          two variables.

       EQUIVALENCED VARIABLE HAS MORE SUBSCRIPTS THAN ITS
       DIMENSION: {name}
          The EQUIVALENCE variable {name} uses more subscripts
          than the number of defined subscripts for that variable.

       EQUIVALENCED VARIABLE {name} HAS A CHARACTER RANGE
       SPECIFIED BUT IS NOT A CHARACTER VARIABLE
          The variable {name} is not a character variable, but a
          character range specification exists for it in an
          EQUIVALENCE statement.

       EQUIVALENCED VARIABLE {name} USES SUBSCRIPTS BUT IT IS NOT
       DIMENSIONED
          The variable {name} is not dimensioned, but it has a
          subscript specification in an EQUIVALENCE statement.
          This may be caused by using a subscript of (1) when it
          is superfluous.

       EQUIVALENCE VARIABLE SUBSCRIPTS AND RANGE SPECIFICATIONS
       MUST BE NUMERIC
          Specification of a subscript or character range value
          is not numeric.

       EXPRESSION INVALID
          An arithmetic statement, an arithmetic expression, a
          logical statement, or a logical expression is not valid.

       FORMAT HAS A DECIMAL POINT WITHOUT LEFT AND RIGHT DIGITS:
       {text}
          Numerical digits do not precede and follow a decimal
          point.  {text} will contain nine characters, where
          character 5 is the location of the error.

       FORMAT HAS AN ILLEGAL CHARACTER: {text}
          A character occurs where it is not allowed.  {text}
          will contain nine characters, where character 5 is the
          location of the error.  No further processing of this
          statement occur after the error is detected.  The most
          usual cause of this message is when a comma is missing,
          between format specifications, such as:
          FORMAT(1H15X,A15).  The correct form for the example is:
          FORMAT(1H1,5X,A15).  This message may not occur when a
          comma is expected but not found while removing holl-
          erith fields in a FORTRAN statement in SUBROUTINE
          COMPRS.

          Some FORTRAN compilers allow the ascii code A to be
          used with no length specified.  Example:
          FORMAT('ZZ',A5,A,I4).  The character sequence ,A, in a
          FORMAT statement will cause this message.

       FORMAT HAS AN ILLEGAL COMMA: {text}
          A comma occurs where it is not allowed.  {text} will
          contain nine characters, where character 5 is the loc-
          ation of the error.  No further processing of the
          statement occurs after this error is detected.
          Most FORTRAN compilers allow the FORMAT statement to
          contain a code sequence of: ,/,  The commas are super-
          fluous, and FXREF will print this message for each
          occurrence.

       FORMAT HAS AN ILLEGAL DECIMAL POINT: {text}
          A period or decimal point occurs where it is not allow-
          ed.  {text} will contain nine characters, where charac-
          ter 5 is the location of the error.  No further pro-
          cessing of the statement occurs after this error is
          detected.

       FORMAT HAS AN ILLEGAL RIGHT PARENTHESIS: {text}
          A right parenthesis occurs where is not allowed. {text}
          will contain nine characters, where character 5 is the
          location of the error.

       FORMAT HAS NO MATCHING RIGHT PARENTHESIS: {text}
          A right parenthesis does not match a left parenthesis
          when one is expected.  {text} will contain nine charac-
          ters, where character 5 is the location of the error.

       FORMAT HAS NO MATCHING SYMBOL: > OR <: {text}
          Case 1:
          The FORMAT statement has the symbol: <, but no matching
          symbol > was found.  {text} will contain nine charact-
          ers, where character 5 is the location of the < symbol.
          Case 2:
          The FORMAT statement has the symbol: >, but no matching
          symbol < preceded it.  {text} will contain nine chara-
          cters, where character 5 is the location of the >
          symbol.

          No further processing occurs after this is detected.

       FORMAT IS MISSING A COMMA: {text}
          A comma does not occur where one is expected.  {text}
          will contain nine characters, where character 5 is the
          is the location of the error.  No further processing
          occurs after the error is detected.  This message is
          generated by SUBROUTINE FMTSYN and may be a warning
          rather than an error.

       FORMAT LACKS A LEFT BOUNDING PARENTHESIS: {text}
          A left parenthesis does not follow the key word FORMAT.
          {test} will contain nine characters, where character 7
          is the location of the error.  No further processing
          occurs after this error is detected.

       FORMAT LACKS A RIGHT BOUNDING PARENTHESIS: {text}
          A right parenthesis does not terminate the FORMAT
          statement.  {text} will contain nine characters where
          character 9 is the location of the error.  No further
          processing occurs after the error is detected.

       FORMAT STATEMENT HAS NO STATEMENT NUMBER
          A FORMAT statement must have a statement number spec-
          ified, but one does not exist.  This error usually
          causes the message to be written that a statement num-
          ber was not defined.

       FUNCTION HAS A LENGTH DEFINED BUT NO DATA TYPE IS DEFINED
       {text}
          A FUNCTION has a defined length specified, but no data
          type is defined.  This message occurs only when the
          FUNCTION is specified as:
          FUNCTION*{length} {name} [arguments].

       FUNCTION STATEMENT NOT THE FIRST STATEMENT
          A FUNCTION statement occurs that is not the first non-
          comment statement in a subprogram.

       HOLLERITH FIELD HAS MORE THAN 255 CHARACTERS
          A literal exists in a statement that exceeds 255
          characters.

       ILLEGAL CHARACTERS IN IF STATEMENT: {text}
          A character immediately following the IF statement log-
          ical condition field violates correct syntax.  The err-
          oneous character is the third character in {text}

       ILLEGAL EXPRESSION SYNTAX IN PARAMETER STATEMENT EXPRESSION
          Syntax of an expression defining a PARAMETER variable,
          a type statement length, or the size of a DIMENSION is
          in error.

       ILLEGAL USE OF A RECORD VARIABLE: {name}
          The variable {name} defined by a RECORD statement is
          not used correctly.

       ILLEGAL VARIABLE NAME: {name}
          The initial character of a variable name is not an
          alphabetic character or an underscore, or the second
          and subsequent characters are not alphabetic, numeric,
          underscore, or dollar sign characters.

       ILLEGAL RETURN DESIGNATION FOR ARGUMENT {number}
          A RETURN statement has an argument that is not a stat-
          ement number.  {number} is the invalid specification.

       IN ENTRY STATEMENT {name}, ARGUMENT {number) IS A
       SUBPROGRAM NAME
          Argument {number} in ENTRY statement {name} is a sub-
          program name.

       IN FUNCTION STATEMENT {name}, ARGUMENT {number} IS A
       SUBPROGRAM NAME
          The argument {number} in an ENTRY or SUBROUTINE name.
          {name} is the FUNCTION name.  This is a warning message
          that argument {number} is in a FUNCTION definition
          statement identical to a subprogram name within the
          program.

       IN ITBLSR, COMPARE FIELD LENGTH GREATER THAN FIELD LENGTH
          The length of the field to be searched for in the ITBLSR
          routine is greater than the record length of the table
          entry.  This message should never occur.  It indicates
          damaged data.

       IN ITBLSR, COMPARE FIELD LENGTH OF COMPARE FIELDS UNEQUAL
          Two fields to be compared in the ITBLSR routine are not
          of equal length.  This message should never occur.  It
          indicates damaged data.

       IN ROUTINE {name1}, SUBPROGRAM {name2} IS DEFINED AS
       {name3}, BUT IS CALLED AS {name4}
          In the calling subprogram {name1}, the program module
          {name2} is defined as an ENTRY, FUNCTION, or SUBROUTINE
          ({name3}), but it is called as an ENTRY, FUNCTION, or
          SUBROUTINE ({NAME4}). This is a global message.

       IN ROUTINE {name1}, CALLED ARGUMENT {number} ({name2}) IS
       TYPE {character1} BUT IS DEFINED AS TYPE {character2}
          In the calling subprogram {name1}, the argument number
          number {number}, whose variable name is {name2}, has
          type characteristic of {character1}, but the definition
          type characteristic is type {character2}.  This is a
          global message. {character1} and {character2} are the
          usage codes that appear in table 2.

       IN ROUTINE {name1}, CALLED ARGUMENT {number1} ({name2})
       HAS A LENGTH CHARACTERISTIC OF {number2} BUT HAS A DEFINED
       LENGTH OF {number3}
          In the calling subprogram {name1}, the called subprogram
          argument number {number1} whose name is {name2} has a
          length characteristic of {number2}, but the definition
          type length is {number3}.  This is a global message.

          This message is suppressed when the length definition
          is (*), in a type statement or when the CALL satement
          passes numeric values.  An inherited length is unknown
          to the subprogram that uses this definition.  A CALL
          statement using actual numeric arguments will not know
          the type defined length characteristic of the dummy
          variable argument in the called subprogram.

       IN ROUTINE {name1}, CALLED SUBPROGRAM {name2} HAS {number1}
       ARGUMENTS, BUT IS DEFINED WITH {number2} ARGUMENTS
          In the calling subprogram {name1}, the called subprogram
          {name2} uses {number1} arguments, but the defined sub-
          program uses {number2} arguments.  This message is a
          global message.

       IN ROUTINE {name1}, CALLED SUBPROGRAM {NAME2} IS NOT
       DEFINED
          Subprogram {name2} has been called from subprogram
          {name1}, but no such subprogram exists.  This is a
          global message.

       IN SUBROUTINE STATEMENT {name}, ARGUMENT {number} IS A
       SUBPROGRAM NAME
          Argument {number} is an ENTRY or FUNCTION name.  {name}
          is the SUBROUTINE name.

       IN TABSRH, COMPARE FIELD LENGTH GREATER THAN FIELD LENGTH
          The length of the field to be searched for in the TABSRH
          routine is greater than the record length of the table
          entry.  This message should never occur.  It indicates
          a damaged record.

       IN TABSRH, COMPARE FIELD LENGTH OF COMPARE FIELDS UNEQUAL
          The fields to be compared in the TABSRH routine are not
          of equal length.  This message should never occur.  It
          indicates damaged data.

       IN TBLSRH, COMPARE FIELD LENGTH GREATER THAN RECORD LENGTH
          The length of the field to be searched for in the TBLSRH
          routine is greater than the record length of the table
          entry.  This message should never occur.  It indicates
          damaged data.

       INCLUDE ARGUMENT NOT A LITERAL
          The argument of an INCLUDE statement is not a literal.

       INCLUDE FILE NAME EXCEEDS 80 CHARACTERS
          When the file name of an INCLUDE statement specifies no
          directory, the file name is modified to use the direct-
          ory of the first output file on unit 6.  The number of
          characters in the modified file name exceeds 80 charac-
          ters.  FXREF will terminate execution.

       INCLUDE FILE NOT FOUND {file name}
          A file name specified in an INCLUDE statement can not
          be found.  The file name may not exist, or it has an
          incorrect path name.  Unless the include file is in the
          same directory as FXREF.EXE, a path name is required,
          since FXREF has no search routine to find the file name
          in other directories.

          This message is written to the monitor screen, and FXREF
          exection stops.

       INPUT-OUTPUT PARAMETER CONTROL LIST ERROR
          The statement using a control list has an invalid para-
          ameter.  It does not pertain to the argument value of
          the parameter.

       INQUIRE ARGUMENTS "FILE" AND "UNIT" CAN NOT OCCUR
       SIMULTANEOUSLY
          An INQUIRE statement executes by seeking a file name or
          a unit designation,  It can not perform both simultan-
          eously.

       INQUIRE HAS AN INVALID ARGUMENT
          An INQUIRE statement has specified an invalid argument.

       INQUIRE HAS INSUFFICIENT ARGUMENTS
          An INQUIRE statement lacks required arguments.

       INQUIRE LACKS LEFT PARENTHESIS
       INQUIRE LACKS RIGHT PARENTHESIS
          An INQUIRE statement lacks a left or a right parenth-
          esis.

       INQUIRE SPECIFIES A DUPLICATE ARGUMENT
          An INQUIRE statement has multiple specifications of the
          same argument.

       INTEGER LENGTH NOT EQUAL TO 1, 2, OR, 4
          An INTEGER statement defined a variable length as other
          than 1, 2, or 4.  The length is set to four to continue
          processing.

       INTEGER STATEMENT CONTAINS A FLOATING NUMBER: {number}
          An INTEGER statement with data initialization specif-
          ications contains a floating point number.  The number
          is converted to integer format and both forms will be
          listed in the the tables of integers and floating point
          numbers.

       INTEGER VARIABLE HAS ILLEGAL LENGTH
          An INTEGER data type definition has an incorrect length
          specification.

       INTRINSIC FUNCTION NAME USED AS A VARIABLE: {name}
          A variable name is identical asqan intrinsic function
          name.  This is a warning message and may not be an
          error in a particular program, since FORTRAN compilers
          differ in the routines included in the intrinsic
          FORTRAN library.  This message may also appear in the
          global messages if global analysis is requested.

       INVALID CHARACTERS FOLLOW THE STOP STATEMENT
          The STOP statement has an illegal argument.

       INVALID EXPRESSION IN PARAMETER STATEMENT
          A PARAMETER expression defining a PARAMETER variable is
          incorrect.

       INVALID INPUT-OUTPUT CONTROL COMMAND FOR ENCODE OR DECODE
          An ENCODE or DECODE statement is not coded correctly.

       INVALID I/O UNIT {number}
          The input - output unit in a data manipulation statement
          is greater than 99.

       LENGTH NOT DEFINED FOR STRUCTURE: {name}
          A STRUCTURE statement that has not been defined prior
          to the occurrence of a RECORD statement which refers to
          the STRUCTURE statement using {name}.

       LENGTH OF INPUT SOURCE RECORD EXCEEDS {number}
          A FORTRAN source record length exceeds the value spec-
          ified in the control card on unit 1.

       LENGTH SPECIFICATION EQUALS ZERO
          The length of an integer or logical specification is
          zero.  The length is set to four to continue processing.

       LENGTH SPECIFICATION EXCEEDS 1 DIGIT
          The length specification of an integer specification
          is greater than one digit.

       LENGTH SPECIFICATION EXCEEDS 7 DIGITS
          The length specification of a CHARACTER type variable
          contains more than seven digits, or a syntax error exists.
          The number value may be larger than seven digits, but FXREF
          will process only seven.

       LENGTH SPECIFICATION IS REAL: {real number}
          The length specified for a variable is a real value not
          an integer value.

       LITERAL LACKS BALANCED ' OR "
          A character constant lacks an even number of apostrophes
          or quotation marks delimiting a literal.

       LOCATION OF EQUIVALENCE VARIABLE {name} AT {number1} IS
       GREATER THAN DEFINED COMMON LENGTH {number2}
          An EQUIVALENCE variable address exceeds that of the
          COMMON block to which is equivalenced .  While equiv-
          alenced variables may extend the total length of a
          COMMON block, the initial location of the equivalenced
          variable must lie within the original COMMON block
          before extension.

       LOGICAL CONDITION OF A DO WHILE OR IF STATEMENT LACKS
       PARENTHESES
          A logical specification does not exist for a DO WHILE
          or an IF statement.

       LOGICAL LENGTH MUST BE 1, 2, OR 4
          A LOGICAL statement defined a variable length as other
          than 1, 2, or 4.  The length is set to four to continue
          processing.

       LOGICAL OPERATOR SYNTAX ERROR: {text}
          A LOGICAL variable operator syntax is wrong.  {text}
          will show the logical operator from the statement or
          the text immediately following the logical operator.
          This message may appear more than once for a single
          error.

       LOGICAL STATEMENT HAS ILLEGAL LENGTH
          A LOGICAL data type definition has an incorrect length
          specification.

       LOWER LIMIT IS GREATER THAN UPPER LIMIT FOR A DIMENSION
       RANGE
          In a DIMENSION statement specifying a subscript range,
          the upper limit value is lower than the lower limit
          value.

       MORE THAN TWO SLASHES IN A RECORD STATEMENT
          A RECORD statement has more than two slashes.  The
          RECORD statement will not be processed, since the
          structure name can not be identified.

       MORE THAN 10 PARENTHESES IN A PARAMETER STATEMENT
       EXPRESSION
          A PARAMETER definition used to define another PARAMETER
          variable, the length of a type statement, or the size of
          a DIMENSION statement by using an expression of previously
          defined PARAMETER variables has more than ten matching
          parentheses, the maximum allowed by FXREF.

          This message may occur only for a PARAMETER variable
          defined as an integer data type.

       MORE THAN 100 INTEGER UNIT NUMBERS
          FXREF has determined that the program being analyzed
          uses more than 100 integer units.

       MORE THAN 1000 DIMENSIONED VARIABLES USED
          More than 1,000 variables have been dimensioned.  The
          output listing will be incomplete.  Dimensioned varia-
          bles brought into a program or subprogram by an INCLUDE
          statement are not counted for this limit unless the
          variable is used within a routine.

       MORE THAN 1000 ISNS FOR A VARIABLE NAME: {name}
          A variable is referenced more than 1000 times in a
          single routine.

       MORE THAN 1000 LITERALS IN CALL STATEMENTS
          The total number of literals occurring as CALL stat-
          ement arguments exceed 1000 in all the program's
          modules.

       MORE THAN 1000 LITERALS IN A SINGLE ROUTINE
          A FORTRAN module has more than 1000 literals.

       MORE THAN 1000 VARIABLES ARE DEFINED IN STRUCTURE
       STATEMENTS
          Variables defined within STRUCTURE statements exceed
          the table size where they are saved.

       MORE THAN 20 VARIABLES IN AN EQUIVALENCE GROUP
          More than 20 variables occur within a single equival-
          enced group that are brought into the same COMMON block.
          FXREF will combine separate EQUIVALENCE definitions
          when they are matched to a COMMON block.  The 20 var-
          iable limit applies to the combined group as well as to
          a singly defined group.

       MORE THAN 2000 INTEGERS OCCUR IN THE PROGRAM
          The program or subprogram being processed has more than
          2000 unique integer numbers which has filled the table
          where they are stored.  This includes all integer const-
          ants, all integer subscripts, all integer data type len-
          gth definitions, all integer substring specifications,
          all integer dimension specifications, and all integer
          PARAMETER specifications.  FORMAT statements using the
          <...> syntax will have all the integers occuring bet-
          ween <...> placed in the integer table.

          The count of 2000 integers is for each occurrence of
          an integer including multiple occurrences.  Consequent-
          ly, Fewer than 2000 integers will appear in the output
          listing.

          This message will appear only once for a given program
          module.  No integers occurring in FORTRAN statements
          after this statement identified by the ISN will be cat-
          taloged; consequently, the printed listing table of
          integers, table 5, will be incomplete, and fewer than
          2000 integers will appear in the output listing.

       MORE THAN 30 COLONS IN A CALL STATEMENT
          The argument of a CALL statement that is an expression
          uses more than 30 range specifications for CHARACTER
          type variables.

       MORE THAN 30 LEFT PARENTHESES IN A CALL STATEMENT
          A CALL statement argument expression contains more than
          30 left parentheses, the maximum allowed by FXREF.

       MORE THAN 30 RIGHT PARENTHESES IN A CALL STATEMENT
          A CALL statement argument expression contains more than
          30 right parentheses, the maximum allowed by FXREF.

       MORE THAN 4000 FLOATING NUMBERS OCCUR IN THE PROGRAM
          The program or subprogram being processed has more than
          4000 unique floating numbers which has filled the table
          where they are stored.

       MORE THAN 4000 INTEGER PARAMETER DEFINITIONS
          More than 4000 integer parameters are defined.  The
          The listing will be incomplete.  Integer parameter def-
          initions brought into a program or subprogram by
          INCLUDE statements are counted for this total.

       MORE THAN 4000 SUBPROGRAMS EXIST
          More than 4000 ENTRY, FUNCTION, and SUBROUTINES are
          defined for the current program being processed.  This
          is a global message.

       MORE THAN 4000 VARIABLE NAMES USED
          More than 4,000 variable names are defined in a program
          or subprogram.  This count includes all variables
          brought into a module by INCLUDE statements.  Intrinsic
          function names are counted for this total.  The listing
          will be incomplete.

       MORE THAN 500 LITERALS IN A SINGLE STATEMENT
          A FORTRAN statement has more than 500 literals.

       MORE THAN 500 VARIABLES USED IN AN EXPRESSION
          An arithmetic assignment statement or an expression
          contains more than 500 unique variables.  The remaining
          variables are not processed for this ISN statement.

       MORE THAN 6 NESTED INCLUDE STATEMENTS
          INCLUDE statements may be nested only to a depth of 6.
          Thus, the total number of INCLUDE statement within the
          nest is 7.

       MORE THAN 7 DIMENSION PARAMETERS SPECIFIED
          A variable has more than seven dimension parameters
          defined.  This is the maximum number of dimensions all-
          owed by most FORTRAN compilers.

       MULTIPLE FUNCTION LENGTHS ARE DEFINED
          A FUNCTION statement has more than one defined length
          characterisitc.  The initial length definition will be
          used.  If the value is not allowed for the data type,
          the standard default length is used.

       MULTIPLE IMPLICIT STATEMENTS NOT ALLOWED
          A program or subprogram contains multiple IMPLICIT
          statements, and one of them is an IMPLICIT NONE state-
          ment.  An IMPLICIT NONE statemenmt allows no other
          IMPLICIT statements.

       NAMELIST STATEMENT LACKS BALANCED SLASHES
          An odd number of slashes occur in a NAMELIST statement.

       NO CLOSING COMMA OR RIGHT PARENTHESIS
          A statement lacks either a comma or a right parenthesis
          where one is required.

       NO CLOSING COMMA OR RIGHT OR LEFT PARENTHESIS
          A statement lacks a comma, right parenthesis, or left
          parenthesis where one is required.

       NO LEFT OR RIGHT PARENTHESIS AFTER AN EQUIVALENCE
          A left or right parenthesis is missing in an EQUIVALENCE
          statement.  An EQUIVALENCE statement must start with a
          left parenthesis after the key word and must end with
          a right parenthesis.

       NO SUBPROGRAM SPECIFIED FOR AN EXTERNAL STATEMENT
          An EXTERNAL statement has no argument.

       NO TYPE DEFINITION FOR VARIABLE: {name}
          Variable {name} has no type and length definition.
          This is caused by using a variable name in the execut-
          able section of a program or subprogram when an
          IMPLICIT NONE statement exists in the module.  All var-
          iables must be defined in the declaration section of a
          program or subprogram when IMPLICIT NONE exists.

       NONDEFINED VARIABLE USED ILLEGALLY: {name}
          Variable {name} occurs to the right side of an equal
          sign, but it has not been defined prior to its use.

       NOT A COMMON VARIABLE: {name}
          A variable is not in common when it should be.

       NOT A FORTRAN STATEMENT
          A statement can not be identified as a FORTRAN state-
          ment or some portion of the statement is not valid
          FORTRAN syntax.  There are two forms of this message.
          One contains the internal statement number to identify
          the erroneous statement.  The other lists the first 20
          characters of the statement when no statement number is
          available.  See the prior section of messages without
          an ISN.

       NOT A PARAMETER VARIABLE: {name}
          {name} is a variable used where only a variable in a
          PARAMETER statement may be used.

       NOT A RECORD DEFINITION: {name}
          {name} is used in a compound variable name, but it is
          not defined in a RECORD statement.

       NOT A PAUSE STATEMENT
          A statement appears to be a PAUSE statement but is not.

       NUMBER GREATER THAN 7 DIGITS
          An INTEGER number being converted to a text format con-
          tains more than seven digits after conversion.

       OPEN SPECIFIES A DUPLICATE ARGUMENT
          An argument occurs twice in the control list.

       OPEN HAS AN INVALID ARGUMENT: {value}
          One of the specified arguments for the OPEN statement
          is not valid.  {value} may be {name} or {number}.  If
          {value} is an input-output unit designated as a var-
          iable name, the lack of UNIT= parameter in the control
          list will cause this message.

       OPEN HAS INSUFFICIENT ARGUMENTS
          The OPEN statement lacks required arguments.

       OPEN LACKS LEFT PARENTHESIS
       OPEN LACKS RIGHT PARENTHESIS
          A left or right parenthesis is lacking in an OPEN
          statement.

       OPEN SPECIFIES A DUPLICATE ARGUMENT
          An argument in an OPEN  statement occurs more than once.

       PARAMETER EVALUATION ARGUMENT NOT FOUND
          A PARAMETER variable name has not been found in the
          table of PARAMETER defined variables.  This message is
          probably caused by using a variable prior to its def-
          inition in a PARAMETER statement.  Also, it may be
          caused by a variable name used as a DIMENSION specific-
          cation that is not in a COMMON block, or that is an
          argument of an ENTRY, FUNCTION, or SUBROUTINE statement.

          The message will also appear when the value is a lit-
          teral defined in an include file.  Even when a literal
          represents a numerical integer value, it is not enter-
          ed into the integer parameter table used to evaluate
          expressions from a prior PARAMETER definition.  Use of
          OS/2-ECS APIs have many switches set as literals, and
          they may cause this message when used in an expression in
          exprerssion in the calling routine.  Hexidecimal and octal
          constants used to set the value of an integer parameter
          variable are not evaluated.

          This message will occur only for integer PARAMETER var-
          iables for defined integer constants.  FXREF maintians
          a table of integer PARAMETER variables only, since they
          can be used to define the size of dimensioned arrays,
          data length definitions, and subsequent PARAMETER var-
          iable definitions within a program or subprogram.  No
          other data type will be tabulated in the PARAMETER
          table.

       PARAMETER STATEMENT LACKS AN EQUAL SIGN
          An equal sign is missing where expected in a PARAMETER
          statement.

       PARAMETER STATEMENT LACKS PARENTHESES
       PARAMETER STATEMENT LACKS A LEFT PARENTHESIS
          Parentheses are missing in a PARAMETER statement.  When
          one of these messages occurs, the possible PARAMETER
          statement is not processed.  Some older FORTRAN compil-
          ers did not require that PARAMETER statements be encap-
          suled within parentheses.

       REAL EXPONENT EXCEEDS 308
          A real number expressed in scientific notation has an
          exponent equal to or larger than +308 or equal to or
          less than -308. The original exponent value is changed
          to +307 or -307, and the number is converted to one of
          those values.  This prevents any real number from caus-
          ing FXREF to terminate abnormally by attempting to con-
          vert the text form to the binary floating point form.

       REAL VARIABLE HAS ILLEGAL LENGTH
          A REAL data type definition has an incorrect length
          specification.  The length specifications for a real
          variable are 4 and 8.  While some FORTRAN compilers
          permit a real length of 16, this error message is
          written when 16 is used to define the variable length,
          but the the length of 16 will apper in the tables of
          variable names.  Other lengths will always cause this
          message to be printed.  The length is set to four to
          continue processing.

       STATEMENT ENDS ILLEGALLY
          A statement lacks a correct termination.

       STATEMENT HAS MORE THAN 30 ARGUMENTS
          A CALL, ENTRY, FUNCTION, or SUBROUTINE statement cont-
          ains more than 30 arguments.  Only the first 30 will be
          processed.

       STATEMENT NUMBER IS DEFINED MORE THAN ONCE
          Duplicate statement numbers exist in the routine.

       STATEMENT NUMBER NOT DEFINED
          A statement number has been referenced but not defined.

       STATEMENT NUMBER NOT REFERENCED
          A statement number has been defined but never referenced
          within the program.

       STRUCTURE NAME LACKS CLOSING SLASH
          The variable name of a STRUCTURE definition is not
          terminated by a slash.

       STRUCTURE NOT ENCAPSULATED BY SLASHES
          The name of STRUCTURE definition is not surrounded by
          slashes.

       SUBPROGRAM NAME IS AN ARGUMENT BUT IS NOT DEFINED IN AN
       EXTERNAL STATEMENT
          A SUBROUTINE or FUNCTION subprogram name occurs in a
          CALL statement as an argument, but the subprogram name
          is not defined in an EXTERNAL statement.

       SUBROUTINE ARGUMENT IS DEFINED IN COMMON: {name}
          A variable name used as a dummy argument in a SUBROUTINE
          statement is defined in a COMMON block.

       SUBROUTINE STATEMENT IS NOT THE FIRST STATEMENT
          A SUBROUTINE statement occurs that is not the first non-
          comment statement in a subprogram.

       SUBSCRIPT COUNT ERROR FOR EQUIVALENCED VARIABLE: {name}
          The number of subscripts used by a variable in an
          EQUIVALENCE statement is different from that defined
          in its DIMENSION definition.

       SUBSCRIPT DOES NOT MATCH DIMENSION SIZE: {name}
          The dimensioned variable {name} is used with an incorr-
          ect number of subscripts.

       SUBSCRIPTED VARIABLE IS NOT DIMENSIONED: {name}
          Variable {name} that uses subscripts has not been dimen-
          sioned.  When this message is written, the variable is
          assumed to be a FUNCTION name and will appear in the
          listing as a FUNCTION name.

          When the variable name is a definition of various data
          and constants from IBM's Presentation Manager macros
          for OS/2-ECS, this message will be generated when param-
          eters of API arguments occur, such as: SHORT1FROMMP,
          MPFROMP, etc.  These parameters require arguments, but
          are not subprogram names, nor are they defined array
          variables.  The message is superfluous in this case.

          A defined CHARACTER variable, which is not dimensioned,
          in the current program module being analyzed will cause
          this message if used in an EQUIVALENCE statement with
          numeric values encapsulated within parentheses that
          appear to be subscripts, for example: (1) rather than
          (1:1). The message indicates the EQUIVALENCE statement
          syntax should be corrected.

          Other FORTRAN statements may also cause additional mess-
          ages to be generated when this message is written in the
          output file on unit 6.  If global analysis has been req-
          uested, many superfluous global messages may be
          generated.

       SUBSCRIPTED VARIABLE LACKS A SUBSCRIPT VALUE
          A dimensioned array variable lacks a variable name or
          number for the subscript.

       THIRD ARGUMENT OF ENCODE OR DECODE NOT A VARIABLE NAME
          The ENCODE or DECODE third argument is not a variable
          name as required.

       THIS STATEMENT OCCURS AFTER THE FIRST EXECUTABLE STATEMENT
          Declarative and definition statements may not follow
          the initial executable statement in the execution seg-
          gment of a program or subprogram.  The statements are:
          BLOCK DATA, BYTE, CHARACTER, COMMON, COMPLEX, DATA,
          DIMENSION, DOUBLE COMPLEX, DOUBLE PRECISION, END STRUC-
          TURE, END MAP, END UNION, EQUIVALENCE, EXTERNAL, FUNC-
          TION, IMPLICIT, INCLUDE, INTEGER, INTRINSIC, LOGICAL,
          MAP, NAMELIST, PARAMETER, PROGRAM, REAL, RECORD, SAVE,
          STRUCTURE, SUBROUTINE, UNION.  An INCLUDE statement
          error may or may not be an error.  The contents of an
          included file will determine its validity.

          Any of the above statements that occur after a state-
          ment function definition will cause this message.
          Some older FORTRAN compilers allow DATA statements to
          be placed anywhere within a program module.

          Various FORTRAN compilers may have other statements
          that would belong to the definition or declaritive
          category.

          This message may appear when a PARAMETER statement
          lacking any parentheses occurs.  Some older FORTRAN
          compilers did not use parentheses to encapsulate the
          parameter variable names and their assigned values.

          Example: PARAMETER NACC = 550 will be treated as the
          variable: PARAMETERNACC = 550.

          When any declarative or definition statements occur
          after an ENTRY statement, this message will appear.

       TYPE STATEMENT DATA SPECIFICATIONS LACK BALANCED SLASHES
          COMMON, or DATA statements lack balanced slashes
          encapsulating the data values.

       UNBALANCED PARENTHESES
          An odd number of parentheses occur in the statement
          being analyzed.  This message may appear when one or
          more parentheses are part of a hollerith field in a
          DATA or CALL statement and may not indicate a syntax
          error.

       UNBALANCED PARENTHESES IN PARAMETER STATEMENT
          A PARAMETER statement that is defined as an expression
          of previouisly defined PARAMETER variables has unmatch-
          ed left and right parentheses.

       UNBALANCED PARENTHESES IN SUBPROGRAM STATEMENT
          A SUBROUTINE statement has unmatched left or right par-
          entheses.

       UNDEFINED TYPE FOR VARIABLE: {name}
          A variable used in a program or subprogram does not
          have a data type definition.  This is usually caused by
          failing to define the variable's data type when an
          IMPLICIT NONE statement exists in the program module
          which prevents the standard implicit typing normally
          used in FORTRAN.

       UNION HAS LESS THAN 2 MAP DEFINITIONS
          The UNION statement must have at least two MAP definit-
          ions.

       USE OF UNIT "*" NOT ALLOWED IN INQUIRE
          An asterisk (used to indicate the console monitor) can
          not be specified as the unit in an INQUIRE statement.

       USE OF UNIT "*" NOT ALLOWED IN OPEN
          An asterisk (used to indicate the console monitor) can
          not be specified as the unit in an OPEN statement.

       VARIABLE DIMENSION SUBSCRIPT VALUE IS ZERO: {name}
          A dimensioned variable {name} has its size defined by
          an expression, but evaluating the expression attempts
          to cause an exponential computation of 0**0.  This
          message may be caused by failing to correctly define
          PARAMETER statement variable values.  The result will
          be set to a default value.

       VARIABLE INPUT-OUTPUT UNIT MUST BE EITHER A CHARACTER OR
       INTEGER
          An input-output variable unit name is not defined as a
          character or an integer.  This message will be a warn-
          ing message when a unit is a variable name with numeric
          subscript values.

       VARIABLE IS NOT DIMENSIONED: {name}
          Variable {name} has a subscript, but it is not dimens-
          iond.  This message may occur when OS/2-ECS API function
          parameters require an argument such as MPFROMP(ARG)
          exists.  FXREF does not contain a catalog of OS/2-ECS API
          functions but does have a table of defined OS/2-ECS macros.
          Any messages refering to these usages should be ignored.

       VARIABLE {name} IS EQUIVALENCED TO MULTIPLE COMMON BLOCKS
          The variable {name} is equivalenced to more than one
          common block.  Table two will contain all the ISNs
          where {name} occurs; the other common blocks can be be
          identified there.

       VARIABLE NAME EXCEEDS 32 CHARACTERS: {name}
          There are too many characters in the variable name.
          Only the first 32 characters will be shown.

       VARIABLE NAME IS MULTI-DIMENSIONED: {name}
          A variable name occurs more than once in a DIMENSION
          statement within the same program or subprogram.

       VARIABLE NOT DEFINED; (name}
          The named variable {name} is used in the routine, but
          it is not defined.

       VARIABLE NOT DIMENSIONED: {name}
          The variable (name} uses subscripts in an expression,
          but it is not dimensioned.  The expression may be a
          CALL statement argument.

       VARIABLE NAME IS NOT DEFINED AS A RECORD: {name}
          The variable {name} used in a compound variable name as
          a RECORD name, but no RECORD statement defines {name}.

       VARIABLE NAME IS NOT DEFINED IN A STRUCTURE: {name}
          The variable {name} used in a compound variable is not
          defined in a STRUCTURE.

       VARIABLE NOT REFERENCED: {name}
          The variable {NAME} is not used in the routine, but it
          is defined.  This may occur when a synthetic variable
          name C## is used as a variable name in a program
          module.

       VARIABLE OR BLOCK COMMON NAME DOES NOT FOLLOW THE SAVE
       STATEMENT
          The SAVE statement lacks a variable name or a common
          block name.

INPUT-OUTPUT UNITS USED:

       FXREF uses a number of input and output files during exec-
       ution.  Most are internal working files for storing temp-
       orary information.  Each file is opened and closed by the
       program when required by its operation.  Work files are
       also deleted after the completion of a program or sub-
       gram or subprogram module analysis.

       Should an abnormal termination of FXREF occur, the work
       files left on the disks will be deleted before processing
       begins when the program is restarted.

       OS/2_ECS limits each process, an executing program, to a max-
       imum of 20 simultaneously open files.  FXREF requires more
       than this limit when the programs or subprograms being
       analyzed contain INCLUDE statements, since additional
       files must be opened.  The WATCOM FORTRAN 77 compiler FXREF
       was developed on contains a non-standard library function
       named GROWHANDLES which is called to increase the total
       maximum of open files 20 to 40.  Operating systems other
       than OS/2-ECS may or may not require such a file limit mod-
       ification, which usually can be set by environment param-
       eters of the operating system or by the FORTRAN compiler
       parameters being used.  FXREF is currently set to have a
       maximum of 7 INCLUDE files open simultaneously.

       Likewise, other FORTRAN compilers other than WATCOM's may
       also have similar restrictions, and the user of any other
       compiler may require compiler parameter or program changes
       to increase the limit.  The code that causes the change of
       the maximum limit for OS/2-ECS is the initial executable
       statement in the main module of FXREF.  In any case where
       FXREF is being recompiled from teh source code, the pro-
       spective user should insure that a sufficient number of
       files may be opened when FXREF requires the by substituting
       the correct call to a routine which accomplishes the same
       purpose, or provide the correct environment operating system
       changes if necessary and deleting the call to the GROWHANDLES
       function.

       All files of the form {name}.XXX are work files and will
       be created in the same directory where FXREF.EXE is
       located.

       The routines that create a postscript listing file does
       not use the unit numbers shown in the following table.
       Those units are shown after this table.

       Unit       Contents and Use

        0   - Error messages for listing on unit 6.  This is an
              ASCII text file.  The maximum record length is 120
              characters.  File name is MESS.LST.

        1   - Input file named FXREF.CCD containing the file
              name of the FORTRAN source code to be analyzed.
              This file is an ASCII text file.  Record structure
              is provided in the EXECUTION section in this doc-
              ument.

              After the control cards are read and if global ana-
              lysis is requested, unit 1 is closed and then re-
              opened to save all block COMMON variable names
              occurring in a source module for creating the out-
              put tables.  This file is used to perform global
              analysis of COMMON blocks.

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   Name of the routine in which the
                                 COMMON block occurs.
             33 - 64  A*32  16   Name of the COMMON block
             65 - 68  I*4   17 # Number of characters of the name
                                 in cols. 1 - 32.
             69 - 72  I*4   18 # Number of characters in the name
                                 in cols. 33 - 64
             73 - 76  I*4   19 # Memory size of the COMMON block
                                 in cols. 33- 64

             NOTE: Fields marked with # have 128 added to their
                   true value. This is done to prevent them from
                   being interpreted as HEX 0A, 0D, 1A during
                   reading and writing the record.

        2   - The input - output units' variable names.
              File name is: FUNT.XXX

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   The input-output variable name.
             33 - 36  I*4    9   The ISN + 128 of the input-output
                                 statement.
             37 - 40  I*4   10   The length of the variable name
                                 in cols.1-32 plus 128.

        3   - A list of all subprograms defined within a program.
              This file does not contain intrinsic function names.
              This is a binary file; file name is: SUNP.XXX.

              The file on this unit has two sections.  Section one
              defines the subprogram name characteristics, while
              section 2 describes the individual arguments charac-
              teristics.

              Section 1:
              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   The ENTRY, FUNCTION, or SUBPROG-
                                 RAM name.
             33 - 36  I*4    9   The ISN of the subprogram state-
                                 ment.
                  37  A*1        FUNCTION data type; ENTRY and
                                 SUBROUTINE statements do not
                                 have a defined data type.
             38 - 44  A*7   11   Length characteristic of a
                                 FUNCTION.
             45 - 48  I*4   12   Bit switches
             49 - 52  I*4   13   Number of characters in the sub-
                                 program name in columns 1-32.
             53 - 56  I*4   14   Number of arguments for this sub-
                                 program.  A maximum of 30 are
                                 allowed.
              Section 2:

        This section immediately follows section 1 and may be re-
        peated 30 times.  The total record length is 1496 chara-
        cters.

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*4    8   Argument variable name
                  33  A*1        Argument variable data type.
             34 - 40  A*7   10   Argument variable data type
                                 length.
             41 - 44  I*4   11   Bit switches
             45 - 48  I*4   12   Number of characters in the
                                 argument varible name in columns
                                 1-32.

        4   - The statement numbers and their ISNs referenced
              within the source code from unit 5.  This file does
              not contain the definition ISNs of statement num-
              bers.  This is a binary file; file name is:
              SNUM.XXX.

              Record Structure

              Columns TYPE WORD  Description
              1 - 4   I*4    1   Integer value of a statement
                                 number
              5 - 8   I*4    2   Integer value of the ISN where
                                 the statement number is refer-
                                 enced in the program.  The value
                                 stored in this field is the
                                 the statement number plus 128.
                                 The addition of 128 to the value
                                 prevents this field from being
                                 interpreted as the HEX characters
                                 0A, 0D, or 1A or any other ASCII
                                 command characters which can
                                 cause difficulty in reading the
                                 file.  It may be necessary to
                                 change the value to 256 for an
                                 EBCDIC computer through out
                                 FXREF.

        5   - Reads the FORTRAN source code to be analyzed.  This
              is the file specified in record 3 of the FXREF.CCD
              file read by unit 1.  This file is an ASCII file.
              The maximum record length is 132 characters, but 80
              is the standard.  See the PROGRAM INSTALLATION AND
              EXECUTION section in this document.

              More than one file name may be processed from this
              unit.  See the control card decsription in the
              INSTALLATION AND EXECUTION section in this document.

        6   - The cross reference printer listing of the source
              code read from unit 5.  This file name is specif-
              ied in record 2 of FXREF.CCD read by unit 1.  This
              file is an ASCII text file.  Maximum length is 121
              characters.

              When a postscript output file is requested in
              record 1 of file FXREF.CCD, FXREF will create a
              text output file with standard carriage control
              characters in column one of each record.  The sub-
              routine PSPRINT will then create the postscript
              version of the text output file.  See the PROGRAM
              INSTALLATION AND EXECUTION section of this document.

        7   - The variable names and each ISN occurring in the
              source code from unit 5.  This is a binary file;
              file name is: VNME.XXX.

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   Variable name
             33 - 36  I*4    9   Integer value of the ISN where
                                 the variable name is referenced
                                 in the program.  The value stored
                                 in this field is the statement
                                 number plus 128.  The addition
                                 of 128 to the value prevents this
                                 field from being interpreted as
                                 HEX characters 0A, 0D, or 1A or
                                 any other ASCII command chara-
                                 cters which can cause difficulty
                                 in reading the file.  EBCDIC
                                 computers may require 128 be
                                 changed to 256 through out
                                 FXREF.  A value of -1 in this
                                 field indicates the variable name
                                 occurs in code brought into the
                                 current program or subprogram
                                 through an INCLUDE statement.
                  37 A*1         Data type code
                                 B - COMPLEX, C - CHARACTER, D -
                                 DOUBLE PRECISIOIN, E - DOUBLE
                                 COMPLEX, I - INTEGER, L -
                                 LOGICAL, R - REAL
             38 - 44 A*7   11   Length of the data type of a var-
                                iable name, ASCII field
             45 - 48 I*4   12   Bit switches
             49 - 52 I*4   13   Number of characters in the var-
                                iable name in columns 1-32

        8   - The list of variable unit numbers used by the
              source code from unit 5.  This is a binary file;
              file name is: IUNT.XXX.

              Record Structure

              Columns TYPE WORD  Description
              1 - 4   I*4    1   Input-output unit number.  Units
                                 are designated an integer value
                                 + 128.
              5 - 8   I*4    2   Integer value of the ISN where
                                 the input-output name or number
                                 is referenced in the program.
                                 The value stored in this field
                                 is the statement number plus 128
                                 The addition of 128 to the value
                                 prevents this field from being
                                 interpreted as the HEX charac-
                                 ters 0A, 0D, or 1A or any other
                                 ASCII command characters which
                                 can cause difficulty in reading
                                 the file.  EBCDIC computers may
                                 require changing 128 TO 256
                                 through out FXREF.
               9 - 10  A*2       Input-output unit number.  Units
                                 are designated as ASCII digits.

        9   - List of character constants, i.e. literals or holl-
              erith fields, occurring in the source code from
              unit 5.  This is a binary file.  File name is:
              SLIT.XXX.

              Record Structure

              Columns TYPE WORD  Description
              1 - 80  A*80  20   The value of a literal or charac-
                                 ter constant including the encap-
                                 sulating apostrophes or quotation
                                 marks.  If the literal is longer
                                 than 80 characters, it is truncated
                                 to 80 characters.
             81 - 84  I*4   21   The number of characters in the
                                 literal.  Stored as an integer
                                 value.
             85 - 88  I*4   22   Integer value of the ISN where
                                 the literal is referenced in the
                                 program.  The value stored in
                                 stored in this field is the
                                 statement number plus 128.  The
                                 addition of 128 to the value
                                 prevents this field from being
                                 interpreted as the HEX characters
                                 0A, 0D, or 1A or any other ASCII
                                 command characters which can
                                 cause difficulty in reading the
                                 file.  EBCDIC computers may req-
                                 uire changing 128 to 256 through
                                 out FXREF.
              89- 92  I*4   23   Integer value of the argument
                                 number in a CALL statement; set
                                 zero if not a CALL statement.

        10  - A list of all subprogram names used in a CALL
              statement.  Subprogram names used as arguments
              in a CALL statement are not placed in this file.
              This is a binary file; file name is: CALL.XXX.

              Section 1:

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   The called subprogram name.
             33 - 36  I*4    9   ISN of the CALL statement.
                  37  A*1        FUNCTION data type; ENTRY and
                                 SUBROUTINE statements do not
                                 have a defined data type.
             38 - 44  A*7   11   Length characteristic of a
                                 FUNCTION statement.
             45 - 48  I*4   12   Bit switches
             49 - 52  I*4   13   Number of characters in the var-
                                 iable name in columns 1-32 of
                                 section 1.
             53 - 84  A*32  21   Name of the routine where the CALL
                                 statement occurs.
             85 - 88  I*4   22   Number of characters in the var-
                                 iable name in cols. 53 - 84 of
                                 section 1.
             89 - 92  I*4   23   Number of arguments in this CALL
                                 statement.  A maximum of 30 are
                                 are allowed.
              Section 2:

        This section immediately follows section 1 and may be
        repeated 30 times.  The total record length is 1532
        characters.

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*4    8   Argument variable name
                  33  A*1        Argument data type.
             34 - 40  A*7   10   Argument data length.
             41 - 44  I*4   11   Bit switches
             45 - 48  I*4   12   Number of characters in the arg-
                                 ument variable name in columns
                                 1-32 of section 2.

        11  - Blank and named COMMON definitions organized by
              COMMON block occurring in the source code from
              unit 5.  This is a binary file.  This file is used
              to process COMMON variables in routine PCOMM; it is
              not used in global checking of COMMON blocks length
              length consistency.  File name is: COMM.XXX.

                 Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   Variable name belonging to a
                                 COMMON block.
             33 - 36  I*4    9   The number of characters in the
                                 variable name in columns 1-32.
                                 The value is negative if the
                                 variable name in columns 1-32
                                 is the COMMON block name; it is
                                 positive for the variable names
                                 that are placed in the COMMON
                                 block.
             37 - 44  A*8   11   Type and length definitions for
                                 the variable name in cols. 1-32.

        12  - Equivalenced variable names organized by EQUIVALENCE
              group in routine PEQUIC from unit 2.  This is a
              binary file; file name is: EQUI.XXX

              Record Structure

              Columns TYPE WORD  Description
              1 - 32  A*32   8   Variable name belonging to an
                                 equivalenced group.
             33 - 36  I*4    9   The ISN of the EQUIVALENCE
                                 statement containing the variab-
                                 le in columns 1-32.  The value
                                 is negative for the initial var-
                                 iable in an equivalenced group.
                                 For all other variables belong-
                                 ing to the same equivalenced
                                 group, the value is positive.
             37 - 40  I*4   10   The number of subscripts for the
                                 variable name in columns 1-32
                                 stored as an integer value.
             41 - 44  I*4   11   Location of the initial charac-
                                 ter in a character variable sub-
                                 string stored as an integer
                                 value.
             45 - 48  I*4   12   Integer value of the first
                                 subscript.
             47 - 52  I*4   13   Integer value of the second
                                 subscript.
             53 - 56  I*4   14   Integer value of the third
                                 subscript.
             57 - 60  I*4   15   Integer value of the fourth
                                 subscript.
             61 - 64  I*4   16   Integer value of the fifth
                                 subscript.
             65 - 68  I*4   17   Integer value of the sixth
                                 subscript.
             69 - 72  I*4   18   Integer value of the seventh
                                 subscript.
             73 - 76  I*4   19   Bit switches
             77 - 80  I*4   20   Associate variable index of the
                                 record

        13 - Reserved, used for debugging

        14 through 20
             Units 14 through 20 are used for the input of
             FORTRAN source code files that are brought into a
             program or subprogram by using the INCLUDE state-
             ment.  Include files may be nested up to 6 deep in
             FXREF.  Each FORTRAN compiler has its own standard
             for nesting of INCLUDE statements.  FXREF allows up
             to a depth of 6, but the program has a capacity of
             a depth up to 19.  To accommodate this larger possi-
             bility, the total number of simultaneouosly open
             files must be increased from 20 to 40.  The nesing
             depth is a function of the  FORTRAN compiler in use
             and the operating system.

             The file name specified in an INCLUDE statement must
             provide the path name when the INCLUDE file is not
             in the same directory as the execute module.  Other-
             wise, FXREF assumes the INCLUDE file is in the
             current directory.

INPUT - OUTPUT UNITS FOR POSTSCRIPT ROUTINES

   The input-output units used by the postscript modules are
   different from those used by the remainder of FXREF.  The sub-
   routines CARCTL, HEADER, NUMCV, PAGENM, and REVPRT use of read
   - write units are listed below.  The final listing may be one
   or two files depending on the parameters set in the control
   card file, FXREF.CCD.

        Unit    Contents and Use

        IIN    - Input of the FXREF listing generated by the LIST
                 subroutine.  This is set to a value of 1.

        IOUT   - Output of the postscript listing created by the
                 PSPRINT subroutine.  This unit will write the
                 odd page postscript output file.  The unit num-
                 ber may be 2, 4, or 7 in rotation.

        JOUT   - Output of the FXREF postscript listing even pages
                 in ascending order.  The unit number is set to a
                 value of 4.

        JOUTW  - Output of the postscript listing even pages in
                 reverse page order.  This unit is set to a value
                 value of 7.

BIT SWITCHES

   FXREF uses a standard set of bit switches though out the prog-
   ram to indicate various characteristics of a variable name.
   Variable name means a subprogram name or variable used within
   a program module.  Bit switches are referred to in the input-
   output unit records described above.  They occupy one word of
   32 bits and are defined in the table below.  When bit switches
   are part of a record, they are usually in columns 45-48 of the
   record.  Bit switches are also part of various table records
   stored in memory.

   When a switch is set to 1 (one), the switch is on (equivalent
   to true); when set to 0 (zero), the switch is off (equivalent
   to false.)

       CHAR-      (IF ON)
       ACTER        HEX    PRINT
       NUMBER  BIT VALUE   CODE  DESCRIPTION

        42/45   0    1             Not used
                1    2      C    This variable is used in COMMON
                2    4      R    This variable is used in a RECORD
                3    8      E    This variable is used in an
                                 EQUIVALENCE
                4    1      N    This variable is in a NAMELIST
                5    2      U    This variable is in a UNION
                6    4      T    This variable in a STRUCTURE
                7    8      A    This variable is used as an
                                 argument
        43/46   8    1      B    This variable is used in an
                                 ENTRY definition
                9    2      S    This variable is a SUBROUTINE
                                 definition
               10    4      F    This variable is a FUNCTION
                                 definition
               11    8      C    This variable is a COMMON
                                 definition
               12    1      N    This variable is a NAMELIST
                                 definition
               13    2      T    This variable is a STRUCTURE
                                 definition
               14    4      P    This variable is a PARAMETER
                                 definition
               15    8           This variable is in the output
                                 tables
        44/47  16    1      F    This variable is an intrinsic
                                 FUNCTION
               17    2      D    This variable exists in a
                                 DIMENSION
               18    4           A called subprogram name matches
                                 a defined subprogram name
               19    8           A FUNCTION has a length but no
                                 data type
               20    1           Variable is an ENTRY, FUNCTION,
                                 or, SUBROUTINE dummy argument
               21    2           A subprogram name is an external
                                 routine
               22    4           Not used
               23    8           Not used
        45/48  24    1           Not used
               25    2           Not used
               26    4           Not used
               27    8           Not used
               28    1           Not used
               29    2           Not used
               30    4           Not used
               31    8           Not used


MODIFICATIONS FOR BIG ENDIAN COMPUTERS AND OTHER OPERATING
SYSTEMS:

   FXREF may exceed the operating system limit for the number of
   simultaneously open files for some operating systems.  If this
   is a consistent problem, modify the limit value of the req-
   uired system configuration files when required.

   File names used by this program adhere to the OS/2-ECS standard
   form, XXXXXXXX.YYY where XXXXXXXX is the first part and YYY is
   the second part.  Other operating systems will require FXREF's
   code to be changed to process their naming standard.

   FXREF output listing file name modification for split post-
   script files may require changes for other operating systems
   and EBCDIC computers.

   In order to simplify modification of FXREF for a big endian
   computer and operating systems other than OS/2-ECS , the named
   COMMON statement /ASCII/ contains the most important variables
   that require modification.  It is shown below for little endian
   ASCII coding.  This is the form compiled into the OS/2-ECS ver-
   sion, and the statement occurs in the BLOCK DATA subroutine.

      COMMON /ASCII/ ICAPS/32/, ICTN/64/, IDTN/48/, IDXA/1/,
     1       IDXB/2/, IDXC/3/, IDXD/4/, IDXE/1/, IDXF/2/

   The variables IDXA, IDXB, IDXC, etc., representing subscript
   values, must be set to values correct for the computer system
   being used.  The other variables, ICTN, IDTN contain the
   values as algebraic quantities and character digits.  The var-
   iable ICAPS contains the value to force lower case alphabetic
   characters to upper case.

   The big endian EBCDIC version is shown below.  However, they
   should be verified as accurate before recompiling for EBCDIC
   computers.

      COMMON /ASCII/ ICAPS/Z'20'/, ICTN/Z'40'/, IDTN/Z'30'/,
        1    IDXA/4/, IDXB/3/, IDXC/2/, IDXD/1/, IDXE/2/, IDXF/1/

   This form is commented out for the OS/2-ECS version; to compile
   a big endian version, comment out the ASCII version and remove
   C in column one of the EBCDIC version.  None of the prospect-
   ive changes have been tested.  See the comments in the BLOCK
   DATA subroutine source code.

   Other subscript values throughout FXREF may require modificat-
   ion to convert the references of subscript values for a big
   endian computer.  While an extensive effort has been made to
   remove these values through use of the /ASCII/ common, not all
   of the cases may have been identified.

   In SUBROUTINE COMPRS, four hexadecimal constants are defined
   for variables CX30, CX5A, CX60, and CX70 are used to exclude
   ASCII characters that are not FORTRAN language usage.  EBCDIC
   computers must recode all these constants and all the IF
   statements using them.  Additional constants and IF statements
   will be required to perform the tests to detect invalid logical
   operators in EBCDIC coded FORTRAN code.

   The maximum exponent value of a floating point number for per-
   sonal computers is 308.  Other FORTRAN compilers and different
   hardware for CPUs may have different values.  If desired, the
   308 value could be modified.

   The table of FORTRAN intrinsic functions in subroutine CHKNME
   (variable FUNTBL) is ordered in ASCII collating sequence.  The
   table must be changed to EBCDIC collating sequence for an
   EBCDIC computer.

   None of the suggested changes for other operating systems and
   big endian computers have been tested.  Also, review the req-
   uirements section at the beginning of this document.

   FXREF uses two routines named GETDAT, and GETTIM to obtain
   information to create the "%%Date:" parameter for postscript
   output file listings.  The user of FXREF must replace these
   subroutine names with one existing for their compiler or other
   operating system that obtain the same information.  If the
   user desires to omit the creation and date information, they
   may comment out the necessary CALL statements and the output
   WRITE statement where they are written and modify the variable
   CFMT in routine PSPRINT containing the format used to write
   the postscript prologue header.  These routines are used in
   the PSPRINT subroutine that creates a postscript version of
   the output listing file.  The main routine also uses GETDAT
   and GETTIM to determine the time and date of execution that
   is printed on the first page of the output listing.

   Subroutine GETDAT returns three arguments containing the year,
   month, and day as integer values.  Subroutine GETTIM returns
   four arguments containing the hour. minute, second, and hund-
   redths of a second.

    FXREF uses a number different methods to convert text numer-
    ical values to and from arithmetic values of numbers.  Two
    subroutines named: NUMBER and ITOC are subroutines within
    FXREF.  READ and WRITE statements are also used extensively
    to make numeric value conversions from one variable type to
    another.  The major problem with some of these techniques is
    the difference of bit order between little endian and big
    endian computers.  Careful examination of type conversions
    are required to insure the correct results are obtained when
    big endian computers recompile FXREF.

WARRANTY AND OTHER ISSUES:

    This program is freeware and may be modified, copied, and
    distributed as desired.  Although FXREF has been tested
    against a wide spectrum of FORTRAN programs, no warranty of
    any kind, either expressed or implied, as to its correctness
    and usability is made.  In using this program, the user
    assumes all liability and all risk.

    The GNU General Public license applies to this program and
    its documentation.

    Copyright is retained by the author.

    All trademarks are the property of their respective owners.

MAINTENANCE:

July 2008 - Original release
